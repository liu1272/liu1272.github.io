title: 远控后门排查
author: liuGuobin
tags:
  - 日报
categories:
  - 日报
date: 2023-08-14 11:10:00
---
##### 获取事件告警信息
监控EDR、态势感知、防火墙等平台查看威胁告警以及日志。

##### 定位后门文件
```
根据告警信息定位后门文件位置，查找进程pid
lsof | grep xxxx.xx
lsof /root/xxxx.xx
fuser /root/xxxx.xx
```

##### 查看外连事件详情
```
根据五元组来查找通信的端口ip对应的pid
netstat -pantu | grep 114.114.114.114
netstat -pantu | grep 65533
lsof -i:65533
netstat -pantu | grep 65533
lsof -i:65533
```

##### 查找进程信息
```
查找进程相关文件
lsof -p 1234   （需要root权限）
pwdx

获取pid程序详细信息
lsof -p pid
pwdx pid
systemctl status pid
cat /proc/pid/maps
ls -al /proc/pid/exe
```

##### 根据pid查看对应线程
```
ps H -T -p pid
ps -aLf pid
pstree -agplU（推荐使用）
```

##### 确定进程运行时间
```
ps -eo pid,lstart,etime,cmd | grep <pid>
```

##### 比对恶意文件的创建时间
```
stat xxx.xx
ls -al xxx.xx
```

##### 样本采集分析
```
使用SCP/Xshell等将样本移出主机，计算哈希值后到威胁情报平台中去搜索
certutil -hashfile 文件 MD5
```

##### 进程查杀
```
【查找子进程】
ps ajfx
systemctl status

【杀死进程】
kill -9 pid   （这样子是杀不死子进程的！！！）
kill -9 -pid   （杀掉进程组）
```

##### 删除文件
```
# 查看文件占用，解除占用后删除
lsof xxxx.xx

# 移除 i, a 属性
chattr -ia file.sh
# 查看是否移除成功
lsattr file.sh
# 移除文件
rm -rf file.sh

# 奇怪文件名无法删除，先查inode再删除
ls -li xxxx.xx
find ./* -inum 12327526 -delete
find ./ -inum 12327526 -exec rm {} \;
find ./* -inum 12327526 -exec rm -i {} \;
find ./* -inum 12327526 -exec rm -f {} \;
find ./* -inum 12327526 |xargs rm -f
rm `find ./* -inum 12327526`

# 目录挂载无法删除（Device or resource busy）
sudo lsblk -a
sudo umount /dev/sdb1
rm -rf xxxx.xx
```

##### 补充：守护进程
```
# 守护进程是什么？
其他进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，但系统服务进程（守护进程）不受用户登录注销的影响，它们一直在运行着。

# 守护进程的本质是什么？
（1）守护进程的本职就是孤儿进程，该进程自成会话，自成进程组，一般守护进程与终端无关；（即：pid=sid=gid）
（2）后台进程受用户登录注销的影响，而守护进程不受用户登录和注销的影响。但是它们都受关机的影响。

# 守护进程有什么特点？
1. 没有控制终端，终端名设置为？号
2. 父进程不是用户创建的进程，一般由init进程或者systemd（pid=1）的进程为父进程
3. 进程名字通常以字母 d 结束
4. 工作目录为/（根），主要是为了防止占用磁盘导致无法卸载磁盘
5. 以kthreadd内核进程创建的守护进程以kthreadd为父进程

# 守护进程如何设置？
1. 执行一个fork()，之后父进程退出，子进程继续执行。
2. 子进程调用setsid()开启一个新回话并释放它与控制终端之间的所有关联关系。
3. 在setsid()调用之后执行第二个fork()，让父进程退出并让孙进程继续执行。确保了子进程不会成为会话组长。
（根据System V中获取终端的规则，进程永远不会重新请求一个控制终端。多一个fork()调用不会带来任何坏处。）
4. 使用  umask(0);  清除进程的umask以确保当daemon创建文件和目录时拥有所需的权限。
5. 修改进程的当前工作目录，通常会改为根目录（/）。
6. 关闭daemon从其父进程继承而来的所有打开着的文件描述符。

# 守护进程如何删除？
1. 首先ps axj | grep 守护进程名字，找到相应的守护进程，然后使用kill -9 守护进程名杀掉；
2. 利用ps -ef命令查找相应的守护进程，再用kill -9命令将其杀死；
3. 创建shell脚本对进程的启动、关闭、重启进行自动管理。
注：kill -9 -pid   （杀掉进程组）
```

##### 补充：screen的原理
- 当用户启动Screen时，它会创建一个守护进程作为后台进程，并与用户终端会话（称为控制终端）分离。
- 控制终端不再直接处理用户输入和输出，而是由Screen守护进程负责接收和处理。
- 守护进程通过与Unix域套接字进行通信，与控制终端保持连接。
- 用户在控制终端中输入的命令会被发送到守护进程，并由守护进程解析和执行。
- 守护进程还负责从虚拟终端读取输出内容，并将其发送回控制终端进行显示。

通过这种方式，Screen实现了在控制终端与守护进程之间的交互，并通过守护进程来管理多个虚拟终端、处理窗口切换、保存会话状态等功能。
需要注意的是，虽然Screen的守护进程在后台运行，但用户仍然可以通过重新连接到控制终端来恢复与之前会话的交互，即使之前的SSH连接断开或终端关闭。这是Screen的一个重要特性，允许用户在断开连接后恢复他们的工作环境。

##### 补充：恢复守护进程会话的交互
可以使用`nohup`命令启动一个守护进程，并将输出重定向到文件中，例如：
```shell

nohup ./your_daemon &
```
通过这种方式启动的守护进程不会因为用户退出终端而停止运行。

当用户重新连接到控制终端时，可以使用`jobs`命令查看守护进程的状态，并使用`fg`命令将其调至前台，恢复与之前会话的交互。例如：
```shell

jobs
fg %job_id
```
其中，`job_id`是守护进程的作业号，可以在`jobs`命令的输出中找到。