<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin</title>
  
  <subtitle>LiuGuobin&#39;s blog</subtitle>
  <link href="https://liu1272.github.io/atom.xml" rel="self"/>
  
  <link href="https://liu1272.github.io/"/>
  <updated>2023-03-03T12:12:11.899Z</updated>
  <id>https://liu1272.github.io/</id>
  
  <author>
    <name>liuGuobin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UOOC中国近现代史纲要答案</title>
    <link href="https://liu1272.github.io/2023/02/20/UOOC%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AD%94%E6%A1%88/"/>
    <id>https://liu1272.github.io/2023/02/20/UOOC%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E7%AD%94%E6%A1%88/</id>
    <published>2023-02-20T13:53:00.000Z</published>
    <updated>2023-03-03T12:12:11.899Z</updated>
    
    <content type="html"><![CDATA[<h5 id="此文章答案仅为个人记录所用，请勿用于其他用途"><a href="#此文章答案仅为个人记录所用，请勿用于其他用途" class="headerlink" title="此文章答案仅为个人记录所用，请勿用于其他用途"></a><em>此文章答案仅为个人记录所用，请勿用于其他用途</em></h5><h5 id="不保证完全一致，极可能存在多套题组，请核对后再查看"><a href="#不保证完全一致，极可能存在多套题组，请核对后再查看" class="headerlink" title="不保证完全一致，极可能存在多套题组，请核对后再查看"></a>不保证完全一致，极可能存在多套题组，请核对后再查看</h5><h5 id="tip：PC网页版刷新后是另一套题组"><a href="#tip：PC网页版刷新后是另一套题组" class="headerlink" title="tip：PC网页版刷新后是另一套题组"></a>tip：PC网页版刷新后是另一套题组</h5><h4 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h4><p>单选<br>1-5:CCABB<br>6-10:DCBDD<br>多选<br>11.AB<br>12-16:ABCD<br>17:BCD<br>18:ACD<br>19:AB<br>20.AB<br>判断<br>21-25:BABBB<br>26-30:BBBBB</p><h4 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h4><p>1-5:ACCDD<br>6-10:CCCBC<br>11:AB<br>12:ABCD<br>13:CD<br>14:BCD<br>15:ACD<br>16-17:ABCD<br>18:BC<br>19:ABCD<br>20:BCD<br>21-25:BBAAB<br>16-20:BAABB</p><h4 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h4><p>1-5:CBCCC<br>6:ABC<br>7:ABCE<br>8:ABCD<br>9:BCD<br>10:ACD<br>11:AD<br>12:AC<br>13:AB<br>14:BCD<br>15:ABCD<br>16-20:AABBA<br>21-25:BBAAA</p><h4 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h4><p>1-5:DAADC<br>6-10:AABAC<br>11:ABCDE<br>12:ABDE<br>13:ABCE<br>14:CD<br>15:AB<br>16-17:ABCD<br>18:DE<br>19:ABC<br>20:BC<br>21-25:ABBBA<br>26-30:AAABA</p><h4 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h4><p>1-5:CCABC<br>6:ABC<br>7:ABCDE<br>8:BCCD<br>9:AB<br>10:ABCD<br>11-12:ABCDE<br>13:ABC<br>14:BC<br>15:ABC<br>16-20:BBABA<br>21-25:BAABA</p><h4 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h4><p>1-5:CCCDC<br>6-8:ABCDE<br>9:ABC<br>10:ABCD<br>11:BCD<br>12:ABCD<br>13:AD<br>14:AB<br>15:ABC<br>16-20:AABAB<br>21-25:BAAAA</p><h4 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h4><p>1-5:BCDBB<br>6-10:DBBBD<br>11:ABCD<br>12:ABC<br>13:ACD<br>14:ABCDE<br>15:ABCD<br>16:ABC<br>17:CD<br>18:CD<br>19:CDE<br>20:ABD<br>21-25:AABBA<br>26-30:AAAAAA</p><h4 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h4><p>1-5:DCBBC<br>6-10:CCDAD<br>11:ABD<br>12:CDE<br>13:AB<br>14:ABCDE<br>15:ABCD<br>16:BCD<br>17:ABCDE<br>18:ABCD<br>19:ABD<br>20:AC<br>21-25:AAAAA<br>26-30:AAABA</p><h4 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h4><p>1-5:DBBDA<br>6-10:CBDDC<br>11:ABCDE<br>12-13:ABCD<br>14-16:ABCDE<br>17:ABC<br>18:ABCD<br>19:ABC<br>20-25:BBAAA<br>26-30:BABAA</p><h4 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h4><p>1-5:ACDCB<br>6-10:DDBBB<br>11:ABCDE<br>12:ABCD<br>13-14:ABCDE<br>15-16:ABCD<br>17:ABC<br>18:ABCD<br>19:ABC<br>20:BC<br>21-25:BBAAA<br>26-30:ABABA</p><h4 id="第11章（？）"><a href="#第11章（？）" class="headerlink" title="第11章（？）"></a>第11章（？）</h4><p>1-5:CCBAA<br>6-10:ACABC<br>11:ABC<br>12:ABCCD<br>13:ABCE<br>14:CDE<br>15-17:ABCD<br>18-19:ABCDE<br>20:ACE<br>21-25:AABAA<br>26-30:AAAAB</p><h3 id="不保证完全一致，极可能存在多套题组，请核对后再查看-1"><a href="#不保证完全一致，极可能存在多套题组，请核对后再查看-1" class="headerlink" title="不保证完全一致，极可能存在多套题组，请核对后再查看"></a>不保证完全一致，极可能存在多套题组，请核对后再查看</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;此文章答案仅为个人记录所用，请勿用于其他用途&quot;&gt;&lt;a href=&quot;#此文章答案仅为个人记录所用，请勿用于其他用途&quot; class=&quot;headerlink&quot; title=&quot;此文章答案仅为个人记录所用，请勿用于其他用途&quot;&gt;&lt;/a&gt;&lt;em&gt;此文章答案仅为个人记录所用，请勿</summary>
      
    
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>Github Action初体验</title>
    <link href="https://liu1272.github.io/2023/02/02/20230202/"/>
    <id>https://liu1272.github.io/2023/02/02/20230202/</id>
    <published>2023-02-02T12:41:00.000Z</published>
    <updated>2023-03-03T11:17:09.894Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h3><p>今天小小地了解了一下Github Action这个东西<br>感觉它实际上就是一个轻量级服务器而已<br>用户每个月有限制内存和运行时间，但是基本上不用担心用完</p><p>Action可以选择很多模板，也可以自己设置定时任务。<br>文件是yaml类型，语法不难理解<br>尝试几次就成功把以前那个该死的经典诵读文件做成一个定时任务了。</p><p>感觉很好的是密钥的添加很方便，也很好管理<br>但是，还是要翻旧账批评它没有一键删除history这个功能</p><p>这个定时任务文件代码放在这里了，有需要的自己改了用吧</p><pre><code># This workflow will install Python dependencies, run tests and lint with a single version of Python# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-pythonname: Python applicationon:  schedule:  # 定时任务，在每天的上午11点推送天气信息到邮箱    - cron: &#39;0 3 * * *&#39;    jobs:  build:    runs-on: ubuntu-latest    steps:    - uses: actions/checkout@v3    - name: Set up Python 3.10      uses: actions/setup-python@v3      with:        python-version: &quot;3.10&quot;            - name: Install dependencies      run: |        python -m pip install --upgrade pip        pip install flake8 pytest        pip3 install requests        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi            - name: RunScripts      run: |        # stop the build if there are Python syntax errors or undefined names        python 程序.py        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Github-Action&quot;&gt;&lt;a href=&quot;#Github-Action&quot; class=&quot;headerlink&quot; title=&quot;Github Action&quot;&gt;&lt;/a&gt;Github Action&lt;/h3&gt;&lt;p&gt;今天小小地了解了一下Github Action这个东</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>NoneBot2框架&amp;刷机小记</title>
    <link href="https://liu1272.github.io/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2023/02/01/202301%E6%9C%88%E6%80%BB%E7%BB%93/</id>
    <published>2023-02-01T12:20:00.000Z</published>
    <updated>2023-03-03T11:17:48.575Z</updated>
    
    <content type="html"><![CDATA[<p>半个月前，我一时兴起入坑QQbot，在go-cqhttp和nonebot2上接触到异步代码。<br>以及，在Python的异步代码里使用requests会堵塞这个问题。<br>自己写了点插件，也爬了很多api端口和网站。<br>本来想着在官网上也发布一个插件的，但是想想自己的臃肿的代码还是算了。<br><img src="https://s2.loli.net/2023/02/02/V57JDlnIgtaz2iq.png" alt="Bot长这样"><br><img src="https://s2.loli.net/2023/02/02/x8DAz94RnSQHZVJ.png" alt="查看服务器状态的插件"><br>近几天在玩刷机，拿个高通410的随身wifi刷了Debian。<br>超频到2.1GHz，同时释放了内存，现在它有这么大！<br><img src="https://s2.loli.net/2023/02/02/JeSaDVBqiMIc5yZ.png" alt="就问你离不离谱！"><br>你敢相信？他能跑上面所说的nonebot2<br>甚至能流畅运行1.8.8及更高版本的mc服务器！<br>今天下午试着用ZeroTier内网穿透，但是很可惜没做完。</p><p>由于17号要开学了，所以接下来还是多看看课本吧。<br>毕竟开学之后每周一从早八到晚上九点真的要命！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;半个月前，我一时兴起入坑QQbot，在go-cqhttp和nonebot2上接触到异步代码。&lt;br&gt;以及，在Python的异步代码里使用requests会堵塞这个问题。&lt;br&gt;自己写了点插件，也爬了很多api端口和网站。&lt;br&gt;本来想着在官网上也发布一个插件的，但是想想自己</summary>
      
    
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>新年快乐！</title>
    <link href="https://liu1272.github.io/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
    <id>https://liu1272.github.io/2023/01/21/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/</id>
    <published>2023-01-21T13:15:00.000Z</published>
    <updated>2023-01-21T13:39:10.296Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/20/1R8PjGN5Baq7dJW.jpg" alt="随便写点东西"><br><img src="https://s2.loli.net/2023/01/20/PJjSVf2ZcrsplF6.png" alt="随便放点喜欢的图"><br><img src="https://s2.loli.net/2023/01/20/5QgoSpuZj8tzY4H.jpg" alt="过年就要做喜欢的事"><br><img src="https://s2.loli.net/2023/01/20/ASsKZNOHUvQ1oh3.jpg" alt="开心就好呐"><br><img src="https://s2.loli.net/2023/01/20/cUhNVqupKTbSa57.png" alt="过去没达到的目标"><br><img src="https://s2.loli.net/2023/01/20/QPysl5H9gJKNMY3.png" alt="就让它留在过去吧"><br><img src="https://s2.loli.net/2023/01/20/T5jayCcslFYtbG7.jpg" alt="但是现在立下的目标"><br><img src="https://s2.loli.net/2023/01/20/sDyIUJd1zkepg5H.jpg" alt="一定要为它负责啊！"></p><h6 id="小事记"><a href="#小事记" class="headerlink" title="小事记"></a>小事记</h6><p>本来打算在春节之前写完一个CVE的漏洞复现，但是写了一半才发现已经被师兄抢了！！！<br>师兄你不讲武德，抢了所有任务里最简单的一个哈哈哈。<br>没办法只能写另外一个CVE了，但是由于不是很懂java和c，所以理解很困难。<br>看了一堆大佬的文章之后终于搞明白了，也磕磕绊绊地大概写了一个exp<br>最后看到只能自己搭建漏洞环境来测试，这下就真的顶不住了……<br>现在我不打算继续搭建了，毕竟这样子做出来的成本太高，效果很差不说，跟我现在接触的知识还有些脱节。</p><h6 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h6><p>世界有长久事物，便是安慰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/20/1R8PjGN5Baq7dJW.jpg&quot; alt=&quot;随便写点东西&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/20/PJjSVf2ZcrsplF6.p</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>有点意思~</title>
    <link href="https://liu1272.github.io/2023/01/12/20230112/"/>
    <id>https://liu1272.github.io/2023/01/12/20230112/</id>
    <published>2023-01-12T15:00:00.000Z</published>
    <updated>2023-03-03T11:18:34.664Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png" alt="真正值得纪念的，或许不止是一张画片"><br><img src="https://s2.loli.net/2023/01/13/1vqJb5eflmtMFIp.png" alt="你见证了她的努力，此时就再守护她一会吧"><br><img src="https://s2.loli.net/2023/01/13/sCdprRjVKS1Gz3X.png" alt="想找出“恋爱”的公式，或许还需要一段时间"><br><img src="https://s2.loli.net/2023/01/13/SHhNsIKOYijGLuz.png" alt="玫瑰的意义，只存在于你我心中"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png&quot; alt=&quot;真正值得纪念的，或许不止是一张画片&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/13/1vqJb5</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>经典诵读的正确打开方式</title>
    <link href="https://liu1272.github.io/2023/01/07/20220107/"/>
    <id>https://liu1272.github.io/2023/01/07/20220107/</id>
    <published>2023-01-06T16:08:00.000Z</published>
    <updated>2023-03-03T11:31:41.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>今天是广州某大学的wx小程序研究资料。<br>既然来了，那么话不多说，直接上教程<br>首先下载安装必备的应用<br><em>关于Python的安装和环境配置就不在这里赘述了</em><br><strong><a href="https://blog.csdn.net/qq_45502336/article/details/109531599?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167291320016800186585384%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167291320016800186585384&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-9-109531599-null-null.142%5Ev70%5Econtrol,201%5Ev4%5Eadd_ask&utm_term=python&spm=1018.2226.3001.4187">Python传送门</a></strong><br><strong>Charles</strong><br>1.前往<a href="https://www.charlesproxy.com/download/">官网</a>下载安装最新版本<br><img src="https://s2.loli.net/2023/01/07/m1S8RCupIAgQyP9.png" alt="随便选个喜欢的"><br>2.在下图处输入<strong>pojie</strong>和<strong>9d8fb452d26c0decc5</strong>后确定<br><img src="https://s2.loli.net/2023/01/07/ZzpSn2uRG8BgIoA.png" alt="恭喜你解锁VIP"><br>3.点击HEIP-&gt;SSLProxying-&gt;Install Charles Root Certificate配置证书<br>4.点击【安装】，点击【下一步】，然后选【放入下列存储】，然后是【受信任的根证书颁发机构】<br>5.点击【Proxy】–&gt;【SSL Proxying Settings…】<br>6.勾选【Enable SSL Proxying】点击【add】，在Host输入【*】，在Prot输入【443】最后点击【ok】保存</p><h5 id="接下来是抓包"><a href="#接下来是抓包" class="headerlink" title="接下来是抓包"></a>接下来是抓包</h5><p>1.关闭防火墙:打开网络设置&gt;高级网络设置&gt;Windows防火墙&gt;公用网络&gt;关闭并确认<br>2.在PC端wx中打开该小程序<br>3.在任务管理器里找到该小程序的应用<br><img src="https://s2.loli.net/2023/01/07/meVHGjo6vDNUScL.png" alt="找到这个万恶之源！"><br>4.右键点开小程序，打开文件所在位置，找到一个叫Runtime的包<br>5.将小程序和微信都关闭掉（否则部分文件删除不掉），然后将Runtime包下的文件都删除掉<br>6.把Runtime文件夹改为只读状态<br><img src="https://s2.loli.net/2023/01/07/YtoPvDxO6Z8unwa.png" alt="就是这个"><br>7.重新进入该wx小程序登录<br>8.打开Charles后在小程序内随意进入一个页面<br>9.CTRL+F输入<strong>key</strong>找到并复制字段<br><img src="https://s2.loli.net/2023/01/07/ruwzPXvIG7AWCNB.png" alt="就类似于这样，不能放得更多了"></p><h5 id="最后开始让代码跑起来"><a href="#最后开始让代码跑起来" class="headerlink" title="最后开始让代码跑起来"></a>最后开始让代码跑起来</h5><p>在主程序的这个位置粘贴刚刚复制的key并运行<br><img src="https://s2.loli.net/2023/01/07/tSf9DFdlPKWLBbs.png" alt="报错没有库的自己装"></p><h4 id="这就结束了？当然不！"><a href="#这就结束了？当然不！" class="headerlink" title="这就结束了？当然不！"></a>这就结束了？当然不！</h4><h5 id="接下来是移动端部分"><a href="#接下来是移动端部分" class="headerlink" title="接下来是移动端部分"></a>接下来是移动端部分</h5><p>1.打开<a href="https://pan.baidu.com/s/1ff-HmcwQSz8cHGqgpMJrcw">百度网盘</a>链接下载安装pydriod，提取码:de5q<br>2.打开保存在手机里的主程序文件并填入key<br>3.左栏Pip中选择INSTALL，分别输入requests,json,random,urllib,time并INSTALL<br>4.左栏Settings的Editor选项内打开Preserve files on exit<br>5.点击大大的黄色的运行按钮</p><p>注:<br>如果运行时发生错误请检查网络或尝试重启<br>如果出现名字不显示或者各种奇奇怪怪的bug但确确实实在运行，那么看着就好(正所谓能跑就行)<br>如果显示<strong>得分失败，重新开始匹配</strong>就多等一会，因为没有真人跟你匹配是不会得分的<br>本章内容只对该小程序进行分析，仅限学习研究使用，严禁进行其他非法行为！造成的后果本人不承担相关责任。</p><p><em><strong>最后感谢该校各位前辈的指导和帮助！！！</strong></em></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>每个烟花都像是盲盒，不知道点燃升空之后会是什么颜色、什么形状、会持续多久。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;p&gt;今天是广州某大学的wx小程序研究资料。&lt;br&gt;既然来了，那么话不多说，直接上教程&lt;br&gt;首先下载安装必备的应用&lt;br&gt;&lt;em</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Midjourney</title>
    <link href="https://liu1272.github.io/2023/01/06/20220106/"/>
    <id>https://liu1272.github.io/2023/01/06/20220106/</id>
    <published>2023-01-06T03:34:00.000Z</published>
    <updated>2023-03-03T11:31:54.563Z</updated>
    
    <content type="html"><![CDATA[<h5 id="无聊玩了一下Midjourney，挺方便，功能也很强大"><a href="#无聊玩了一下Midjourney，挺方便，功能也很强大" class="headerlink" title="无聊玩了一下Midjourney，挺方便，功能也很强大"></a>无聊玩了一下Midjourney，挺方便，功能也很强大</h5><p><img src="https://s2.loli.net/2023/01/06/vBlOqfjzJATF2kG.png#pic_center" alt="荒星"><br><img src="https://s2.loli.net/2023/01/07/uTWD6a93ZHOlxLq.png#pic_center" alt="好像刀妹"><br><img src="https://s2.loli.net/2023/01/06/X1FeICpcr74lkL9.png#pic_center" alt="粉毛YYDS"></p><h5 id="最后放个邀请地址"><a href="#最后放个邀请地址" class="headerlink" title="最后放个邀请地址"></a>最后放个<a href="https://discord.com/invite/midjourney">邀请地址</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;无聊玩了一下Midjourney，挺方便，功能也很强大&quot;&gt;&lt;a href=&quot;#无聊玩了一下Midjourney，挺方便，功能也很强大&quot; class=&quot;headerlink&quot; title=&quot;无聊玩了一下Midjourney，挺方便，功能也很强大&quot;&gt;&lt;/a&gt;无聊玩了一</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Hentai</title>
    <link href="https://liu1272.github.io/2023/01/05/20220105/"/>
    <id>https://liu1272.github.io/2023/01/05/20220105/</id>
    <published>2023-01-05T15:37:00.000Z</published>
    <updated>2023-03-03T11:32:01.832Z</updated>
    
    <content type="html"><![CDATA[<h5 id="能找到这里的都是Hentai"><a href="#能找到这里的都是Hentai" class="headerlink" title="能找到这里的都是Hentai"></a>能找到这里的都是<a href="https://track.mp3-malina.me/play-track/d33532303034b6303534368cb734823000/ff34543f34e2aa427c7b17347be4cc40/S3rl%20-%20Hentai.mp3">Hentai</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;能找到这里的都是Hentai&quot;&gt;&lt;a href=&quot;#能找到这里的都是Hentai&quot; class=&quot;headerlink&quot; title=&quot;能找到这里的都是Hentai&quot;&gt;&lt;/a&gt;能找到这里的都是&lt;a href=&quot;https://track.mp3-malina.me</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>图床及其相关</title>
    <link href="https://liu1272.github.io/2023/01/04/20220104/"/>
    <id>https://liu1272.github.io/2023/01/04/20220104/</id>
    <published>2023-01-04T10:12:00.000Z</published>
    <updated>2023-03-03T11:32:35.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="图床的创建"><a href="#图床的创建" class="headerlink" title="图床的创建"></a>图床的创建</h5><p>市面上免费的图床有SM.MS&emsp;Sibnet&emsp; Shutterfly<br>不完全免费的也有腾讯云&emsp; 阿里云&emsp; 七牛云<br>这里我把阿里云和SM.MS都试了一下</p><p>创建的话就跟着下面的步骤走就行了:<br>一.阿里云<br>&emsp;1.打开<a href="https://www.aliyun.com/?spm=5176.8466032.top-nav.dlogo.27b81450NiIk8F">官网</a>点击右上角进行注册/登录<br>&emsp;2.实名认证<br>&emsp;3.在左上角折叠页面里选择对象存储OSS<br>&emsp;4.右侧Bucket管理板块点击添加Bucket<br>&emsp;5.名称填写Bucket的名字，读写权限更改为公共读，其他的默认即可<br>&emsp;6.创建完成之后鼠标移至右上角头像上，选择AccessKey管理<br>&emsp;7.查看Secret并分别复制两行ID<br>&emsp;8.前往<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo下载页面</a>选择对应版本下载安装<br>&emsp;9.打开PicGo图床设置的阿里云页面填写相关资料<br>&emsp;10.上传区选择格式就能使用了<br>二.SM.MS<br>&emsp;1.<a href="https://smms.app/">官网注册/登录</a><br>&emsp;2.复制<a href="https://smms.app/home/apitoken">此页面</a>的Secret Token<br>&emsp;3.在<a href="https://smms.app/">此页面</a>上传文件<br>&emsp;4.打开PicGo的SM.MS页面粘贴Secret Token<br>&emsp;5.上传区选择格式就能使用了</p><p>注:<br>1.我在使用PicGo链接SM.MS时总是失败，不知道为啥<br>2.因为阿里云不是免费的，想省钱可以选择香港<br>3.一定要设置<a href="https://help.aliyun.com/document_detail/31869.html?spm=5176.8466032.bucket.28.27b81450rEXDcJ">防盗链</a></p><h5 id="图床在markdown中的使用"><a href="#图床在markdown中的使用" class="headerlink" title="图床在markdown中的使用"></a>图床在markdown中的使用</h5><p>方法一:使用img标签</p><pre><code> &lt;img src=&quot;图片地址&quot;&gt;</code></pre><p>方法二:md语法</p><pre><code> ![图片简介](图片地址)</code></pre><h5 id="更改图片参数"><a href="#更改图片参数" class="headerlink" title="更改图片参数"></a>更改图片参数</h5><pre><code>使用html更改位置&lt;center&gt;&lt;img src=&quot;地址&quot;&gt;&lt;/center&gt;居中对齐操作：#pic_center向左对齐操作：#pic_left向右对齐操作：#pic_right想调整图片的尺寸就在上面这个指令后面加上=200x200(=200x宽高自适应)width=&quot;100&quot;调整大小</code></pre><p>今天的内容就这么多，下次有空再继续写。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>眼下的生活，不是没有快乐。只是所有快乐都暗含着一层谨慎的底色。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h5 id=&quot;图床的创建&quot;&gt;&lt;a href=&quot;#图床的创建&quot; class=&quot;headerlink&quot; title=&quot;图床的创建&quot;&gt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022年度总结</title>
    <link href="https://liu1272.github.io/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-31T11:46:00.000Z</published>
    <updated>2023-01-04T11:28:04.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="呆"><a href="#呆" class="headerlink" title="呆~"></a>呆~</h4><p>  简直突如其来呐。<br>  万万没想到一个月就过去了，时间过得真快啊。</p><p>  在2022年的抗疫决赛圈，几乎所有人都成了小阳人，其中也包括我。<br>  发烧第一天真的是给我吓到了，中午一觉起来高烧42.5℃，惊恐之余赶紧撑着摇摇欲坠的身体去买布洛芬(似乎我这个城市退烧药还算充足？)到晚上睡前才降到39℃。看到那个长度我真的是笑希了，感觉39℃也不过是小问题……<br>  (⁄ ⁄•⁄ω⁄•⁄ ⁄)<br>  感谢芙灵和一个现在被迫带烧返校的可怜的江苏高三Dog!<br>  现在病情已经到了欲说还休的阶段了，因此被鹅鸭杀劝退<del>，因此才能闲到来写这个文章</del><br>  希望早日康复吧，我还想吃正新鸡排</p><p>  这个小小站点活过了第一个国庆，第一个圣诞，马上就是元旦和春节了，希望这里能永远保存下去。<br>  最近了解了GitHub Arctic Code Vault这个东东，虽然说想得到这个可能有点不现实，但是可以把它当作理想吧。<br>  (づ ●─● )づ</p><p>  对于2023年的规划没有太多的变化，仍然是多学习，多看世界，多保重身体。<br>  人生刚刚开始，未来可期。<br>  犹豫不决的时候不要问别人，问自己。听别人的如果后悔了，是要后悔两次的。</p><p>  最后，元旦快乐~</p><p>  乾杯 []~ （￣▽￣） ~*</p><h5 id="20230104补档"><a href="#20230104补档" class="headerlink" title="20230104补档"></a>20230104补档</h5><p>  <strong>试验阿里云+PicGo图床</strong><br>   <img src="https://liuguobin-blog.oss-cn-hongkong.aliyuncs.com/base.png#pic_center" width="300"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;呆&quot;&gt;&lt;a href=&quot;#呆&quot; class=&quot;headerlink&quot; title=&quot;呆~&quot;&gt;&lt;/a&gt;呆~&lt;/h4&gt;&lt;p&gt;  简直突如其来呐。&lt;br&gt;  万万没想到一个月就过去了，时间过得真快啊。&lt;/p&gt;
&lt;p&gt;  在2022年的抗疫决赛圈，几乎所有人都成了小阳人，</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>PHP序列化及常见魔术方法</title>
    <link href="https://liu1272.github.io/2022/12/04/20221204/"/>
    <id>https://liu1272.github.io/2022/12/04/20221204/</id>
    <published>2022-12-04T13:59:00.000Z</published>
    <updated>2023-03-03T11:33:39.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><pre><code>【数组序列化】&lt;?php$a=null;echo serialize($a);?&gt;a:参数数量:&#123;i:0;s:字符串长度:&quot;字符串&quot;;&#125;$a=null;         N;$b=123456;       i:123456;$c=1.2;          d:1.2;$d=true;         b:1;$e=false;        b:0;$f=&#39;benben&#39;;     s:长度:字符串;【对象序列化】&lt;?phpclass lei&#123;    public $chengyuan=&#39;zifuchuan&#39;;    function hanshu()&#123;        echo $this-&gt;chengyuan;    &#125;&#125;$a=new lei();echo serialize($a);echo urlencode(serialize($a));?&gt;O:类名长度:&quot;类名&quot;:1:&#123;s:成员长度:&quot;成员名&quot;;s:值长度:&quot;值&quot;;&#125;修饰符public公有，private私有私有的成员属性要在前后都加上二进制的%00,在urlencode时可以看见【对象序列化的嵌套】&lt;?phpclass test&#123;    public $pub=&#39;benben&#39;;    function jineng()&#123;        echo $this-&gt;pub;    &#125;&#125;class test2&#123;    var $ben;&#125;$b=new test();$a=new test2();$a-&gt;ben=$b;echo serialize($a);?&gt;O:5:&quot;test2&quot;:1:&#123;s:3:&quot;ben&quot;;O:4:&quot;test&quot;:1:&#123;s:3:&quot;pub&quot;;s:6:&quot;benben&quot;;&#125;&#125;当在对象内调用对象时，会出现嵌套:实例化后的对象$a的成员变量&#39;ben&#39;调用实例化后的对象$b</code></pre><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>1.反序列化后的内容为一个对象，与序列化相反<br>2.反序列化生成的对象内的值，由反序列化里的值提供，与原有类预定义的值无关<br>3.反序列化不触发类的成员方法，需要调用方法之后才能触发</p><pre><code>&lt;?phpclass test&#123;    public $a=&#39;benben&#39;;    protected $b=666;    private $c=false;    public function displayVar()&#123;        echo $this-&gt;a;    &#125;&#125;$d=new test();$d=serialize($d);echo urlencode($d);$a=urlencode($d);$b=unserialize(urldecode($a));$b-&gt;displayVar();var_dump($b);?&gt;benbenobject(test)#1 (3) &#123;  [&quot;a&quot;]=&gt;  string(6) &quot;benben&quot;  [&quot;b&quot;:protected]=&gt;  int(666)  [&quot;c&quot;:&quot;test&quot;:private]=&gt;  bool(false)&#125;</code></pre><h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>概念:<br>预定好的，在特定的情况下处罚的行为方法。<br>反序列化成因(作用):<br>反序列化过程中unserizlize()接收的值(字符串)可控；<br>通过更改这个值(字符串)，所得到的代码；<br>通过调用方法，触发代码执行。<br>相关机制:<br>触发时机(先决条件)-&gt;功能(最重要)-&gt;参数(尤其是pop链)-&gt;返回值<br>详解:</p><pre><code>1.__construct()构造函数在实例化对象时，自动执行的方法只有当new时触发，不需要特地调用2.__destruct()析构函数在对象的所有引用都被删除或者对象被显式销毁时才触发new和unserialize之后会触发3.__sleep()清理对象可以传入成员属性，serialize之前触发并返回一个包含对象中所有需要被序列化的变量名称的数组如果无返回则NULL被序列化，产生E_NOTICE错误4.__wakeup()预先准备对象资源，返回void在unserialize前触发5.__tostring()表达方式错误把对象当成字符串调用时触发，如echo，print6.__invoke()格式表达错误把对象当成函数调用时触发，如echo $a() -&gt; hanshu7.__call()不存在方法不存在调用的方法时触发8.__callStatic()不存在方法静态调用或调用成员常量不存在时使用9.__get()不存在方法检查成员属性是否存在10.__set()不存在方法给不存在的成员属性赋值时触发11.__isset()或__empty()或__unset()不可访问对不可访问的属性访问时会触发如protect属性(不可读)或根本不存在的属性12.__clone()复制使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone()</code></pre><p>注意:<br>1.只有该类或对象包含了该魔术方法才能被使用或触发<br>2.先分析尾部代码看看有什么执行的步骤<br>3.接着从触发的方法及其顺序判断漏洞的利用地点<br>4.最后构造playload<br>5.比较长的代码建议使用反推法进行分析<br>6.一定要先实例化(new)</p><h4 id="POP链"><a href="#POP链" class="headerlink" title="POP链"></a>POP链</h4><p>反序列化中成员变量可以被控制，使用有一种漏洞叫面向属性编程(POP)<br>POP链是利用魔术方法在里面多次跳转然后获取敏感信息的一种playload</p><h4 id="POC编写"><a href="#POC编写" class="headerlink" title="POC编写"></a>POC编写</h4><p>概念验证(POC)是漏洞验证程序，只是为了证明提出者观点的一段代码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221202</title>
    <link href="https://liu1272.github.io/2022/12/02/20221202/"/>
    <id>https://liu1272.github.io/2022/12/02/20221202/</id>
    <published>2022-12-02T12:14:40.000Z</published>
    <updated>2022-12-02T15:17:22.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Gi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>20221202</title>
    <link href="https://liu1272.github.io/2022/12/02/20221202/"/>
    <id>https://liu1272.github.io/2022/12/02/20221202/</id>
    <published>2022-12-01T16:45:00.000Z</published>
    <updated>2022-12-02T16:46:15.340Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>小声比比</title>
    <link href="https://liu1272.github.io/2022/12/01/20221201%E6%9C%88%E7%BB%93/"/>
    <id>https://liu1272.github.io/2022/12/01/20221201%E6%9C%88%E7%BB%93/</id>
    <published>2022-12-01T12:13:00.000Z</published>
    <updated>2023-03-03T11:33:57.550Z</updated>
    
    <content type="html"><![CDATA[<h5 id="又是一个月，该总结一下了"><a href="#又是一个月，该总结一下了" class="headerlink" title="又是一个月，该总结一下了"></a>又是一个月，该总结一下了</h5><p>  首先还是这个月干了啥。<br>  好像也没干啥？？？<br>  学了JS，PHP，数据库，一点点命令，还有算是课内知识的python爬虫<br>  虽然看着学了很多，但是基础并不牢固。<br>  因此<br>  我可能将要用至少一个月的时间来消化从建站到现在所学的内容<br>  毕竟…<br>  高数和现代终究是大头，还有一个计导虎视眈眈</p><p>  接着来说说接下来一个月的计划吧~<br>  首先，既然是在家上网课<br>  当然是要<br>  <del>吃了就睡，睡了就吃，跟个死猪一样</del><br>  <em><strong>好好学习，天天向上</strong></em></p><h5 id="鸭梨山大"><a href="#鸭梨山大" class="headerlink" title="鸭梨山大"></a>鸭梨山大</h5><p>  其实在这个月的学习中我的感触很深，网络安全绝不是一朝一夕可以完成的(屁话)<br>  现在所学的全部这些内容可以说都是前置知识的一部分<br>  包括在平时练习的CTF，都是走向安全的一段路<br>  那么，既然如此<br>  我更应该将重心放在基础上，而非一味的追求解题量<br>  甚至是成为众人最不屑的“赛棍”。</p><h5 id="还有啥好讲的？"><a href="#还有啥好讲的？" class="headerlink" title="还有啥好讲的？"></a>还有啥好讲的？</h5><p>  既然这是一篇发布在博客的文章，那就再聊聊博客的事吧<br>  首先是最令我头疼的事——主页解析的视频老是失效。真的是脑阔疼，我找了很久了，但是一直没有解决方法，如果有人有方法或是突发奇想请在GitHub上评论，十分感谢！！！<br>  然后是关于加载速度有些缓慢甚至是在网不好的情况下出现白屏的问题(响应速度还是蛮快的，并没有发生许多人所说的被墙的情况，尽管是在校园网的情况下)，是因为主页启用了过多插件的缘故，在一段时间后(可能年后有空时)，会对这个blog进行一次大修改，争取加载时间缩短到1000毫秒内吧。<br>  最后，还是重复说明一下。这个博客虽然是public的，但是我只希望它的作用只是个刻录我在大学四年或更久的时光里的里程碑。时不时记录下成长经历，时不时写点随笔，时不时慷慨地发点自己总结的知识梳理，方便我自己和其他来到这里的 <em><strong>朋友们</strong></em> 学习。</p><h5 id="好了，最后还是一句"><a href="#好了，最后还是一句" class="headerlink" title="好了，最后还是一句"></a>好了，最后还是一句</h5><p><strong>人，活的不是一个点，人活起伏。</strong><br>说人话版:是个三维的东西就不要天天像个二维的玩意一样躺平~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;又是一个月，该总结一下了&quot;&gt;&lt;a href=&quot;#又是一个月，该总结一下了&quot; class=&quot;headerlink&quot; title=&quot;又是一个月，该总结一下了&quot;&gt;&lt;/a&gt;又是一个月，该总结一下了&lt;/h5&gt;&lt;p&gt;  首先还是这个月干了啥。&lt;br&gt;  好像也没干啥？？？&lt;b</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Kali常用命令</title>
    <link href="https://liu1272.github.io/2022/11/21/Kali%E5%91%BD%E4%BB%A4/"/>
    <id>https://liu1272.github.io/2022/11/21/Kali%E5%91%BD%E4%BB%A4/</id>
    <published>2022-11-21T05:12:00.000Z</published>
    <updated>2023-03-03T11:34:08.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali的常用命令"><a href="#kali的常用命令" class="headerlink" title="kali的常用命令"></a>kali的常用命令</h1><h3 id="1-基础命令"><a href="#1-基础命令" class="headerlink" title="1.基础命令"></a>1.基础命令</h3><pre><code>passwd 修改密码passwd root 修改root用户密码date 显示系统日期sudo 后面加命令 就可以调用管理权限apt-get update 更新软件列表访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。我们在新立得软件包管理器里看到的软件列表，都是通过update命令更新的。apt-get upgrade 更新软件把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。apt-get dist-upgrade 更新软件  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--【apt-get upgrade 与 apt-get dist-upgrade 的区别】upgrade:系统将现有的Package升级,如果有相依性的问题,而此相依性需要安装其它新的Package或影响到其它Package的相依性时,此Package就不会被升级,会保留下来.dist-upgrade:如果有相依性问题,需要安装/移除新的Package,就会试着去安装/移除它.(所以通常这个会被认为是有点风险的升级)apt-get upgrade 和 apt-get dist-upgrade 本质上是没有什么不同的，只不过dist-upgrade会识别出当依赖关系改变的情形并作出处理，而upgrade对此情形不处理。例如软件包 a 原先依赖 b c d，但是在源里面可能已经升级了，现在是 a 依赖 b c e。这种情况下，dist-upgrade 会删除 d 安装 e，并把 a 软件包升级，而 upgrade 会认为依赖关系改变而拒绝升级 a软件包。--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--clear 清屏sudo gpedit 特权调用gpedit编辑器reboot 重启apt-get install XXXXX 安装缺少的依赖包，（XXX）里面输入缺少依赖包的名字apt-get autoremove –purge 软件名 删除包及其依赖的软件包+配置文件等apt-get install +模块名 这种方法也可以安装模块,或者apt-get install python-模块名firefox 浏览器打开shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)su -l 切换登陆用户logout 注销用户登陆pwd 当前路径</code></pre><h3 id="2-文件夹或文本操作"><a href="#2-文件夹或文本操作" class="headerlink" title="2.文件夹或文本操作"></a>2.文件夹或文本操作</h3><pre><code>cd .. 返回上一级目录cd ../.. 返回上级两级目录cd - 返回上次所在的目录cd 文件夹名  进去文件夹cd ~ 进去当前用户主目录pwd 显示当前工作路径touch 文件名  常见文件cat 文件名 读取文档内容mkdir 文件名 创建文件夹mkdir -p 文件夹 递归创建文件夹cp 复制命令cp -r moon moons 复制moon 文件夹到当前 moons 如果有里面有文件 使用-r mv 移动命令mv moon moons 也可以说是改名mkdir 文件名 文件名 创建多个文件夹ls 显示文件和文件夹名ls -a 显示所有的文件和文件夹 包含隐藏文件ls -l 显示文件和目录的详细资料rm -f 文件  删除文件rm 文件夹名 删除文件夹rm -rf  文件/文件夹  删除文件夹 及其目录下的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar x file1.rar 解压rar包unrar x file1.rar 解压rar包dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表tar zcvf +压缩文件名 压缩文件tar zxvf +解压包名 解压文件tar -jcvf renwolesshel.tar.bz2 打包tar jxvf renwolesshel.tar.bz2 解压zip -q -r renwolesshel.zip renwolesshel/ 解压zip格式的压缩包unzip renwolesshel.zipwhich 加软件名 可以查出软件目录在哪./+文件名或者apt-get +文件名 安装文件</code></pre><h3 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h3><pre><code>arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/cpuinfo 显示CPU info的信息cat /proc/mounts 显示已加载的文件系统</code></pre><h3 id="4-vi-常用命令"><a href="#4-vi-常用命令" class="headerlink" title="4.vi 常用命令"></a>4.vi 常用命令</h3><p>vi编辑器分为三种状态，分别是：<br>1.命令模式（command mode）<br>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>2.插入模式（Insert mode）<br>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>3.底行模式（last line mode）<br>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p><pre><code>**打开**vi filename :打开或新建文件，并将光标置于第一行首vi +n filename ：打开文件，并将光标置于第n行首vi + filename ：打开文件，并将光标置于最后一行首**编辑**i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行编辑结束，按Esc返回命令模式**基本查找**/text　　查找text，按n健查找下一个，按N健查找前一个。?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。**删除**删除当前行 dd删除2行 2dd**拷贝和粘贴**yy 拷贝当前行nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。p  在当前光标后粘贴区块拷贝1. 将光标移动到要复制的文本开始的地方，按 v进入可视模式。2. 将光标移动到要复制的文本的结束的地方，按y复制。此时vim会自动将光标定位到选中文本的开始的地方，并退出可视模式。3. 我移动光标到文本结束的地方，按 p粘贴。**退出命令**:wq 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件:w保存修改**显示行号**set numberset nu输入:n，代表跳转到第n行，如:100，就跳转到第100行。撤销操作u——&gt; vim与vi的区别——&gt; vim是vi的延申 vim编辑源码会高亮 vim的命令对vi是完全兼容的</code></pre><h3 id="5-文件搜索"><a href="#5-文件搜索" class="headerlink" title="5.文件搜索"></a>5.文件搜索</h3><pre><code>find / -name file1 从 ‘/’ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find . -name &#39;*.php&#39; -mmin -30  查找最近30分钟修改的当前目录下的.php文件find . -name &#39;*.php&#39; -mtime 0  查找最近24小时修改的当前目录下的.php文件find . -name &#39;*.inc&#39; -mtime 0 -ls  查找最近24小时修改的当前目录下的.php文件，并列出详细信息find . -type f -mtime 1  查找当前目录下，最近24-48小时修改过的常规文件。find . -type f -mtime +1  查找当前目录下，最近1天前修改过的常规文件。-atime 文件访问时间-ctime 文件常见时间-mtime文件修改时间-mtime n : n为数字，意思为在n天之前的“一天之内”被更改过内容的文件-mtime +n : 列出在n天之前（不含n天本身）被更改过内容的文件名-mtime -n : 列出在n天之内（含n天本身）被更改过内容的文件名-type f 代表一个普通格式的文件 二进制文件-type d 代表文件夹find / -name *.rpm -exec chmod 755 ‘&#123;&#125;’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--文件中r w x -的含义:r是只读权限，w是写的权限，x是可执行权限,-是没有任何权限。目录中r w x的含义:r具有ls权限，w是在目录上可以增加、删除、创建权限，x是具有ls –l权限。权限     读    写   执行        读    写   执行      读   写   执行字符     r     w     x           r     w    x         r    w    x数字     4     2     1           4     2    1         4    2    1分配     对象文件所有者          文件所属组用户         其他用户chmod 777 +文件名 给单独文件赋所有权限chmod -R 777 /home/user  表示将整个/home/user目录与其中的文件和子目录的权限都设置为rwxrwxrwx常用权限-rw------- (600) 只有所有者才有读和写的权限-rw-r--r-- (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限-rwx------ (700) 只有所有者才有读，写，执行的权限-rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限-rwx--x--x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限-rw-rw-rw- (666) 每个人都有读写的权限-rwxrwxrwx (777) 每个人都有读写和执行的权限也可以使用字母模式chmod +x 和chmod a+x 是一样的，一般没有明确要求，可以就用chmod +xu代表用户   g代表用户组   o代表其它   a代表所有创建一个文件只有用户具有完全控制的权限touch 文件名chmod u+rwx 文件名 当前用户加全部的权限chmod g-r 文件名   群组把读取权限去掉chmod o-r 文件名   其他用户读取权限去掉--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径grep kali /etc/passwd grep关键词搜索find / -name moonsec 2&gt;/dev/null   搜索某个文件/文件夹 屏蔽出错信息</code></pre><h3 id="6-用户和群组"><a href="#6-用户和群组" class="headerlink" title="6.用户和群组"></a>6.用户和群组</h3><pre><code>groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组cat /etc/group | grep group_name usermod -a -G moontea k1把用户k1附加其他用户组useradd moonsecpasswd moonsecuseradd -r -m -s /bin/bash moonsec参数的意思：-r 建立系统账号-m 自动建立用户的登入目录-s /bin/bash 指定用户登入后所使用的shellsu - root 切换到root用户su 用户名 切换到普通用户</code></pre><h3 id="7-系统管理"><a href="#7-系统管理" class="headerlink" title="7.系统管理"></a>7.系统管理</h3><pre><code>top  查看正在指向的程序信息ps -ef 查看所有进程信息ps -ef | grep tomcat 查找指定进程kill -9 id 强制杀死进程env 当前的变量查看系统变量echo $PATHhostname 查看主机名history 查看历史命令</code></pre><h3 id="8-查看磁盘信息"><a href="#8-查看磁盘信息" class="headerlink" title="8.查看磁盘信息"></a>8.查看磁盘信息</h3><pre><code>df   默认不带单位，挂载点、总容量、已用、可用df  -h   友好显示（带单位），很多命令的友好显示都是-h</code></pre><h3 id="9-查看内存信息"><a href="#9-查看内存信息" class="headerlink" title="9.查看内存信息"></a>9.查看内存信息</h3><pre><code>free   默认以KB为单位，总容量、已用、可用、缓存大小free  -m   默认以MB为单位free  -h   上面2种都不带单位、只显示数值，这种是友好显示的，会带单位G、M等</code></pre><h3 id="10-查看环境变量"><a href="#10-查看环境变量" class="headerlink" title="10.查看环境变量"></a>10.查看环境变量</h3><pre><code>echo  $JAVA_HOMEecho $PATH | grep jdk</code></pre><h3 id="11-开机自启"><a href="#11-开机自启" class="headerlink" title="11.开机自启"></a>11.开机自启</h3><p>有很多程序往往都需要设置开机自启，比如tomcat、mysql、nginx等。</p><pre><code>vim /etc/rc.d/rc.local   在/etc/rc.d/rc.local文件中加入开机要自动执行的程序mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share   挂载一个windows网络共享</code></pre><h3 id="12-网卡配置"><a href="#12-网卡配置" class="headerlink" title="12.网卡配置"></a>12.网卡配置</h3><pre><code>vi /etc/network/interfacesauto eth0                     //指定网卡（根据ifconfig结果修改）iface eth0 inet static        //启动静态ipaddress 192.168.0.66          // 设置静态ipnetmask 255.255.255.0         //子网掩码gateway 192.168.0.1           //指定网关service networking restart    //重启网络systemctl restart networking  //重启网络ifconfig eth0 192.168.0.33    //设置临时ip</code></pre><h3 id="13网卡DNS服务器"><a href="#13网卡DNS服务器" class="headerlink" title="13网卡DNS服务器"></a>13网卡DNS服务器</h3><pre><code>vi /etc/resovl.confnameserver 114.114.114.114重启网卡service networking restartsystemctl restart networking注意有时候重启才生效</code></pre><h3 id="14-服务相关"><a href="#14-服务相关" class="headerlink" title="14.服务相关"></a>14.服务相关</h3><pre><code>apache2服务器打开：/etc/init.d/apache2 start 重启：/etc/init.d/apache2 restart关闭：/etc/init.d/apache2 stop/etc/init.d/network start  启动网卡echo 1 &gt; /proc/sys/net/ipv4/ip_forward  开启路由转发</code></pre><h3 id="15-linux常用网络命令"><a href="#15-linux常用网络命令" class="headerlink" title="15.linux常用网络命令"></a>15.linux常用网络命令</h3><p>网络和监控命令类似于这些： hostname, ping, ifconfig, iwconfig, netstat, nslookup, traceroute, finger, telnet, ethtool<br>用于查看 linux 服务器 ip 地址，管理服务器网络配置，通过 telnet 和 ethernet 建立与 linux 之间的网络链接，查看 linux 的服务器信息等。</p><pre><code>hostname 查看本机名ping  一般用于测试网络是否通 内网icmpping www.baidu.com -c 3 执行3次ifconfig 网卡信息iwconfig 用于配置或获取无线网络设备信息netstat -a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到netstat -ano-an 查看当前所有已连接端口-nlpt 查看当前所有tcp端口-nlpu 查看当前所有udp端口-nlpt | grep 80 查看所有80端口使用情况netstat -lntup 查看所有的tcp和upd端口nslookup 查询其他记录直接查询返回的是A记录，我们可以指定参数，查询其他记录，比如AAAA、MX等。nslookup -qt=type domain [dns-server]其中，type可以是以下这些类型：A 地址记录AAAA 地址记录AFSDB Andrew文件系统数据库服务器记录ATMA ATM地址记录CNAME 别名记录HINFO 硬件配置记录，包括CPU、操作系统信息ISDN 域名对应的ISDN号码MB 存放指定邮箱的服务器MG 邮件组记录MINFO 邮件组和邮箱的信息记录MR 改名的邮箱记录MX 邮件服务器记录NS 名字服务器记录PTR 反向记录RP 负责人记录RT 路由穿透记录SRV TCP服务器信息记录TXT 域名对应的文本信息X25 域名对应的X.25地址记录traceroute-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。(traceroute是用来检测发出数据包的主机到目标主机之间所经过的网关数量的工具。)(traceroute的原理是试图以最小的TTL（存活时间）发出探测包来跟踪数据包到达目标主机所经过的网关，然后监听一个来自网关ICMP的应答。发送数据包的大小默认为38个字节。)telnetLinux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。现在多数用于检测某个端口是否开放FingerFinger是一种用户信息分享服务。它工作在TCP 79端口，可以用来公开用户的特定信息。Nmap的finger的脚本可以向Finger服务器发送请求，查询并获取用户的相关信息，如登录名、用户名、TTY类型、登录时间等。ethtool 是用于查询及设置网卡参数的命令</code></pre><h3 id="16-防火墙iptables"><a href="#16-防火墙iptables" class="headerlink" title="16.防火墙iptables"></a>16.防火墙iptables</h3><pre><code>iptalbes -L  查看防火墙规则iptables -F   清除规则/etc/init.d/iptables stop   关闭防火墙service iptables stop安装：apt-get install ufw关闭：ufw disable # To disable the firewall开启：ufw enable # To enable the firewall</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kali的常用命令&quot;&gt;&lt;a href=&quot;#kali的常用命令&quot; class=&quot;headerlink&quot; title=&quot;kali的常用命令&quot;&gt;&lt;/a&gt;kali的常用命令&lt;/h1&gt;&lt;h3 id=&quot;1-基础命令&quot;&gt;&lt;a href=&quot;#1-基础命令&quot; class=&quot;head</summary>
      
    
    
    
    <category term="附录" scheme="https://liu1272.github.io/categories/%E9%99%84%E5%BD%95/"/>
    
    
    <category term="附录" scheme="https://liu1272.github.io/tags/%E9%99%84%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Windows常用命令</title>
    <link href="https://liu1272.github.io/2022/11/20/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://liu1272.github.io/2022/11/20/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-11-20T11:37:00.000Z</published>
    <updated>2022-11-21T11:38:20.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Windows常用命令"><a href="#Windows常用命令" class="headerlink" title="Windows常用命令"></a>Windows常用命令</h3><pre><code>ifconfig /all 获取获取域名、IP地址、DHCP服务器、网关、MAC地址、主机名net time /domain 查看域名、时间net view /domain 查看域内所有共享net view ip 查看对方局域网内开启了哪些共享net config workstation 查看域名、机器名等net user 用户名 密码 /add 建立用户net user 用户名 /del #删除用户net user guest /active:yes 激活guest账户net user 查看账户net user 账户名 查看指定账户信息net user /domain 查看域内有哪些用户，Windows NT Workstation 计算机上可用，由此可以此判断用户是否是域成员。net user 用户名 /domain 查看账户信息net group /domain 查看域中的组net group &quot;domain admins&quot; /domain 查看当前域的管理用户query user 查看当前在线的用户net localgroup 查看所有的本地组net localgroup administrators 查看administrators组中有哪些用户net localgroup administrators 用户名 /add 把用户添加到管理员组中net start 查看开启服务net start 服务名 开启某服务net stop 服务名 停止某服务net share 查看本地开启的共享net share ipc$ 开启ipc$共享net share ipc$ /del 删除ipc$共享net share c$ /del 删除C：共享\\192.168.0.108\c 访问默认共享c盘dsquery server 查看所有域控制器dsquery subnet 查看域内内子网dsquery group 查看域内工作组dsquery site 查看域内站点netstat -a 查看开启了哪些端口,常用netstat -annetstat -n 查看端口的网络连接情况，常用netstat -annetstat -v 查看正在进行的工作netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）netstat -s 查看正在使用的所有协议使用情况nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写reg save hklm\sam sam.hive 导出用户组信息、权限配置reg save hklm\system system.hive 导出SYSKEYnet use \\目标IP\ipc$ 密码 /u:用户名 连接目标机器at \\目标IP 21:31 c:\server.exe 在某个时间启动某个应用wmic /node:&quot;目标IP&quot; /password:&quot;123456&quot; /user:&quot;admin&quot; 连接目标机器psexec.exe \\目标IP -u username -p password -s cmd 在目标机器上执行cmdfinger username @host 查看最近有哪些用户登陆route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interfacearp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a 将显示出全部信息nslookup IP地址侦测器tasklist 查看当前进程taskkill /pid PID数 终止指定PID进程whoami 查看当前用户及权限systeminfo 查看计算机信息（版本，位数，补丁情况）ver 查看计算机操作系统版本tasklist /svc 查看当前计算机进程情况netstat -ano 查看当前计算机进程情况wmic product &gt; ins.txt 查看安装软件以及版本路径等信息，重定向到ins.txt</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Windows常用命令&quot;&gt;&lt;a href=&quot;#Windows常用命令&quot; class=&quot;headerlink&quot; title=&quot;Windows常用命令&quot;&gt;&lt;/a&gt;Windows常用命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;ifconfig /all 获取获取域名、IP地址、</summary>
      
    
    
    
    <category term="附录" scheme="https://liu1272.github.io/categories/%E9%99%84%E5%BD%95/"/>
    
    
    <category term="附录" scheme="https://liu1272.github.io/tags/%E9%99%84%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ODBC数据库</title>
    <link href="https://liu1272.github.io/2022/11/19/ODBC%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://liu1272.github.io/2022/11/19/ODBC%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-11-18T18:49:00.000Z</published>
    <updated>2022-11-21T06:03:24.436Z</updated>
    
    <content type="html"><![CDATA[<h5 id="此章节是拓展阅读，选择性食用"><a href="#此章节是拓展阅读，选择性食用" class="headerlink" title="此章节是拓展阅读，选择性食用"></a>此章节是拓展阅读，选择性食用</h5><p>概念:ODBC 是一种应用程序编程接口(API)，使我们有能力连接到某个数据源。</p><h4 id="创建-ODBC-连接"><a href="#创建-ODBC-连接" class="headerlink" title="创建 ODBC 连接"></a>创建 ODBC 连接</h4><p>通过一个 ODBC 连接，可以连接到网络中的任何计算机上的任何数据库。<br>创建到达 MS Access 数据库的 ODBC 连接的方法:<br>1.在控制面板中打开管理工具图标。<br>2.双击其中的数据源(ODBC)图标。<br>3.选择系统 DSN 选项卡。<br>4.点击系统 DSN 选项卡中的添加。<br>5.选择Microsoft Access Driver。点击完成。<br>6.在下一个界面，点击选择来定位数据库。<br>7.为数据库起一个数据源名(DSN)。<br>8.点击确定。</p><p>注意:必须在您的网站所在的计算机上完成这个配置。<br>如果您的计算机上正在运行 Internet 信息服务(IIS)，上面的指令将会生效。<br>但是如果您的网站位于远程服务器，您必须拥有对该服务器的物理访问权限，或者请您的主机提供商为您建立 DSN。</p><h4 id="连接-ODBC"><a href="#连接-ODBC" class="headerlink" title="连接 ODBC"></a>连接 ODBC</h4><pre><code>实例下面的实例创建了到达名为 link 的 DSN 的连接，没有用户名和密码。然后创建并执行一条 SQL 语句：$conn=odbc_connect(&#39;link&#39;,&#39;&#39;,&#39;&#39;);           //数据源名、用户名、密码以及可选的指针类型$sql=&quot;SELECT * FROM customers&quot;;$rs=odbc_exec($conn,$sql);                  //执行 SQL 语句</code></pre><h4 id="取回记录"><a href="#取回记录" class="headerlink" title="取回记录"></a>取回记录</h4><p>从结果集中返回记录。如果能够返回行，则函数返回 true，否则返回 false。</p><pre><code>该函数有两个参数：ODBC 结果标识符和可选的行号:odbc_fetch_row ( resource $result_id [, int $row_number = 1 ] )</code></pre><h4 id="从记录中取回字段"><a href="#从记录中取回字段" class="headerlink" title="从记录中取回字段"></a>从记录中取回字段</h4><p>从记录中读取字段。该函数有两个参数:ODBC 结果标识符和字段编号或名称。</p><pre><code>$compname=odbc_result($rs,1);                             //从记录中返回第一个字段的值$compname=odbc_result($rs,&quot;CompanyName&quot;);                 //返回名为 &quot;CompanyName&quot; 的字段的值</code></pre><h4 id="关闭-ODBC-连接"><a href="#关闭-ODBC-连接" class="headerlink" title="关闭 ODBC 连接"></a>关闭 ODBC 连接</h4><p> odbc_close($conn); </p><h4 id="全过程示例"><a href="#全过程示例" class="headerlink" title="全过程示例"></a>全过程示例</h4><pre><code> &lt;?php $conn=odbc_connect(&#39;northwind&#39;,&#39;&#39;,&#39;&#39;);            //连接 ODBC if (!$conn)                                       //验证链接 &#123;exit(&quot;Connection Failed: &quot; . $conn);&#125;            //失败的回显 $sql=&quot;SELECT * FROM customers&quot;;                   //创建链接 $rs=odbc_exec($conn,$sql);                        //执行 SQL 语句 if (!$rs) &#123;exit(&quot;Error in SQL&quot;);&#125;                           //判断是否连接正常 echo &quot;&lt;table&gt;&lt;tr&gt;&quot;; echo &quot;&lt;th&gt;Companyname&lt;/th&gt;&quot;;                      //回显 echo &quot;&lt;th&gt;Contactname&lt;/th&gt;&lt;/tr&gt;&quot;; while (odbc_fetch_row($rs))                       //取回记录 &#123; $compname=odbc_result($rs,&quot;CompanyName&quot;);         //从记录中取回字段compname $conname=odbc_result($rs,&quot;ContactName&quot;);          //从记录中取回字段compname echo &quot;&lt;tr&gt;&lt;td&gt;$compname&lt;/td&gt;&quot;;  echo &quot;&lt;td&gt;$conname&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; odbc_close($conn);                                //关闭 ODBC 连接 echo &quot;&lt;/table&gt;&quot;; ?&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;此章节是拓展阅读，选择性食用&quot;&gt;&lt;a href=&quot;#此章节是拓展阅读，选择性食用&quot; class=&quot;headerlink&quot; title=&quot;此章节是拓展阅读，选择性食用&quot;&gt;&lt;/a&gt;此章节是拓展阅读，选择性食用&lt;/h5&gt;&lt;p&gt;概念:ODBC 是一种应用程序编程接口(AP</summary>
      
    
    
    
    <category term="附录" scheme="https://liu1272.github.io/categories/%E9%99%84%E5%BD%95/"/>
    
    
    <category term="附录" scheme="https://liu1272.github.io/tags/%E9%99%84%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>基于面向对象的Python爬虫</title>
    <link href="https://liu1272.github.io/2022/11/19/20221119/"/>
    <id>https://liu1272.github.io/2022/11/19/20221119/</id>
    <published>2022-11-18T18:36:00.000Z</published>
    <updated>2023-03-03T11:34:22.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="基于面向对象的Python爬虫"><a href="#基于面向对象的Python爬虫" class="headerlink" title="基于面向对象的Python爬虫"></a>基于面向对象的Python爬虫</h4><pre><code>import urllib.requestimport reclass GetHtml(object):    def __init__(self,URL,HEAD):      //初始化        self.url=URL        self.head=HEAD        def get_index(self):              //获取主页信息        self.request=urllib.request.Request(self.url)        self.request.add_header(&#39;user-agent&#39;,self.request)        self.response=urllib.request.urlopen(self.request)        return self.response.read()        def get_list(self):               //获取符合条件的列表        self.strimglist=[]        self.imglist=re.findall(b&#39;匹配条件&#39;,self.get_index())        for i in self.imglist:            self.strimglist.append(self.url+str(i,encoding=&#39;utf8&#39;))        return self.strimglist        def get_image(self):              //下载资源        num=0        for self.url in self.get_list():            num+=1            with open(str(num)+&#39;后缀&#39;,&#39;wb&#39;) as file:                file.write(self.get_index())html=GetHtml(&#39;目标地址&#39;,&#39;请求头&#39;)html.get_list()</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。"><a href="#有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。" class="headerlink" title="有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。"></a>有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;基于面向对象的Python爬虫&quot;&gt;&lt;a href=&quot;#基于面向对象的Python爬虫&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://liu1272.github.io/2022/11/18/20221118/"/>
    <id>https://liu1272.github.io/2022/11/18/20221118/</id>
    <published>2022-11-17T18:35:00.000Z</published>
    <updated>2023-03-03T11:34:35.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>类:设计<br>对象:实例</p><h4 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h4><p>驼峰命名法</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>class 类名:    属性(变量) = 值    def 函数名(self):         //方法(函数),一定要写self        执行代码对象名=类名()                 //创建对象对象名.函数()                 //调用对象</code></pre><h4 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h4><p>通常格式为__方法名__</p><pre><code>def __init__(self,值):    self.属性=值如果值也是一个变量就能随时传参进行更改</code></pre><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>1.定义类class<br>2.创建内存空间,定义属性和方法<br>3.实例化类,创建对象<br>4.调用类的方法</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="风吹落最后一片叶，"><a href="#风吹落最后一片叶，" class="headerlink" title="风吹落最后一片叶，"></a>风吹落最后一片叶，</h5><h5 id="我的心也飘着雪，"><a href="#我的心也飘着雪，" class="headerlink" title="我的心也飘着雪，"></a>我的心也飘着雪，</h5><h5 id="爱只能往回忆里堆叠。"><a href="#爱只能往回忆里堆叠。" class="headerlink" title="爱只能往回忆里堆叠。"></a>爱只能往回忆里堆叠。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;面向对象编程&quot;&gt;&lt;a href=&quot;#面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;面向对象编</summary>
      
    
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫一篇就够了</title>
    <link href="https://liu1272.github.io/2022/11/17/20221117/"/>
    <id>https://liu1272.github.io/2022/11/17/20221117/</id>
    <published>2022-11-17T04:02:00.000Z</published>
    <updated>2023-03-03T11:37:57.352Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Python爬虫思路"><a href="#Python爬虫思路" class="headerlink" title="Python爬虫思路"></a>Python爬虫思路</h4><p>1.发送请求获取网站html代码<br>2.过滤有效信息<br>3.解析数据<br>4.处理数据</p><h4 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h4><p>1.找到网站发起请求<br>2.分析url并提取<br>3.分析url并解释网络内容<br>4.存储数据并获取新url<br>5.判断是否满足停止条件0</p><h4 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h4><p>决定可以访问的user(允许爬取的user)</p><h4 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h4><p>http端口是8080<br>https加密,SSL层,端口是443</p><h4 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h4><p>url包括协议类型，主机名/域名，端口号，查找路径，查找参数，锚点<br>uri是utl请求之前部分</p><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>get不影响资源/post影响资源</p><h4 id="请求头参数"><a href="#请求头参数" class="headerlink" title="请求头参数"></a>请求头参数</h4><p>user-agent:浏览器名称<br>referer:请求源头<br>cookie:用于判断用户身份</p><h4 id="常见响应状态码"><a href="#常见响应状态码" class="headerlink" title="常见响应状态码"></a>常见响应状态码</h4><p>200:正常返回<br>301:永久重定向<br>404:url错误<br>418:反爬虫，解决响应<br>500:服务器错误，bug</p><h4 id="请求交互过程"><a href="#请求交互过程" class="headerlink" title="请求交互过程"></a>请求交互过程</h4><p>1.客户端浏览器向服务器发送请求<br>2.网站接收请求处理后返回响应数据<br>3.浏览器解析源码</p><h4 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h4><p>element:分析网页结构，获取数据<br>console:打印输出网站信息<br>network:查看网络请求<br>source:所有的源文件(只能查看静态数据)</p><h4 id="Session与Cookie原理"><a href="#Session与Cookie原理" class="headerlink" title="Session与Cookie原理"></a>Session与Cookie原理</h4><p>【Session】<br>特点:可长时间保存会话<br>过程:<br>1.客户端第一次发送请求时服务器端创建Session对象(生成sessionID)<br>2.将sessionID存入cookie传回<br>3.下次发送请求时包含sessionID<br>【Cookie】<br>特点:从服务器发送给浏览器后一直保存到关闭浏览器<br>过程:<br>1.创建cookie<br>2.设置存储cookie<br>3.发送cookie<br>4.读取cookie</p><h4 id="JSON-数据交换语言"><a href="#JSON-数据交换语言" class="headerlink" title="JSON(数据交换语言)"></a>JSON(数据交换语言)</h4><p>JavaScript ObjectNotation，JS对象标记<br>数据格式:<br>1.对象表示为键值对<br>2.数据用逗号分隔<br>3.花括号保存对象<br>4.方括号保存数组<br>整体上与python的字典相似<br>例:</p><pre><code>json_yuju=&#123;&#39;name&#39;:&#39;python&#39;,&#39;address&#39;:&#123;&#39;province&#39;:&#39;guangdong&#39;,&#39;city&#39;:[&#39;guangzhou&#39;,&#39;huizhou&#39;]&#125;&#125;print(json_yuju[&#39;address&#39;][&#39;city&#39;][2])               //输出huizhou</code></pre><h4 id="Ajax-Web数据交互方式"><a href="#Ajax-Web数据交互方式" class="headerlink" title="Ajax(Web数据交互方式)"></a>Ajax(Web数据交互方式)</h4><p>Ajax在服务器与浏览器之间使用异步数据传输(可以只请求少量信息)<br>Ajax技术独立于浏览器与平台<br>Ajax一般返回JSON(对Ajax地址进行post或get就可以返回JSON数据)<br>Ajax渲染到html的叫做动态数据<br>服务器后台生成的是静态数据<br>html中的在source中没有找到那就是ajax<br>注意:Ajax需要用户允许JavaScript在浏览器上执行</p><h4 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h4><p>py自带的网络请求库<br>模块:<br>urllib.request打开并读取url</p><pre><code>模拟浏览器发送请求并获取响应结果data默认为None即Get请求，post请求时要将data以字典形式存储，由字典类型转换成字节类型转换成的数据类型看网页源代码【GET】import urllib.requesturl=&#39;https......&#39;                           //传入urlresponse=urllib.request.urlopen(url)        //发送get请求html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【POST】import urllib.requesturl=&#39;https......&#39;                           //传入urldata=&#123;&#39;a&#39;:&#39;A&#39;,&#39;b&#39;:&#39;B&#39;,&#39;action&#39;:&#39;login&#39;&#125;     //从Form Data处查看response=urllib.request.urlopen(url,data=bytes(urllib.prase.urlencode(data),encoding=&#39;utf-8&#39;))html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【通过伪造请求头绕过418】import urllib.requesturl=&#39;https......&#39;                           //传入urlheader=&#123;&#39;User-Agent&#39;:&#39;浏览器信息&#39;&#125;request=urllib.request.Request(url,headers=header)response=urllib.request.urlopen(request)html=response.read().decode(&#39;utf-8&#39;)        //读取响应并将数据类型转为strprint(html)</code></pre><p>urllib.error包含提出的异常urllib.request</p><pre><code>import urllib.requestimport urllib.errorurl=&#39;目标地址&#39;try:    response=urllib.request.urlopen(url)    //尝试链接expect urllib.error.URLError as e:          //捕获返回信息    print(e.reason)</code></pre><p>urllib.parse解析url</p><pre><code>import urllib.parsea=&#123;&#39;A&#39;:&#39;内容&#39;&#125;                              //创建键值对result1=urllib.parse.urlencode(a)           //url编码result2=urllib.prase.unquote(result1)       //url解码属性:code:请求返回的状态码reason:返回错误的原因headers:请求返回的响应头信息</code></pre><p>urllib.robotparase解析robots.txt文件</p><h4 id="IP代理"><a href="#IP代理" class="headerlink" title="IP代理"></a>IP代理</h4><p>网站会拒绝同一IP多次访问<br>命令行中输入ipconfig的IPv4是本地IP<br>分类:<br>1.透明代理，知道使用了且知道源IP<br>2.匿名代理，知道使用了但是不知道源IP<br>3.高匿代理，都不知道<br><a href="https://www.xicidaili.com/nn/">免费网站</a><br>语法:</p><pre><code>from urllib.request import build_openerfrom urllib.request import ProxyHandlerproxy=ProxyHandler(&#123;&#39;协议类型http/https&#39;:&#39;IP地址:端口&#39;&#125;)opener=build_opener(proxy)url=&#39;目标地址&#39;response=opener.open(url)print(response.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h4><p>使用步骤:<br>1.实例化MozillaCookieJar(保存cookie)<br>2.创建handler对象(cookie的处理器)<br>3.创建opener对象<br>4.打开网页发送请求获取响应<br>5.保存cookie文件<br>语法:</p><pre><code>import urllib.requestfrom http import cookiejarfilename=&#39;cookie.txt&#39;def get_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar(filename)           //实例化MCJ    handler=urllib.request.HTTPCookieProcessor(cookie)    //创建handler对象    opener=urllib.request.build_opener(handler)           //创建opener对象    url=&#39;目标地址&#39;    response=opener.open(url)                             //发送请求并获取响应    cookie.save()                                         //保存cookie文件def use_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar()                   //实例化MCJ    cookie.load(filename)                                 //加载cookie文件    print(cookie)if __name__ = &#39;__main__&#39;:    use_cookie()                                          //读取cookie</code></pre><h4 id="requests库-包括上面的功能"><a href="#requests库-包括上面的功能" class="headerlink" title="requests库(包括上面的功能)"></a>requests库(包括上面的功能)</h4><pre><code>常用方法:requestsrequests.request(url)            //构造请求requests.get(url,params=None)    //Get请求。params可省略,params是请求的参数requests.post(url,data=None,json=None)requests.head()                  //获取html头部信息requests.put()                   //发送Put请求requests.patch()                 //提交局部修改的请求requests.delete()                //提交删除请求params是请求参数常用属性:response.status_code             //响应状态码response.content                 //response对象转为二进制数据response.text                    //response对象转为字符串数据response.encoding                //定义response对象编码response.cookies()               //获取请求后的cookieresponse.session()               //获取请求后的sessionresponse.url                     //获取请求网址response.json()                  //内置JSON解码器Response.headers                 //以字典对象存储服务器响应头，字典不分大小写获取二进制数据实例:import requestsurl=&#39;目标文件的地址&#39;response=requests.get(url)with open(&#39;文件名,模式&#39;,&#39;wb&#39;) as file:              //读写文件的操作    file.write(response.content)    常用参数:r:   以只读方式打开文件。文件的指针将会放在文件的开头。这是**默认模式**。r+:  打开一个文件用于读写。文件指针将会放在文件的开头。w:   打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。w+:  打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。a:   打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。a+:  打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。rb:  以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。rb+: 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。wb:  以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。wb+: 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。ab:  以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。ab+: 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。file.read([size])        将文件数据作为字符串返回，可选参数size控制读取的字节数file.readlines([size])   返回文件中行内容的列表，size参数可选file.write(str)          将字符串写入文件file.writelines(strings) 将字符串序列写入文件file.close()             关闭文件file.closed              表示文件已经被关闭，否则为Falsefile.mode                Access文件打开时使用的访问模式file.encoding            文件所使用的编码file.name                文件名file.newlines            未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，则为一个包含所有当前所遇到的行结束的列表file.softspace           为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用</code></pre><h4 id="XPath解析数据-lxml库"><a href="#XPath解析数据-lxml库" class="headerlink" title="XPath解析数据(lxml库)"></a>XPath解析数据(lxml库)</h4><p>概述:<br>小型查询语言，在XML文档中查找信息的语言<br>优点:<br>可在XPath中查找信息<br>支持HTML查找<br>可通过元素和属性进行导航<br>XML树形结构和语句与HTML相类似<br>XPath语法点击<a href="https://blog.csdn.net/Victor2code/article/details/108298390?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166877297016782395359090%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166877297016782395359090&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108298390-null-null.142%5Ev65%5Eopensearch_v2,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=xpath%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187">此处</a><br>代码实现:</p><pre><code>import requestsfrom lxml import etreeurl=&#39;目标地址&#39;headers=&#123;请求头信息，以键值对形式存储&#125;response=requests.get(url,headers)etree=rtree.HTML(response.text)                       //将响应的str类型转换为etree类型A=etree.xpath(&#39;谷歌浏览器中XPath的语句&#39;)              //获取内容B=etree.path(&#39;另一个语句&#39;)for A中定位的元素,B中定位的元素 in zip(A,B)           //遍历打包    print(A中定位的元素, &#39;:&#39; ,B中定位的元素)          //输出</code></pre><h4 id="BeautifulSoup解析数据-bs4库"><a href="#BeautifulSoup解析数据-bs4库" class="headerlink" title="BeautifulSoup解析数据(bs4库)"></a>BeautifulSoup解析数据(bs4库)</h4><p>概述:<br>能从HTML和XML文件中提取数据的库<br>语法:</p><pre><code>                        【Tag对象】print(bs.标签)                       //获取标签print(bs.标签.attrs)                 //获取标签的全部属性print(bs.标签[&#39;属性名&#39;])             //获取属性值print(bs.标签.text)                  //获取标签的文本内容(不包括注释内的)print(bs.标签.string)                //获取标签的文本内容(包括注释内的)                        【CSS选择器】print(bs.select(&#39;ID&#39;))               //ID查找print(bs.select(&#39;classa&#39;))           //classa查找print(bs.select(标签,属性))          //属性查找                        【其他功能】print(bs.find(标签,属性))            //提取首个满足条件的print(bs.find_all(标签,属性))        //提取所有满足条件的</code></pre><p>代码实现:</p><pre><code>import requestsfrom bs4 import BeautifulSoupurl=&#39;目标地址&#39;headers=&#123;头文件键值对&#125;response=requests.get(url,headers)bs=BeautifulSoup(response.text,&#39;html.parser&#39;)               //bs=BeautifulSoup(response.text,&#39;lxml&#39;)二选一使用即可a_list=bs.find_all(&#39;标签&#39;)for a in a_list:    url=a.get(&#39;属性&#39;)    if url==None                                              //以None开头的url无用        continue    if url.startswich(&#39;http&#39;) or url.startswich(&#39;https&#39;)      //保留以http或https开头的url        print(url)</code></pre><h4 id="正则表达式-re库"><a href="#正则表达式-re库" class="headerlink" title="正则表达式(re库)"></a>正则表达式(re库)</h4><p>概述:<br>特殊的字符序列，检查字符串是否与某种模式相匹配<br>正则语法:</p><pre><code>.           //匹配任意字符^           //匹配字符串开头$           //匹配字符串末尾*           //匹配前一个元字符0到多次+           //匹配前一个元字符1到多次?           //匹配前一个元字符0到1次&#123;m&#125;         //匹配前一个元字符m次&#123;m,n&#125;       //匹配前一个元字符m到n次&#123;m,n&#125;?      //匹配前一个元字符m到n次，并去尽可能少的情况\\          //对特殊字符转义[]          //字符集合，匹配其中任意一个字符|           //或(...)       //作为一个元组，findall在有组情况下只显示组的内容</code></pre><p>特殊序列:</p><pre><code>\A          //只在字符串开头匹配\b          //匹配开头或结尾的空字符串\B          //匹配不位于开头或结尾的空字符串\d          //匹配十进制数，[0-9]\D          //匹配非字符数字字符，[^0-9]s           //匹配空白字符，[\t\n\r\f\v]\S          //匹配非空白字符，[^\t\n\r\f\v]\w          //匹配数字字母下划线，[a-z A-Z 0-9]\W          //匹配非数字字母下划线，[^a-z A-Z 0-9]\Z          //只在字符串末尾进行匹配[\u4e00-\u9fa5]         //中文</code></pre><p>正则处理函数:</p><pre><code>re.match(pattern,string,flags=0)                  //从字符串开头匹配模式，成功则返回成功的对象，否则返回Nonere.search(pattern,string,flags=0)                 //扫描整个字符串返回第一个成功匹配的对象，失败则返回Nonere.findall(pattern,string,flags=0)                //获取列表的所有匹配的字符串，以列表形式返回re.sub(pattern,repl,string,count=0,flags=0)       //用于替换字符串的匹配项，没有匹配项则返回没有匹配的字符串re.compile(pattern,[,flag])                       //编译正则表达式，生成正则表达式对象，供match和search函数使用</code></pre><h4 id="爬取并下载视频示例"><a href="#爬取并下载视频示例" class="headerlink" title="爬取并下载视频示例"></a>爬取并下载视频示例</h4><pre><code>import requestsimport reurl=&#39;目标地址&#39;headers=&#123;请求头&#125;response=requests.get(url,headers=headers)                            //发送请求info=re.findall(&#39;标签，配合使用正则表达式&#39;,response.text)             //正则查找所有符合要求的对象lst=[]for item in info:    lst.append(&#39;https:&#39;+item)                                         //将符合条件的对象放入列表中并补全绝对路径count=0for item in lst:    count+=1    response=requests.get(item.headers=headers)                       //将补全的路径再次请求    with open(&#39;存储路径&#39;+str(count)+&#39;后缀&#39;) as file                   //设置下载路径和文件名        file.write(response.content)                                  //将文件存为二进制print(下载完毕)</code></pre><h4 id="pyquery解析数据-pyquery库"><a href="#pyquery解析数据-pyquery库" class="headerlink" title="pyquery解析数据(pyquery库)"></a>pyquery解析数据(pyquery库)</h4><p>概述:<br>是jQuery的Python实现，可以jQuery语法操作解析HTML文档，易用性和解析速度很好<br>初始化方式:</p><pre><code>字符串方式from pyquery import PyQuery as pyhtml=&#39;html代码&#39;doc=py(html)      //创建PyQuery对象，将str类型转换为PyQuery类型url方式from pyquery import PyQuerydoc=PyQuery(url=&#39;地址&#39;,encoding=&#39;utf-8&#39;)文件from pyquery import PyQuerydoc=PyQuery(filename=&#39;存有html文件的地址&#39;)</code></pre><p>使用方式:</p><pre><code>doc(&#39;#main&#39;)                             //获取当前节点doc(&#39;#main&#39;).children()                  //获取子节点doc(&#39;#main&#39;).parent()                    //获取父节点doc(&#39;#main&#39;).sinlings()                  //获取兄弟节点doc(&#39;标签&#39;)attr(&#39;属性&#39;)                  //获取属性值doc(&#39;#main&#39;).html()                      //获取内容，以html代码形式显示doc(&#39;#main&#39;).text()                      //获取内容，以文本显示显示</code></pre><p>代码实现:</p><pre><code>import requestsfrom pyquery import PyQuery as pyurl=&#39;&#39;headers=&#123;&#125;response=resquests.get(url,headers=headers)   //发送请求doc=py(response.text)                         //初始化PyQuery对象A=[x.text for x in doc(h4 a)]                 //从doc中提取h4中的a标签的内容传给x，再显示x的文本部分</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>requests用于发送和接收请求<br>四种解析方式是数据的提取<br>对于爬虫更重要的是提取了数据之后对数据的操作</p><h4 id="2023-3-3补档"><a href="#2023-3-3补档" class="headerlink" title="2023.3.3补档"></a>2023.3.3补档</h4><p>今日发现一个好用的库叫做URLParser，可以去尝试一下</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="想不清楚一件事，往往因为这件事里有你想逃避的东西。"><a href="#想不清楚一件事，往往因为这件事里有你想逃避的东西。" class="headerlink" title="想不清楚一件事，往往因为这件事里有你想逃避的东西。"></a>想不清楚一件事，往往因为这件事里有你想逃避的东西。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;Python爬虫思路&quot;&gt;&lt;a href=&quot;#Python爬虫思路&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
</feed>
