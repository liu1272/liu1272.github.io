<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin</title>
  
  <subtitle>LiuGuobin&#39;s blog</subtitle>
  <link href="https://liu1272.github.io/atom.xml" rel="self"/>
  
  <link href="https://liu1272.github.io/"/>
  <updated>2023-01-13T15:13:49.520Z</updated>
  <id>https://liu1272.github.io/</id>
  
  <author>
    <name>liuGuobin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20230112</title>
    <link href="https://liu1272.github.io/2023/01/12/20230112/"/>
    <id>https://liu1272.github.io/2023/01/12/20230112/</id>
    <published>2023-01-12T15:00:00.000Z</published>
    <updated>2023-01-13T15:13:49.520Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png" alt="真正值得纪念的，或许不止是一张画片"><br><img src="https://s2.loli.net/2023/01/13/1vqJb5eflmtMFIp.png" alt="你见证了她的努力，此时就再守护她一会吧"><br><img src="https://s2.loli.net/2023/01/13/sCdprRjVKS1Gz3X.png" alt="想找出“恋爱”的公式，或许还需要一段时间"><br><img src="https://s2.loli.net/2023/01/13/SHhNsIKOYijGLuz.png" alt="玫瑰的意义，只存在于你我心中"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/12/HxhJLnMmr7TvGIX.png&quot; alt=&quot;真正值得纪念的，或许不止是一张画片&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2023/01/13/1vqJb5</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>20230107</title>
    <link href="https://liu1272.github.io/2023/01/07/20220107/"/>
    <id>https://liu1272.github.io/2023/01/07/20220107/</id>
    <published>2023-01-06T16:08:00.000Z</published>
    <updated>2023-01-12T16:00:11.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>今天是广州某大学的wx小程序研究资料。<br>既然来了，那么话不多说，直接上教程<br>首先下载安装必备的应用<br><em>关于Python的安装和环境配置就不在这里赘述了</em><br><strong><a href="https://blog.csdn.net/qq_45502336/article/details/109531599?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167291320016800186585384%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=167291320016800186585384&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-9-109531599-null-null.142%5Ev70%5Econtrol,201%5Ev4%5Eadd_ask&utm_term=python&spm=1018.2226.3001.4187">Python传送门</a></strong><br><strong>Charles</strong><br>1.前往<a href="https://www.charlesproxy.com/download/">官网</a>下载安装最新版本<br><img src="https://s2.loli.net/2023/01/07/m1S8RCupIAgQyP9.png" alt="随便选个喜欢的"><br>2.在下图处输入<strong>pojie</strong>和<strong>9d8fb452d26c0decc5</strong>后确定<br><img src="https://s2.loli.net/2023/01/07/ZzpSn2uRG8BgIoA.png" alt="恭喜你解锁VIP"></p><h5 id="接下来是抓包"><a href="#接下来是抓包" class="headerlink" title="接下来是抓包"></a>接下来是抓包</h5><p>1.关闭防火墙:打开网络设置&gt;高级网络设置&gt;Windows防火墙&gt;公用网络&gt;关闭并确认<br>2.在PC端wx中打开该小程序<br>3.在任务管理器里找到该小程序的应用<br><img src="https://s2.loli.net/2023/01/07/meVHGjo6vDNUScL.png" alt="找到这个万恶之源！"><br>4.右键点开小程序，打开文件所在位置，找到一个叫Runtime的包<br>5.将小程序和微信都关闭掉（否则部分文件删除不掉），然后将Runtime包下的文件都删除掉<br>6.把Runtime文件夹改为只读状态<br><img src="https://s2.loli.net/2023/01/07/YtoPvDxO6Z8unwa.png" alt="就是这个"><br>7.重新进入该wx小程序登录<br>8.打开Charles后在小程序内随意进入一个页面<br>9.CTRL+F输入<strong>key</strong>找到并复制字段<br><img src="https://s2.loli.net/2023/01/07/ruwzPXvIG7AWCNB.png" alt="就类似于这样，不能放得更多了"></p><h5 id="最后开始让代码跑起来"><a href="#最后开始让代码跑起来" class="headerlink" title="最后开始让代码跑起来"></a>最后开始让代码跑起来</h5><p>在主程序的这个位置粘贴刚刚复制的key并运行<br><img src="https://s2.loli.net/2023/01/07/tSf9DFdlPKWLBbs.png" alt="报错没有库的自己装"></p><h4 id="这就结束了？当然不！"><a href="#这就结束了？当然不！" class="headerlink" title="这就结束了？当然不！"></a>这就结束了？当然不！</h4><h5 id="接下来是移动端部分"><a href="#接下来是移动端部分" class="headerlink" title="接下来是移动端部分"></a>接下来是移动端部分</h5><p>1.打开<a href="https://pan.baidu.com/s/1ff-HmcwQSz8cHGqgpMJrcw">百度网盘</a>链接下载安装pydriod，提取码:de5q<br>2.打开保存在手机里的主程序文件并填入key<br>3.左栏Pip中选择INSTALL，分别输入requests,json,random,urllib,time并INSTALL<br>4.左栏Settings的Editor选项内打开Preserve files on exit<br>5.点击大大的黄色的运行按钮</p><p>注:<br>如果运行时发生错误请检查网络或尝试重启<br>如果出现名字不显示或者各种奇奇怪怪的bug但确确实实在运行，那么看着就好(正所谓能跑就行)<br>如果显示<strong>得分失败，重新开始匹配</strong>就多等一会，因为没有真人跟你匹配是不会得分的<br>本章内容只对该小程序进行分析，仅限学习研究使用，严禁进行其他非法行为！造成的后果本人不承担相关责任。</p><p><em><strong>最后感谢该校各位前辈的指导和帮助！！！</strong></em></p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>每个烟花都像是盲盒，不知道点燃升空之后会是什么颜色、什么形状、会持续多久。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;p&gt;今天是广州某大学的wx小程序研究资料。&lt;br&gt;既然来了，那么话不多说，直接上教程&lt;br&gt;首先下载安装必备的应用&lt;br&gt;&lt;em</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20230106</title>
    <link href="https://liu1272.github.io/2023/01/06/20220106/"/>
    <id>https://liu1272.github.io/2023/01/06/20220106/</id>
    <published>2023-01-06T03:34:00.000Z</published>
    <updated>2023-01-12T16:00:19.700Z</updated>
    
    <content type="html"><![CDATA[<h5 id="无聊玩了一下Midjourney，挺方便，功能也很强大"><a href="#无聊玩了一下Midjourney，挺方便，功能也很强大" class="headerlink" title="无聊玩了一下Midjourney，挺方便，功能也很强大"></a>无聊玩了一下Midjourney，挺方便，功能也很强大</h5><p><img src="https://s2.loli.net/2023/01/06/vBlOqfjzJATF2kG.png#pic_center" alt="荒星"><br><img src="https://s2.loli.net/2023/01/07/uTWD6a93ZHOlxLq.png#pic_center" alt="好像刀妹"><br><img src="https://s2.loli.net/2023/01/06/X1FeICpcr74lkL9.png#pic_center" alt="粉毛YYDS"></p><h5 id="最后放个邀请地址"><a href="#最后放个邀请地址" class="headerlink" title="最后放个邀请地址"></a>最后放个<a href="https://discord.com/invite/midjourney">邀请地址</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;无聊玩了一下Midjourney，挺方便，功能也很强大&quot;&gt;&lt;a href=&quot;#无聊玩了一下Midjourney，挺方便，功能也很强大&quot; class=&quot;headerlink&quot; title=&quot;无聊玩了一下Midjourney，挺方便，功能也很强大&quot;&gt;&lt;/a&gt;无聊玩了一</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>20230105</title>
    <link href="https://liu1272.github.io/2023/01/05/20220105/"/>
    <id>https://liu1272.github.io/2023/01/05/20220105/</id>
    <published>2023-01-05T15:37:00.000Z</published>
    <updated>2023-01-12T16:00:26.816Z</updated>
    
    <content type="html"><![CDATA[<h5 id="能找到这里的都是Hentai"><a href="#能找到这里的都是Hentai" class="headerlink" title="能找到这里的都是Hentai"></a>能找到这里的都是<a href="https://track.mp3-malina.me/play-track/d33532303034b6303534368cb734823000/ff34543f34e2aa427c7b17347be4cc40/S3rl%20-%20Hentai.mp3">Hentai</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;能找到这里的都是Hentai&quot;&gt;&lt;a href=&quot;#能找到这里的都是Hentai&quot; class=&quot;headerlink&quot; title=&quot;能找到这里的都是Hentai&quot;&gt;&lt;/a&gt;能找到这里的都是&lt;a href=&quot;https://track.mp3-malina.me</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20230104</title>
    <link href="https://liu1272.github.io/2023/01/04/20220104/"/>
    <id>https://liu1272.github.io/2023/01/04/20220104/</id>
    <published>2023-01-04T10:12:00.000Z</published>
    <updated>2023-01-12T16:00:31.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h5 id="图床的创建"><a href="#图床的创建" class="headerlink" title="图床的创建"></a>图床的创建</h5><p>市面上免费的图床有SM.MS&emsp;Sibnet&emsp; Shutterfly<br>不完全免费的也有腾讯云&emsp; 阿里云&emsp; 七牛云<br>这里我把阿里云和SM.MS都试了一下</p><p>创建的话就跟着下面的步骤走就行了:<br>一.阿里云<br>&emsp;1.打开<a href="https://www.aliyun.com/?spm=5176.8466032.top-nav.dlogo.27b81450NiIk8F">官网</a>点击右上角进行注册/登录<br>&emsp;2.实名认证<br>&emsp;3.在左上角折叠页面里选择对象存储OSS<br>&emsp;4.右侧Bucket管理板块点击添加Bucket<br>&emsp;5.名称填写Bucket的名字，读写权限更改为公共读，其他的默认即可<br>&emsp;6.创建完成之后鼠标移至右上角头像上，选择AccessKey管理<br>&emsp;7.查看Secret并分别复制两行ID<br>&emsp;8.前往<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo下载页面</a>选择对应版本下载安装<br>&emsp;9.打开PicGo图床设置的阿里云页面填写相关资料<br>&emsp;10.上传区选择格式就能使用了<br>二.SM.MS<br>&emsp;1.<a href="https://smms.app/">官网注册/登录</a><br>&emsp;2.复制<a href="https://smms.app/home/apitoken">此页面</a>的Secret Token<br>&emsp;3.在<a href="https://smms.app/">此页面</a>上传文件<br>&emsp;4.打开PicGo的SM.MS页面粘贴Secret Token<br>&emsp;5.上传区选择格式就能使用了</p><p>注:<br>1.我在使用PicGo链接SM.MS时总是失败，不知道为啥<br>2.因为阿里云不是免费的，想省钱可以选择香港<br>3.一定要设置<a href="https://help.aliyun.com/document_detail/31869.html?spm=5176.8466032.bucket.28.27b81450rEXDcJ">防盗链</a></p><h5 id="图床在markdown中的使用"><a href="#图床在markdown中的使用" class="headerlink" title="图床在markdown中的使用"></a>图床在markdown中的使用</h5><p>方法一:使用img标签</p><pre><code> &lt;img src=&quot;图片地址&quot;&gt;</code></pre><p>方法二:md语法</p><pre><code> ![图片简介](图片地址)</code></pre><h5 id="更改图片参数"><a href="#更改图片参数" class="headerlink" title="更改图片参数"></a>更改图片参数</h5><pre><code>使用html更改位置&lt;center&gt;&lt;img src=&quot;地址&quot;&gt;&lt;/center&gt;居中对齐操作：#pic_center向左对齐操作：#pic_left向右对齐操作：#pic_right想调整图片的尺寸就在上面这个指令后面加上=200x200(=200x宽高自适应)width=&quot;100&quot;调整大小</code></pre><p>今天的内容就这么多，下次有空再继续写。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>眼下的生活，不是没有快乐。只是所有快乐都暗含着一层谨慎的底色。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h5 id=&quot;图床的创建&quot;&gt;&lt;a href=&quot;#图床的创建&quot; class=&quot;headerlink&quot; title=&quot;图床的创建&quot;&gt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>2022年度总结</title>
    <link href="https://liu1272.github.io/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://liu1272.github.io/2022/12/31/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-31T11:46:00.000Z</published>
    <updated>2023-01-04T11:28:04.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="呆"><a href="#呆" class="headerlink" title="呆~"></a>呆~</h4><p>  简直突如其来呐。<br>  万万没想到一个月就过去了，时间过得真快啊。</p><p>  在2022年的抗疫决赛圈，几乎所有人都成了小阳人，其中也包括我。<br>  发烧第一天真的是给我吓到了，中午一觉起来高烧42.5℃，惊恐之余赶紧撑着摇摇欲坠的身体去买布洛芬(似乎我这个城市退烧药还算充足？)到晚上睡前才降到39℃。看到那个长度我真的是笑希了，感觉39℃也不过是小问题……<br>  (⁄ ⁄•⁄ω⁄•⁄ ⁄)<br>  感谢芙灵和一个现在被迫带烧返校的可怜的江苏高三Dog!<br>  现在病情已经到了欲说还休的阶段了，因此被鹅鸭杀劝退<del>，因此才能闲到来写这个文章</del><br>  希望早日康复吧，我还想吃正新鸡排</p><p>  这个小小站点活过了第一个国庆，第一个圣诞，马上就是元旦和春节了，希望这里能永远保存下去。<br>  最近了解了GitHub Arctic Code Vault这个东东，虽然说想得到这个可能有点不现实，但是可以把它当作理想吧。<br>  (づ ●─● )づ</p><p>  对于2023年的规划没有太多的变化，仍然是多学习，多看世界，多保重身体。<br>  人生刚刚开始，未来可期。<br>  犹豫不决的时候不要问别人，问自己。听别人的如果后悔了，是要后悔两次的。</p><p>  最后，元旦快乐~</p><p>  乾杯 []~ （￣▽￣） ~*</p><h5 id="20230104补档"><a href="#20230104补档" class="headerlink" title="20230104补档"></a>20230104补档</h5><p>  <strong>试验阿里云+PicGo图床</strong><br>   <img src="https://liuguobin-blog.oss-cn-hongkong.aliyuncs.com/base.png#pic_center" width="300"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;呆&quot;&gt;&lt;a href=&quot;#呆&quot; class=&quot;headerlink&quot; title=&quot;呆~&quot;&gt;&lt;/a&gt;呆~&lt;/h4&gt;&lt;p&gt;  简直突如其来呐。&lt;br&gt;  万万没想到一个月就过去了，时间过得真快啊。&lt;/p&gt;
&lt;p&gt;  在2022年的抗疫决赛圈，几乎所有人都成了小阳人，</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>20221204</title>
    <link href="https://liu1272.github.io/2022/12/04/20221204/"/>
    <id>https://liu1272.github.io/2022/12/04/20221204/</id>
    <published>2022-12-04T13:59:00.000Z</published>
    <updated>2022-12-06T14:31:40.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><pre><code>【数组序列化】&lt;?php$a=null;echo serialize($a);?&gt;a:参数数量:&#123;i:0;s:字符串长度:&quot;字符串&quot;;&#125;$a=null;         N;$b=123456;       i:123456;$c=1.2;          d:1.2;$d=true;         b:1;$e=false;        b:0;$f=&#39;benben&#39;;     s:长度:字符串;【对象序列化】&lt;?phpclass lei&#123;    public $chengyuan=&#39;zifuchuan&#39;;    function hanshu()&#123;        echo $this-&gt;chengyuan;    &#125;&#125;$a=new lei();echo serialize($a);echo urlencode(serialize($a));?&gt;O:类名长度:&quot;类名&quot;:1:&#123;s:成员长度:&quot;成员名&quot;;s:值长度:&quot;值&quot;;&#125;修饰符public公有，private私有私有的成员属性要在前后都加上二进制的%00,在urlencode时可以看见【对象序列化的嵌套】&lt;?phpclass test&#123;    public $pub=&#39;benben&#39;;    function jineng()&#123;        echo $this-&gt;pub;    &#125;&#125;class test2&#123;    var $ben;&#125;$b=new test();$a=new test2();$a-&gt;ben=$b;echo serialize($a);?&gt;O:5:&quot;test2&quot;:1:&#123;s:3:&quot;ben&quot;;O:4:&quot;test&quot;:1:&#123;s:3:&quot;pub&quot;;s:6:&quot;benben&quot;;&#125;&#125;当在对象内调用对象时，会出现嵌套:实例化后的对象$a的成员变量&#39;ben&#39;调用实例化后的对象$b</code></pre><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>1.反序列化后的内容为一个对象，与序列化相反<br>2.反序列化生成的对象内的值，由反序列化里的值提供，与原有类预定义的值无关<br>3.反序列化不触发类的成员方法，需要调用方法之后才能触发</p><pre><code>&lt;?phpclass test&#123;    public $a=&#39;benben&#39;;    protected $b=666;    private $c=false;    public function displayVar()&#123;        echo $this-&gt;a;    &#125;&#125;$d=new test();$d=serialize($d);echo urlencode($d);$a=urlencode($d);$b=unserialize(urldecode($a));$b-&gt;displayVar();var_dump($b);?&gt;benbenobject(test)#1 (3) &#123;  [&quot;a&quot;]=&gt;  string(6) &quot;benben&quot;  [&quot;b&quot;:protected]=&gt;  int(666)  [&quot;c&quot;:&quot;test&quot;:private]=&gt;  bool(false)&#125;</code></pre><h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>概念:<br>预定好的，在特定的情况下处罚的行为方法。<br>反序列化成因(作用):<br>反序列化过程中unserizlize()接收的值(字符串)可控；<br>通过更改这个值(字符串)，所得到的代码；<br>通过调用方法，触发代码执行。<br>相关机制:<br>触发时机(先决条件)-&gt;功能(最重要)-&gt;参数(尤其是pop链)-&gt;返回值<br>详解:</p><pre><code>1.__construct()构造函数在实例化对象时，自动执行的方法只有当new时触发，不需要特地调用2.__destruct()析构函数在对象的所有引用都被删除或者对象被显式销毁时才触发new和unserialize之后会触发3.__sleep()清理对象可以传入成员属性，serialize之前触发并返回一个包含对象中所有需要被序列化的变量名称的数组如果无返回则NULL被序列化，产生E_NOTICE错误4.__wakeup()预先准备对象资源，返回void在unserialize前触发5.__tostring()表达方式错误把对象当成字符串调用时触发，如echo，print6.__invoke()格式表达错误把对象当成函数调用时触发，如echo $a() -&gt; hanshu7.__call()不存在方法不存在调用的方法时触发8.__callStatic()不存在方法静态调用或调用成员常量不存在时使用9.__get()不存在方法检查成员属性是否存在10.__set()不存在方法给不存在的成员属性赋值时触发11.__isset()或__empty()或__unset()不可访问对不可访问的属性访问时会触发如protect属性(不可读)或根本不存在的属性12.__clone()复制使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone()</code></pre><p>注意:<br>1.只有该类或对象包含了该魔术方法才能被使用或触发<br>2.先分析尾部代码看看有什么执行的步骤<br>3.接着从触发的方法及其顺序判断漏洞的利用地点<br>4.最后构造playload<br>5.比较长的代码建议使用反推法进行分析<br>6.一定要先实例化(new)</p><h4 id="POP链"><a href="#POP链" class="headerlink" title="POP链"></a>POP链</h4><p>反序列化中成员变量可以被控制，使用有一种漏洞叫面向属性编程(POP)<br>POP链是利用魔术方法在里面多次跳转然后获取敏感信息的一种playload</p><h4 id="POC编写"><a href="#POC编写" class="headerlink" title="POC编写"></a>POC编写</h4><p>概念验证(POC)是漏洞验证程序，只是为了证明提出者观点的一段代码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221202</title>
    <link href="https://liu1272.github.io/2022/12/02/20221202/"/>
    <id>https://liu1272.github.io/2022/12/02/20221202/</id>
    <published>2022-12-02T12:14:40.000Z</published>
    <updated>2022-12-02T15:17:22.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Gi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>20221202</title>
    <link href="https://liu1272.github.io/2022/12/02/20221202/"/>
    <id>https://liu1272.github.io/2022/12/02/20221202/</id>
    <published>2022-12-01T16:45:00.000Z</published>
    <updated>2022-12-02T16:46:15.340Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>202211月总结</title>
    <link href="https://liu1272.github.io/2022/12/01/20221201%E6%9C%88%E7%BB%93/"/>
    <id>https://liu1272.github.io/2022/12/01/20221201%E6%9C%88%E7%BB%93/</id>
    <published>2022-12-01T12:13:00.000Z</published>
    <updated>2022-12-02T16:03:02.461Z</updated>
    
    <content type="html"><![CDATA[<h5 id="又是一个月，该总结一下了"><a href="#又是一个月，该总结一下了" class="headerlink" title="又是一个月，该总结一下了"></a>又是一个月，该总结一下了</h5><p>  首先还是这个月干了啥。<br>  好像也没干啥？？？<br>  学了JS，PHP，数据库，一点点命令，还有算是课内知识的python爬虫<br>  虽然看着学了很多，但是基础并不牢固。<br>  因此<br>  我可能将要用至少一个月的时间来消化从建站到现在所学的内容<br>  毕竟…<br>  高数和现代终究是大头，还有一个计导虎视眈眈</p><p>  接着来说说接下来一个月的计划吧~<br>  首先，既然是在家上网课<br>  当然是要<br>  <del>吃了就睡，睡了就吃，跟个死猪一样</del><br>  <em><strong>好好学习，天天向上</strong></em></p><h5 id="鸭梨山大"><a href="#鸭梨山大" class="headerlink" title="鸭梨山大"></a>鸭梨山大</h5><p>  其实在这个月的学习中我的感触很深，网络安全绝不是一朝一夕可以完成的(屁话)<br>  现在所学的全部这些内容可以说都是前置知识的一部分<br>  包括在平时练习的CTF，都是走向安全的一段路<br>  那么，既然如此<br>  我更应该将重心放在基础上，而非一味的追求解题量<br>  甚至是成为众人最不屑的“赛棍”。</p><h5 id="还有啥好讲的？"><a href="#还有啥好讲的？" class="headerlink" title="还有啥好讲的？"></a>还有啥好讲的？</h5><p>  既然这是一篇发布在博客的文章，那就再聊聊博客的事吧<br>  首先是最令我头疼的事——主页解析的视频老是失效。真的是脑阔疼，我找了很久了，但是一直没有解决方法，如果有人有方法或是突发奇想请在GitHub上评论，十分感谢！！！<br>  然后是关于加载速度有些缓慢甚至是在网不好的情况下出现白屏的问题(响应速度还是蛮快的，并没有发生许多人所说的被墙的情况，尽管是在校园网的情况下)，是因为主页启用了过多插件的缘故，在一段时间后(可能年后有空时)，会对这个blog进行一次大修改，争取加载时间缩短到1000毫秒内吧。<br>  最后，还是重复说明一下。这个博客虽然是public的，但是我只希望它的作用只是个刻录我在大学四年或更久的时光里的里程碑。时不时记录下成长经历，时不时写点随笔，时不时慷慨地发点自己总结的知识梳理，方便我自己和其他来到这里的 <em><strong>朋友们</strong></em> 学习。</p><h5 id="好了，最后还是一句"><a href="#好了，最后还是一句" class="headerlink" title="好了，最后还是一句"></a>好了，最后还是一句</h5><p><strong>人，活的不是一个点，人活起伏。</strong><br>说人话版:是个三维的东西就不要天天像个二维的玩意一样躺平~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;又是一个月，该总结一下了&quot;&gt;&lt;a href=&quot;#又是一个月，该总结一下了&quot; class=&quot;headerlink&quot; title=&quot;又是一个月，该总结一下了&quot;&gt;&lt;/a&gt;又是一个月，该总结一下了&lt;/h5&gt;&lt;p&gt;  首先还是这个月干了啥。&lt;br&gt;  好像也没干啥？？？&lt;b</summary>
      
    
    
    
    <category term="随笔" scheme="https://liu1272.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://liu1272.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Kali命令</title>
    <link href="https://liu1272.github.io/2022/11/21/Kali%E5%91%BD%E4%BB%A4/"/>
    <id>https://liu1272.github.io/2022/11/21/Kali%E5%91%BD%E4%BB%A4/</id>
    <published>2022-11-21T05:12:00.000Z</published>
    <updated>2022-11-21T05:58:42.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali的常用命令"><a href="#kali的常用命令" class="headerlink" title="kali的常用命令"></a>kali的常用命令</h1><h3 id="1-基础命令"><a href="#1-基础命令" class="headerlink" title="1.基础命令"></a>1.基础命令</h3><pre><code>passwd 修改密码passwd root 修改root用户密码date 显示系统日期sudo 后面加命令 就可以调用管理权限apt-get update 更新软件列表访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。我们在新立得软件包管理器里看到的软件列表，都是通过update命令更新的。apt-get upgrade 更新软件把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。apt-get dist-upgrade 更新软件  --+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--【apt-get upgrade 与 apt-get dist-upgrade 的区别】upgrade:系统将现有的Package升级,如果有相依性的问题,而此相依性需要安装其它新的Package或影响到其它Package的相依性时,此Package就不会被升级,会保留下来.dist-upgrade:如果有相依性问题,需要安装/移除新的Package,就会试着去安装/移除它.(所以通常这个会被认为是有点风险的升级)apt-get upgrade 和 apt-get dist-upgrade 本质上是没有什么不同的，只不过dist-upgrade会识别出当依赖关系改变的情形并作出处理，而upgrade对此情形不处理。例如软件包 a 原先依赖 b c d，但是在源里面可能已经升级了，现在是 a 依赖 b c e。这种情况下，dist-upgrade 会删除 d 安装 e，并把 a 软件包升级，而 upgrade 会认为依赖关系改变而拒绝升级 a软件包。--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--clear 清屏sudo gpedit 特权调用gpedit编辑器reboot 重启apt-get install XXXXX 安装缺少的依赖包，（XXX）里面输入缺少依赖包的名字apt-get autoremove –purge 软件名 删除包及其依赖的软件包+配置文件等apt-get install +模块名 这种方法也可以安装模块,或者apt-get install python-模块名firefox 浏览器打开shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)su -l 切换登陆用户logout 注销用户登陆pwd 当前路径</code></pre><h3 id="2-文件夹或文本操作"><a href="#2-文件夹或文本操作" class="headerlink" title="2.文件夹或文本操作"></a>2.文件夹或文本操作</h3><pre><code>cd .. 返回上一级目录cd ../.. 返回上级两级目录cd - 返回上次所在的目录cd 文件夹名  进去文件夹cd ~ 进去当前用户主目录pwd 显示当前工作路径touch 文件名  常见文件cat 文件名 读取文档内容mkdir 文件名 创建文件夹mkdir -p 文件夹 递归创建文件夹cp 复制命令cp -r moon moons 复制moon 文件夹到当前 moons 如果有里面有文件 使用-r mv 移动命令mv moon moons 也可以说是改名mkdir 文件名 文件名 创建多个文件夹ls 显示文件和文件夹名ls -a 显示所有的文件和文件夹 包含隐藏文件ls -l 显示文件和目录的详细资料rm -f 文件  删除文件rm 文件夹名 删除文件夹rm -rf  文件/文件夹  删除文件夹 及其目录下的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar x file1.rar 解压rar包unrar x file1.rar 解压rar包dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表tar zcvf +压缩文件名 压缩文件tar zxvf +解压包名 解压文件tar -jcvf renwolesshel.tar.bz2 打包tar jxvf renwolesshel.tar.bz2 解压zip -q -r renwolesshel.zip renwolesshel/ 解压zip格式的压缩包unzip renwolesshel.zipwhich 加软件名 可以查出软件目录在哪./+文件名或者apt-get +文件名 安装文件</code></pre><h3 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h3><pre><code>arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/cpuinfo 显示CPU info的信息cat /proc/mounts 显示已加载的文件系统</code></pre><h3 id="4-vi-常用命令"><a href="#4-vi-常用命令" class="headerlink" title="4.vi 常用命令"></a>4.vi 常用命令</h3><p>vi编辑器分为三种状态，分别是：<br>1.命令模式（command mode）<br>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>2.插入模式（Insert mode）<br>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>3.底行模式（last line mode）<br>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p><pre><code>**打开**vi filename :打开或新建文件，并将光标置于第一行首vi +n filename ：打开文件，并将光标置于第n行首vi + filename ：打开文件，并将光标置于最后一行首**编辑**i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行编辑结束，按Esc返回命令模式**基本查找**/text　　查找text，按n健查找下一个，按N健查找前一个。?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。**删除**删除当前行 dd删除2行 2dd**拷贝和粘贴**yy 拷贝当前行nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。p  在当前光标后粘贴区块拷贝1. 将光标移动到要复制的文本开始的地方，按 v进入可视模式。2. 将光标移动到要复制的文本的结束的地方，按y复制。此时vim会自动将光标定位到选中文本的开始的地方，并退出可视模式。3. 我移动光标到文本结束的地方，按 p粘贴。**退出命令**:wq 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件:w保存修改**显示行号**set numberset nu输入:n，代表跳转到第n行，如:100，就跳转到第100行。撤销操作u——&gt; vim与vi的区别——&gt; vim是vi的延申 vim编辑源码会高亮 vim的命令对vi是完全兼容的</code></pre><h3 id="5-文件搜索"><a href="#5-文件搜索" class="headerlink" title="5.文件搜索"></a>5.文件搜索</h3><pre><code>find / -name file1 从 ‘/’ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find . -name &#39;*.php&#39; -mmin -30  查找最近30分钟修改的当前目录下的.php文件find . -name &#39;*.php&#39; -mtime 0  查找最近24小时修改的当前目录下的.php文件find . -name &#39;*.inc&#39; -mtime 0 -ls  查找最近24小时修改的当前目录下的.php文件，并列出详细信息find . -type f -mtime 1  查找当前目录下，最近24-48小时修改过的常规文件。find . -type f -mtime +1  查找当前目录下，最近1天前修改过的常规文件。-atime 文件访问时间-ctime 文件常见时间-mtime文件修改时间-mtime n : n为数字，意思为在n天之前的“一天之内”被更改过内容的文件-mtime +n : 列出在n天之前（不含n天本身）被更改过内容的文件名-mtime -n : 列出在n天之内（含n天本身）被更改过内容的文件名-type f 代表一个普通格式的文件 二进制文件-type d 代表文件夹find / -name *.rpm -exec chmod 755 ‘&#123;&#125;’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--文件中r w x -的含义:r是只读权限，w是写的权限，x是可执行权限,-是没有任何权限。目录中r w x的含义:r具有ls权限，w是在目录上可以增加、删除、创建权限，x是具有ls –l权限。权限     读    写   执行        读    写   执行      读   写   执行字符     r     w     x           r     w    x         r    w    x数字     4     2     1           4     2    1         4    2    1分配     对象文件所有者          文件所属组用户         其他用户chmod 777 +文件名 给单独文件赋所有权限chmod -R 777 /home/user  表示将整个/home/user目录与其中的文件和子目录的权限都设置为rwxrwxrwx常用权限-rw------- (600) 只有所有者才有读和写的权限-rw-r--r-- (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限-rwx------ (700) 只有所有者才有读，写，执行的权限-rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限-rwx--x--x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限-rw-rw-rw- (666) 每个人都有读写的权限-rwxrwxrwx (777) 每个人都有读写和执行的权限也可以使用字母模式chmod +x 和chmod a+x 是一样的，一般没有明确要求，可以就用chmod +xu代表用户   g代表用户组   o代表其它   a代表所有创建一个文件只有用户具有完全控制的权限touch 文件名chmod u+rwx 文件名 当前用户加全部的权限chmod g-r 文件名   群组把读取权限去掉chmod o-r 文件名   其他用户读取权限去掉--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径grep kali /etc/passwd grep关键词搜索find / -name moonsec 2&gt;/dev/null   搜索某个文件/文件夹 屏蔽出错信息</code></pre><h3 id="6-用户和群组"><a href="#6-用户和群组" class="headerlink" title="6.用户和群组"></a>6.用户和群组</h3><pre><code>groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组cat /etc/group | grep group_name usermod -a -G moontea k1把用户k1附加其他用户组useradd moonsecpasswd moonsecuseradd -r -m -s /bin/bash moonsec参数的意思：-r 建立系统账号-m 自动建立用户的登入目录-s /bin/bash 指定用户登入后所使用的shellsu - root 切换到root用户su 用户名 切换到普通用户</code></pre><h3 id="7-系统管理"><a href="#7-系统管理" class="headerlink" title="7.系统管理"></a>7.系统管理</h3><pre><code>top  查看正在指向的程序信息ps -ef 查看所有进程信息ps -ef | grep tomcat 查找指定进程kill -9 id 强制杀死进程env 当前的变量查看系统变量echo $PATHhostname 查看主机名history 查看历史命令</code></pre><h3 id="8-查看磁盘信息"><a href="#8-查看磁盘信息" class="headerlink" title="8.查看磁盘信息"></a>8.查看磁盘信息</h3><pre><code>df   默认不带单位，挂载点、总容量、已用、可用df  -h   友好显示（带单位），很多命令的友好显示都是-h</code></pre><h3 id="9-查看内存信息"><a href="#9-查看内存信息" class="headerlink" title="9.查看内存信息"></a>9.查看内存信息</h3><pre><code>free   默认以KB为单位，总容量、已用、可用、缓存大小free  -m   默认以MB为单位free  -h   上面2种都不带单位、只显示数值，这种是友好显示的，会带单位G、M等</code></pre><h3 id="10-查看环境变量"><a href="#10-查看环境变量" class="headerlink" title="10.查看环境变量"></a>10.查看环境变量</h3><pre><code>echo  $JAVA_HOMEecho $PATH | grep jdk</code></pre><h3 id="11-开机自启"><a href="#11-开机自启" class="headerlink" title="11.开机自启"></a>11.开机自启</h3><p>有很多程序往往都需要设置开机自启，比如tomcat、mysql、nginx等。</p><pre><code>vim /etc/rc.d/rc.local   在/etc/rc.d/rc.local文件中加入开机要自动执行的程序mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share   挂载一个windows网络共享</code></pre><h3 id="12-网卡配置"><a href="#12-网卡配置" class="headerlink" title="12.网卡配置"></a>12.网卡配置</h3><pre><code>vi /etc/network/interfacesauto eth0                     //指定网卡（根据ifconfig结果修改）iface eth0 inet static        //启动静态ipaddress 192.168.0.66          // 设置静态ipnetmask 255.255.255.0         //子网掩码gateway 192.168.0.1           //指定网关service networking restart    //重启网络systemctl restart networking  //重启网络ifconfig eth0 192.168.0.33    //设置临时ip</code></pre><h3 id="13网卡DNS服务器"><a href="#13网卡DNS服务器" class="headerlink" title="13网卡DNS服务器"></a>13网卡DNS服务器</h3><pre><code>vi /etc/resovl.confnameserver 114.114.114.114重启网卡service networking restartsystemctl restart networking注意有时候重启才生效</code></pre><h3 id="14-服务相关"><a href="#14-服务相关" class="headerlink" title="14.服务相关"></a>14.服务相关</h3><pre><code>apache2服务器打开：/etc/init.d/apache2 start 重启：/etc/init.d/apache2 restart关闭：/etc/init.d/apache2 stop/etc/init.d/network start  启动网卡echo 1 &gt; /proc/sys/net/ipv4/ip_forward  开启路由转发</code></pre><h3 id="15-linux常用网络命令"><a href="#15-linux常用网络命令" class="headerlink" title="15.linux常用网络命令"></a>15.linux常用网络命令</h3><p>网络和监控命令类似于这些： hostname, ping, ifconfig, iwconfig, netstat, nslookup, traceroute, finger, telnet, ethtool<br>用于查看 linux 服务器 ip 地址，管理服务器网络配置，通过 telnet 和 ethernet 建立与 linux 之间的网络链接，查看 linux 的服务器信息等。</p><pre><code>hostname 查看本机名ping  一般用于测试网络是否通 内网icmpping www.baidu.com -c 3 执行3次ifconfig 网卡信息iwconfig 用于配置或获取无线网络设备信息netstat -a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到netstat -ano-an 查看当前所有已连接端口-nlpt 查看当前所有tcp端口-nlpu 查看当前所有udp端口-nlpt | grep 80 查看所有80端口使用情况netstat -lntup 查看所有的tcp和upd端口nslookup 查询其他记录直接查询返回的是A记录，我们可以指定参数，查询其他记录，比如AAAA、MX等。nslookup -qt=type domain [dns-server]其中，type可以是以下这些类型：A 地址记录AAAA 地址记录AFSDB Andrew文件系统数据库服务器记录ATMA ATM地址记录CNAME 别名记录HINFO 硬件配置记录，包括CPU、操作系统信息ISDN 域名对应的ISDN号码MB 存放指定邮箱的服务器MG 邮件组记录MINFO 邮件组和邮箱的信息记录MR 改名的邮箱记录MX 邮件服务器记录NS 名字服务器记录PTR 反向记录RP 负责人记录RT 路由穿透记录SRV TCP服务器信息记录TXT 域名对应的文本信息X25 域名对应的X.25地址记录traceroute-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。(traceroute是用来检测发出数据包的主机到目标主机之间所经过的网关数量的工具。)(traceroute的原理是试图以最小的TTL（存活时间）发出探测包来跟踪数据包到达目标主机所经过的网关，然后监听一个来自网关ICMP的应答。发送数据包的大小默认为38个字节。)telnetLinux telnet命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。现在多数用于检测某个端口是否开放FingerFinger是一种用户信息分享服务。它工作在TCP 79端口，可以用来公开用户的特定信息。Nmap的finger的脚本可以向Finger服务器发送请求，查询并获取用户的相关信息，如登录名、用户名、TTY类型、登录时间等。ethtool 是用于查询及设置网卡参数的命令</code></pre><h3 id="16-防火墙iptables"><a href="#16-防火墙iptables" class="headerlink" title="16.防火墙iptables"></a>16.防火墙iptables</h3><pre><code>iptalbes -L  查看防火墙规则iptables -F   清除规则/etc/init.d/iptables stop   关闭防火墙service iptables stop安装：apt-get install ufw关闭：ufw disable # To disable the firewall开启：ufw enable # To enable the firewall</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kali的常用命令&quot;&gt;&lt;a href=&quot;#kali的常用命令&quot; class=&quot;headerlink&quot; title=&quot;kali的常用命令&quot;&gt;&lt;/a&gt;kali的常用命令&lt;/h1&gt;&lt;h3 id=&quot;1-基础命令&quot;&gt;&lt;a href=&quot;#1-基础命令&quot; class=&quot;head</summary>
      
    
    
    
    <category term="附录" scheme="https://liu1272.github.io/categories/%E9%99%84%E5%BD%95/"/>
    
    
    <category term="附录" scheme="https://liu1272.github.io/tags/%E9%99%84%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Windows常用命令</title>
    <link href="https://liu1272.github.io/2022/11/20/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://liu1272.github.io/2022/11/20/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-11-20T11:37:00.000Z</published>
    <updated>2022-11-21T11:38:20.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Windows常用命令"><a href="#Windows常用命令" class="headerlink" title="Windows常用命令"></a>Windows常用命令</h3><pre><code>ifconfig /all 获取获取域名、IP地址、DHCP服务器、网关、MAC地址、主机名net time /domain 查看域名、时间net view /domain 查看域内所有共享net view ip 查看对方局域网内开启了哪些共享net config workstation 查看域名、机器名等net user 用户名 密码 /add 建立用户net user 用户名 /del #删除用户net user guest /active:yes 激活guest账户net user 查看账户net user 账户名 查看指定账户信息net user /domain 查看域内有哪些用户，Windows NT Workstation 计算机上可用，由此可以此判断用户是否是域成员。net user 用户名 /domain 查看账户信息net group /domain 查看域中的组net group &quot;domain admins&quot; /domain 查看当前域的管理用户query user 查看当前在线的用户net localgroup 查看所有的本地组net localgroup administrators 查看administrators组中有哪些用户net localgroup administrators 用户名 /add 把用户添加到管理员组中net start 查看开启服务net start 服务名 开启某服务net stop 服务名 停止某服务net share 查看本地开启的共享net share ipc$ 开启ipc$共享net share ipc$ /del 删除ipc$共享net share c$ /del 删除C：共享\\192.168.0.108\c 访问默认共享c盘dsquery server 查看所有域控制器dsquery subnet 查看域内内子网dsquery group 查看域内工作组dsquery site 查看域内站点netstat -a 查看开启了哪些端口,常用netstat -annetstat -n 查看端口的网络连接情况，常用netstat -annetstat -v 查看正在进行的工作netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）netstat -s 查看正在使用的所有协议使用情况nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写reg save hklm\sam sam.hive 导出用户组信息、权限配置reg save hklm\system system.hive 导出SYSKEYnet use \\目标IP\ipc$ 密码 /u:用户名 连接目标机器at \\目标IP 21:31 c:\server.exe 在某个时间启动某个应用wmic /node:&quot;目标IP&quot; /password:&quot;123456&quot; /user:&quot;admin&quot; 连接目标机器psexec.exe \\目标IP -u username -p password -s cmd 在目标机器上执行cmdfinger username @host 查看最近有哪些用户登陆route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interfacearp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a 将显示出全部信息nslookup IP地址侦测器tasklist 查看当前进程taskkill /pid PID数 终止指定PID进程whoami 查看当前用户及权限systeminfo 查看计算机信息（版本，位数，补丁情况）ver 查看计算机操作系统版本tasklist /svc 查看当前计算机进程情况netstat -ano 查看当前计算机进程情况wmic product &gt; ins.txt 查看安装软件以及版本路径等信息，重定向到ins.txt</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Windows常用命令&quot;&gt;&lt;a href=&quot;#Windows常用命令&quot; class=&quot;headerlink&quot; title=&quot;Windows常用命令&quot;&gt;&lt;/a&gt;Windows常用命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;ifconfig /all 获取获取域名、IP地址、</summary>
      
    
    
    
    <category term="附录" scheme="https://liu1272.github.io/categories/%E9%99%84%E5%BD%95/"/>
    
    
    <category term="附录" scheme="https://liu1272.github.io/tags/%E9%99%84%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ODBC数据库</title>
    <link href="https://liu1272.github.io/2022/11/19/ODBC%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://liu1272.github.io/2022/11/19/ODBC%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-11-18T18:49:00.000Z</published>
    <updated>2022-11-21T06:03:24.436Z</updated>
    
    <content type="html"><![CDATA[<h5 id="此章节是拓展阅读，选择性食用"><a href="#此章节是拓展阅读，选择性食用" class="headerlink" title="此章节是拓展阅读，选择性食用"></a>此章节是拓展阅读，选择性食用</h5><p>概念:ODBC 是一种应用程序编程接口(API)，使我们有能力连接到某个数据源。</p><h4 id="创建-ODBC-连接"><a href="#创建-ODBC-连接" class="headerlink" title="创建 ODBC 连接"></a>创建 ODBC 连接</h4><p>通过一个 ODBC 连接，可以连接到网络中的任何计算机上的任何数据库。<br>创建到达 MS Access 数据库的 ODBC 连接的方法:<br>1.在控制面板中打开管理工具图标。<br>2.双击其中的数据源(ODBC)图标。<br>3.选择系统 DSN 选项卡。<br>4.点击系统 DSN 选项卡中的添加。<br>5.选择Microsoft Access Driver。点击完成。<br>6.在下一个界面，点击选择来定位数据库。<br>7.为数据库起一个数据源名(DSN)。<br>8.点击确定。</p><p>注意:必须在您的网站所在的计算机上完成这个配置。<br>如果您的计算机上正在运行 Internet 信息服务(IIS)，上面的指令将会生效。<br>但是如果您的网站位于远程服务器，您必须拥有对该服务器的物理访问权限，或者请您的主机提供商为您建立 DSN。</p><h4 id="连接-ODBC"><a href="#连接-ODBC" class="headerlink" title="连接 ODBC"></a>连接 ODBC</h4><pre><code>实例下面的实例创建了到达名为 link 的 DSN 的连接，没有用户名和密码。然后创建并执行一条 SQL 语句：$conn=odbc_connect(&#39;link&#39;,&#39;&#39;,&#39;&#39;);           //数据源名、用户名、密码以及可选的指针类型$sql=&quot;SELECT * FROM customers&quot;;$rs=odbc_exec($conn,$sql);                  //执行 SQL 语句</code></pre><h4 id="取回记录"><a href="#取回记录" class="headerlink" title="取回记录"></a>取回记录</h4><p>从结果集中返回记录。如果能够返回行，则函数返回 true，否则返回 false。</p><pre><code>该函数有两个参数：ODBC 结果标识符和可选的行号:odbc_fetch_row ( resource $result_id [, int $row_number = 1 ] )</code></pre><h4 id="从记录中取回字段"><a href="#从记录中取回字段" class="headerlink" title="从记录中取回字段"></a>从记录中取回字段</h4><p>从记录中读取字段。该函数有两个参数:ODBC 结果标识符和字段编号或名称。</p><pre><code>$compname=odbc_result($rs,1);                             //从记录中返回第一个字段的值$compname=odbc_result($rs,&quot;CompanyName&quot;);                 //返回名为 &quot;CompanyName&quot; 的字段的值</code></pre><h4 id="关闭-ODBC-连接"><a href="#关闭-ODBC-连接" class="headerlink" title="关闭 ODBC 连接"></a>关闭 ODBC 连接</h4><p> odbc_close($conn); </p><h4 id="全过程示例"><a href="#全过程示例" class="headerlink" title="全过程示例"></a>全过程示例</h4><pre><code> &lt;?php $conn=odbc_connect(&#39;northwind&#39;,&#39;&#39;,&#39;&#39;);            //连接 ODBC if (!$conn)                                       //验证链接 &#123;exit(&quot;Connection Failed: &quot; . $conn);&#125;            //失败的回显 $sql=&quot;SELECT * FROM customers&quot;;                   //创建链接 $rs=odbc_exec($conn,$sql);                        //执行 SQL 语句 if (!$rs) &#123;exit(&quot;Error in SQL&quot;);&#125;                           //判断是否连接正常 echo &quot;&lt;table&gt;&lt;tr&gt;&quot;; echo &quot;&lt;th&gt;Companyname&lt;/th&gt;&quot;;                      //回显 echo &quot;&lt;th&gt;Contactname&lt;/th&gt;&lt;/tr&gt;&quot;; while (odbc_fetch_row($rs))                       //取回记录 &#123; $compname=odbc_result($rs,&quot;CompanyName&quot;);         //从记录中取回字段compname $conname=odbc_result($rs,&quot;ContactName&quot;);          //从记录中取回字段compname echo &quot;&lt;tr&gt;&lt;td&gt;$compname&lt;/td&gt;&quot;;  echo &quot;&lt;td&gt;$conname&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; odbc_close($conn);                                //关闭 ODBC 连接 echo &quot;&lt;/table&gt;&quot;; ?&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;此章节是拓展阅读，选择性食用&quot;&gt;&lt;a href=&quot;#此章节是拓展阅读，选择性食用&quot; class=&quot;headerlink&quot; title=&quot;此章节是拓展阅读，选择性食用&quot;&gt;&lt;/a&gt;此章节是拓展阅读，选择性食用&lt;/h5&gt;&lt;p&gt;概念:ODBC 是一种应用程序编程接口(AP</summary>
      
    
    
    
    <category term="附录" scheme="https://liu1272.github.io/categories/%E9%99%84%E5%BD%95/"/>
    
    
    <category term="附录" scheme="https://liu1272.github.io/tags/%E9%99%84%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>20221119</title>
    <link href="https://liu1272.github.io/2022/11/19/20221119/"/>
    <id>https://liu1272.github.io/2022/11/19/20221119/</id>
    <published>2022-11-18T18:36:00.000Z</published>
    <updated>2022-11-19T09:41:54.691Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="基于面向对象的Python爬虫"><a href="#基于面向对象的Python爬虫" class="headerlink" title="基于面向对象的Python爬虫"></a>基于面向对象的Python爬虫</h4><pre><code>import urllib.requestimport reclass GetHtml(object):    def __init__(self,URL,HEAD):      //初始化        self.url=URL        self.head=HEAD        def get_index(self):              //获取主页信息        self.request=urllib.request.Request(self.url)        self.request.add_header(&#39;user-agent&#39;,self.request)        self.response=urllib.request.urlopen(self.request)        return self.response.read()        def get_list(self):               //获取符合条件的列表        self.strimglist=[]        self.imglist=re.findall(b&#39;匹配条件&#39;,self.get_index())        for i in self.imglist:            self.strimglist.append(self.url+str(i,encoding=&#39;utf8&#39;))        return self.strimglist        def get_image(self):              //下载资源        num=0        for self.url in self.get_list():            num+=1            with open(str(num)+&#39;后缀&#39;,&#39;wb&#39;) as file:                file.write(self.get_index())html=GetHtml(&#39;目标地址&#39;,&#39;请求头&#39;)html.get_list()</code></pre><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。"><a href="#有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。" class="headerlink" title="有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。"></a>有阳光、还感觉冷。如果我忍住这个秘密、温暖冬天就会遥遥而无期。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;基于面向对象的Python爬虫&quot;&gt;&lt;a href=&quot;#基于面向对象的Python爬虫&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221118</title>
    <link href="https://liu1272.github.io/2022/11/18/20221118/"/>
    <id>https://liu1272.github.io/2022/11/18/20221118/</id>
    <published>2022-11-17T18:35:00.000Z</published>
    <updated>2022-11-19T09:41:15.724Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>类:设计<br>对象:实例</p><h4 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h4><p>驼峰命名法</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>class 类名:    属性(变量) = 值    def 函数名(self):         //方法(函数),一定要写self        执行代码对象名=类名()                 //创建对象对象名.函数()                 //调用对象</code></pre><h4 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h4><p>通常格式为__方法名__</p><pre><code>def __init__(self,值):    self.属性=值如果值也是一个变量就能随时传参进行更改</code></pre><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>1.定义类class<br>2.创建内存空间,定义属性和方法<br>3.实例化类,创建对象<br>4.调用类的方法</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="风吹落最后一片叶，"><a href="#风吹落最后一片叶，" class="headerlink" title="风吹落最后一片叶，"></a>风吹落最后一片叶，</h5><h5 id="我的心也飘着雪，"><a href="#我的心也飘着雪，" class="headerlink" title="我的心也飘着雪，"></a>我的心也飘着雪，</h5><h5 id="爱只能往回忆里堆叠。"><a href="#爱只能往回忆里堆叠。" class="headerlink" title="爱只能往回忆里堆叠。"></a>爱只能往回忆里堆叠。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;面向对象编程&quot;&gt;&lt;a href=&quot;#面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;面向对象编</summary>
      
    
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221117</title>
    <link href="https://liu1272.github.io/2022/11/17/20221117/"/>
    <id>https://liu1272.github.io/2022/11/17/20221117/</id>
    <published>2022-11-17T04:02:00.000Z</published>
    <updated>2022-11-19T09:40:38.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="Python爬虫思路"><a href="#Python爬虫思路" class="headerlink" title="Python爬虫思路"></a>Python爬虫思路</h4><p>1.发送请求获取网站html代码<br>2.过滤有效信息<br>3.解析数据<br>4.处理数据</p><h4 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h4><p>1.找到网站发起请求<br>2.分析url并提取<br>3.分析url并解释网络内容<br>4.存储数据并获取新url<br>5.判断是否满足停止条件0</p><h4 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h4><p>决定可以访问的user(允许爬取的user)</p><h4 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h4><p>http端口是8080<br>https加密,SSL层,端口是443</p><h4 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h4><p>url包括协议类型，主机名/域名，端口号，查找路径，查找参数，锚点<br>uri是utl请求之前部分</p><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>get不影响资源/post影响资源</p><h4 id="请求头参数"><a href="#请求头参数" class="headerlink" title="请求头参数"></a>请求头参数</h4><p>user-agent:浏览器名称<br>referer:请求源头<br>cookie:用于判断用户身份</p><h4 id="常见响应状态码"><a href="#常见响应状态码" class="headerlink" title="常见响应状态码"></a>常见响应状态码</h4><p>200:正常返回<br>301:永久重定向<br>404:url错误<br>418:反爬虫，解决响应<br>500:服务器错误，bug</p><h4 id="请求交互过程"><a href="#请求交互过程" class="headerlink" title="请求交互过程"></a>请求交互过程</h4><p>1.客户端浏览器向服务器发送请求<br>2.网站接收请求处理后返回响应数据<br>3.浏览器解析源码</p><h4 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h4><p>element:分析网页结构，获取数据<br>console:打印输出网站信息<br>network:查看网络请求<br>source:所有的源文件(只能查看静态数据)</p><h4 id="Session与Cookie原理"><a href="#Session与Cookie原理" class="headerlink" title="Session与Cookie原理"></a>Session与Cookie原理</h4><p>【Session】<br>特点:可长时间保存会话<br>过程:<br>1.客户端第一次发送请求时服务器端创建Session对象(生成sessionID)<br>2.将sessionID存入cookie传回<br>3.下次发送请求时包含sessionID<br>【Cookie】<br>特点:从服务器发送给浏览器后一直保存到关闭浏览器<br>过程:<br>1.创建cookie<br>2.设置存储cookie<br>3.发送cookie<br>4.读取cookie</p><h4 id="JSON-数据交换语言"><a href="#JSON-数据交换语言" class="headerlink" title="JSON(数据交换语言)"></a>JSON(数据交换语言)</h4><p>JavaScript ObjectNotation，JS对象标记<br>数据格式:<br>1.对象表示为键值对<br>2.数据用逗号分隔<br>3.花括号保存对象<br>4.方括号保存数组<br>整体上与python的字典相似<br>例:</p><pre><code>json_yuju=&#123;&#39;name&#39;:&#39;python&#39;,&#39;address&#39;:&#123;&#39;province&#39;:&#39;guangdong&#39;,&#39;city&#39;:[&#39;guangzhou&#39;,&#39;huizhou&#39;]&#125;&#125;print(json_yuju[&#39;address&#39;][&#39;city&#39;][2])               //输出huizhou</code></pre><h4 id="Ajax-Web数据交互方式"><a href="#Ajax-Web数据交互方式" class="headerlink" title="Ajax(Web数据交互方式)"></a>Ajax(Web数据交互方式)</h4><p>Ajax在服务器与浏览器之间使用异步数据传输(可以只请求少量信息)<br>Ajax技术独立于浏览器与平台<br>Ajax一般返回JSON(对Ajax地址进行post或get就可以返回JSON数据)<br>Ajax渲染到html的叫做动态数据<br>服务器后台生成的是静态数据<br>html中的在source中没有找到那就是ajax<br>注意:Ajax需要用户允许JavaScript在浏览器上执行</p><h4 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h4><p>py自带的网络请求库<br>模块:<br>urllib.request打开并读取url</p><pre><code>模拟浏览器发送请求并获取响应结果data默认为None即Get请求，post请求时要将data以字典形式存储，由字典类型转换成字节类型转换成的数据类型看网页源代码【GET】import urllib.requesturl=&#39;https......&#39;                           //传入urlresponse=urllib.request.urlopen(url)        //发送get请求html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【POST】import urllib.requesturl=&#39;https......&#39;                           //传入urldata=&#123;&#39;a&#39;:&#39;A&#39;,&#39;b&#39;:&#39;B&#39;,&#39;action&#39;:&#39;login&#39;&#125;     //从Form Data处查看response=urllib.request.urlopen(url,data=bytes(urllib.prase.urlencode(data),encoding=&#39;utf-8&#39;))html=response.read().decode(&#39;gbk&#39;)          //读取响应并将数据类型转为strprint(html)【通过伪造请求头绕过418】import urllib.requesturl=&#39;https......&#39;                           //传入urlheader=&#123;&#39;User-Agent&#39;:&#39;浏览器信息&#39;&#125;request=urllib.request.Request(url,headers=header)response=urllib.request.urlopen(request)html=response.read().decode(&#39;utf-8&#39;)        //读取响应并将数据类型转为strprint(html)</code></pre><p>urllib.error包含提出的异常urllib.request</p><pre><code>import urllib.requestimport urllib.errorurl=&#39;目标地址&#39;try:    response=urllib.request.urlopen(url)    //尝试链接expect urllib.error.URLError as e:          //捕获返回信息    print(e.reason)</code></pre><p>urllib.parse解析url</p><pre><code>import urllib.parsea=&#123;&#39;A&#39;:&#39;内容&#39;&#125;                              //创建键值对result1=urllib.parse.urlencode(a)           //url编码result2=urllib.prase.unquote(result1)       //url解码属性:code:请求返回的状态码reason:返回错误的原因headers:请求返回的响应头信息</code></pre><p>urllib.robotparase解析robots.txt文件</p><h4 id="IP代理"><a href="#IP代理" class="headerlink" title="IP代理"></a>IP代理</h4><p>网站会拒绝同一IP多次访问<br>命令行中输入ipconfig的IPv4是本地IP<br>分类:<br>1.透明代理，知道使用了且知道源IP<br>2.匿名代理，知道使用了但是不知道源IP<br>3.高匿代理，都不知道<br><a href="https://www.xicidaili.com/nn/">免费网站</a><br>语法:</p><pre><code>from urllib.request import build_openerfrom urllib.request import ProxyHandlerproxy=ProxyHandler(&#123;&#39;协议类型http/https&#39;:&#39;IP地址:端口&#39;&#125;)opener=build_opener(proxy)url=&#39;目标地址&#39;response=opener.open(url)print(response.read().decode(&#39;utf-8&#39;))</code></pre><h4 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h4><p>使用步骤:<br>1.实例化MozillaCookieJar(保存cookie)<br>2.创建handler对象(cookie的处理器)<br>3.创建opener对象<br>4.打开网页发送请求获取响应<br>5.保存cookie文件<br>语法:</p><pre><code>import urllib.requestfrom http import cookiejarfilename=&#39;cookie.txt&#39;def get_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar(filename)           //实例化MCJ    handler=urllib.request.HTTPCookieProcessor(cookie)    //创建handler对象    opener=urllib.request.build_opener(handler)           //创建opener对象    url=&#39;目标地址&#39;    response=opener.open(url)                             //发送请求并获取响应    cookie.save()                                         //保存cookie文件def use_cookie():                                         //定义获取cookie函数    cookie=cookiejar.MozillaCookieJar()                   //实例化MCJ    cookie.load(filename)                                 //加载cookie文件    print(cookie)if __name__ = &#39;__main__&#39;:    use_cookie()                                          //读取cookie</code></pre><h4 id="requests库-包括上面的功能"><a href="#requests库-包括上面的功能" class="headerlink" title="requests库(包括上面的功能)"></a>requests库(包括上面的功能)</h4><pre><code>常用方法:requestsrequests.request(url)            //构造请求requests.get(url,params=None)    //Get请求。params可省略,params是请求的参数requests.post(url,data=None,json=None)requests.head()                  //获取html头部信息requests.put()                   //发送Put请求requests.patch()                 //提交局部修改的请求requests.delete()                //提交删除请求params是请求参数常用属性:response.status_code             //响应状态码response.content                 //response对象转为二进制数据response.text                    //response对象转为字符串数据response.encoding                //定义response对象编码response.cookies()               //获取请求后的cookieresponse.session()               //获取请求后的sessionresponse.url                     //获取请求网址response.json()                  //内置JSON解码器Response.headers                 //以字典对象存储服务器响应头，字典不分大小写获取二进制数据实例:import requestsurl=&#39;目标文件的地址&#39;response=requests.get(url)with open(&#39;文件名,模式&#39;,&#39;wb&#39;) as file:              //读写文件的操作    file.write(response.content)    常用参数:r:   以只读方式打开文件。文件的指针将会放在文件的开头。这是**默认模式**。r+:  打开一个文件用于读写。文件指针将会放在文件的开头。w:   打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。w+:  打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。a:   打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。a+:  打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。rb:  以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。rb+: 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。wb:  以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。wb+: 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。ab:  以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。ab+: 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。file.read([size])        将文件数据作为字符串返回，可选参数size控制读取的字节数file.readlines([size])   返回文件中行内容的列表，size参数可选file.write(str)          将字符串写入文件file.writelines(strings) 将字符串序列写入文件file.close()             关闭文件file.closed              表示文件已经被关闭，否则为Falsefile.mode                Access文件打开时使用的访问模式file.encoding            文件所使用的编码file.name                文件名file.newlines            未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，则为一个包含所有当前所遇到的行结束的列表file.softspace           为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用</code></pre><h4 id="XPath解析数据-lxml库"><a href="#XPath解析数据-lxml库" class="headerlink" title="XPath解析数据(lxml库)"></a>XPath解析数据(lxml库)</h4><p>概述:<br>小型查询语言，在XML文档中查找信息的语言<br>优点:<br>可在XPath中查找信息<br>支持HTML查找<br>可通过元素和属性进行导航<br>XML树形结构和语句与HTML相类似<br>XPath语法点击<a href="https://blog.csdn.net/Victor2code/article/details/108298390?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166877297016782395359090%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166877297016782395359090&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108298390-null-null.142%5Ev65%5Eopensearch_v2,201%5Ev3%5Econtrol,213%5Ev2%5Et3_esquery_v2&utm_term=xpath%E8%AF%AD%E6%B3%95&spm=1018.2226.3001.4187">此处</a><br>代码实现:</p><pre><code>import requestsfrom lxml import etreeurl=&#39;目标地址&#39;headers=&#123;请求头信息，以键值对形式存储&#125;response=requests.get(url,headers)etree=rtree.HTML(response.text)                       //将响应的str类型转换为etree类型A=etree.xpath(&#39;谷歌浏览器中XPath的语句&#39;)              //获取内容B=etree.path(&#39;另一个语句&#39;)for A中定位的元素,B中定位的元素 in zip(A,B)           //遍历打包    print(A中定位的元素, &#39;:&#39; ,B中定位的元素)          //输出</code></pre><h4 id="BeautifulSoup解析数据-bs4库"><a href="#BeautifulSoup解析数据-bs4库" class="headerlink" title="BeautifulSoup解析数据(bs4库)"></a>BeautifulSoup解析数据(bs4库)</h4><p>概述:<br>能从HTML和XML文件中提取数据的库<br>语法:</p><pre><code>                        【Tag对象】print(bs.标签)                       //获取标签print(bs.标签.attrs)                 //获取标签的全部属性print(bs.标签[&#39;属性名&#39;])             //获取属性值print(bs.标签.text)                  //获取标签的文本内容(不包括注释内的)print(bs.标签.string)                //获取标签的文本内容(包括注释内的)                        【CSS选择器】print(bs.select(&#39;ID&#39;))               //ID查找print(bs.select(&#39;classa&#39;))           //classa查找print(bs.select(标签,属性))          //属性查找                        【其他功能】print(bs.find(标签,属性))            //提取首个满足条件的print(bs.find_all(标签,属性))        //提取所有满足条件的</code></pre><p>代码实现:</p><pre><code>import requestsfrom bs4 import BeautifulSoupurl=&#39;目标地址&#39;headers=&#123;头文件键值对&#125;response=requests.get(url,headers)bs=BeautifulSoup(response.text,&#39;html.parser&#39;)               //bs=BeautifulSoup(response.text,&#39;lxml&#39;)二选一使用即可a_list=bs.find_all(&#39;标签&#39;)for a in a_list:    url=a.get(&#39;属性&#39;)    if url==None                                              //以None开头的url无用        continue    if url.startswich(&#39;http&#39;) or url.startswich(&#39;https&#39;)      //保留以http或https开头的url        print(url)</code></pre><h4 id="正则表达式-re库"><a href="#正则表达式-re库" class="headerlink" title="正则表达式(re库)"></a>正则表达式(re库)</h4><p>概述:<br>特殊的字符序列，检查字符串是否与某种模式相匹配<br>正则语法:</p><pre><code>.           //匹配任意字符^           //匹配字符串开头$           //匹配字符串末尾*           //匹配前一个元字符0到多次+           //匹配前一个元字符1到多次?           //匹配前一个元字符0到1次&#123;m&#125;         //匹配前一个元字符m次&#123;m,n&#125;       //匹配前一个元字符m到n次&#123;m,n&#125;?      //匹配前一个元字符m到n次，并去尽可能少的情况\\          //对特殊字符转义[]          //字符集合，匹配其中任意一个字符|           //或(...)       //作为一个元组，findall在有组情况下只显示组的内容</code></pre><p>特殊序列:</p><pre><code>\A          //只在字符串开头匹配\b          //匹配开头或结尾的空字符串\B          //匹配不位于开头或结尾的空字符串\d          //匹配十进制数，[0-9]\D          //匹配非字符数字字符，[^0-9]s           //匹配空白字符，[\t\n\r\f\v]\S          //匹配非空白字符，[^\t\n\r\f\v]\w          //匹配数字字母下划线，[a-z A-Z 0-9]\W          //匹配非数字字母下划线，[^a-z A-Z 0-9]\Z          //只在字符串末尾进行匹配[\u4e00-\u9fa5]         //中文</code></pre><p>正则处理函数:</p><pre><code>re.match(pattern,string,flags=0)                  //从字符串开头匹配模式，成功则返回成功的对象，否则返回Nonere.search(pattern,string,flags=0)                 //扫描整个字符串返回第一个成功匹配的对象，失败则返回Nonere.findall(pattern,string,flags=0)                //获取列表的所有匹配的字符串，以列表形式返回re.sub(pattern,repl,string,count=0,flags=0)       //用于替换字符串的匹配项，没有匹配项则返回没有匹配的字符串re.compile(pattern,[,flag])                       //编译正则表达式，生成正则表达式对象，供match和search函数使用</code></pre><h4 id="爬取并下载视频示例"><a href="#爬取并下载视频示例" class="headerlink" title="爬取并下载视频示例"></a>爬取并下载视频示例</h4><pre><code>import requestsimport reurl=&#39;目标地址&#39;headers=&#123;请求头&#125;response=requests.get(url,headers=headers)                            //发送请求info=re.findall(&#39;标签，配合使用正则表达式&#39;,response.text)             //正则查找所有符合要求的对象lst=[]for item in info:    lst.append(&#39;https:&#39;+item)                                         //将符合条件的对象放入列表中并补全绝对路径count=0for item in lst:    count+=1    response=requests.get(item.headers=headers)                       //将补全的路径再次请求    with open(&#39;存储路径&#39;+str(count)+&#39;后缀&#39;) as file                   //设置下载路径和文件名        file.write(response.content)                                  //将文件存为二进制print(下载完毕)</code></pre><h4 id="pyquery解析数据-pyquery库"><a href="#pyquery解析数据-pyquery库" class="headerlink" title="pyquery解析数据(pyquery库)"></a>pyquery解析数据(pyquery库)</h4><p>概述:<br>是jQuery的Python实现，可以jQuery语法操作解析HTML文档，易用性和解析速度很好<br>初始化方式:</p><pre><code>字符串方式from pyquery import PyQuery as pyhtml=&#39;html代码&#39;doc=py(html)      //创建PyQuery对象，将str类型转换为PyQuery类型url方式from pyquery import PyQuerydoc=PyQuery(url=&#39;地址&#39;,encoding=&#39;utf-8&#39;)文件from pyquery import PyQuerydoc=PyQuery(filename=&#39;存有html文件的地址&#39;)</code></pre><p>使用方式:</p><pre><code>doc(&#39;#main&#39;)                             //获取当前节点doc(&#39;#main&#39;).children()                  //获取子节点doc(&#39;#main&#39;).parent()                    //获取父节点doc(&#39;#main&#39;).sinlings()                  //获取兄弟节点doc(&#39;标签&#39;)attr(&#39;属性&#39;)                  //获取属性值doc(&#39;#main&#39;).html()                      //获取内容，以html代码形式显示doc(&#39;#main&#39;).text()                      //获取内容，以文本显示显示</code></pre><p>代码实现:</p><pre><code>import requestsfrom pyquery import PyQuery as pyurl=&#39;&#39;headers=&#123;&#125;response=resquests.get(url,headers=headers)   //发送请求doc=py(response.text)                         //初始化PyQuery对象A=[x.text for x in doc(h4 a)]                 //从doc中提取h4中的a标签的内容传给x，再显示x的文本部分</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>requests用于发送和接收请求<br>四种解析方式是数据的提取<br>对于爬虫更重要的是提取了数据之后对数据的操作</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="想不清楚一件事，往往因为这件事里有你想逃避的东西。"><a href="#想不清楚一件事，往往因为这件事里有你想逃避的东西。" class="headerlink" title="想不清楚一件事，往往因为这件事里有你想逃避的东西。"></a>想不清楚一件事，往往因为这件事里有你想逃避的东西。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;Python爬虫思路&quot;&gt;&lt;a href=&quot;#Python爬虫思路&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221116</title>
    <link href="https://liu1272.github.io/2022/11/16/20221116/"/>
    <id>https://liu1272.github.io/2022/11/16/20221116/</id>
    <published>2022-11-16T05:45:00.000Z</published>
    <updated>2022-11-19T09:40:07.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><p>php7之前是mysql链接(硬链接)<br>php7之后是mysqli链接(i链接/improved链接)</p><h4 id="PHP连接数据库-MySQLi-面向对象"><a href="#PHP连接数据库-MySQLi-面向对象" class="headerlink" title="PHP连接数据库(MySQLi - 面向对象)"></a>PHP连接数据库(MySQLi - 面向对象)</h4><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;echo &quot;Connected successfully&quot;;?&gt;</code></pre><h4 id="关闭连接-MySQLi-面向对象"><a href="#关闭连接-MySQLi-面向对象" class="headerlink" title="关闭连接(MySQLi - 面向对象)"></a>关闭连接(MySQLi - 面向对象)</h4><p>连接在脚本执行完后会自动关闭,也可以手动关闭<br>$conn-&gt;close();</p><h4 id="创建数据库-MySQLi-面向对象"><a href="#创建数据库-MySQLi-面向对象" class="headerlink" title="创建数据库(MySQLi - 面向对象)"></a>创建数据库(MySQLi - 面向对象)</h4><p>需要 CREATE 权限来创建或删除 MySQL 数据库。</p><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;// Create database$sql = &quot;CREATE DATABASE myDB&quot;;                     //库名叫做myDBif ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;Database created successfully&quot;;&#125; else &#123;    echo &quot;Error creating database: &quot; . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;</code></pre><h4 id="创建表-MySQLi-面向对象"><a href="#创建表-MySQLi-面向对象" class="headerlink" title="创建表(MySQLi - 面向对象)"></a>创建表(MySQLi - 面向对象)</h4><p>在 PHP 中创建完数据库之后，我们需要在数据库中创建一个或者多个的数据表。<br>一个数据表有一个唯一名称，并有行和列组成。<br>创建表前，我们需要使用use myDB;来选择要操作的数据库</p><pre><code>&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;$dbname = &quot;myDB&quot;;// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;Connection failed: &quot; . $conn-&gt;connect_error);&#125;// sql to create table$sql = &quot;CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)&quot;;if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;Table MyGuests created successfully&quot;;&#125; else &#123;    echo &quot;Error creating table: &quot; . $conn-&gt;error;&#125;$conn-&gt;close();?&gt;</code></pre><p>其中表内数据类型有<a href="https://www.w3cschool.cn/mysql/sql-datatypes.html">规定</a></p><p>同时可以为每个列指定其他选项的属性:<br>NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。<br>DEFAULT value - 设置默认值<br>UNSIGNED - 使用无符号数值类型，0 及正数<br>AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1<br>PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与AUTO_INCREMENT 一起使用。</p><p>每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值。</p><h4 id="插入数据-MySQLi-面向对象"><a href="#插入数据-MySQLi-面向对象" class="headerlink" title="插入数据(MySQLi - 面向对象)"></a>插入数据(MySQLi - 面向对象)</h4><p>语法规则:<br>1.PHP 中 SQL 查询语句必须使用引号<br>2.在 SQL 查询语句中的字符串值必须加引号<br>3.数值的值不需要引号<br>4.NULL 值不需要引号<br>向 MySQL 表添加新的记录:<br>INSERT INTO table_name (column1, column2, column3,…)<br>VALUES (value1, value2, value3,…)</p><pre><code>在连接检测和关闭数据库中间加入$sql = &quot;INSERT INTO MyGuests (firstname, lastname, email)VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;)&quot;;                    //向 &quot;MyGuests&quot; 表添加新的记录if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;New record created successfully&quot;;&#125; else &#123;    echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error;&#125;</code></pre><h4 id="插入多条数据-MySQLi-面向对象"><a href="#插入多条数据-MySQLi-面向对象" class="headerlink" title="插入多条数据(MySQLi - 面向对象)"></a>插入多条数据(MySQLi - 面向对象)</h4><p>【方法一:使用函数】<br>mysqli_multi_query() 函数可用来执行多条SQL语句。</p><pre><code>$sql = &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;);&quot;;$sql .= &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;Mary&#39;, &#39;Moe&#39;, &#39;mary@example.com&#39;);&quot;;$sql .= &quot;INSERT INTOMyGuests (firstname, lastname, email)VALUES (&#39;Julie&#39;, &#39;Dooley&#39;, &#39;julie@example.com&#39;)&quot;;if ($conn-&gt;multi_query($sql) === TRUE) &#123;echo &quot;Newrecords created successfully&quot;;&#125; else &#123;echo&quot;Error: &quot; . $sql . &quot;&quot; . $conn-&gt;error;&#125;</code></pre><p>注意:每个SQL语句必须用分号隔开。</p><p>【方法二:MySQLi 使用预处理语句】</p><pre><code>// 为 mysqli_stmt_prepare() 初始化statement 对象$stmt =mysqli_stmt_init($conn);//预处理语句if (mysqli_stmt_prepare($stmt, $sql)) &#123;// 绑定参数mysqli_stmt_bind_param($stmt, &#39;sss&#39;, $firstname, $lastname, $email);// 设置参数并执行$firstname = &#39;John&#39;;$lastname= &#39;Doe&#39;;$email =&#39;john@example.com&#39;;mysqli_stmt_execute($stmt);$firstname = &#39;Mary&#39;;$lastname= &#39;Moe&#39;;$email =&#39;mary@example.com&#39;;mysqli_stmt_execute($stmt);$firstname = &#39;Julie&#39;;$lastname = &#39;Dooley&#39;;$email =&#39;julie@example.com&#39;;mysqli_stmt_execute($stmt);&#125;</code></pre><p>每个参数必须指定类型，来保证数据的安全性。通过类型的判断可以减少SQL注入漏洞带来的风险。<br>参数类型:<br>i - integer<br>d - double<br>s - string<br>b - BLOB</p><h4 id="MySQLi使用预处理语句-包括面向对象和面向过程"><a href="#MySQLi使用预处理语句-包括面向对象和面向过程" class="headerlink" title="MySQLi使用预处理语句(包括面向对象和面向过程)"></a>MySQLi使用预处理语句(包括面向对象和面向过程)</h4><p>流程:<br>1.预处理:创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记<br>2.数据库解析并编译(内部处理):对SQL语句模板执行查询优化，并存储结果(不输出)<br>3.执行:将应用绑定的值传递给参数（?标记），数据库执行语句。(如果参数的值不一样,可以多次执行语句)</p><p>优点:<br>1.减少了分析时间，只做了一次查询（虽然语句多次执行）<br>2.绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句<br>3.预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。</p><pre><code>// 步骤一，prepare and bind$stmt = $conn-&gt;prepare(&quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)&quot;);$stmt-&gt;bind_param(&quot;sss&quot;, $firstname, $lastname, $email);// 步骤三，设置参数并执行$firstname = &quot;John&quot;;$lastname = &quot;Doe&quot;;$email = &quot;john@example.com&quot;;$stmt-&gt;execute();$firstname = &quot;Mary&quot;;$lastname = &quot;Moe&quot;;$email = &quot;mary@example.com&quot;;$stmt-&gt;execute();             $firstname = &quot;Julie&quot;;$lastname = &quot;Dooley&quot;;$email = &quot;julie@example.com&quot;;$stmt-&gt;execute();echo &quot;New records created successfully&quot;;$stmt-&gt;close();</code></pre><p>语句中如果有?就转换为其他类型的数据</p><h4 id="读取数据-MySQLi-面向对象"><a href="#读取数据-MySQLi-面向对象" class="headerlink" title="读取数据(MySQLi - 面向对象)"></a>读取数据(MySQLi - 面向对象)</h4><pre><code>SELECT 语句用于从数据表中读取数据:SELECT column_name(s) FROM table_name我们可以使用 * 号来读取所有数据表中的字段:SELECT * FROM table_name用 WHERE 命令来筛选出满足条件的结果:SELECT column_name(s)  FROM table_name  WHERE column_name operator value——————————————————————————————————————————————————————————————————————————————                           【SELECT】$sql = &quot;SELECT id, firstname, lastname FROM MyGuests&quot;;$result = $conn-&gt;query($sql);if ($result-&gt;num_rows &gt; 0) &#123;    // 输出每行数据    while($row = $result-&gt;fetch_assoc()) &#123;        echo &quot;id: &quot;. $row[&quot;id&quot;]. &quot; - Name: &quot;. $row[&quot;firstname&quot;]. &quot; &quot; . $row[&quot;lastname&quot;]. &quot;&lt;br&gt;&quot;;    &#125;&#125; else &#123;    echo &quot;0 results&quot;;&#125;——————————————————————————————————————————————————————————————————————————————                           【WHERE】$result = mysqli_query($con,&quot;SELECT * FROM PersonsWHERE FirstName=&#39;Peter&#39;&quot;);while($row = mysqli_fetch_array($result))&#123;echo $row[&#39;FirstName&#39;] . &quot; &quot; . $row[&#39;LastName&#39;];echo &quot;&lt;br&gt;&quot;;&#125;</code></pre><h4 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h4><pre><code>ORDER BY 关键词用于对记录集中的数据进行排序。SELECT column_name(s)FROM table_nameORDER BY column1, column2... ASC|DESC    默认是升序ASC，DESC改为降序$result = mysqli_query($con,&quot;SELECT * FROM Persons ORDER BY age&quot;);while($row = mysqli_fetch_array($result))&#123;echo $row[&#39;FirstName&#39;];echo &quot; &quot; . $row[&#39;LastName&#39;];echo &quot; &quot; . $row[&#39;Age&#39;];echo &quot;&lt;br&gt;&quot;;&#125;可以根据多个列进行排序(第一列的值相同时才使用第二列)</code></pre><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>UPDATE 语句用于更新数据库表中已存在的记录。<br>WHERE 子句规定了哪些记录需要更新。<br>如果您想省去 WHERE 子句，所有的记录都会被更新！<br>PHP执行该语句，必须使用mysqli_query()函数(该函数用于向 MySQL 连接发送查询或命令)</p><pre><code>语法:UPDATE table_name SET column1=value, column2=value2,... WHERE some_column=some_value 操作:mysqli_query($con,&quot;UPDATE Persons SET Age=36WHERE FirstName=&#39;Peter&#39; AND LastName=&#39;Griffin&#39;&quot;);</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>DELETE FROM 语句用于从数据库表中删除记录。<br>WHERE 子句规定了哪些记录需要更新。<br>如果您想省去 WHERE 子句，所有的记录都会被更新！<br>PHP执行该语句，必须使用mysqli_query()函数(该函数用于向 MySQL 连接发送查询或命令)</p><pre><code>语法:DELETE FROM table_name WHERE some_column = some_value操作:mysqli_query($con,&quot;DELETE FROM Persons WHERE LastName=&#39;Griffin&#39;&quot;);</code></pre><h4 id="PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi-面向过程和PDO请前往此处"><a href="#PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi-面向过程和PDO请前往此处" class="headerlink" title="PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi - 面向过程和PDO请前往此处"></a>PHP中有关MySQL数据库的内容暂时告一段落，若想了解MySQLi - 面向过程和PDO请前往<a href="https://www.w3cschool.cn/php/php-mysql-connect.html">此处</a></h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="我们生而破碎，用活着来修修补补。"><a href="#我们生而破碎，用活着来修修补补。" class="headerlink" title="我们生而破碎，用活着来修修补补。"></a>我们生而破碎，用活着来修修补补。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;p&gt;php7之前是mysql链接(硬链接)&lt;br&gt;php7之后是mysqli链接(i链接/improved链接)&lt;/p&gt;
&lt;h4</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>20221115</title>
    <link href="https://liu1272.github.io/2022/11/15/20221115/"/>
    <id>https://liu1272.github.io/2022/11/15/20221115/</id>
    <published>2022-11-15T14:28:00.000Z</published>
    <updated>2022-11-19T09:39:43.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>概念:正则表达式是用于描述字符排列和匹配模式的一种语法规则。<br>作用:<br>1.匹配，也常常用于从字符串中析取信息。<br>2.用新文本代替匹配文本。<br>3.将一个字符串拆分为一组更小的信息块。<br>基本语法:<br>1.正则匹配模式使用分隔符与元字符组成<br>(1)分隔符可以是非数字、非反斜线、非空格的任意字符<br>(2)经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)<br>2.元字符是用于构造规则表达式的具有特殊含义的字符<br>3.如果要在正则表达式中包含元字符本身，必须在其前加上”\”进行转义 </p><pre><code>           【常见元字符】 元字符             说明*                0次、1次或多次匹配其前的原子+                1次或多次匹配其前的原子?                0次或1次匹配其前的原子|                匹配两个或多个选择^                匹配字符串串首的原子$                匹配字符串串尾的原子[]                匹配方括号中的任一原子[^]                匹配除方括号中的原子外的任何字符&#123;m&#125;                表示其前原子恰好出现m次&#123;m,n&#125;            表示其前原子至少出现m次，至少出现n次(n&gt;m)&#123;m,&#125;            表示其前原子出现不少于m次()                整体表示一个原子.                匹配除换行之外的任何一个字符边界限制:1.^和$分别指定字符串的开始和结束。2.^Tom$精确匹配————Tom模糊匹配3.重复匹配:    ?匹配存在?前的一个字母或是不存在这个字母的字符串    *匹配0/1/多次匹配该字母的字符串    +匹配1/多次该字母的字符串    .匹配除换行符外的任何字符    .*组合称为全匹配符或单含匹配符    &#123;&#125;指定原子重复的次数        &#123;m&#125;表示其前原子恰好出现m次；        &#123;m，n&#125;表示其前原子至少出现m次，至多出现n次；        &#123;m，&#125;表示其前原子出现不少于m次。    []匹配其中的一个原子并且地位平等    |匹配多个选择之一，可以连用|4.模式单元:    ()将其中的正则表达式变为原子(或称为模式单元)使用————其实用处相等于数学的括号5.模式匹配的顺序(从高到低):  顺序    元字符         说明  1        （）          模式单元      2       ？* +&#123;&#125;        重复匹配  3         ^$           边界限制  4         |            模式选择</code></pre><p>特殊字符:<br>$匹配输入字符串的结尾位置<br>()标记表达式开始与结束的位置<br>*匹配前面的子表达式0次或多次<br>+匹配前面的子表达式1次或多次<br>.匹配除换行符\n外的任何单字符<br>[标记一个中括号表达式的开始<br>?匹配前面的子表达式0次或一次，或指明一个非贪婪限定符<br>\将下一个字符标记为特殊字符/原义字符/向后引用/八进制转义符<br>^匹配字符串的开始位置(在方括号中表示不接受该字符集合)<br>{标记限定符巴达兽的开始<br>|指明两项之间的一个选择</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="生活哪有什么胜利可言，挺住意味着一切。"><a href="#生活哪有什么胜利可言，挺住意味着一切。" class="headerlink" title="生活哪有什么胜利可言，挺住意味着一切。"></a>生活哪有什么胜利可言，挺住意味着一切。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>元字符表</title>
    <link href="https://liu1272.github.io/2022/11/15/%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8/"/>
    <id>https://liu1272.github.io/2022/11/15/%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8/</id>
    <published>2022-11-15T05:42:00.000Z</published>
    <updated>2022-11-16T05:45:29.574Z</updated>
    
    <content type="html"><![CDATA[<pre><code>字符     描述\        将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(”。^        匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。$        匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。*        匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于&#123;0,&#125;。+        匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 &#123;1,&#125;。?        匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 &#123;0,1&#125;。&#123;n&#125;       n是一个非负整数。匹配确定的 n 次。例如，’o&#123;2&#125;’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。&#123;n,&#125;      n是一个非负整数。至少匹配n 次。例如，’o&#123;2,&#125;’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o&#123;1,&#125;’ 等价于 ‘o+’。’o&#123;0,&#125;’ 则等价于 ‘o*’。&#123;n,m&#125;     m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o&#123;1,3&#125;” 将匹配 “fooooood” 中的前三个 o。’o&#123;0,1&#125;’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。?         当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。.         匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。(pattern)    匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘′或‘’。(?:pattern)    匹 配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。(?=pattern)    正 向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000″ 中的 “Windows” ，但不能匹配 “Windows 3.1″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern)    负 向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1″ 中的 “Windows”，但不能匹配 “Windows 2000″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始x|y    匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。[xyz]    字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。[^xyz]    负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p&#39;。[a-z]    字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。[^a-z]    负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。\b    匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。\B    匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。\cx    匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。\d    匹配一个数字字符。等价于 [0-9]。\D    匹配一个非数字字符。等价于 [^0-9]。\f    匹配一个换页符。等价于 \x0c 和 \cL。\n    匹配一个换行符。等价于 \x0a 和 \cJ。\r    匹配一个回车符。等价于 \x0d 和 \cM。\s    匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。\S    匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。\t    匹配一个制表符。等价于 \x09 和 \cI。\v    匹配一个垂直制表符。等价于 \x0b 和 \cK。\w    匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。\W    匹配任何非单词字符包括下划线。等价于 ‘[^A-Za-z0-9_]’。\xn    匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41′ 匹配 “A”。’\x041′ 则等价于 ‘\x04′ &amp; “1″。正则表达式中可以使用 ASCII 编码。.\num    匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1′ 匹配两个连续的相同字符。\n    标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\nm    标 识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。\nml    如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。\un    匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。例子 匹配32位md5/^[a-z0-9]&#123;32&#125;$/</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;字符     描述
\        将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(”。
^      </summary>
      
    
    
    
    <category term="附录" scheme="https://liu1272.github.io/categories/%E9%99%84%E5%BD%95/"/>
    
    
    <category term="附录" scheme="https://liu1272.github.io/tags/%E9%99%84%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>20221114</title>
    <link href="https://liu1272.github.io/2022/11/14/20221114/"/>
    <id>https://liu1272.github.io/2022/11/14/20221114/</id>
    <published>2022-11-14T08:34:00.000Z</published>
    <updated>2022-11-19T09:39:16.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日一记"><a href="#每日一记" class="headerlink" title="每日一记"></a>每日一记</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。<br>对象 − 是类的实例。<br>对象的主要三个特性：<br>1.对象的行为：可以对对象施加那些操作，开灯，关灯就是行为。<br>2.对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。<br>3.对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。</p><p>成员函数 − 定义在类的内部，可用于访问对象的数据。</p><p>继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</p><p>父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</p><p>子类 − 一个类继承其他类称为子类，也可称为派生类。</p><p>多态 − 多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</p><p>重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p><p>抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</p><p>封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</p><p>构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p><p>析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><pre><code>【定义函数】&lt;?php                                      //1.定义类class 类名 &#123;  /* 成员变量 */  var $var1;  var $var2 = &quot;constant string&quot;;  /* 成员函数 */  function 成员函数的函数名 ($arg1, $arg2)   &#123;      return $this-&gt;函数 = 变量             //赋值并调用函数  &#125;&#125;?&gt;$对象名 = new 类名;                         //2.创建对象echo $对象名-&gt;成员函数(&quot;传入的参数&quot;);        //3.调用成员方法大括号&#123;&#125;内可以定义变量和方法变量使用 var 来声明, 变量也可以初始化值函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。变量 $this 代表自身的对象【构造函数】在创建对象时， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。&lt;?phpclass 类名 &#123;   function __construct() &#123;       print &quot;构造函数&quot;;       $this-&gt;name = &quot;&quot;;   &#125;   function __destruct() &#123;       print &quot;销毁&quot; . $this-&gt;name . &quot;\n&quot;;   &#125;&#125;$obj = new 类名();?&gt;【继承】子类继承父类的特征和行为，使得子类对象具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为(父类=基类)&lt;?php // 子类扩展站点类别class 类名 &#123;           //extends继承一个类   var $category;    function setCate($par)&#123;        $this-&gt;category = $par;    &#125;    function getCate()&#123;        echo $this-&gt;category . PHP_EOL;    &#125;&#125;注意:PHP 不支持多继承【方法重写】顾名思义重新定义function【访问控制】PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有）protected(受保护的)只能被自身子父类访问private(私有的)只能被定义的类访问publice(公有的)可以在任何地方访问类属性必须被定义，var视为publice【接口】概念:指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。特性:通过interface定义，但是其中定义的所有方法都必须是公有而且要是空的。类可以实现多个接口，用逗号来分隔多个接口的名称。【常量】在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。常量的值必须是一个定值【接口与抽象类】1. 接口（1）对接口的使用是通过关键字implements（2）接口不能定义成员变量（包括类静态变量），能定义常量（3）子类必须实现接口定义的所有方法（4）接口只能定义不能实现该方法（5）接口没有构造函数（6）接口中的方法和实现它的类默认都是public类型的2. 抽象类（1）对抽象类的使用是通过关键字extends（2）不能被实例化，可以定义子类必须实现的方法（3）子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类中一样（或者更为宽松）（4）如一个类中有一个抽象方法，则该类必须定义为抽象类（5）抽象类可以有构造函数（6）抽象类中的方法可以使用private,protected,public来修饰。（7）一个类可以同时实现多个接口，但一个类只能继承于一个抽象类。【关键字】1.Static(1)声明类属性或方法为 static(静态)，就可以不实例化类而直接访问(2)静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。(3)由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。(4)静态属性不可以由对象通过 -&gt; 操作符来访问。2.Final(1)如果父类中的方法被声明为 final，则子类无法覆盖该方法。(2)如果一个类被声明为 final，则不能被继承。【调用父类构造方法】PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() </code></pre><h4 id="面向对象暂时先写到这里，后面有新的认识再回来更改。"><a href="#面向对象暂时先写到这里，后面有新的认识再回来更改。" class="headerlink" title="面向对象暂时先写到这里，后面有新的认识再回来更改。"></a>面向对象暂时先写到这里，后面有新的认识再回来更改。</h4><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><h5 id="当废话满天飞的时候，沉默是人类最大的贡献。"><a href="#当废话满天飞的时候，沉默是人类最大的贡献。" class="headerlink" title="当废话满天飞的时候，沉默是人类最大的贡献。"></a>当废话满天飞的时候，沉默是人类最大的贡献。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日一记&quot;&gt;&lt;a href=&quot;#每日一记&quot; class=&quot;headerlink&quot; title=&quot;每日一记&quot;&gt;&lt;/a&gt;每日一记&lt;/h3&gt;&lt;h4 id=&quot;类与对象&quot;&gt;&lt;a href=&quot;#类与对象&quot; class=&quot;headerlink&quot; title=&quot;类与对象&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
</feed>
